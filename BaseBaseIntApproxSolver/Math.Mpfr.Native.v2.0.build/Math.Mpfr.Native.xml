<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Math.Mpfr.Native</name>
    </assembly>
    <members>
        <member name="T:Math.Mpfr.Native.intmax_t">
            <summary>
            Represents the maximum width integer type.
            </summary>
            <remarks>
            <para>
            In .Net, this is a 64-bit integer. 
            </para>
            </remarks>
        </member>
        <member name="F:Math.Mpfr.Native.intmax_t.Value">
            <summary>
            The value of the <see cref="T:Math.Mpfr.Native.intmax_t">intmax_t</see>.
            </summary>
        </member>
        <member name="M:Math.Mpfr.Native.intmax_t.#ctor(System.Int64)">
            <summary>
            Creates a new <see cref="T:Math.Mpfr.Native.intmax_t">intmax_t</see>, and sets its <paramref name="value"/>.
            </summary>
            <param name="value">The value of the new <see cref="T:Math.Mpfr.Native.intmax_t">intmax_t</see>.</param>
        </member>
        <member name="M:Math.Mpfr.Native.intmax_t.op_Implicit(System.Byte)~Math.Mpfr.Native.intmax_t">
            <summary>
            Converts a <see cref="T:System.Byte">Byte</see> value to an <see cref="T:Math.Mpfr.Native.intmax_t">intmax_t</see> value.
            </summary>
            <param name="value">A <see cref="T:System.Byte">Byte</see> value.</param>
            <returns>An <see cref="T:Math.Mpfr.Native.intmax_t">intmax_t</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.intmax_t.op_Implicit(System.SByte)~Math.Mpfr.Native.intmax_t">
            <summary>
            Converts a <see cref="T:System.Byte">Byte</see> value to an <see cref="T:Math.Mpfr.Native.intmax_t">intmax_t</see> value.
            </summary>
            <param name="value">A <see cref="T:System.Byte">Byte</see> value.</param>
            <returns>An <see cref="T:Math.Mpfr.Native.intmax_t">intmax_t</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.intmax_t.op_Implicit(System.UInt16)~Math.Mpfr.Native.intmax_t">
            <summary>
            Converts a <see cref="T:System.UInt16">UInt16</see> value to an <see cref="T:Math.Mpfr.Native.intmax_t">intmax_t</see> value.
            </summary>
            <param name="value">A <see cref="T:System.UInt16">UInt16</see> value.</param>
            <returns>An <see cref="T:Math.Mpfr.Native.intmax_t">intmax_t</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.intmax_t.op_Implicit(System.Int16)~Math.Mpfr.Native.intmax_t">
            <summary>
            Converts an <see cref="T:System.Int16">Int16</see> value to an <see cref="T:Math.Mpfr.Native.intmax_t">intmax_t</see> value.
            </summary>
            <param name="value">An <see cref="T:System.Int16">Int16</see> value.</param>
            <returns>An <see cref="T:Math.Mpfr.Native.intmax_t">intmax_t</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.intmax_t.op_Implicit(System.UInt32)~Math.Mpfr.Native.intmax_t">
            <summary>
            Converts a <see cref="T:System.UInt32">UInt32</see> value to an <see cref="T:Math.Mpfr.Native.intmax_t">intmax_t</see> value.
            </summary>
            <param name="value">A <see cref="T:System.UInt32">UInt32</see> value.</param>
            <returns>An <see cref="T:Math.Mpfr.Native.intmax_t">intmax_t</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.intmax_t.op_Implicit(System.Int32)~Math.Mpfr.Native.intmax_t">
            <summary>
            Converts an <see cref="T:System.Int32">Int32</see> value to an <see cref="T:Math.Mpfr.Native.intmax_t">intmax_t</see> value.
            </summary>
            <param name="value">An <see cref="T:System.Int32">Int32</see> value.</param>
            <returns>An <see cref="T:Math.Mpfr.Native.intmax_t">intmax_t</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.intmax_t.op_Explicit(System.UInt64)~Math.Mpfr.Native.intmax_t">
            <summary>
            Converts a <see cref="T:System.UInt64">UInt64</see> value to an <see cref="T:Math.Mpfr.Native.intmax_t">intmax_t</see> value.
            </summary>
            <param name="value">A <see cref="T:System.UInt64">UInt64</see> value.</param>
            <returns>An <see cref="T:Math.Mpfr.Native.intmax_t">intmax_t</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.intmax_t.op_Implicit(System.Int64)~Math.Mpfr.Native.intmax_t">
            <summary>
            Converts an <see cref="T:System.Int64">Int64</see> value to a <see cref="T:Math.Mpfr.Native.intmax_t">intmax_t</see> value.
            </summary>
            <param name="value">An <see cref="T:System.Int64">Int64</see> value.</param>
            <returns>An <see cref="T:Math.Mpfr.Native.intmax_t">intmax_t</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.intmax_t.op_Explicit(Math.Mpfr.Native.intmax_t)~System.Byte">
            <summary>
            Converts an <see cref="T:Math.Mpfr.Native.intmax_t">intmax_t</see> value to a <see cref="T:System.Byte">Byte</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Mpfr.Native.intmax_t">intmax_t</see> value.</param>
            <returns>A <see cref="T:System.Byte">Byte</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.intmax_t.op_Explicit(Math.Mpfr.Native.intmax_t)~System.SByte">
            <summary>
            Converts an <see cref="T:Math.Mpfr.Native.intmax_t">intmax_t</see> value to an <see cref="T:System.SByte">SByte</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Mpfr.Native.intmax_t">intmax_t</see> value.</param>
            <returns>An <see cref="T:System.SByte">SByte</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.intmax_t.op_Explicit(Math.Mpfr.Native.intmax_t)~System.UInt16">
            <summary>
            Converts an <see cref="T:Math.Mpfr.Native.intmax_t">intmax_t</see> value to a <see cref="T:System.UInt16">UInt16</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Mpfr.Native.intmax_t">intmax_t</see> value.</param>
            <returns>A <see cref="T:System.UInt16">UInt16</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.intmax_t.op_Explicit(Math.Mpfr.Native.intmax_t)~System.Int16">
            <summary>
            Converts an <see cref="T:Math.Mpfr.Native.intmax_t">intmax_t</see> value to an <see cref="T:System.Int16">Int16</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Mpfr.Native.intmax_t">intmax_t</see> value.</param>
            <returns>An <see cref="T:System.Int16">Int16</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.intmax_t.op_Explicit(Math.Mpfr.Native.intmax_t)~System.UInt32">
            <summary>
            Converts an <see cref="T:Math.Mpfr.Native.intmax_t">intmax_t</see> value to a <see cref="T:System.UInt32">UInt32</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Mpfr.Native.intmax_t">intmax_t</see> value.</param>
            <returns>A <see cref="T:System.UInt32">UInt32</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.intmax_t.op_Explicit(Math.Mpfr.Native.intmax_t)~System.Int32">
            <summary>
            Converts an <see cref="T:Math.Mpfr.Native.intmax_t">intmax_t</see> value to an <see cref="T:System.Int32">Int32</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Mpfr.Native.intmax_t">intmax_t</see> value.</param>
            <returns>An <see cref="T:System.Int32">Int32</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.intmax_t.op_Explicit(Math.Mpfr.Native.intmax_t)~System.UInt64">
            <summary>
            Converts an <see cref="T:Math.Mpfr.Native.intmax_t">intmax_t</see> value to a <see cref="T:System.UInt64">UInt64</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Mpfr.Native.intmax_t">intmax_t</see> value.</param>
            <returns>A <see cref="T:System.UInt64">UInt64</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.intmax_t.op_Implicit(Math.Mpfr.Native.intmax_t)~System.Int64">
            <summary>
            Converts an <see cref="T:Math.Mpfr.Native.intmax_t">intmax_t</see> value to an <see cref="T:System.Int64">Int64</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Mpfr.Native.intmax_t">intmax_t</see> value.</param>
            <returns>An <see cref="T:System.Int64">Int64</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.intmax_t.ToString">
            <summary>
            Gets the string representation of the <see cref="T:Math.Mpfr.Native.intmax_t">intmax_t</see>.
            </summary>
            <returns>The string representation of the <see cref="T:Math.Mpfr.Native.intmax_t">intmax_t</see>.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.intmax_t.Equals(System.Object)">
            <summary>
            Returns a value indicating whether this instance is equal to a specified object.
            </summary>
            <param name="obj">An object to compare with this instance.</param>
            <returns><c>True</c> if <paramref name="obj"/> is an instance of <see cref="T:Math.Mpfr.Native.intmax_t">intmax_t</see> and equals the value of this instance; otherwise, <c>False</c>.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.intmax_t.Equals(Math.Mpfr.Native.intmax_t)">
            <summary>
            Returns a value indicating whether this instance is equal to a specified <see cref="T:Math.Mpfr.Native.intmax_t">intmax_t</see> value.
            </summary>
            <param name="other">A <see cref="T:Math.Mpfr.Native.intmax_t">intmax_t</see> value to compare to this instance.</param>
            <returns><c>True</c> if <paramref name="other"/> has the same value as this instance; otherwise, <c>False</c>.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.intmax_t.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.intmax_t.op_Equality(Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.intmax_t)">
            <summary>
            Gets a value that indicates whether the two argument values are equal.
            </summary>
            <param name="value1">A <see cref="T:Math.Mpfr.Native.intmax_t">intmax_t</see> value.</param>
            <param name="value2">A <see cref="T:Math.Mpfr.Native.intmax_t">intmax_t</see> value.</param>
            <returns><c>True</c> if the two values are equal, and <c>False</c> otherwise.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.intmax_t.op_Inequality(Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.intmax_t)">
            <summary>
            Gets a value that indicates whether the two argument values are different.
            </summary>
            <param name="value1">A <see cref="T:Math.Mpfr.Native.intmax_t">intmax_t</see> value.</param>
            <param name="value2">A <see cref="T:Math.Mpfr.Native.intmax_t">intmax_t</see> value.</param>
            <returns><c>True</c> if the two values are different, and <c>False</c> otherwise.</returns>
        </member>
        <member name="T:Math.Mpfr.Native.mpfr_free_cache_t">
            <summary>
            Represents the free cache policies.
            </summary>
        </member>
        <member name="F:Math.Mpfr.Native.mpfr_free_cache_t.MPFR_FREE_LOCAL_CACHE">
            <summary>
            To free the local cache.
            </summary>
        </member>
        <member name="F:Math.Mpfr.Native.mpfr_free_cache_t.MPFR_FREE_GLOBAL_CACHE">
            <summary>
            To free the global cache.
            </summary>
        </member>
        <member name="T:Math.Mpfr.Native.mpfr_flags_t">
            <summary>
            Represents one or more exception flags.
            </summary>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exceptions">GNU MPFR - Exceptions</a></seealso>
        </member>
        <member name="F:Math.Mpfr.Native.mpfr_flags_t.MPFR_FLAGS_UNDERFLOW">
            <summary>
            Represents the underflow flag.
            </summary>
            <remarks>
            <para>
            An underflow occurs when the exact result of a function is a non-zero real number and the result obtained after the rounding,
            assuming an unbounded exponent range (for the rounding), has an exponent smaller than the minimum value of the current exponent range.
            (In the round-to-nearest mode, the halfway case is rounded toward zero.)
            </para>
            <para>
            Note: This is not the single possible definition of the underflow.
            MPFR chooses to consider the underflow after rounding.
            The underflow before rounding can also be defined.
            For instance, consider a function that has the exact result 7 × 2^(e−4), where e is the smallest exponent
            (for a significand between 1/2 and 1), with a 2-bit target precision and rounding toward plus infinity.
            The exact result has the exponent e−1.
            With the underflow before rounding, such a function call would yield an underflow, as e−1 is outside
            the current exponent range.
            However, MPFR first considers the rounded result assuming an unbounded exponent range.
            The exact result cannot be represented exactly in precision 2, and here, it is rounded to 0.5 × 2^e,
            which is representable in the current exponent range.
            As a consequence, this will not yield an underflow in MPFR.
            </para>
            </remarks>
        </member>
        <member name="F:Math.Mpfr.Native.mpfr_flags_t.MPFR_FLAGS_OVERFLOW">
            <summary>
            Represents the overflow flag.
            </summary>
            <remarks>
            <para>
            An overflow occurs when the exact result of a function is a non-zero real number and the result obtained
            after the rounding, assuming an unbounded exponent range (for the rounding), has an exponent larger than
            the maximum value of the current exponent range.
            In the round-to-nearest mode, the result is infinite.
            Note: unlike the underflow case, there is only one possible definition of overflow here.
            </para>
            </remarks>
        </member>
        <member name="F:Math.Mpfr.Native.mpfr_flags_t.MPFR_FLAGS_NAN">
            <summary>
            Represents the NaN flag.
            </summary>
            <remarks>
            <para>
            A NaN exception occurs when the result of a function is NaN.
            </para>
            </remarks>
        </member>
        <member name="F:Math.Mpfr.Native.mpfr_flags_t.MPFR_FLAGS_INEXACT">
            <summary>
            Represent the inexact flag.
            </summary>
            <remarks>
            <para>
            An inexact exception occurs when the result of a function cannot be represented exactly and must be rounded.
            </para>
            </remarks>
        </member>
        <member name="F:Math.Mpfr.Native.mpfr_flags_t.MPFR_FLAGS_ERANGE">
            <summary>
            
            </summary>
            <remarks>
            <para>
            A range exception occurs when a function that does not return a MPFR number (such as comparisons and
            conversions to an integer) has an invalid result (e.g., an argument is NaN in mpfr_cmp, or a
            conversion to an integer cannot be represented in the target type).
            </para>
            </remarks>
        </member>
        <member name="F:Math.Mpfr.Native.mpfr_flags_t.MPFR_FLAGS_DIVBY0">
            <summary>
            Represent the divide-by-zero flag.
            </summary>
            <remarks>
            <para>
            An exact infinite result is obtained from finite inputs.
            </para>
            </remarks>
        </member>
        <member name="F:Math.Mpfr.Native.mpfr_flags_t.MPFR_FLAGS_ALL">
            <summary>
            Represents all flags.
            </summary>
        </member>
        <member name="T:Math.Mpfr.Native.mpfr_kind_t">
            <summary>
            Represents the kind of floating-point number in the <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Custom-Interface">GNU MPFR - Custom Interface</a>.
            </summary>
        </member>
        <member name="F:Math.Mpfr.Native.mpfr_kind_t.MPFR_NAN_KIND">
            <summary>
            Represents an invalid number.
            </summary>
        </member>
        <member name="F:Math.Mpfr.Native.mpfr_kind_t.MPFR_INF_KIND">
            <summary>
            Represents infinity.
            </summary>
        </member>
        <member name="F:Math.Mpfr.Native.mpfr_kind_t.MPFR_ZERO_KIND">
            <summary>
            Represents zero.
            </summary>
        </member>
        <member name="F:Math.Mpfr.Native.mpfr_kind_t.MPFR_REGULAR_KIND">
            <summary>
            Represent a regular number.
            </summary>
        </member>
        <member name="T:Math.Mpfr.Native.mpfr_sign_t">
            <summary>
            Represents the sign of a floating-point number.
            </summary>
            <remarks>
            <para>
            In .Net, this is a 32-bit integer. 
            </para>
            </remarks>
        </member>
        <member name="F:Math.Mpfr.Native.mpfr_sign_t.Value">
            <summary>
            The value of the <see cref="T:Math.Mpfr.Native.mpfr_sign_t">mpfr_sign_t</see>
            </summary>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_sign_t.#ctor(System.Int32)">
            <summary>
            Creates a new <see cref="T:Math.Mpfr.Native.mpfr_sign_t">mpfr_sign_t</see>, and sets its <paramref name="value"/>.
            </summary>
            <param name="value">The value of the new <see cref="T:Math.Mpfr.Native.mpfr_sign_t">mpfr_sign_t</see>.</param>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_sign_t.op_Implicit(System.Byte)~Math.Mpfr.Native.mpfr_sign_t">
            <summary>
            Converts a <see cref="T:System.Byte">Byte</see> value to an <see cref="T:Math.Mpfr.Native.mpfr_sign_t">mpfr_sign_t</see> value.
            </summary>
            <param name="value">A <see cref="T:System.Byte">Byte</see> value.</param>
            <returns>An <see cref="T:Math.Mpfr.Native.mpfr_sign_t">mpfr_sign_t</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_sign_t.op_Implicit(System.SByte)~Math.Mpfr.Native.mpfr_sign_t">
            <summary>
            Converts a <see cref="T:System.Byte">Byte</see> value to an <see cref="T:Math.Mpfr.Native.mpfr_sign_t">mpfr_sign_t</see> value.
            </summary>
            <param name="value">A <see cref="T:System.Byte">Byte</see> value.</param>
            <returns>An <see cref="T:Math.Mpfr.Native.mpfr_sign_t">mpfr_sign_t</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_sign_t.op_Implicit(System.UInt16)~Math.Mpfr.Native.mpfr_sign_t">
            <summary>
            Converts a <see cref="T:System.UInt16">UInt16</see> value to an <see cref="T:Math.Mpfr.Native.mpfr_sign_t">mpfr_sign_t</see> value.
            </summary>
            <param name="value">A <see cref="T:System.UInt16">UInt16</see> value.</param>
            <returns>An <see cref="T:Math.Mpfr.Native.mpfr_sign_t">mpfr_sign_t</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_sign_t.op_Implicit(System.Int16)~Math.Mpfr.Native.mpfr_sign_t">
            <summary>
            Converts an <see cref="T:System.Int16">Int16</see> value to an <see cref="T:Math.Mpfr.Native.mpfr_sign_t">mpfr_sign_t</see> value.
            </summary>
            <param name="value">An <see cref="T:System.Int16">Int16</see> value.</param>
            <returns>An <see cref="T:Math.Mpfr.Native.mpfr_sign_t">mpfr_sign_t</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_sign_t.op_Explicit(System.UInt32)~Math.Mpfr.Native.mpfr_sign_t">
            <summary>
            Converts a <see cref="T:System.UInt32">UInt32</see> value to an <see cref="T:Math.Mpfr.Native.mpfr_sign_t">mpfr_sign_t</see> value.
            </summary>
            <param name="value">A <see cref="T:System.UInt32">UInt32</see> value.</param>
            <returns>An <see cref="T:Math.Mpfr.Native.mpfr_sign_t">mpfr_sign_t</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_sign_t.op_Implicit(System.Int32)~Math.Mpfr.Native.mpfr_sign_t">
            <summary>
            Converts an <see cref="T:System.Int32">Int32</see> value to an <see cref="T:Math.Mpfr.Native.mpfr_sign_t">mpfr_sign_t</see> value.
            </summary>
            <param name="value">An <see cref="T:System.Int32">Int32</see> value.</param>
            <returns>An <see cref="T:Math.Mpfr.Native.mpfr_sign_t">mpfr_sign_t</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_sign_t.op_Explicit(System.UInt64)~Math.Mpfr.Native.mpfr_sign_t">
            <summary>
            Converts a <see cref="T:System.UInt64">UInt64</see> value to an <see cref="T:Math.Mpfr.Native.mpfr_sign_t">mpfr_sign_t</see> value.
            </summary>
            <param name="value">A <see cref="T:System.UInt64">UInt64</see> value.</param>
            <returns>An <see cref="T:Math.Mpfr.Native.mpfr_sign_t">mpfr_sign_t</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_sign_t.op_Explicit(System.Int64)~Math.Mpfr.Native.mpfr_sign_t">
            <summary>
            Converts an <see cref="T:System.Int64">Int64</see> value to a <see cref="T:Math.Mpfr.Native.mpfr_sign_t">mpfr_sign_t</see> value.
            </summary>
            <param name="value">An <see cref="T:System.Int64">Int64</see> value.</param>
            <returns>An <see cref="T:Math.Mpfr.Native.mpfr_sign_t">mpfr_sign_t</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_sign_t.op_Explicit(Math.Mpfr.Native.mpfr_sign_t)~System.Byte">
            <summary>
            Converts an <see cref="T:Math.Mpfr.Native.mpfr_sign_t">mpfr_sign_t</see> value to a <see cref="T:System.Byte">Byte</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Mpfr.Native.mpfr_sign_t">mpfr_sign_t</see> value.</param>
            <returns>A <see cref="T:System.Byte">Byte</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_sign_t.op_Explicit(Math.Mpfr.Native.mpfr_sign_t)~System.SByte">
            <summary>
            Converts an <see cref="T:Math.Mpfr.Native.mpfr_sign_t">mpfr_sign_t</see> value to an <see cref="T:System.SByte">SByte</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Mpfr.Native.mpfr_sign_t">mpfr_sign_t</see> value.</param>
            <returns>An <see cref="T:System.SByte">SByte</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_sign_t.op_Explicit(Math.Mpfr.Native.mpfr_sign_t)~System.UInt16">
            <summary>
            Converts an <see cref="T:Math.Mpfr.Native.mpfr_sign_t">mpfr_sign_t</see> value to a <see cref="T:System.UInt16">UInt16</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Mpfr.Native.mpfr_sign_t">mpfr_sign_t</see> value.</param>
            <returns>A <see cref="T:System.UInt16">UInt16</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_sign_t.op_Explicit(Math.Mpfr.Native.mpfr_sign_t)~System.Int16">
            <summary>
            Converts an <see cref="T:Math.Mpfr.Native.mpfr_sign_t">mpfr_sign_t</see> value to an <see cref="T:System.Int16">Int16</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Mpfr.Native.mpfr_sign_t">mpfr_sign_t</see> value.</param>
            <returns>An <see cref="T:System.Int16">Int16</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_sign_t.op_Explicit(Math.Mpfr.Native.mpfr_sign_t)~System.UInt32">
            <summary>
            Converts an <see cref="T:Math.Mpfr.Native.mpfr_sign_t">mpfr_sign_t</see> value to a <see cref="T:System.UInt32">UInt32</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Mpfr.Native.mpfr_sign_t">mpfr_sign_t</see> value.</param>
            <returns>A <see cref="T:System.UInt32">UInt32</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_sign_t.op_Implicit(Math.Mpfr.Native.mpfr_sign_t)~System.Int32">
            <summary>
            Converts an <see cref="T:Math.Mpfr.Native.mpfr_sign_t">mpfr_sign_t</see> value to an <see cref="T:System.Int32">Int32</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Mpfr.Native.mpfr_sign_t">mpfr_sign_t</see> value.</param>
            <returns>An <see cref="T:System.Int32">Int32</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_sign_t.op_Explicit(Math.Mpfr.Native.mpfr_sign_t)~System.UInt64">
            <summary>
            Converts an <see cref="T:Math.Mpfr.Native.mpfr_sign_t">mpfr_sign_t</see> value to a <see cref="T:System.UInt64">UInt64</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Mpfr.Native.mpfr_sign_t">mpfr_sign_t</see> value.</param>
            <returns>A <see cref="T:System.UInt64">UInt64</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_sign_t.op_Implicit(Math.Mpfr.Native.mpfr_sign_t)~System.Int64">
            <summary>
            Converts an <see cref="T:Math.Mpfr.Native.mpfr_sign_t">mpfr_sign_t</see> value to an <see cref="T:System.Int64">Int64</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Mpfr.Native.mpfr_sign_t">mpfr_sign_t</see> value.</param>
            <returns>An <see cref="T:System.Int64">Int64</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_sign_t.ToString">
            <summary>
            Gets the string representation of the <see cref="T:Math.Mpfr.Native.mpfr_sign_t">mpfr_sign_t</see>.
            </summary>
            <returns>The string representation of the <see cref="T:Math.Mpfr.Native.mpfr_sign_t">mpfr_sign_t</see>.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_sign_t.Equals(System.Object)">
            <summary>
            Returns a value indicating whether this instance is equal to a specified object.
            </summary>
            <param name="obj">An object to compare with this instance.</param>
            <returns><c>True</c> if <paramref name="obj"/> is an instance of <see cref="T:Math.Mpfr.Native.mpfr_sign_t">mpfr_sign_t</see> and equals the value of this instance; otherwise, <c>False</c>.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_sign_t.Equals(Math.Mpfr.Native.mpfr_sign_t)">
            <summary>
            Returns a value indicating whether this instance is equal to a specified <see cref="T:Math.Mpfr.Native.mpfr_sign_t">mpfr_sign_t</see> value.
            </summary>
            <param name="other">A <see cref="T:Math.Mpfr.Native.mpfr_sign_t">mpfr_sign_t</see> value to compare to this instance.</param>
            <returns><c>True</c> if <paramref name="other"/> has the same value as this instance; otherwise, <c>False</c>.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_sign_t.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_sign_t.op_Equality(Math.Mpfr.Native.mpfr_sign_t,Math.Mpfr.Native.mpfr_sign_t)">
            <summary>
            Gets a value that indicates whether the two argument values are equal.
            </summary>
            <param name="value1">A <see cref="T:Math.Mpfr.Native.mpfr_sign_t">mpfr_sign_t</see> value.</param>
            <param name="value2">A <see cref="T:Math.Mpfr.Native.mpfr_sign_t">mpfr_sign_t</see> value.</param>
            <returns><c>True</c> if the two values are equal, and <c>False</c> otherwise.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_sign_t.op_Inequality(Math.Mpfr.Native.mpfr_sign_t,Math.Mpfr.Native.mpfr_sign_t)">
            <summary>
            Gets a value that indicates whether the two argument values are different.
            </summary>
            <param name="value1">A <see cref="T:Math.Mpfr.Native.mpfr_sign_t">mpfr_sign_t</see> value.</param>
            <param name="value2">A <see cref="T:Math.Mpfr.Native.mpfr_sign_t">mpfr_sign_t</see> value.</param>
            <returns><c>True</c> if the two values are different, and <c>False</c> otherwise.</returns>
        </member>
        <member name="T:Math.Mpfr.Native.mpfr_exp_t">
            <summary>
            Represents the exponent of a floating-point number.
            </summary>
            <remarks>
            <para>
            The floating point functions accept and return exponents in the C type <see cref="T:Math.Mpfr.Native.mpfr_exp_t">mpfr_exp_t</see>.
            Currently this is usually a long, but on some systems it’s an int for efficiency.
            </para>
            <para>
            In .Net, this is a 32-bit integer. 
            </para>
            </remarks>
        </member>
        <member name="F:Math.Mpfr.Native.mpfr_exp_t.Value">
            <summary>
            The <see cref="T:Math.Mpfr.Native.mpfr_exp_t">mpfr_exp_t</see> value.
            </summary>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_exp_t.#ctor(System.Int32)">
            <summary>
            Creates a new <see cref="T:Math.Mpfr.Native.mpfr_exp_t">mpfr_exp_t</see>, and sets its <paramref name="value"/>.
            </summary>
            <param name="value">The value of the new <see cref="T:Math.Mpfr.Native.mpfr_exp_t">mpfr_exp_t</see>.</param>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_exp_t.op_Implicit(System.Byte)~Math.Mpfr.Native.mpfr_exp_t">
            <summary>
            Converts a <see cref="T:System.Byte">Byte</see> value to an <see cref="T:Math.Mpfr.Native.mpfr_exp_t">mpfr_exp_t</see> value.
            </summary>
            <param name="value">A <see cref="T:System.Byte">Byte</see> value.</param>
            <returns>An <see cref="T:Math.Mpfr.Native.mpfr_exp_t">mpfr_exp_t</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_exp_t.op_Implicit(System.SByte)~Math.Mpfr.Native.mpfr_exp_t">
            <summary>
            Converts a <see cref="T:System.Byte">Byte</see> value to an <see cref="T:Math.Mpfr.Native.mpfr_exp_t">mpfr_exp_t</see> value.
            </summary>
            <param name="value">A <see cref="T:System.Byte">Byte</see> value.</param>
            <returns>An <see cref="T:Math.Mpfr.Native.mpfr_exp_t">mpfr_exp_t</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_exp_t.op_Implicit(System.UInt16)~Math.Mpfr.Native.mpfr_exp_t">
            <summary>
            Converts a <see cref="T:System.UInt16">UInt16</see> value to an <see cref="T:Math.Mpfr.Native.mpfr_exp_t">mpfr_exp_t</see> value.
            </summary>
            <param name="value">A <see cref="T:System.UInt16">UInt16</see> value.</param>
            <returns>An <see cref="T:Math.Mpfr.Native.mpfr_exp_t">mpfr_exp_t</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_exp_t.op_Implicit(System.Int16)~Math.Mpfr.Native.mpfr_exp_t">
            <summary>
            Converts an <see cref="T:System.Int16">Int16</see> value to an <see cref="T:Math.Mpfr.Native.mpfr_exp_t">mpfr_exp_t</see> value.
            </summary>
            <param name="value">An <see cref="T:System.Int16">Int16</see> value.</param>
            <returns>An <see cref="T:Math.Mpfr.Native.mpfr_exp_t">mpfr_exp_t</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_exp_t.op_Explicit(System.UInt32)~Math.Mpfr.Native.mpfr_exp_t">
            <summary>
            Converts a <see cref="T:System.UInt32">UInt32</see> value to an <see cref="T:Math.Mpfr.Native.mpfr_exp_t">mpfr_exp_t</see> value.
            </summary>
            <param name="value">A <see cref="T:System.UInt32">UInt32</see> value.</param>
            <returns>An <see cref="T:Math.Mpfr.Native.mpfr_exp_t">mpfr_exp_t</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_exp_t.op_Implicit(System.Int32)~Math.Mpfr.Native.mpfr_exp_t">
            <summary>
            Converts an <see cref="T:System.Int32">Int32</see> value to an <see cref="T:Math.Mpfr.Native.mpfr_exp_t">mpfr_exp_t</see> value.
            </summary>
            <param name="value">An <see cref="T:System.Int32">Int32</see> value.</param>
            <returns>An <see cref="T:Math.Mpfr.Native.mpfr_exp_t">mpfr_exp_t</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_exp_t.op_Explicit(System.UInt64)~Math.Mpfr.Native.mpfr_exp_t">
            <summary>
            Converts a <see cref="T:System.UInt64">UInt64</see> value to an <see cref="T:Math.Mpfr.Native.mpfr_exp_t">mpfr_exp_t</see> value.
            </summary>
            <param name="value">A <see cref="T:System.UInt64">UInt64</see> value.</param>
            <returns>An <see cref="T:Math.Mpfr.Native.mpfr_exp_t">mpfr_exp_t</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_exp_t.op_Explicit(System.Int64)~Math.Mpfr.Native.mpfr_exp_t">
            <summary>
            Converts an <see cref="T:System.Int64">Int64</see> value to a <see cref="T:Math.Mpfr.Native.mpfr_exp_t">mpfr_exp_t</see> value.
            </summary>
            <param name="value">An <see cref="T:System.Int64">Int64</see> value.</param>
            <returns>An <see cref="T:Math.Mpfr.Native.mpfr_exp_t">mpfr_exp_t</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_exp_t.op_Explicit(Math.Mpfr.Native.mpfr_exp_t)~System.Byte">
            <summary>
            Converts an <see cref="T:Math.Mpfr.Native.mpfr_exp_t">mpfr_exp_t</see> value to a <see cref="T:System.Byte">Byte</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Mpfr.Native.mpfr_exp_t">mpfr_exp_t</see> value.</param>
            <returns>A <see cref="T:System.Byte">Byte</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_exp_t.op_Explicit(Math.Mpfr.Native.mpfr_exp_t)~System.SByte">
            <summary>
            Converts an <see cref="T:Math.Mpfr.Native.mpfr_exp_t">mpfr_exp_t</see> value to an <see cref="T:System.SByte">SByte</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Mpfr.Native.mpfr_exp_t">mpfr_exp_t</see> value.</param>
            <returns>An <see cref="T:System.SByte">SByte</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_exp_t.op_Explicit(Math.Mpfr.Native.mpfr_exp_t)~System.UInt16">
            <summary>
            Converts an <see cref="T:Math.Mpfr.Native.mpfr_exp_t">mpfr_exp_t</see> value to a <see cref="T:System.UInt16">UInt16</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Mpfr.Native.mpfr_exp_t">mpfr_exp_t</see> value.</param>
            <returns>A <see cref="T:System.UInt16">UInt16</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_exp_t.op_Explicit(Math.Mpfr.Native.mpfr_exp_t)~System.Int16">
            <summary>
            Converts an <see cref="T:Math.Mpfr.Native.mpfr_exp_t">mpfr_exp_t</see> value to an <see cref="T:System.Int16">Int16</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Mpfr.Native.mpfr_exp_t">mpfr_exp_t</see> value.</param>
            <returns>An <see cref="T:System.Int16">Int16</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_exp_t.op_Explicit(Math.Mpfr.Native.mpfr_exp_t)~System.UInt32">
            <summary>
            Converts an <see cref="T:Math.Mpfr.Native.mpfr_exp_t">mpfr_exp_t</see> value to a <see cref="T:System.UInt32">UInt32</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Mpfr.Native.mpfr_exp_t">mpfr_exp_t</see> value.</param>
            <returns>A <see cref="T:System.UInt32">UInt32</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_exp_t.op_Implicit(Math.Mpfr.Native.mpfr_exp_t)~System.Int32">
            <summary>
            Converts an <see cref="T:Math.Mpfr.Native.mpfr_exp_t">mpfr_exp_t</see> value to an <see cref="T:System.Int32">Int32</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Mpfr.Native.mpfr_exp_t">mpfr_exp_t</see> value.</param>
            <returns>An <see cref="T:System.Int32">Int32</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_exp_t.op_Explicit(Math.Mpfr.Native.mpfr_exp_t)~System.UInt64">
            <summary>
            Converts an <see cref="T:Math.Mpfr.Native.mpfr_exp_t">mpfr_exp_t</see> value to a <see cref="T:System.UInt64">UInt64</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Mpfr.Native.mpfr_exp_t">mpfr_exp_t</see> value.</param>
            <returns>A <see cref="T:System.UInt64">UInt64</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_exp_t.op_Implicit(Math.Mpfr.Native.mpfr_exp_t)~System.Int64">
            <summary>
            Converts an <see cref="T:Math.Mpfr.Native.mpfr_exp_t">mpfr_exp_t</see> value to an <see cref="T:System.Int64">Int64</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Mpfr.Native.mpfr_exp_t">mpfr_exp_t</see> value.</param>
            <returns>An <see cref="T:System.Int64">Int64</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_exp_t.ToString">
            <summary>
            Gets the string representation of the <see cref="T:Math.Mpfr.Native.mpfr_exp_t">mpfr_exp_t</see>.
            </summary>
            <returns>The string representation of the <see cref="T:Math.Mpfr.Native.mpfr_exp_t">mpfr_exp_t</see>.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_exp_t.Equals(System.Object)">
            <summary>
            Returns a value indicating whether this instance is equal to a specified object.
            </summary>
            <param name="obj">An object to compare with this instance.</param>
            <returns><c>True</c> if <paramref name="obj"/> is an instance of <see cref="T:Math.Mpfr.Native.mpfr_exp_t">mpfr_exp_t</see> and equals the value of this instance; otherwise, <c>False</c>.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_exp_t.Equals(Math.Mpfr.Native.mpfr_exp_t)">
            <summary>
            Returns a value indicating whether this instance is equal to a specified <see cref="T:Math.Mpfr.Native.mpfr_exp_t">mpfr_exp_t</see> value.
            </summary>
            <param name="other">A <see cref="T:Math.Mpfr.Native.mpfr_exp_t">mpfr_exp_t</see> value to compare to this instance.</param>
            <returns><c>True</c> if <paramref name="other"/> has the same value as this instance; otherwise, <c>False</c>.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_exp_t.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_exp_t.op_Equality(Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_exp_t)">
            <summary>
            Gets a value that indicates whether the two argument values are equal.
            </summary>
            <param name="value1">A <see cref="T:Math.Mpfr.Native.mpfr_exp_t">mpfr_exp_t</see> value.</param>
            <param name="value2">A <see cref="T:Math.Mpfr.Native.mpfr_exp_t">mpfr_exp_t</see> value.</param>
            <returns><c>True</c> if the two values are equal, and <c>False</c> otherwise.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_exp_t.op_Inequality(Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_exp_t)">
            <summary>
            Gets a value that indicates whether the two argument values are different.
            </summary>
            <param name="value1">A <see cref="T:Math.Mpfr.Native.mpfr_exp_t">mpfr_exp_t</see> value.</param>
            <param name="value2">A <see cref="T:Math.Mpfr.Native.mpfr_exp_t">mpfr_exp_t</see> value.</param>
            <returns><c>True</c> if the two values are different, and <c>False</c> otherwise.</returns>
        </member>
        <member name="T:Math.Mpfr.Native.mpfr_rnd_t">
            <summary>
            Represents the different rounding modes.
            </summary>
            <remarks>
            <para>
            The ‘roundtonearest’ mode works as in the IEEE 754 standard: in case the number to be rounded lies exactly in
            the middle of two representable numbers, it is rounded to the one with the least significant bit set to zero.
            For example, the number 2.5, which is represented by (10.1) in binary, is rounded to (10.0)=2 with a precision
            of two bits, and not to (11.0)=3.
            This rule avoids the drift phenomenon mentioned by Knuth in volume 2 of The Art of Computer Programming
            (Section 4.2.2).
            </para>
            <para>
            The MPFR_RNDF mode works as follows: the computed value is either that corresponding to MPFR_RNDD or that
            corresponding to MPFR_RNDU.
            In particular when those values are identical, i.e., when the result of the corresponding operation is exactly
            representable, that exact result is returned.
            Thus, the computed result can take at most two possible values, and in absence of underflow/overflow, the
            corresponding error is strictly less than one ulp (unit in the last place) of that result and of the exact result.
            For MPFR_RNDF, the ternary value (defined below) and the inexact flag (defined later, as with the other flags)
            are unspecified, the divide-by-zero flag is as with other roundings, and the underflow and overflow flags match
            what would be obtained in the case the computed value is the same as with MPFR_RNDD or MPFR_RNDU.
            The results may not be reproducible.
            </para>
            <para>
            Most MPFR functions take as first argument the destination variable, as second and following arguments the input
            variables, as last argument a rounding mode, and have a return value of type int, called the ternary value.
            The value stored in the destination variable is correctly rounded, i.e., MPFR behaves as if it computed the
            result with an infinite precision, then rounded it to the precision of this variable.
            The input variables are regarded as exact (in particular, their precision does not affect the result).
            </para>
            <para>
            As a consequence, in case of a non-zero real rounded result, the error on the result is less or equal to 1/2 ulp
            (unit in the last place) of that result in the rounding to nearest mode, and less than 1 ulp of that result in
            the directed rounding modes (a ulp is the weight of the least significant represented bit of the result after
            rounding).
            </para>
            <para>
            Unless documented otherwise, functions returning an int return a ternary value.
            If the ternary value is zero, it means that the value stored in the destination variable is the exact result of
            the corresponding mathematical function.
            If the ternary value is positive (resp. negative), it means the value stored in the destination variable is greater
            (resp. lower) than the exact result.
            For example with the MPFR_RNDU rounding mode, the ternary value is usually positive, except when the result is exact,
            in which case it is zero.
            In the case of an infinite result, it is considered as inexact when it was obtained by overflow, and exact otherwise.
            A NaN result (Not-a-Number) always corresponds to an exact return value.
            The opposite of a returned ternary value is guaranteed to be representable in an int.
            </para>
            <para>
            Unless documented otherwise, functions returning as result the value 1 (or any other value specified in this manual)
            for special cases (like acos(0)) yield an overflow or an underflow if that value is not representable in the current
            exponent range.
            </para>
            </remarks>
        </member>
        <member name="F:Math.Mpfr.Native.mpfr_rnd_t.MPFR_RNDN">
            <summary>
            Round to nearest, with ties to even.
            </summary>
        </member>
        <member name="F:Math.Mpfr.Native.mpfr_rnd_t.MPFR_RNDZ">
            <summary>
            Round toward zero.
            </summary>
        </member>
        <member name="F:Math.Mpfr.Native.mpfr_rnd_t.MPFR_RNDU">
            <summary>
            Round toward +Infinity.
            </summary>
        </member>
        <member name="F:Math.Mpfr.Native.mpfr_rnd_t.MPFR_RNDD">
            <summary>
            Round toward -Infinity.
            </summary>
        </member>
        <member name="F:Math.Mpfr.Native.mpfr_rnd_t.MPFR_RNDA">
            <summary>
            Round away from zero.
            </summary>
        </member>
        <member name="F:Math.Mpfr.Native.mpfr_rnd_t.MPFR_RNDF">
            <summary>
            Faithful rounding.
            </summary>
            <remarks>
            <para>
            This feature is currently experimental.
            Specific support for this rounding mode has been added to some functions, such as the basic operations
            (addition, subtraction, multiplication, square, division, square root) or when explicitly documented.
            It might also work with other functions, as it is possible that they do not need modification in their code;
            even though a correct behavior is not guaranteed yet (corrections were done when failures occurred in the
            test suite, but almost nothing has been checked manually), failures should be regarded as bugs and reported,
            so that they can be fixed.
            </para>
            </remarks>
        </member>
        <member name="F:Math.Mpfr.Native.mpfr_rnd_t.MPFR_RNDNA">
            <summary>
            Round to nearest, with ties away from zero (<see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_lib.mpfr_round</see>).
            </summary>
        </member>
        <member name="T:Math.Mpfr.Native.mpfr_t">
            <summary>
            Represents a multiple precision floating-point number.
            </summary>
            <remarks>
            <para>
            A floating-point number, or float for short, is an arbitrary precision significand (also called mantissa)
            with a limited precision exponent.
            The C data type for such objects is <see cref="T:Math.Mpfr.Native.mpfr_t">mpfr_t</see> (internally defined as a one-element array of a
            structure, and <a href="https://machinecognitis.github.io/Math.Gmp.Native/html/4609ac5e-5cf9-cd20-2fa9-8040101c165c.htm">mp_ptr</a>
            is the C data type representing a pointer to this structure).
            A floating-point number can have three special values: Not-a-Number (NaN) or plus or minus Infinity.
            NaN represents an uninitialized object, the result of an invalid operation (like 0 divided by 0), or
            a value that cannot be determined (like +Infinity minus +Infinity).
            Moreover, like in the IEEE 754 standard, zero is signed, i.e., there are both +0 and -0; the behavior
            is the same as in the IEEE 754 standard and it is generalized to the other functions supported by MPFR.
            Unless documented otherwise, the sign bit of a NaN is unspecified. 
            </para>
            <para>
            The precision is the number of bits used to represent the significand of a floating-point number;
            the corresponding C data type is <see cref="T:Math.Mpfr.Native.mpfr_prec_t">mpfr_prec_t</see>.
            The precision can be any integer between <see cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_PREC_MIN">mpfr_lib.MPFR_PREC_MIN</see> and <see cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_PREC_MAX">mpfr_lib.MPFR_PREC_MAX</see>.
            In the current implementation, <see cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_PREC_MIN">mpfr_lib.MPFR_PREC_MIN</see> is equal to 2. 
            </para>
            <para>
            Warning! MPFR needs to increase the precision internally, in order to provide accurate results
            (and in particular, correct rounding).
            Do not attempt to set the precision to any value near <see cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_PREC_MAX">mpfr_lib.MPFR_PREC_MAX</see>, otherwise MPFR will
            abort due to an assertion failure.
            Moreover, you may reach some memory limit on your platform, in which case the program may abort, crash or have
            undefined behavior (depending on your C implementation).
            </para>
            <para>
            The rounding mode specifies the way to round the result of a floating-point operation, in case the exact result
            can not be represented exactly in the destination significand; the corresponding C data type is <see cref="T:Math.Mpfr.Native.mpfr_rnd_t">mpfr_rnd_t</see>. 
            </para>
            </remarks>
        </member>
        <member name="F:Math.Mpfr.Native.mpfr_t._initialized">
            <summary>
            The <see cref="T:Math.Mpfr.Native.mpfr_t">mpfr_t</see> value.
            </summary>
        </member>
        <member name="P:Math.Mpfr.Native.mpfr_t._mpfr_prec">
            <summary>
            The precision of the mantissa, in limbs.
            </summary>
            <remarks>
            <para>
            In any calculation the aim is to produce <see cref="P:Math.Mpfr.Native.mpfr_t._mpfr_prec">_mpfr_prec</see> limbs of result (the most significant being non-zero). 
            </para>
            </remarks>
        </member>
        <member name="P:Math.Mpfr.Native.mpfr_t._mpfr_sign">
            <summary>
            Gets the sign of the floating-point number.
            </summary>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_signbit(Math.Mpfr.Native.mpfr_t)">mpfr_signbit</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_setsign(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_setsign</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_copysign(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_copysign</seealso>
        </member>
        <member name="P:Math.Mpfr.Native.mpfr_t._mpfr_exp">
            <summary>
            The _mpfr_exp field stores the exponent.
            </summary>
            <remarks>
            <para>
            An exponent of 0 means a radix point just above the most significant limb.
            Non-zero values n are a multiplier 2^n relative to that point.
            A NaN, an infinity and a zero are indicated by special values of the exponent field. 
            </para>
            </remarks>
        </member>
        <member name="P:Math.Mpfr.Native.mpfr_t._mp_d_intptr">
            <summary>
            The <see cref="P:Math.Mpfr.Native.mpfr_t._mp_d_intptr">_mp_d_intptr</see> field is a pointer to the limbs, least significant limbs stored first. 
            </summary>
            <remarks>
            <para>
            The number of limbs in use is controlled by <see cref="P:Math.Mpfr.Native.mpfr_t._mpfr_prec">_mpfr_prec</see>, namely
            ceil(<see cref="P:Math.Mpfr.Native.mpfr_t._mpfr_prec">_mpfr_prec</see> / <a href="https://machinecognitis.github.io/Math.Gmp.Native/html/f88c76a8-118a-5cbd-0df1-e30adcacb8ae.htm">mp_bits_per_limb</a>).
            Non-singular (i.e., different from NaN, Infinity or zero) values always have the most
            significant bit of the most significant limb set to 1.
            When the precision does not correspond to a whole number of limbs, the excess bits at
            the low end of the data are zeros.
            </para>
            </remarks>
        </member>
        <member name="P:Math.Mpfr.Native.mpfr_t._mp_size">
            <summary>
            The number of limbs currently in use.
            </summary>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_t.ToIntPtr">
            <summary>
            Gets the unmanaged memory pointer of the multiple precision floating-point number.
            </summary>
            <returns>The unmanaged memory pointer of the multiple precision floating-point number.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_t.op_Implicit(System.String)~Math.Mpfr.Native.mpfr_t">
            <summary>
            Converts a <see cref="T:System.String">string</see> value to an <see cref="T:Math.Mpfr.Native.mpfr_t">mpfr_t</see> value.
            </summary>
            <param name="value">A <see cref="T:System.String">string</see> value.</param>
            <returns>An <see cref="T:Math.Mpfr.Native.mpfr_t">mpfr_t</see> value.</returns>
            <remarks>
            <para>
            Base is assumed to be 10 unless the first character of the string is <c>B</c>
            followed by the base <c>2</c> to <c>62</c> or <c>-62</c> to <c>-2</c> followed
            by a space and then the floating-point number.
            Negative values are used to specify that the exponent is in decimal.
            </para>
            </remarks>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_t.ToString">
            <summary>
            Return the string representation of the float.
            </summary>
            <returns>The string representation of the float.</returns>
        </member>
        <member name="T:Math.Mpfr.Native.mpfr_prec_t">
            <summary>
            Represents precision in number of bits.
            </summary>
        </member>
        <member name="F:Math.Mpfr.Native.mpfr_prec_t.Value">
            <summary>
            The <see cref="T:Math.Mpfr.Native.mpfr_prec_t">mpfr_prec_t</see> value.
            </summary>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_prec_t.#ctor(System.UInt32)">
            <summary>
            Creates a new <see cref="T:Math.Mpfr.Native.mpfr_prec_t">mpfr_prec_t</see>, and sets its <paramref name="value"/>.
            </summary>
            <param name="value">The value of the new <see cref="T:Math.Mpfr.Native.mpfr_prec_t">mpfr_prec_t</see>.</param>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_prec_t.op_Implicit(System.Byte)~Math.Mpfr.Native.mpfr_prec_t">
            <summary>
            Converts a <see cref="T:System.Byte">Byte</see> value to an <see cref="T:Math.Mpfr.Native.mpfr_prec_t">mpfr_prec_t</see> value.
            </summary>
            <param name="value">A <see cref="T:System.Byte">Byte</see> value.</param>
            <returns>An <see cref="T:Math.Mpfr.Native.mpfr_prec_t">mpfr_prec_t</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_prec_t.op_Explicit(System.SByte)~Math.Mpfr.Native.mpfr_prec_t">
            <summary>
            Converts a <see cref="T:System.Byte">Byte</see> value to an <see cref="T:Math.Mpfr.Native.mpfr_prec_t">mpfr_prec_t</see> value.
            </summary>
            <param name="value">A <see cref="T:System.Byte">Byte</see> value.</param>
            <returns>An <see cref="T:Math.Mpfr.Native.mpfr_prec_t">mpfr_prec_t</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_prec_t.op_Implicit(System.UInt16)~Math.Mpfr.Native.mpfr_prec_t">
            <summary>
            Converts a <see cref="T:System.UInt16">UInt16</see> value to an <see cref="T:Math.Mpfr.Native.mpfr_prec_t">mpfr_prec_t</see> value.
            </summary>
            <param name="value">A <see cref="T:System.UInt16">UInt16</see> value.</param>
            <returns>An <see cref="T:Math.Mpfr.Native.mpfr_prec_t">mpfr_prec_t</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_prec_t.op_Explicit(System.Int16)~Math.Mpfr.Native.mpfr_prec_t">
            <summary>
            Converts an <see cref="T:System.Int16">Int16</see> value to an <see cref="T:Math.Mpfr.Native.mpfr_prec_t">mpfr_prec_t</see> value.
            </summary>
            <param name="value">An <see cref="T:System.Int16">Int16</see> value.</param>
            <returns>An <see cref="T:Math.Mpfr.Native.mpfr_prec_t">mpfr_prec_t</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_prec_t.op_Implicit(System.UInt32)~Math.Mpfr.Native.mpfr_prec_t">
            <summary>
            Converts a <see cref="T:System.UInt32">UInt32</see> value to an <see cref="T:Math.Mpfr.Native.mpfr_prec_t">mpfr_prec_t</see> value.
            </summary>
            <param name="value">A <see cref="T:System.UInt32">UInt32</see> value.</param>
            <returns>An <see cref="T:Math.Mpfr.Native.mpfr_prec_t">mpfr_prec_t</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_prec_t.op_Explicit(System.Int32)~Math.Mpfr.Native.mpfr_prec_t">
            <summary>
            Converts an <see cref="T:System.Int32">Int32</see> value to an <see cref="T:Math.Mpfr.Native.mpfr_prec_t">mpfr_prec_t</see> value.
            </summary>
            <param name="value">An <see cref="T:System.Int32">Int32</see> value.</param>
            <returns>An <see cref="T:Math.Mpfr.Native.mpfr_prec_t">mpfr_prec_t</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_prec_t.op_Explicit(System.UInt64)~Math.Mpfr.Native.mpfr_prec_t">
            <summary>
            Converts a <see cref="T:System.UInt64">UInt64</see> value to an <see cref="T:Math.Mpfr.Native.mpfr_prec_t">mpfr_prec_t</see> value.
            </summary>
            <param name="value">A <see cref="T:System.UInt64">UInt64</see> value.</param>
            <returns>An <see cref="T:Math.Mpfr.Native.mpfr_prec_t">mpfr_prec_t</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_prec_t.op_Explicit(System.Int64)~Math.Mpfr.Native.mpfr_prec_t">
            <summary>
            Converts an <see cref="T:System.Int64">Int64</see> value to a <see cref="T:Math.Mpfr.Native.mpfr_prec_t">mpfr_prec_t</see> value.
            </summary>
            <param name="value">An <see cref="T:System.Int64">Int64</see> value.</param>
            <returns>An <see cref="T:Math.Mpfr.Native.mpfr_prec_t">mpfr_prec_t</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_prec_t.op_Explicit(Math.Mpfr.Native.mpfr_prec_t)~System.Byte">
            <summary>
            Converts an <see cref="T:Math.Mpfr.Native.mpfr_prec_t">mpfr_prec_t</see> value to a <see cref="T:System.Byte">Byte</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Mpfr.Native.mpfr_prec_t">mpfr_prec_t</see> value.</param>
            <returns>A <see cref="T:System.Byte">Byte</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_prec_t.op_Explicit(Math.Mpfr.Native.mpfr_prec_t)~System.SByte">
            <summary>
            Converts an <see cref="T:Math.Mpfr.Native.mpfr_prec_t">mpfr_prec_t</see> value to an <see cref="T:System.SByte">SByte</see> value.
            </summary>
            <param name="value">An <see cref="T:System.SByte">SByte</see> value.</param>
            <returns>An <see cref="T:System.Byte">Byte</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_prec_t.op_Explicit(Math.Mpfr.Native.mpfr_prec_t)~System.UInt16">
            <summary>
            Converts an <see cref="T:Math.Mpfr.Native.mpfr_prec_t">mpfr_prec_t</see> value to a <see cref="T:System.UInt16">UInt16</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Mpfr.Native.mpfr_prec_t">mpfr_prec_t</see> value.</param>
            <returns>A <see cref="T:System.UInt16">UInt16</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_prec_t.op_Explicit(Math.Mpfr.Native.mpfr_prec_t)~System.Int16">
            <summary>
            Converts an <see cref="T:Math.Mpfr.Native.mpfr_prec_t">mpfr_prec_t</see> value to an <see cref="T:System.Int16">Int16</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Mpfr.Native.mpfr_prec_t">mpfr_prec_t</see> value.</param>
            <returns>An <see cref="T:System.Int16">Int16</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_prec_t.op_Implicit(Math.Mpfr.Native.mpfr_prec_t)~System.UInt32">
            <summary>
            Converts an <see cref="T:Math.Mpfr.Native.mpfr_prec_t">mpfr_prec_t</see> value to a <see cref="T:System.UInt32">UInt32</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Mpfr.Native.mpfr_prec_t">mpfr_prec_t</see> value.</param>
            <returns>A <see cref="T:System.UInt32">UInt32</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_prec_t.op_Explicit(Math.Mpfr.Native.mpfr_prec_t)~System.Int32">
            <summary>
            Converts an <see cref="T:Math.Mpfr.Native.mpfr_prec_t">mpfr_prec_t</see> value to an <see cref="T:System.Int32">Int32</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Mpfr.Native.mpfr_prec_t">mpfr_prec_t</see> value.</param>
            <returns>An <see cref="T:System.Int32">Int32</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_prec_t.op_Implicit(Math.Mpfr.Native.mpfr_prec_t)~System.UInt64">
            <summary>
            Converts an <see cref="T:Math.Mpfr.Native.mpfr_prec_t">mpfr_prec_t</see> value to a <see cref="T:System.UInt64">UInt64</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Mpfr.Native.mpfr_prec_t">mpfr_prec_t</see> value.</param>
            <returns>A <see cref="T:System.UInt64">UInt64</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_prec_t.op_Implicit(Math.Mpfr.Native.mpfr_prec_t)~System.Int64">
            <summary>
            Converts an <see cref="T:Math.Mpfr.Native.mpfr_prec_t">mpfr_prec_t</see> value to an <see cref="T:System.Int64">Int64</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Mpfr.Native.mpfr_prec_t">mpfr_prec_t</see> value.</param>
            <returns>An <see cref="T:System.Int64">Int64</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_prec_t.ToString">
            <summary>
            Gets the string representation of the <see cref="T:Math.Mpfr.Native.mpfr_prec_t">mpfr_prec_t</see>.
            </summary>
            <returns>The string representation of the <see cref="T:Math.Mpfr.Native.mpfr_prec_t">mpfr_prec_t</see>.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_prec_t.Equals(System.Object)">
            <summary>
            Returns a value indicating whether this instance is equal to a specified object.
            </summary>
            <param name="obj">An object to compare with this instance.</param>
            <returns><c>True</c> if <paramref name="obj"/> is an instance of <see cref="T:Math.Mpfr.Native.mpfr_prec_t">mpfr_prec_t</see> and equals the value of this instance; otherwise, <c>False</c>.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_prec_t.Equals(Math.Mpfr.Native.mpfr_prec_t)">
            <summary>
            Returns a value indicating whether this instance is equal to a specified <see cref="T:Math.Mpfr.Native.mpfr_prec_t">mpfr_prec_t</see> value.
            </summary>
            <param name="other">A <see cref="T:Math.Mpfr.Native.mpfr_prec_t">mpfr_prec_t</see> value to compare to this instance.</param>
            <returns><c>True</c> if <paramref name="other"/> has the same value as this instance; otherwise, <c>False</c>.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_prec_t.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_prec_t.op_Equality(Math.Mpfr.Native.mpfr_prec_t,Math.Mpfr.Native.mpfr_prec_t)">
            <summary>
            Gets a value that indicates whether the two argument values are equal.
            </summary>
            <param name="value1">A <see cref="T:Math.Mpfr.Native.mpfr_prec_t">mpfr_prec_t</see> value.</param>
            <param name="value2">A <see cref="T:Math.Mpfr.Native.mpfr_prec_t">mpfr_prec_t</see> value.</param>
            <returns><c>True</c> if the two values are equal, and <c>False</c> otherwise.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_prec_t.op_Inequality(Math.Mpfr.Native.mpfr_prec_t,Math.Mpfr.Native.mpfr_prec_t)">
            <summary>
            Gets a value that indicates whether the two argument values are different.
            </summary>
            <param name="value1">A <see cref="T:Math.Mpfr.Native.mpfr_prec_t">mpfr_prec_t</see> value.</param>
            <param name="value2">A <see cref="T:Math.Mpfr.Native.mpfr_prec_t">mpfr_prec_t</see> value.</param>
            <returns><c>True</c> if the two values are different, and <c>False</c> otherwise.</returns>
        </member>
        <member name="T:Math.Mpfr.Native.uintmax_t">
            <summary>
            Represents the maximum width unsigned integer type.
            </summary>
            <remarks>
            <para>
            In .NET, this is an unsigned 64-bit integer.
            </para>
            </remarks>
            <seealso cref="T:Math.Mpfr.Native.intmax_t"/>
        </member>
        <member name="F:Math.Mpfr.Native.uintmax_t.Value">
            <summary>
            The value of the <see cref="T:Math.Mpfr.Native.uintmax_t">uintmax_t</see>.
            </summary>
        </member>
        <member name="M:Math.Mpfr.Native.uintmax_t.#ctor(System.UInt64)">
            <summary>
            Creates a new <see cref="T:Math.Mpfr.Native.uintmax_t">uintmax_t</see>, and sets its <paramref name="value"/>.
            </summary>
            <param name="value">The value of the new <see cref="T:Math.Mpfr.Native.uintmax_t">uintmax_t</see>.</param>
        </member>
        <member name="M:Math.Mpfr.Native.uintmax_t.op_Implicit(System.Byte)~Math.Mpfr.Native.uintmax_t">
            <summary>
            Converts a <see cref="T:System.Byte">Byte</see> value to an <see cref="T:Math.Mpfr.Native.uintmax_t">uintmax_t</see> value.
            </summary>
            <param name="value">A <see cref="T:System.Byte">Byte</see> value.</param>
            <returns>An <see cref="T:Math.Mpfr.Native.uintmax_t">uintmax_t</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.uintmax_t.op_Explicit(System.SByte)~Math.Mpfr.Native.uintmax_t">
            <summary>
            Converts a <see cref="T:System.Byte">Byte</see> value to an <see cref="T:Math.Mpfr.Native.uintmax_t">uintmax_t</see> value.
            </summary>
            <param name="value">A <see cref="T:System.Byte">Byte</see> value.</param>
            <returns>An <see cref="T:Math.Mpfr.Native.uintmax_t">uintmax_t</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.uintmax_t.op_Implicit(System.UInt16)~Math.Mpfr.Native.uintmax_t">
            <summary>
            Converts a <see cref="T:System.UInt16">UInt16</see> value to an <see cref="T:Math.Mpfr.Native.uintmax_t">uintmax_t</see> value.
            </summary>
            <param name="value">A <see cref="T:System.UInt16">UInt16</see> value.</param>
            <returns>An <see cref="T:Math.Mpfr.Native.uintmax_t">uintmax_t</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.uintmax_t.op_Explicit(System.Int16)~Math.Mpfr.Native.uintmax_t">
            <summary>
            Converts an <see cref="T:System.Int16">Int16</see> value to an <see cref="T:Math.Mpfr.Native.uintmax_t">uintmax_t</see> value.
            </summary>
            <param name="value">An <see cref="T:System.Int16">Int16</see> value.</param>
            <returns>An <see cref="T:Math.Mpfr.Native.uintmax_t">uintmax_t</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.uintmax_t.op_Implicit(System.UInt32)~Math.Mpfr.Native.uintmax_t">
            <summary>
            Converts a <see cref="T:System.UInt32">UInt32</see> value to an <see cref="T:Math.Mpfr.Native.uintmax_t">uintmax_t</see> value.
            </summary>
            <param name="value">A <see cref="T:System.UInt32">UInt32</see> value.</param>
            <returns>An <see cref="T:Math.Mpfr.Native.uintmax_t">uintmax_t</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.uintmax_t.op_Explicit(System.Int32)~Math.Mpfr.Native.uintmax_t">
            <summary>
            Converts an <see cref="T:System.Int32">Int32</see> value to an <see cref="T:Math.Mpfr.Native.uintmax_t">uintmax_t</see> value.
            </summary>
            <param name="value">An <see cref="T:System.Int32">Int32</see> value.</param>
            <returns>An <see cref="T:Math.Mpfr.Native.uintmax_t">uintmax_t</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.uintmax_t.op_Implicit(System.UInt64)~Math.Mpfr.Native.uintmax_t">
            <summary>
            Converts a <see cref="T:System.UInt64">UInt64</see> value to an <see cref="T:Math.Mpfr.Native.uintmax_t">uintmax_t</see> value.
            </summary>
            <param name="value">A <see cref="T:System.UInt64">UInt64</see> value.</param>
            <returns>An <see cref="T:Math.Mpfr.Native.uintmax_t">uintmax_t</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.uintmax_t.op_Explicit(System.Int64)~Math.Mpfr.Native.uintmax_t">
            <summary>
            Converts an <see cref="T:System.Int64">Int64</see> value to a <see cref="T:Math.Mpfr.Native.uintmax_t">uintmax_t</see> value.
            </summary>
            <param name="value">An <see cref="T:System.Int64">Int64</see> value.</param>
            <returns>An <see cref="T:Math.Mpfr.Native.uintmax_t">uintmax_t</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.uintmax_t.op_Explicit(Math.Mpfr.Native.uintmax_t)~System.Byte">
            <summary>
            Converts an <see cref="T:Math.Mpfr.Native.uintmax_t">uintmax_t</see> value to a <see cref="T:System.Byte">Byte</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Mpfr.Native.uintmax_t">uintmax_t</see> value.</param>
            <returns>A <see cref="T:System.Byte">Byte</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.uintmax_t.op_Explicit(Math.Mpfr.Native.uintmax_t)~System.SByte">
            <summary>
            Converts an <see cref="T:Math.Mpfr.Native.uintmax_t">uintmax_t</see> value to an <see cref="T:System.SByte">SByte</see> value.
            </summary>
            <param name="value">An <see cref="T:System.SByte">SByte</see> value.</param>
            <returns>An <see cref="T:System.Byte">Byte</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.uintmax_t.op_Explicit(Math.Mpfr.Native.uintmax_t)~System.UInt16">
            <summary>
            Converts an <see cref="T:Math.Mpfr.Native.uintmax_t">uintmax_t</see> value to a <see cref="T:System.UInt16">UInt16</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Mpfr.Native.uintmax_t">uintmax_t</see> value.</param>
            <returns>A <see cref="T:System.UInt16">UInt16</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.uintmax_t.op_Explicit(Math.Mpfr.Native.uintmax_t)~System.Int16">
            <summary>
            Converts an <see cref="T:Math.Mpfr.Native.uintmax_t">uintmax_t</see> value to an <see cref="T:System.Int16">Int16</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Mpfr.Native.uintmax_t">uintmax_t</see> value.</param>
            <returns>An <see cref="T:System.Int16">Int16</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.uintmax_t.op_Explicit(Math.Mpfr.Native.uintmax_t)~System.UInt32">
            <summary>
            Converts an <see cref="T:Math.Mpfr.Native.uintmax_t">uintmax_t</see> value to a <see cref="T:System.UInt32">UInt32</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Mpfr.Native.uintmax_t">uintmax_t</see> value.</param>
            <returns>A <see cref="T:System.UInt32">UInt32</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.uintmax_t.op_Explicit(Math.Mpfr.Native.uintmax_t)~System.Int32">
            <summary>
            Converts an <see cref="T:Math.Mpfr.Native.uintmax_t">uintmax_t</see> value to an <see cref="T:System.Int32">Int32</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Mpfr.Native.uintmax_t">uintmax_t</see> value.</param>
            <returns>An <see cref="T:System.Int32">Int32</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.uintmax_t.op_Implicit(Math.Mpfr.Native.uintmax_t)~System.UInt64">
            <summary>
            Converts an <see cref="T:Math.Mpfr.Native.uintmax_t">uintmax_t</see> value to a <see cref="T:System.UInt64">UInt64</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Mpfr.Native.uintmax_t">uintmax_t</see> value.</param>
            <returns>A <see cref="T:System.UInt64">UInt64</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.uintmax_t.op_Explicit(Math.Mpfr.Native.uintmax_t)~System.Int64">
            <summary>
            Converts an <see cref="T:Math.Mpfr.Native.uintmax_t">uintmax_t</see> value to an <see cref="T:System.Int64">Int64</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Mpfr.Native.uintmax_t">uintmax_t</see> value.</param>
            <returns>An <see cref="T:System.Int64">Int64</see> value.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.uintmax_t.ToString">
            <summary>
            Gets the string representation of the <see cref="T:Math.Mpfr.Native.uintmax_t">uintmax_t</see>.
            </summary>
            <returns>The string representation of the <see cref="T:Math.Mpfr.Native.uintmax_t">uintmax_t</see>.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.uintmax_t.Equals(System.Object)">
            <summary>
            Returns a value indicating whether this instance is equal to a specified object.
            </summary>
            <param name="obj">An object to compare with this instance.</param>
            <returns><c>True</c> if <paramref name="obj"/> is an instance of <see cref="T:Math.Mpfr.Native.uintmax_t">uintmax_t</see> and equals the value of this instance; otherwise, <c>False</c>.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.uintmax_t.Equals(Math.Mpfr.Native.uintmax_t)">
            <summary>
            Returns a value indicating whether this instance is equal to a specified <see cref="T:Math.Mpfr.Native.uintmax_t">uintmax_t</see> value.
            </summary>
            <param name="other">A <see cref="T:Math.Mpfr.Native.uintmax_t">uintmax_t</see> value to compare to this instance.</param>
            <returns><c>True</c> if <paramref name="other"/> has the same value as this instance; otherwise, <c>False</c>.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.uintmax_t.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.uintmax_t.op_Equality(Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.uintmax_t)">
            <summary>
            Gets a value that indicates whether the two argument values are equal.
            </summary>
            <param name="value1">A <see cref="T:Math.Mpfr.Native.uintmax_t">uintmax_t</see> value.</param>
            <param name="value2">A <see cref="T:Math.Mpfr.Native.uintmax_t">uintmax_t</see> value.</param>
            <returns><c>True</c> if the two values are equal, and <c>False</c> otherwise.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.uintmax_t.op_Inequality(Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.uintmax_t)">
            <summary>
            Gets a value that indicates whether the two argument values are different.
            </summary>
            <param name="value1">A <see cref="T:Math.Mpfr.Native.uintmax_t">uintmax_t</see> value.</param>
            <param name="value2">A <see cref="T:Math.Mpfr.Native.uintmax_t">uintmax_t</see> value.</param>
            <returns><c>True</c> if the two values are different, and <c>False</c> otherwise.</returns>
        </member>
        <member name="T:Math.Mpfr.Native.va_list">
            <summary>
            Represent a variable argument list.
            </summary>
        </member>
        <member name="M:Math.Mpfr.Native.va_list.#ctor(System.Object[])">
            <summary>
            Creates a variable list of arguments in unmanaged memory.
            </summary>
            <param name="args">The list of arguments.</param>
        </member>
        <member name="M:Math.Mpfr.Native.va_list.ToIntPtr">
            <summary>
            Return the pointer to the list of arguments in unmanaged memory.
            </summary>
            <returns>The pointer to the list of arguments in unmanaged memory.</returns>
        </member>
        <member name="M:Math.Mpfr.Native.va_list.RetrieveArgumentValues">
            <summary>
            Retrieves argument values from unmanaged memory.
            </summary>
        </member>
        <member name="T:Math.Mpfr.Native.mpfr_lib">
            <summary>
            Represents all of the functions of the GNU MPFR library.
            </summary>
            <remarks>
            <para>
            <h2>Functions Categories</h2>
            </para>
            <para><a name="Initialization_Functions"/><h3>Initialization Functions:</h3></para>
            <list type="bullet">
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear(Math.Mpfr.Native.mpfr_t)">mpfr_clear</see> - Free the space occupied by the significand of <i>x</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clears(Math.Mpfr.Native.mpfr_t[])">mpfr_clears</see> - Free the space occupied by all the <see cref="T:Math.Mpfr.Native.mpfr_t">mpfr_t</see> variables of the given list <i>x</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_default_prec">mpfr_get_default_prec</see> - Return the current default MPFR precision in bits.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_prec(Math.Mpfr.Native.mpfr_t)">mpfr_get_prec</see> - Return the precision of <i>x</i>, i.e., the number of bits used to store its significand.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init(Math.Mpfr.Native.mpfr_t)">mpfr_init</see> - Initialize <i>x</i>, set its precision to the default precision, and set its value to NaN.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_prec_t)">mpfr_init2</see> - Initialize <i>x</i>, set its precision to be exactly <i>prec</i> bits and its value to NaN.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inits(Math.Mpfr.Native.mpfr_t[])">mpfr_inits</see> - Initialize all the <see cref="T:Math.Mpfr.Native.mpfr_t">mpfr_t</see> variables of the given list <i>x</i>, set their precision to the default precision and their value to NaN.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inits2(Math.Mpfr.Native.mpfr_prec_t,Math.Mpfr.Native.mpfr_t[])">mpfr_inits2</see> - Initialize all the <see cref="T:Math.Mpfr.Native.mpfr_t">mpfr_t</see> variables of the given variable argument <i>x</i>, set their precision to be exactly <i>prec</i> bits and their value to NaN.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_default_prec(Math.Mpfr.Native.mpfr_prec_t)">mpfr_set_default_prec</see> - Set the default precision to be exactly <i>prec</i> bits, where <i>prec</i> can be any integer between <see cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_PREC_MIN">MPFR_PREC_MIN</see>and <see cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_PREC_MAX">MPFR_PREC_MAX</see>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_prec(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_prec_t)">mpfr_set_prec</see> - Reset the precision of <i>x</i> to be exactly <i>prec</i> bits, and set its value to NaN.</description></item>
            </list>
            <para><a name="Assignment_Functions"/><h3>Assignment Functions:</h3></para>
            <list type="bullet">
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set</see> - Set the value of <i>rop</i> from <i>op</i> rounded toward the given direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_d(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_d</see> - Set the value of <i>rop</i> from <i>op</i> rounded toward the given direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_f</see> - Set the value of <i>rop</i> from <i>op</i> rounded toward the given direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_flt(Math.Mpfr.Native.mpfr_t,System.Single,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_flt</see> - Set the value of <i>rop</i> from <i>op</i> rounded toward the given direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_inf(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_set_inf</see> - Set the variable <i>x</i> to infinity.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_nan(Math.Mpfr.Native.mpfr_t)">mpfr_set_nan</see> - Set the variable <i>x</i> to NaN.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_q</see> - Set the value of <i>rop</i> from <i>op</i> rounded toward the given direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_si(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_si</see> - Set the value of <i>rop</i> from <i>op</i> rounded toward the given direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_si_2exp(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_si_2exp</see> - Set the value of <i>rop</i> from <i>op</i> multiplied by two to the power <i>e</i>, rounded toward the given direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_sj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_sj</see> - Set the value of <i>rop</i> from <i>op</i> rounded toward the given direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_sj_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_sj_2exp</see> - Set the value of <i>rop</i> from <i>op</i> multiplied by two to the power <i>e</i>, rounded toward the given direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_str(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.char_ptr,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_str</see> - Set <i>rop</i> to the value of the string <i>s</i> in base <i>base</i>, rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_ui</see> - Set the value of <i>rop</i> from <i>op</i> rounded toward the given direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_ui_2exp(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_ui_2exp</see> - Set the value of <i>rop</i> from <i>op</i> multiplied by two to the power <i>e</i>, rounded toward the given direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_uj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_uj</see> - Set the value of <i>rop</i> from <i>op</i> rounded toward the given direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_uj_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_uj_2exp</see> - Set the value of <i>rop</i> from <i>op</i> multiplied by two to the power <i>e</i>, rounded toward the given direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_z</see> - Set the value of <i>rop</i> from <i>op</i> rounded toward the given direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_z_2exp(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_z_2exp</see> - Set the value of <i>rop</i> from <i>op</i> multiplied by two to the power <i>e</i>, rounded toward the given direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_zero(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_set_zero</see> - Set the variable <i>x</i> to zero.</description></item>
            <item><description><see cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr">mpfr_strtofr</see> - Read a floating-point number from a string <i>nptr</i> in base <i>base</i>, rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_swap(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_swap</see> - Swap the structures pointed to by <i>x</i> and <i>y</i>.</description></item>
            </list>
            <para><a name="Combined_Initialization_and_Assignment_Functions"/><h3>Combined Initialization and Assignment Functions:</h3></para>
            <list type="bullet">
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set</see> - Initialize <i>rop</i> and set its value from <i>op</i>, rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_d(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_d</see> - Initialize <i>rop</i> and set its value from <i>op</i>, rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_f</see> - Initialize <i>rop</i> and set its value from <i>op</i>, rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_q</see> - Initialize <i>rop</i> and set its value from <i>op</i>, rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_si(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_si</see> - Initialize <i>rop</i> and set its value from <i>op</i>, rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_str(Math.Mpfr.Native.mpfr_t,System.String,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_str</see> - Initialize <i>x</i> and set its value from the string <i>s</i> in base <i>base</i>, rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_ui</see> - Initialize <i>rop</i> and set its value from <i>op</i>, rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_z</see> - Initialize <i>rop</i> and set its value from <i>op</i>, rounded in the direction <i>rnd</i>.</description></item>
            </list>
            <para><a name="Conversion_Functions"/><h3>Conversion Functions:</h3></para>
            <list type="bullet">
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_intmax_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_intmax_p</see> - Return non-zero if <i>op</i> would fit in the C data type  long when rounded to an integer in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_sint_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_sint_p</see> - Return non-zero if <i>op</i> would fit in the C data type  int when rounded to an integer in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_slong_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_slong_p</see> - Return non-zero if <i>op</i> would fit in the C data type  long when rounded to an integer in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_sshort_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_sshort_p</see> - Return non-zero if <i>op</i> would fit in the C data type  short when rounded to an integer in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_uint_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_uint_p</see> - Return non-zero if <i>op</i> would fit in the C data type  unsigned int when rounded to an integer in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_uintmax_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_uintmax_p</see> - Return non-zero if <i>op</i> would fit in the C data type  unsigned long when rounded to an integer in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_ulong_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_ulong_p</see> - Return non-zero if <i>op</i> would fit in the C data type  unsigned long when rounded to an integer in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_ushort_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_ushort_p</see> - Return non-zero if <i>op</i> would fit in the C data type  unsigned short when rounded to an integer in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_str(Math.Gmp.Native.char_ptr)">mpfr_free_str</see> - Free a string allocated by <see cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_str">O:Math.Mpfr.Native.mpfr_lib.mpfr_get_str</see> using the unallocation function .</description></item>
            <item><description><see cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_frexp">mpfr_frexp</see> - Set <i>exp</i> and <i>y</i> such that 0.5 &#8804; abs &lt; 1 and <i>y</i> * 2^<i>exp</i> = <i>x</i> rounded to the precision of <i>y</i>, using the given rounding mode.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_d</see> - Convert <i>op</i> to a double, using the rounding mode <i>rnd</i>.</description></item>
            <item><description><see cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_d_2exp">mpfr_get_d_2exp</see> - Return d and set <i>exp</i> such that 0.5 &#8804; abs &lt;1 and d * 2^<i>exp</i> = <i>op</i> rounded to double precision, using the given rounding mode.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_f(Math.Gmp.Native.mpf_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_f</see> - Convert <i>op</i> to a <see cref="T:Math.Gmp.Native.mpf_t">mpf_t</see>, after rounding it with respect to <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_flt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_flt</see> - Convert <i>op</i> to a float, using the rounding mode <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_si</see> - Convert <i>op</i> to a long after rounding it with respect to <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_sj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_sj</see> - Convert <i>op</i> to an <see cref="T:Math.Mpfr.Native.intmax_t">intmax_t</see> after rounding it with respect to <i>rnd</i>.</description></item>
            <item><description><see cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_str">mpfr_get_str</see> - Convert <i>op</i> to a string of digits in base <i>b</i>, with rounding in the direction <i>rnd</i>, where <i>n</i> is either zero  or the number of significant digits output in the string; in the latter case, <i>n</i> must be greater or equal to 2.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_ui</see> - Convert <i>op</i> to an unsigned long after rounding it with respect to <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_uj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_uj</see> - Convert <i>op</i> to an <see cref="T:Math.Mpfr.Native.uintmax_t">uintmax_t</see> after rounding it with respect to <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_z(Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_z</see> - Convert <i>op</i> to a <see cref="T:Math.Gmp.Native.mpz_t">mpz_t</see>, after rounding it with respect to <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_q(Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_t)">mpfr_get_q</see> - Convert <i>op</i> to a <see cref="T:Math.Gmp.Native.mpq_t"/>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_z_2exp(Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_t)">mpfr_get_z_2exp</see> - Put the scaled significand of <i>op</i>  into <i>rop</i>, and return the exponent exp  such that <i>op</i> = <i>rop</i> * 2^exp.</description></item>
            </list>
            <para><a name="Basic_Arithmetic_Functions"/><h3>Basic Arithmetic Functions:</h3></para>
            <list type="bullet">
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_abs</see> - Set <i>rop</i> to the absolute value of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add</see> - Set <i>rop</i> to <i>op1</i> + <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add_d</see> - Set <i>rop</i> to <i>op1</i> + <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add_q(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add_q</see> - Set <i>rop</i> to <i>op1</i> + <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add_si</see> - Set <i>rop</i> to <i>op1</i> + <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add_ui</see> - Set <i>rop</i> to <i>op1</i> + <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add_z(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add_z</see> - Set <i>rop</i> to <i>op1</i> + <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cbrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cbrt</see> - Set <i>rop</i> to the cubic root of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rootn_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rootn_ui</see> - Set <i>rop</i> to the <i>k</i>th root of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_d_div(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_d_div</see> - Set <i>rop</i> to <i>op1</i> / <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_d_sub(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_d_sub</see> - Set <i>rop</i> to <i>op1</i> - <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_dim(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_dim</see> - Set <i>rop</i> to the positive difference of <i>op1</i> and <i>op2</i>, i.e., <i>op1</i> - <i>op2</i> rounded in the direction <i>rnd</i> if <i>op1</i> &gt; <i>op2</i>, +0 if <i>op1</i> &#8804; <i>op2</i>, and NaN if <i>op1</i> or <i>op2</i> is NaN.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div</see> - Set <i>rop</i> to <i>op1</i> / <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_2si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_2si</see> - Set <i>rop</i> to <i>op1</i> divided by 2^<i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_2ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_2ui</see> - Set <i>rop</i> to <i>op1</i> divided by 2^<i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_d</see> - Set <i>rop</i> to <i>op1</i> / <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_q(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_q</see> - Set <i>rop</i> to <i>op1</i> / <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_si</see> - Set <i>rop</i> to <i>op1</i> / <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_ui</see> - Set <i>rop</i> to <i>op1</i> / <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_z(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_z</see> - Set <i>rop</i> to <i>op1</i> / <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul</see> - Set <i>rop</i> to <i>op1</i> * <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_2si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_2si</see> - Set <i>rop</i> to <i>op1</i> * 2^<i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_2ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_2ui</see> - Set <i>rop</i> to <i>op1</i> * 2^<i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_d</see> - Set <i>rop</i> to <i>op1</i> * <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_q(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_q</see> - Set <i>rop</i> to <i>op1</i> * <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_si</see> - Set <i>rop</i> to <i>op1</i> * <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_ui</see> - Set <i>rop</i> to <i>op1</i> * <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_z(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_z</see> - Set <i>rop</i> to <i>op1</i> * <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_neg</see> - Set <i>rop</i> to -<i>op</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow</see> - Set <i>rop</i> to <i>op1</i> raised to <i>op2</i>, rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow_si</see> - Set <i>rop</i> to <i>op1</i> raised to <i>op2</i>, rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow_ui</see> - Set <i>rop</i> to <i>op1</i> raised to <i>op2</i>, rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow_z(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow_z</see> - Set <i>rop</i> to <i>op1</i> raised to <i>op2</i>, rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rec_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rec_sqrt</see> - Set <i>rop</i> to the reciprocal square root of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_root(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</see> - Set <i>rop</i> to the <i>k</i>th root of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_si_div(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_si_div</see> - Set <i>rop</i> to <i>op1</i> / <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_si_sub(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_si_sub</see> - Set <i>rop</i> to <i>op1</i> - <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqr(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqr</see> - Set <i>rop</i> to the square of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt</see> - Set <i>rop</i> to the square root of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt_ui</see> - Set <i>rop</i> to the square root of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub</see> - Set <i>rop</i> to <i>op1</i> - <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_d</see> - Set <i>rop</i> to <i>op1</i> - <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_q(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_q</see> - Set <i>rop</i> to <i>op1</i> - <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_si</see> - Set <i>rop</i> to <i>op1</i> - <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_ui</see> - Set <i>rop</i> to <i>op1</i> - <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_z(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_z</see> - Set <i>rop</i> to <i>op1</i> - <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sum(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t[],System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sum</see> - Set <i>rop</i> to the sum of all elements of <i>tab</i>, whose size is <i>n</i>, rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ui_div(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ui_div</see> - Set <i>rop</i> to <i>op1</i> / <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ui_pow(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ui_pow</see> - Set <i>rop</i> to <i>op1</i> raised to <i>op2</i>, rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ui_pow_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ui_pow_ui</see> - Set <i>rop</i> to <i>op1</i> raised to <i>op2</i>, rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ui_sub(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ui_sub</see> - Set <i>rop</i> to <i>op1</i> - <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_z_sub(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_z_sub</see> - Set <i>rop</i> to <i>op1</i> - <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
            </list>
            <para><a name="Comparison_Functions"/><h3>Comparison Functions:</h3></para>
            <list type="bullet">
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_cmp</see> - Compare <i>op1</i> and <i>op2</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_d(Math.Mpfr.Native.mpfr_t,System.Double)">mpfr_cmp_d</see> - Compare <i>op1</i> and <i>op2</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t)">mpfr_cmp_f</see> - Compare <i>op1</i> and <i>op2</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t)">mpfr_cmp_q</see> - Compare <i>op1</i> and <i>op2</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_si(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_cmp_si</see> - Compare <i>op1</i> and <i>op2</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_si_2exp(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_exp_t)">mpfr_cmp_si_2exp</see> - Compare <i>op1</i> and <i>op2</i> * 2^<i>e</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_ui(Math.Mpfr.Native.mpfr_t,System.UInt32)">mpfr_cmp_ui</see> - Compare <i>op1</i> and <i>op2</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_ui_2exp(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_exp_t)">mpfr_cmp_ui_2exp</see> - Compare <i>op1</i> and <i>op2</i> * 2^<i>e</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t)">mpfr_cmp_z</see> - Compare <i>op1</i> and <i>op2</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmpabs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_cmpabs</see> - Compare |<i>op1</i>| and |<i>op2</i>|.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_equal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_equal_p</see> - Return non-zero if <i>op1</i> = <i>op2</i>, and zero otherwise.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_greater_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_greater_p</see> - Return non-zero if <i>op1</i> &gt; <i>op2</i>, and zero otherwise.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_greaterequal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_greaterequal_p</see> - Return non-zero if <i>op1</i> &#8805; <i>op2</i>, and zero otherwise.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inf_p(Math.Mpfr.Native.mpfr_t)">mpfr_inf_p</see> - Return non-zero if <i>op</i> is an infinity. Return zero otherwise.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_less_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_less_p</see> - Return non-zero if <i>op1</i> &lt; <i>op2</i>, and zero otherwise.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lessequal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_lessequal_p</see> - Return non-zero if <i>op1</i> &#8804; <i>op2</i>, and zero otherwise.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lessgreater_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_lessgreater_p</see> - Return non-zero if <i>op1</i> &lt; <i>op2</i> or <i>op1</i> &gt; <i>op2</i> , zero otherwise .</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nan_p(Math.Mpfr.Native.mpfr_t)">mpfr_nan_p</see> - Return non-zero if <i>op</i> is NaN. Return zero otherwise.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_number_p(Math.Mpfr.Native.mpfr_t)">mpfr_number_p</see> - Return non-zero if <i>op</i> is an ordinary number . Return zero otherwise.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_regular_p(Math.Mpfr.Native.mpfr_t)">mpfr_regular_p</see> - Return non-zero if <i>op</i> is a regular number . Return zero otherwise.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sgn(Math.Mpfr.Native.mpfr_t)">mpfr_sgn</see> - Return a positive value if <i>op</i> &gt; 0, zero if <i>op</i> = 0, and a negative value if <i>op</i> &lt; 0.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_unordered_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_unordered_p</see> - Return non-zero if <i>op1</i> or <i>op2</i> is a NaN , zero otherwise.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zero_p(Math.Mpfr.Native.mpfr_t)">mpfr_zero_p</see> - Return non-zero if <i>op</i> is zero. Return zero otherwise.</description></item>
            </list>
            <para><a name="Special_Functions"/><h3>Special Functions:</h3></para>
            <list type="bullet">
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_acos(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_acos</see> - Set <i>rop</i> to the arc-cosine of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_acosh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_acosh</see> - Set <i>rop</i> to the inverse hyperbolic cosine of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_agm(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_agm</see> - Set <i>rop</i> to the arithmetic-geometric mean of <i>op1</i> and <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ai(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ai</see> - Set <i>rop</i> to the value of the Airy function Ai on <i>x</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_asin(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_asin</see> - Set <i>rop</i> to the arc-sine of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_asinh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_asinh</see> - Set <i>rop</i> to the inverse hyperbolic sine of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_atan(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_atan</see> - Set <i>rop</i> to the arc-tangent of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_atan2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_atan2</see> - Set <i>rop</i> to the arc-tangent2 of <i>y</i> and <i>x</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_atanh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_atanh</see> - Set <i>rop</i> to the inverse hyperbolic tangent of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_const_catalan(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_const_catalan</see> - Set <i>rop</i> to the value of Catalan’s constant 0.915… rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_const_euler(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_const_euler</see> - Set <i>rop</i> to the value of Euler’s constant 0.577… rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_const_log2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_const_log2</see> - Set <i>rop</i> to the logarithm of 2 rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_const_pi(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_const_pi</see> - Set <i>rop</i> to the value of Pi rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cos(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cos</see> - Set <i>rop</i> to the cosine of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cosh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cosh</see> - Set <i>rop</i> to the hyperbolic cosine of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cot(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cot</see> - Set <i>rop</i> to the cotangent of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_coth(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_coth</see> - Set <i>rop</i> to the hyperbolic cotangent of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_csc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_csc</see> - Set <i>rop</i> to the cosecant of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_csch(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_csch</see> - Set <i>rop</i> to the hyperbolic cosecant of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_digamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_digamma</see> - Set <i>rop</i> to the value of the Digamma  function on <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_eint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_eint</see> - Set <i>rop</i> to the exponential integral of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erf(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erf</see> - Set <i>rop</i> to the value of the error function on <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erfc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erfc</see> - Set <i>rop</i> to the value of the complementary error function on <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_exp</see> - Set <i>rop</i> to the exponential of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_exp10(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_exp10</see> - Set <i>rop</i> to 10^<i>op</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_exp2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_exp2</see> - Set <i>rop</i> to 2^<i>op</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_expm1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_expm1</see> - Set <i>rop</i> to the e^<i>op</i> - 1, rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fac_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fac_ui</see> - Set <i>rop</i> to the factorial of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fma</see> - Set <i>rop</i> to (<i>op1</i> × <i>op2</i>) + <i>op3</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fms</see> - Set <i>rop</i> to (<i>op1</i> × <i>op2</i>) - <i>op3</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmma</see> - Set <i>rop</i> to (<i>op1</i> × <i>op2</i>) + (<i>op3</i> × <i>op4</i>) rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmms</see> - Set <i>rop</i> to (<i>op1</i> × <i>op2</i>) - (<i>op3</i> × <i>op4</i>) rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_cache">mpfr_free_cache</see> - Free all caches and pools used by MPFR internally.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_cache2(Math.Mpfr.Native.mpfr_free_cache_t)">mpfr_free_cache2</see> - Free various caches and pools used by MPFR internally, as specified by <i>way</i>, which is a set of flags.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_pool">mpfr_free_pool</see> - Free the pools used by MPFR internally.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mp_memory_cleanup">mpfr_mp_memory_cleanup</see> - This function should be called before calling <see cref="M:Math.Gmp.Native.gmp_lib.mp_set_memory_functions(Math.Gmp.Native.allocate_function,Math.Gmp.Native.reallocate_function,Math.Gmp.Native.free_function)"/>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_gamma</see> - Set <i>rop</i> to the value of the Gamma function on <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma_inc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_gamma_inc</see> - Set <i>rop</i> to the value of the Incomplete Gamma function on <i>op</i> and <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_beta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_beta</see> - Set <i>rop</i> to the value of the Beta function at arguments <i>op1</i> and <i>op2</i>, rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_hypot(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_hypot</see> - Set <i>rop</i> to the Euclidean norm of <i>x</i> and <i>y</i>, i.e., the square root of the sum of the squares of <i>x</i> and <i>y</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_j0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_j0</see> - Set <i>rop</i> to the value of the first kind Bessel function of order 0 on <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_j1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_j1</see> - Set <i>rop</i> to the value of the first kind Bessel function of order 1 on <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_jn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_jn</see> - Set <i>rop</i> to the value of the first kind Bessel function of order <i>n</i> on <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma">mpfr_lgamma</see> - Set <i>rop</i> to the value of the logarithm of the absolute value of the Gamma function on <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_li2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_li2</see> - Set <i>rop</i> to real part of the dilogarithm of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lngamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_lngamma</see> - Set <i>rop</i> to the value of the logarithm of the Gamma function on <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_log(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_log</see> - Set <i>rop</i> to the natural logarithm of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_log_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_log_ui</see> - Set <i>rop</i> to the natural logarithm of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_log10(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_log10</see> - Set <i>rop</i> to log10 rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_log1p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_log1p</see> - Set <i>rop</i> to the logarithm of one plus <i>op</i>, rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_log2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_log2</see> - Set <i>rop</i> to log2 rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sec(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sec</see> - Set <i>rop</i> to the secant of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sech(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sech</see> - Set <i>rop</i> to the hyperbolic secant of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sin(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sin</see> - Set <i>rop</i> to the sine of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sin_cos(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sin_cos</see> - Set simultaneously <i>sop</i> to the sine of <i>op</i> and <i>cop</i> to the cosine of <i>op</i>, rounded in the direction <i>rnd</i> with the corresponding precisions of <i>sop</i> and <i>cop</i>, which must be different variables.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sinh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sinh</see> - Set <i>rop</i> to the hyperbolic sine of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sinh_cosh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sinh_cosh</see> - Set simultaneously <i>sop</i> to the hyperbolic sine of <i>op</i> and <i>cop</i> to the hyperbolic cosine of <i>op</i>, rounded in the direction <i>rnd</i> with the corresponding precision of <i>sop</i> and <i>cop</i>, which must be different variables.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_tan(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_tan</see> - Set <i>rop</i> to the tangent of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_tanh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_tanh</see> - Set <i>rop</i> to the hyperbolic tangent of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_y0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_y0</see> - Set <i>rop</i> to the value of the first kind Bessel function of order 0 on <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_y1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_y1</see> - Set <i>rop</i> to the value of the first kind Bessel function of order 1 on <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_yn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_yn</see> - Set <i>rop</i> to the value of the first kind Bessel function of order <i>n</i> on <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_zeta</see> - Set <i>rop</i> to the value of the Riemann Zeta function on <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_zeta_ui</see> - Set <i>rop</i> to the value of the Riemann Zeta function on <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
            </list>
            <para><a name="Input_and_Output_Functions"/><h3>Input and Output Functions:</h3></para>
            <list type="bullet">
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inp_str(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_inp_str</see> - Input a string in base <i>base</i> from stream <i>stream</i>, rounded in the direction <i>rnd</i>, and put the read float in <i>rop</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_out_str(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.Int32,Math.Gmp.Native.size_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_out_str</see> - Output <i>op</i> on stream <i>stream</i>, as a string of digits in base <i>base</i>, rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fpif_import(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.ptr{Math.Gmp.Native.FILE})">mpfr_fpif_import</see> - Import the number <i>op</i> from the stream <i>stream</i> in a floating-point interchange format (see <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fpif_export(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},Math.Mpfr.Native.mpfr_t)"/>).</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fpif_export(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},Math.Mpfr.Native.mpfr_t)">mpfr_fpif_export</see> - Export the number <i>op</i> to the stream <i>stream</i> in a floating-point interchange format.</description></item>
            </list>
            <para><a name="Formatted_Output_Functions"/><h3>Formatted Output Functions:</h3></para>
            <list type="bullet">
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_asprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.char_ptr},System.String,System.Object[])">mpfr_asprintf</see> - Write output as a null terminated string in a block of memory allocated using the allocation function .</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.String,System.Object[])">mpfr_fprintf</see> - Print to the stream <i>stream</i> the optional <i>arguments</i> under the control of the template string <i>template</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_printf(System.String,System.Object[])">mpfr_printf</see> - Print to stdout the optional <i>arguments</i> under the control of the template string <i>template</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_snprintf(Math.Gmp.Native.char_ptr,Math.Gmp.Native.size_t,System.String,System.Object[])">mpfr_snprintf</see> - Form a null-terminated string corresponding to the optional <i>arguments</i> under the control of the template string <i>template</i>, and print it in <i>buf</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sprintf(Math.Gmp.Native.char_ptr,System.String,System.Object[])">mpfr_sprintf</see> - Form a null-terminated string corresponding to the optional <i>arguments</i> under the control of the template string <i>template</i>, and print it in <i>buf</i>.</description></item>
            <item><description><see cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_vasprintf">mpfr_vasprintf</see> - Write output as a null terminated string in a block of memory allocated using the allocation function .</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_vfprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.String,System.Object[])">mpfr_vfprintf</see> - Print to the stream <i>stream</i> the optional <i>arguments</i> under the control of the template string <i>template</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_vprintf(System.String,System.Object[])">mpfr_vprintf</see> - Print to stdout the optional <i>arguments</i> under the control of the template string <i>template</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_vsnprintf(Math.Gmp.Native.char_ptr,Math.Gmp.Native.size_t,System.String,System.Object[])">mpfr_vsnprintf</see> - Form a null-terminated string corresponding to the optional <i>arguments</i> under the control of the template string <i>template</i>, and print it in <i>buf</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_vsprintf(Math.Gmp.Native.char_ptr,System.String,System.Object[])">mpfr_vsprintf</see> - Form a null-terminated string corresponding to the optional <i>arguments</i> under the control of the template string <i>template</i>, and print it in <i>buf</i>.</description></item>
            </list>
            <para><a name="Integer_and_Remainder_Related_Functions"/><h3>Integer and Remainder Related Functions:</h3></para>
            <list type="bullet">
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ceil(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_ceil</see> - Set <i>rop</i> to <i>op</i> rounded to the next higher or equal representable integer (like <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)"/> with <see cref="F:Math.Mpfr.Native.mpfr_rnd_t.MPFR_RNDU"/>).</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_floor(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_floor</see> - Set <i>rop</i> to <i>op</i> rounded to the next lower or equal representable integer (like <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)"/> with <see cref="F:Math.Mpfr.Native.mpfr_rnd_t.MPFR_RNDD"/>).</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmod(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmod</see> - Set <i>r</i> to the value of <i>x</i> - n * <i>y</i>, rounded according to the direction <i>rnd</i>, where n is the integer quotient of <i>x</i> divided by <i>y</i>, rounded toward zero.</description></item>
            <item><description><see cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_fmodquo">mpfr_fmodquo</see> - Set <i>r</i> to the value of <i>x</i> - n * <i>y</i>, rounded according to the direction <i>rnd</i>, where n is the integer quotient of <i>x</i> divided by <i>y</i>, rounded toward zero.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_frac(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_frac</see> - Set <i>rop</i> to the fractional part of <i>op</i>, having the same sign as <i>op</i>, rounded in the direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_integer_p(Math.Mpfr.Native.mpfr_t)">mpfr_integer_p</see> - Return non-zero iff <i>op</i> is an integer.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_modf(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_modf</see> - Set simultaneously <i>iop</i> to the integral part of <i>op</i> and <i>fop</i> to the fractional part of <i>op</i>, rounded in the direction <i>rnd</i> with the corresponding precision of <i>iop</i> and <i>fop</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_remainder(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_remainder</see> - Set <i>r</i> to the value of <i>x</i> - n * <i>y</i>, rounded according to the direction <i>rnd</i>, where n is the integer quotient of <i>x</i> divided by <i>y</i>, rounded to the nearest integer .</description></item>
            <item><description><see cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo">mpfr_remquo</see> - Set <i>r</i> to the value of <i>x</i> - n * <i>y</i>, rounded according to the direction <i>rnd</i>, where n is the integer quotient of <i>x</i> divided by <i>y</i>, rounded to the nearest integer .</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint</see> - Set <i>rop</i> to <i>op</i> rounded to the nearest representable integer in the given direction <i>rnd</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_ceil(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_ceil</see> - Set <i>rop</i> to <i>op</i> rounded to the next higher or equal integer.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_floor(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_floor</see> - Set <i>rop</i> to <i>op</i> rounded to the next lower or equal integer.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_round</see> - Set <i>rop</i> to <i>op</i> rounded to the nearest integer, rounding halfway cases away from zero.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_roundeven(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_roundeven</see> - Set <i>rop</i> to <i>op</i> rounded to the nearest integer, rounding halfway cases to the nearest even integer.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_trunc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_trunc</see> - Set <i>rop</i> to <i>op</i> rounded to the next integer toward zero.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_round</see> - Set <i>rop</i> to <i>op</i> rounded to the nearest representable integer, rounding halfway cases away from zero.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_roundeven(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_roundeven</see> - Set <i>rop</i> to <i>op</i> rounded to the nearest representable integer, rounding halfway cases with the even-rounding rule zero (like <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)"/> with <see cref="F:Math.Mpfr.Native.mpfr_rnd_t.MPFR_RNDZ"/>).</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_trunc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_trunc</see> - Set <i>rop</i> to <i>op</i> rounded to the next representable integer toward zero (like <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)"/> with <see cref="F:Math.Mpfr.Native.mpfr_rnd_t.MPFR_RNDZ"/>).</description></item>
            </list>
            <para><a name="Rounding_Related_Functions"/><h3>Rounding Related Functions:</h3></para>
            <list type="bullet">
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_can_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t,Math.Mpfr.Native.mpfr_rnd_t,Math.Mpfr.Native.mpfr_prec_t)">mpfr_can_round</see> - Return non-zero value if one is able to round correctly x to precision <i>prec</i> with the direction <i>rnd2</i>, and 0 otherwise.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_default_rounding_mode">mpfr_get_default_rounding_mode</see> - Get the default rounding mode.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_min_prec(Math.Mpfr.Native.mpfr_t)">mpfr_min_prec</see> - Return the minimal number of bits required to store the significand of <i>x</i>, and 0 for special values, including 0.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_prec_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_prec_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_prec_round</see> - Round <i>x</i> according to <i>rnd</i> with precision <i>prec</i>, which must be an integer between <see cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_PREC_MIN">MPFR_PREC_MIN</see> and <see cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_PREC_MAX">MPFR_PREC_MAX</see>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_print_rnd_mode(Math.Mpfr.Native.mpfr_rnd_t)">mpfr_print_rnd_mode</see> - Return a string  corresponding to the rounding mode <i>rnd</i>, or a null pointer if <i>rnd</i> is an invalid rounding mode.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_default_rounding_mode(Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_default_rounding_mode</see> - Set the default rounding mode to <i>rnd</i>.</description></item>
            </list>
            <para><a name="Miscellaneous_Functions"/><h3>Miscellaneous Functions:</h3></para>
            <list type="bullet">
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_buildopt_decimal_p">mpfr_buildopt_decimal_p</see> - Return a non-zero value if MPFR was compiled with decimal float support, return zero otherwise.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_buildopt_gmpinternals_p">mpfr_buildopt_gmpinternals_p</see> - Return a non-zero value if MPFR was compiled with GMP internals, return zero otherwise.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_buildopt_sharedcache_p">mpfr_buildopt_sharedcache_p </see> - Return a non-zero value if MPFR was compiled so that all threads share the same cache for one MPFR constant, return zero otherwise.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_buildopt_tls_p">mpfr_buildopt_tls_p</see> - Return a non-zero value if MPFR was compiled as thread safe using compiler-level Thread Local Storage, return zero otherwise.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_buildopt_float128_p">mpfr_buildopt_float128_p</see> - Return a non-zero value if MPFR was compiled with ‘__float128’ support, return zero otherwise.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_buildopt_tune_case">mpfr_buildopt_tune_case</see> - Return a string saying which thresholds file has been used at compile time.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_copysign(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_copysign</see> - Set the value of <i>rop</i> from <i>op1</i>, rounded toward the given direction <i>rnd</i>, then set its sign bit to that of <i>op2</i> .</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_patches">mpfr_get_patches</see> - Return a null-terminated string containing the ids of the patches applied to the MPFR library , separated by spaces.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_version">mpfr_get_version</see> - Return the MPFR version, as a null-terminated string.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nrandom(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.gmp_randstate_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_nrandom</see> - Generate one random float according to a standard normal gaussian distribution (with mean zero and variance one).</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_grandom(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.gmp_randstate_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_grandom</see> - Generate two random floats according to a standard normal gaussian distribution (with mean zero and variance one).</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erandom(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.gmp_randstate_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erandom</see> - Generate one random float according to an exponential distribution, with mean one.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_max(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_max</see> - Set <i>rop</i> to the maximum of <i>op1</i> and <i>op2</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_min(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_min</see> - Set <i>rop</i> to the minimum of <i>op1</i> and <i>op2</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nextabove(Math.Mpfr.Native.mpfr_t)">mpfr_nextabove</see> - Equivalent to <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nexttoward(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_nexttoward</see> where y is plus infinity.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nextbelow(Math.Mpfr.Native.mpfr_t)">mpfr_nextbelow</see> - Equivalent to <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nexttoward(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_nexttoward</see> where y is minus infinity.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nexttoward(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_nexttoward</see> - Replace <i>x</i> by the next floating-point number in the direction of <i>y</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_exp_t)">mpfr_set_exp</see> - Set the exponent of <i>x</i> if <i>e</i> is in the current exponent range.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_setsign(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_setsign</see> - Set the value of <i>rop</i> from <i>op</i>, rounded toward the given direction <i>rnd</i>, then set  its sign bit if <i>s</i> is non-zero , even when <i>op</i> is a NaN.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_signbit(Math.Mpfr.Native.mpfr_t)">mpfr_signbit</see> - Return a non-zero value iff <i>op</i> has its sign bit set .</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_urandom(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.gmp_randstate_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_urandom</see> - Generate a uniformly distributed random float.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_urandomb(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.gmp_randstate_t)">mpfr_urandomb</see> - Generate a uniformly distributed random float in the interval 0 &#8804; <i>rop</i> &lt; 1.</description></item>
            <item><description><see cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION">MPFR_VERSION</see> - <see cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION">MPFR_VERSION</see> is the version of MPFR.</description></item>
            <item><description><see cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION_MAJOR">MPFR_VERSION_MAJOR</see> - <see cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION_MAJOR">MPFR_VERSION_MAJOR</see> is the major MPFR version.</description></item>
            <item><description><see cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION_MINOR">MPFR_VERSION_MINOR</see> - <see cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION_MINOR">MPFR_VERSION_MINOR</see> is the minor MPFR version.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION_NUM(System.Int32,System.Int32,System.Int32)">MPFR_VERSION_NUM</see> - Create an integer in the same format as used by <see cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION">MPFR_VERSION</see> from the given <i>major</i>, <i>minor</i> and <i>patchlevel</i>.</description></item>
            <item><description><see cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION_PATCHLEVEL">MPFR_VERSION_PATCHLEVEL</see> - <see cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION_PATCHLEVEL">MPFR_VERSION_PATCHLEVEL</see> is the patch level of MPFR version.</description></item>
            <item><description><see cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION_STRING">MPFR_VERSION_STRING</see> - <see cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION_STRING">MPFR_VERSION_STRING</see> is the version  as a string constant.</description></item>
            <item><description><see cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_PREC_MAX">MPFR_PREC_MAX</see> - The maximum number of bits that can be used to represent the significand of a floating-point number.</description></item>
            <item><description><see cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_PREC_MIN">MPFR_PREC_MIN</see> - The minimum number of bits that can be used to represent the significand of a floating-point number.</description></item>
            </list>
            <para><a name="Exception_Related_Functions"/><h3>Exception Related Functions:</h3></para>
            <list type="bullet">
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_check_range(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_check_range</see> - Check that <i>x</i> is within the current range of acceptable values.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_divby0">mpfr_clear_divby0</see> - Clear (lower) the divide-by-zero flag.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_erangeflag">mpfr_clear_erangeflag</see> - Clear (lower) the erange flag.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_flags">mpfr_clear_flags</see> - Clear (lower) all global flags .</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_inexflag">mpfr_clear_inexflag</see> - Clear (lower) the inexact flag.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_nanflag">mpfr_clear_nanflag</see> - Clear (lower) the invalid flag.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_overflow">mpfr_clear_overflow</see> - Clear (lower) the overflow flag.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_underflow">mpfr_clear_underflow</see> - Clear (lower) the underflow flag.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_divby0_p">mpfr_divby0_p</see> - Return the divide-by-zero flag, which is non-zero iff the flag is set.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erangeflag_p">mpfr_erangeflag_p</see> - Return the erange flag, which is non-zero iff the flag is set.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emax">mpfr_get_emax</see> - Return the  largest exponent allowed for a floating-point variable.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emax_max">mpfr_get_emax_max</see> - Return the maximum exponent allowed for <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_emax(Math.Mpfr.Native.mpfr_exp_t)">mpfr_set_emax</see>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emax_min">mpfr_get_emax_min</see> - Return the minimum exponent allowed for <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_emax(Math.Mpfr.Native.mpfr_exp_t)">mpfr_set_emax</see>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emin">mpfr_get_emin</see> - Return the  smallest exponent allowed for a floating-point variable.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emin_max">mpfr_get_emin_max</see> - Return the maximum exponent allowed for <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_emin(Math.Mpfr.Native.mpfr_exp_t)">mpfr_set_emin</see>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emin_min">mpfr_get_emin_min</see> - Return the minimum exponent allowed for <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_emin(Math.Mpfr.Native.mpfr_exp_t)">mpfr_set_emin</see>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_exp(Math.Mpfr.Native.mpfr_t)">mpfr_get_exp</see> - Return the exponent of <i>x</i>, assuming that <i>x</i> is a non-zero ordinary number and the significand is considered in [1/2,1).</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inexflag_p">mpfr_inexflag_p</see> - Return the inexact flag, which is non-zero iff the flag is set.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nanflag_p">mpfr_nanflag_p</see> - Return the invalid flag, which is non-zero iff the flag is set.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_overflow_p">mpfr_overflow_p</see> - Return the overflow flag, which is non-zero iff the flag is set.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_divby0">mpfr_set_divby0</see> - Set (raise) the divide-by-zero flag.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_emax(Math.Mpfr.Native.mpfr_exp_t)">mpfr_set_emax</see> - Set the largest exponent allowed for a floating-point variable.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_emin(Math.Mpfr.Native.mpfr_exp_t)">mpfr_set_emin</see> - Set the smallest exponent allowed for a floating-point variable.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_erangeflag">mpfr_set_erangeflag</see> - Set (raise) the erange flag.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_inexflag">mpfr_set_inexflag</see> - Set (raise) the inexact flag.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_nanflag">mpfr_set_nanflag</see> - Set (raise) the invalid flag.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_overflow">mpfr_set_overflow</see> - Set (raise) the overflow flag.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_underflow">mpfr_set_underflow</see> - Set (raise) the underflow flag.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_subnormalize(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_subnormalize</see> - This function rounds <i>x</i> emulating subnormal number arithmetic.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_underflow_p">mpfr_underflow_p</see> - Return the underflow flag, which is non-zero iff the flag is set.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_flags_clear(Math.Mpfr.Native.mpfr_flags_t)">mpfr_flags_clear</see> - Clear (lower) the group of flags specified by <i>mask</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_flags_set(Math.Mpfr.Native.mpfr_flags_t)">mpfr_flags_set</see> - Set (raise) the group of flags specified by <i>mask</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_flags_test(Math.Mpfr.Native.mpfr_flags_t)">mpfr_flags_test</see> - Return the flags specified by <i>mask</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_flags_save">mpfr_flags_save</see> - Return all the flags.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_flags_restore(Math.Mpfr.Native.mpfr_flags_t,Math.Mpfr.Native.mpfr_flags_t)">mpfr_flags_restore</see> = Restore the flags specified by <i>mask</i> to their state represented in <i>flags</i>.</description></item>
            </list>
            <para><a name="Compatibility_With_MPF"/><h3>Compatibility With MPF:</h3></para>
            <list type="bullet">
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_2exp</see> - This function is identical to <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_2ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_2ui</see>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_eq(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32)">mpfr_eq</see> - Return non-zero if <i>op1</i> and <i>op2</i> are both non-zero ordinary numbers with the same exponent and the same first <i>op3</i> bits.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_2exp</see> - This function is identical to <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_2ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_2ui</see>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_reldiff(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_reldiff</see> - Compute the relative difference between <i>op1</i> and <i>op2</i> and store the result in <i>rop</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_prec_raw(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_prec_t)">mpfr_set_prec_raw</see> - Reset the precision of <i>x</i> to be exactly <i>prec</i> bits.</description></item>
            </list>
            <para><a name="Custom_Interface"/><h3>Custom Interface:</h3></para>
            <list type="bullet">
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_clear(Math.Mpfr.Native.mpfr_t)">mpfr_custom_clear</see> - Free the space occupied by <i>x</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_get_exp(Math.Mpfr.Native.mpfr_t)">mpfr_custom_get_exp</see> - Return the exponent of <i>x</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_get_kind(Math.Mpfr.Native.mpfr_t)">mpfr_custom_get_kind</see> - Return the current kind of a <see cref="T:Math.Mpfr.Native.mpfr_t">mpfr_t</see> as created by <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_init_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_kind_t,Math.Mpfr.Native.mpfr_exp_t,System.UInt32,Math.Gmp.Native.void_ptr)">mpfr_custom_init_set</see>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_get_significand(Math.Mpfr.Native.mpfr_t)">mpfr_custom_get_significand</see> - Return a pointer to the significand used by a <see cref="T:Math.Mpfr.Native.mpfr_t">mpfr_t</see> initialized with <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_init_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_kind_t,Math.Mpfr.Native.mpfr_exp_t,System.UInt32,Math.Gmp.Native.void_ptr)">mpfr_custom_init_set</see>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_get_size(System.UInt32)">mpfr_custom_get_size</see> - Return the needed size in bytes to store the significand of a floating-point number of precision <i>prec</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_init(Math.Gmp.Native.void_ptr,System.UInt32)">mpfr_custom_init</see> - Initialize a significand of precision <i>prec</i>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_init_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_kind_t,Math.Mpfr.Native.mpfr_exp_t,System.UInt32,Math.Gmp.Native.void_ptr)">mpfr_custom_init_set</see> - Perform a dummy initialization of a <see cref="T:Math.Mpfr.Native.mpfr_t">mpfr_t</see>.</description></item>
            <item><description><see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_move(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.void_ptr)">mpfr_custom_move</see> - Inform MPFR that the significand of <i>x</i> has moved due to a garbage collect and update its new position to <i>new_position</i>.</description></item>
            </list>
            </remarks>
        </member>
        <member name="F:Math.Mpfr.Native.mpfr_lib.MPFR_PREC_MIN">
            <summary>
            The minimum number of bits that can be used to represent the significand of a floating-point number.
            </summary>
            <remarks>
            <para>
            In the current implementation, <see cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_PREC_MIN">MPFR_PREC_MIN</see> is 1.
            </para>
            </remarks>
            <seealso cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_PREC_MAX">MPFR_PREC_MAX</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html">GNU MPFR</a></seealso>
        </member>
        <member name="F:Math.Mpfr.Native.mpfr_lib.MPFR_PREC_MAX">
            <summary>
            The maximum number of bits that can be used to represent the significand of a floating-point number.
            </summary>
            <remarks>
            <para>
            In the current implementation, <see cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_PREC_MIN">MPFR_PREC_MIN</see> is 2,147,483,647.
            </para>
            </remarks>
            <seealso cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_PREC_MIN">MPFR_PREC_MIN</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html">GNU MPFR</a></seealso>
        </member>
        <member name="F:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION">
            <summary>
            <see cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION">MPFR_VERSION</see> is the version of MPFR.
            </summary>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_version">mpfr_get_version</seealso>
            <seealso cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION_MAJOR">MPFR_VERSION_MAJOR</seealso>
            <seealso cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION_MINOR">MPFR_VERSION_MINOR</seealso>
            <seealso cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION_PATCHLEVEL">MPFR_VERSION_PATCHLEVEL</seealso>
            <seealso cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION_STRING">MPFR_VERSION_STRING</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION_NUM(System.Int32,System.Int32,System.Int32)">MPFR_VERSION_NUM</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
        </member>
        <member name="F:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION_MAJOR">
            <summary>
            <see cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION_MAJOR">MPFR_VERSION_MAJOR</see> is the major MPFR version.
            </summary>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_version">mpfr_get_version</seealso>
            <seealso cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION">MPFR_VERSION</seealso>
            <seealso cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION_MINOR">MPFR_VERSION_MINOR</seealso>
            <seealso cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION_PATCHLEVEL">MPFR_VERSION_PATCHLEVEL</seealso>
            <seealso cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION_STRING">MPFR_VERSION_STRING</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION_NUM(System.Int32,System.Int32,System.Int32)">MPFR_VERSION_NUM</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
        </member>
        <member name="F:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION_MINOR">
            <summary>
            <see cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION_MINOR">MPFR_VERSION_MINOR</see> is the minor MPFR version.
            </summary>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_version">mpfr_get_version</seealso>
            <seealso cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION">MPFR_VERSION</seealso>
            <seealso cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION_MAJOR">MPFR_VERSION_MAJOR</seealso>
            <seealso cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION_PATCHLEVEL">MPFR_VERSION_PATCHLEVEL</seealso>
            <seealso cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION_STRING">MPFR_VERSION_STRING</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION_NUM(System.Int32,System.Int32,System.Int32)">MPFR_VERSION_NUM</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
        </member>
        <member name="F:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION_PATCHLEVEL">
            <summary>
            <see cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION_PATCHLEVEL">MPFR_VERSION_PATCHLEVEL</see> is the patch level of MPFR version.
            </summary>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_version">mpfr_get_version</seealso>
            <seealso cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION">MPFR_VERSION</seealso>
            <seealso cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION_MAJOR">MPFR_VERSION_MAJOR</seealso>
            <seealso cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION_MINOR">MPFR_VERSION_MINOR</seealso>
            <seealso cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION_STRING">MPFR_VERSION_STRING</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION_NUM(System.Int32,System.Int32,System.Int32)">MPFR_VERSION_NUM</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
        </member>
        <member name="F:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION_STRING">
            <summary>
            <see cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION_STRING">MPFR_VERSION_STRING</see> is the version (with an optional suffix, used in development and pre-release versions) as a string constant.
            </summary>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_version">mpfr_get_version</seealso>
            <seealso cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION">MPFR_VERSION</seealso>
            <seealso cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION_MAJOR">MPFR_VERSION_MAJOR</seealso>
            <seealso cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION_MINOR">MPFR_VERSION_MINOR</seealso>
            <seealso cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION_PATCHLEVEL">MPFR_VERSION_PATCHLEVEL</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION_NUM(System.Int32,System.Int32,System.Int32)">MPFR_VERSION_NUM</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION_NUM(System.Int32,System.Int32,System.Int32)">
            <summary>
            Create an integer in the same format as used by <see cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION">MPFR_VERSION</see> from the given <paramref name="major"/>, <paramref name="minor"/> and <paramref name="patchlevel"/>. 
            </summary>
            <param name="major">The major version.</param>
            <param name="minor">The minor version.</param>
            <param name="patchlevel">The patch level.</param>
            <returns>An integer in the same format as used by <see cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION">MPFR_VERSION</see> from the given <paramref name="major"/>, <paramref name="minor"/> and <paramref name="patchlevel"/>.</returns>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_version">mpfr_get_version</seealso>
            <seealso cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION">MPFR_VERSION</seealso>
            <seealso cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION_MAJOR">MPFR_VERSION_MAJOR</seealso>
            <seealso cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION_MINOR">MPFR_VERSION_MINOR</seealso>
            <seealso cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION_PATCHLEVEL">MPFR_VERSION_PATCHLEVEL</seealso>
            <seealso cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION_STRING">MPFR_VERSION_STRING</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_out_str(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.Int32,Math.Gmp.Native.size_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Output <paramref name="op"/> on stream <paramref name="stream"/>, as a string of digits in base <paramref name="base"/>, rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="stream">The output stream.</param>
            <param name="base">The base.</param>
            <param name="n">Number of significant digits.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return the number of characters written, or if an error occurred, return 0.</returns>
            <remarks>
            <para>
            The base may vary from 2 to 62. 
            Print <paramref name="n"/> significant digits exactly, or if <paramref name="n"/> is 0,
            enough digits so that <paramref name="op"/> can be read back exactly (see <see cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_str">O:Math.Mpfr.Native.mpfr_lib.mpfr_get_str</see>). 
            </para>
            <para>
            In addition to the significant digits, a decimal point (defined by the current locale) at the right of
            the first digit and a trailing exponent in base 10, in the form ‘eNNN’, are printed.
            If <paramref name="base"/> is greater than 10, ‘@’ will be used instead of ‘e’ as exponent delimiter. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inp_str(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_inp_str</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fpif_export(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},Math.Mpfr.Native.mpfr_t)">mpfr_fpif_export</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fpif_import(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.ptr{Math.Gmp.Native.FILE})">mpfr_fpif_import</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Input_and_Output_Functions">Input and Output Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Input-and-Output-Functions">GNU MPFR - Input and Output Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op to 123456.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            mpfr_lib.mpfr_set_ui(op, 123456U, mpfr_rnd_t.MPFR_RNDN);
            
            // Get a temporary file.
            string pathname = System.IO.Path.GetTempFileName();
            
            // Open temporary file for writing.
            ptr&lt;FILE&gt; stream = new ptr&lt;FILE&gt;();
            _wfopen_s(out stream.Value.Value, pathname, "w");
            
            // Write op to temporary file, and assert that the number of bytes written is 24.
            Assert.IsTrue(mpfr_lib.mpfr_out_str(stream, 10, 0, op, mpfr_rnd_t.MPFR_RNDN) == 24);
            
            // Close temporary file.
            fclose(stream.Value.Value);
            
            // Assert that the content of the temporary file is "123456".
            string result = System.IO.File.ReadAllText(pathname);
            Assert.IsTrue(result == "1.23456000000000000000e5");
            
            // Delete temporary file.
            System.IO.File.Delete(pathname);
            
            // Release unmanaged memory allocated for op.
            mpfr_lib.mpfr_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op to 123456.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            mpfr_lib.mpfr_set_ui(op, 123456U, mpfr_rnd_t.MPFR_RNDN)
            
            ' Get a temporary file.
            Dim pathname As String = System.IO.Path.GetTempFileName() 
            
            ' Open temporary file for writing.
            Dim stream As ptr(Of FILE) =  New ptr(Of FILE)()
            _wfopen_s(stream.Value.Value, pathname,"w")
            
            ' Write op to temporary file, and assert that the number of bytes written is 24.
            Assert.IsTrue(mpfr_lib.mpfr_out_str(stream, 10, 0, op, mpfr_rnd_t.MPFR_RNDN) = 24)
            
            ' Close temporary file.
            fclose(stream.Value.Value)
            
            ' Assert that the content of the temporary file is "123456".
            Dim result As String = System.IO.File.ReadAllText(pathname)
            Assert.IsTrue(result = "1.23456000000000000000e5")
            
            ' Delete temporary file.
            System.IO.File.Delete(pathname)
            
            ' Release unmanaged memory allocated for op.
            mpfr_lib.mpfr_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_inp_str(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Input a string in base <paramref name="base"/> from stream <paramref name="stream"/>, rounded in the direction <paramref name="rnd"/>, and put the read float in <paramref name="rop"/>. 
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="stream">The input stream.</param>
            <param name="base">The base.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return the number of bytes read, or if an error occurred, return 0.</returns>
            <remarks>
            <para>
            This function reads a word (defined as a sequence of characters between whitespace) and parses it using <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_str(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.char_ptr,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_str</see>.
            See the documentation of <see cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr">O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr</see> for a detailed description of the valid string formats. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_out_str(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.Int32,Math.Gmp.Native.size_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_out_str</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fpif_export(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},Math.Mpfr.Native.mpfr_t)">mpfr_fpif_export</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fpif_import(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.ptr{Math.Gmp.Native.FILE})">mpfr_fpif_import</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Input_and_Output_Functions">Input and Output Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Input-and-Output-Functions">GNU MPFR - Input and Output Functions</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize op.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            
            // Write op to a temporary file.
            string pathname = System.IO.Path.GetTempFileName();
            System.IO.File.WriteAllText(pathname, "123456");
            
            // Read op from the temporary file, and assert that the number of bytes read is 6.
            ptr&lt;FILE&gt; stream = new ptr&lt;FILE&gt;();
            _wfopen_s(out stream.Value.Value, pathname, "r");
            Assert.IsTrue(mpfr_lib.mpfr_inp_str(op, stream, 10, mpfr_rnd_t.MPFR_RNDN) == 6);
            fclose(stream.Value.Value);
            
            // Assert that op is 123456.
             Assert.IsTrue(mpfr_lib.mpfr_get_ui(op, mpfr_rnd_t.MPFR_RNDN) == 123456U);
            
            // Delete temporary file.
            System.IO.File.Delete(pathname);
            
            // Release unmanaged memory allocated for op.
            mpfr_lib.mpfr_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create and initialize op.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            
            ' Write op to a temporary file.
            Dim pathname As String = System.IO.Path.GetTempFileName()
            System.IO.File.WriteAllText(pathname, "123456")
            
            ' Read op from the temporary file, and assert that the number of bytes read is 6.
            Dim stream As ptr(Of FILE) =  New ptr(Of FILE)()
            /// _wfopen_s(stream.Value.Value, pathname,"r")
            Assert.IsTrue(mpfr_lib.mpfr_inp_str(op, stream, 10, mpfr_rnd_t.MPFR_RNDN) = 6)
            fclose(stream.Value.Value)
            
            ' Assert that op is 123456.
            Assert.IsTrue(mpfr_lib.mpfr_get_ui(op, mpfr_rnd_t.MPFR_RNDN) = 123456U)
            
            ' Delete temporary file.
            System.IO.File.Delete(pathname)
            
            ' Release unmanaged memory allocated for op.
            mpfr_lib.mpfr_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_fpif_export(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},Math.Mpfr.Native.mpfr_t)">
            <summary>
            Export the number <paramref name="op"/> to the stream <paramref name="stream"/> in a floating-point interchange format. 
            </summary>
            <param name="stream">The export stream.</param>
            <param name="op">The floating-point number.</param>
            <returns>Return 0 iff the export was successful.</returns>
            <remarks>
            <para>
            In particular one can export on a 32-bit computer and import on a 64-bit computer, or export on a little-endian
            computer and import on a big-endian computer. The precision of <paramref name="op"/> and the sign bit of a NaN
            are stored too. 
            </para>
            <para>
            Note: this function is experimental and its interface might change in future versions.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_out_str(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.Int32,Math.Gmp.Native.size_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_out_str</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inp_str(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_inp_str</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fpif_import(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.ptr{Math.Gmp.Native.FILE})">mpfr_fpif_import</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Input_and_Output_Functions">Input and Output Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Input-and-Output-Functions">GNU MPFR - Input and Output Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op to 123456.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            mpfr_lib.mpfr_set_ui(op, 123456U, mpfr_rnd_t.MPFR_RNDN);
            
            // Get a temporary file.
            string pathname = System.IO.Path.GetTempFileName();
            
            // Open temporary file for writing.
            ptr&lt;FILE&gt; stream = new ptr&lt;FILE&gt;();
            _wfopen_s(out stream.Value.Value, pathname, "w");
            
            // Export op to temporary file.
            Assert.IsTrue(mpfr_lib.mpfr_fpif_export(stream, op) == 0);
            fclose(stream.Value.Value);
            
            // Read op from the temporary file.
            mpfr_lib.mpfr_set_ui(op, 0, mpfr_rnd_t.MPFR_RNDN);
            stream = new ptr&lt;FILE&gt;();
            _wfopen_s(out stream.Value.Value, pathname, "r");
            Assert.IsTrue(mpfr_lib.mpfr_fpif_import(op, stream) == 0);
            fclose(stream.Value.Value);
            
            // Assert that op is 123456.
            Assert.IsTrue(mpfr_lib.mpfr_get_ui(op, mpfr_rnd_t.MPFR_RNDN) == 123456U);
            
            // Delete temporary file.
            System.IO.File.Delete(pathname);
            
            // Release unmanaged memory allocated for op.
            mpfr_lib.mpfr_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op to 123456.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            mpfr_lib.mpfr_set_ui(op, 123456U, mpfr_rnd_t.MPFR_RNDN)
            
            ' Get a temporary file.
            Dim pathname As String = System.IO.Path.GetTempFileName() 
            
            ' Open temporary file for writing.
            Dim stream As ptr(Of FILE) =  New ptr(Of FILE)()
             _wfopen_s(stream.Value.Value, pathname,"w")
            
            ' Export op to temporary file.
            Assert.IsTrue(mpfr_lib.mpfr_fpif_export(stream, op) = 0)
            fclose(stream.Value.Value)
            
            ' Read op from the temporary file.
            mpfr_lib.mpfr_set_ui(op, 0, mpfr_rnd_t.MPFR_RNDN)
            stream = New ptr(Of FILE)()
            _wfopen_s(stream.Value.Value, pathname,"r")
            Assert.IsTrue(mpfr_lib.mpfr_fpif_import(op, stream) = 0)
            fclose(stream.Value.Value)
            
            ' Assert that op is 123456.
            Assert.IsTrue(mpfr_lib.mpfr_get_ui(op, mpfr_rnd_t.MPFR_RNDN) = 123456U)
            
            ' Delete temporary file.
            System.IO.File.Delete(pathname)
            
            ' Release unmanaged memory allocated for op.
            mpfr_lib.mpfr_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_fpif_import(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.ptr{Math.Gmp.Native.FILE})">
            <summary>
            Import the number <paramref name="op"/> from the stream <paramref name="stream"/> in a floating-point interchange format (see <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fpif_export(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},Math.Mpfr.Native.mpfr_t)"/>). 
            </summary>
            <param name="op">The imported floating-point number.</param>
            <param name="stream">The input stream.</param>
            <returns>Return 0 iff the import was successful.</returns>
            <remarks>
            <para>
            Note that the precision of <paramref name="op"/> is set to the one read from the stream, and the sign bit
            is always retrieved (even for NaN).
            If the stored precision is zero or greater than <see cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_PREC_MAX"/>, the function fails
            (it returns non-zero) and <paramref name="op"/> is unchanged.
            If the function fails for another reason, <paramref name="op"/> is set to NaN and it is unspecified
            whether the precision of <paramref name="op"/> has changed to the one read from the file. 
            </para>
            <para>
            Note: this function is experimental and its interface might change in future versions.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_out_str(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.Int32,Math.Gmp.Native.size_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_out_str</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inp_str(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_inp_str</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fpif_export(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},Math.Mpfr.Native.mpfr_t)">mpfr_fpif_export</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Input_and_Output_Functions">Input and Output Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Input-and-Output-Functions">GNU MPFR - Input and Output Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op to 123456.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            mpfr_lib.mpfr_set_ui(op, 123456U, mpfr_rnd_t.MPFR_RNDN);
            
            // Get a temporary file.
            string pathname = System.IO.Path.GetTempFileName();
            
            // Open temporary file for writing.
            ptr&lt;FILE&gt; stream = new ptr&lt;FILE&gt;();
            _wfopen_s(out stream.Value.Value, pathname, "w");
            
            // Export op to temporary file.
            Assert.IsTrue(mpfr_lib.mpfr_fpif_export(stream, op) == 0);
            fclose(stream.Value.Value);
            
            // Read op from the temporary file.
            mpfr_lib.mpfr_set_ui(op, 0, mpfr_rnd_t.MPFR_RNDN);
            stream = new ptr&lt;FILE&gt;();
            _wfopen_s(out stream.Value.Value, pathname, "r");
            Assert.IsTrue(mpfr_lib.mpfr_fpif_import(op, stream) == 0);
            fclose(stream.Value.Value);
            
            // Assert that op is 123456.
            Assert.IsTrue(mpfr_lib.mpfr_get_ui(op, mpfr_rnd_t.MPFR_RNDN) == 123456U);
            
            // Delete temporary file.
            System.IO.File.Delete(pathname);
            
            // Release unmanaged memory allocated for op.
            mpfr_lib.mpfr_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op to 123456.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            mpfr_lib.mpfr_set_ui(op, 123456U, mpfr_rnd_t.MPFR_RNDN)
            
            ' Get a temporary file.
            Dim pathname As String = System.IO.Path.GetTempFileName() 
            
            ' Open temporary file for writing.
            Dim stream As ptr(Of FILE) =  New ptr(Of FILE)()
             _wfopen_s(stream.Value.Value, pathname,"w")
            
            ' Export op to temporary file.
            Assert.IsTrue(mpfr_lib.mpfr_fpif_export(stream, op) = 0)
            fclose(stream.Value.Value)
            
            ' Read op from the temporary file.
            mpfr_lib.mpfr_set_ui(op, 0, mpfr_rnd_t.MPFR_RNDN)
            stream = New ptr(Of FILE)()
            _wfopen_s(stream.Value.Value, pathname,"r")
            Assert.IsTrue(mpfr_lib.mpfr_fpif_import(op, stream) = 0)
            fclose(stream.Value.Value)
            
            ' Assert that op is 123456.
            Assert.IsTrue(mpfr_lib.mpfr_get_ui(op, mpfr_rnd_t.MPFR_RNDN) = 123456U)
            
            ' Delete temporary file.
            System.IO.File.Delete(pathname)
            
            ' Release unmanaged memory allocated for op.
            mpfr_lib.mpfr_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_sj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Convert <paramref name="op"/> to an <see cref="T:Math.Mpfr.Native.intmax_t">intmax_t</see> after rounding it with respect to <paramref name="rnd"/>.
            </summary>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>The converted floating-point number.</returns>
            <remarks>
            <para>
            If <paramref name="op"/> is NaN, 0 is returned and the erange flag is set.
            If <paramref name="op"/> is too big for the return type, the function returns the maximum
            or the minimum of the corresponding C type, depending on the direction of the overflow;
            the erange flag is set too.
            When there is no such range error, if the return value differs from <paramref name="op"/>,
            i.e., if <paramref name="op"/> is not an integer, the inexact flag is set.
            See also mpfr_fits_slong_p, mpfr_fits_ulong_p, mpfr_fits_intmax_p and mpfr_fits_uintmax_p.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_flt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_flt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_uj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_uj</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_d_2exp"/>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_frexp"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_z_2exp(Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_t)">mpfr_get_z_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_z(Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_q(Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_t)">mpfr_get_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_f(Math.Gmp.Native.mpf_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_f</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_str"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_str(Math.Gmp.Native.char_ptr)">mpfr_free_str</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_slong_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_slong_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_sint_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_sint_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_sshort_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_sshort_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_intmax_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_intmax_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Conversion_Functions">Conversion Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Conversion-Functions">GNU MPFR - Conversion Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number to -123.0
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, -123.0, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of op is -123.0.
            Assert.IsTrue(mpfr_lib.mpfr_get_sj(op, mpfr_rnd_t.MPFR_RNDN) == -123);
            
            // Release unmanaged memory allocated for x.
            mpfr_lib.mpfr_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number to -123.0
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, -123.0, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of op is -123.0.
            Assert.IsTrue(mpfr_lib.mpfr_get_sj(op, mpfr_rnd_t.MPFR_RNDN) = -123)
            
            ' Release unmanaged memory allocated for x.
            mpfr_lib.mpfr_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_uj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Convert <paramref name="op"/> to an <see cref="T:Math.Mpfr.Native.uintmax_t">uintmax_t</see> after rounding it with respect to <paramref name="rnd"/>.
            </summary>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>The converted floating-point number.</returns>
            <remarks>
            <para>
            If <paramref name="op"/> is NaN, 0 is returned and the erange flag is set.
            If <paramref name="op"/> is too big for the return type, the function returns the maximum
            or the minimum of the corresponding C type, depending on the direction of the overflow;
            the erange flag is set too.
            When there is no such range error, if the return value differs from <paramref name="op"/>,
            i.e., if <paramref name="op"/> is not an integer, the inexact flag is set.
            See also mpfr_fits_slong_p, mpfr_fits_ulong_p, mpfr_fits_intmax_p and mpfr_fits_uintmax_p.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_flt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_flt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_sj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_sj</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_d_2exp"/>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_frexp"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_z_2exp(Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_t)">mpfr_get_z_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_z(Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_q(Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_t)">mpfr_get_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_f(Math.Gmp.Native.mpf_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_f</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_str"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_str(Math.Gmp.Native.char_ptr)">mpfr_free_str</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_slong_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_slong_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_sint_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_sint_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_sshort_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_sshort_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_intmax_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_intmax_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Conversion_Functions">Conversion Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Conversion-Functions">GNU MPFR - Conversion Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number to 123.0
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 123.0, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of op is -123.0.
            Assert.IsTrue(mpfr_lib.mpfr_get_uj(op, mpfr_rnd_t.MPFR_RNDN) == 123);
            
            // Release unmanaged memory allocated for x.
            mpfr_lib.mpfr_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number to 123.0
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 123.0, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of op is -123.0.
            Assert.IsTrue(mpfr_lib.mpfr_get_uj(op, mpfr_rnd_t.MPFR_RNDN) = 123)
            
            ' Release unmanaged memory allocated for x.
            mpfr_lib.mpfr_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_sj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set the value of <paramref name="rop"/> from <paramref name="op"/> rounded toward the given direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            Note that the input 0 is converted to +0 regardless of the rounding mode.
            </para>
            <para>
            This function assigns new values to already initialized floats
            (see <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Initialization-Functions">GNU MPFR - Initialization Functions</a>).
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_si(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_uj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_uj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_flt(Math.Mpfr.Native.mpfr_t,System.Single,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_flt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_d(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_f</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_ui_2exp(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_ui_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_si_2exp(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_si_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_uj_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_uj_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_sj_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_sj_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_z_2exp(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_z_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_str(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.char_ptr,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_str</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_nan(Math.Mpfr.Native.mpfr_t)">mpfr_set_nan</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_inf(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_set_inf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_zero(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_set_zero</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_swap(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_swap</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Assignment_Functions">Assignment Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Assignment-Functions">GNU MPFR - Assignment Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number rop to 10.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_sj(rop, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that op is 10.
            Assert.IsTrue(mpfr_lib.mpfr_get_sj(rop, mpfr_rnd_t.MPFR_RNDN) == 10);
            
            // Release unmanaged memory allocated for rop.
            mpfr_lib.mpfr_clear(rop);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number rop to 10.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_sj(rop, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that op is 10.
            Assert.IsTrue(mpfr_lib.mpfr_get_sj(rop, mpfr_rnd_t.MPFR_RNDN) = 10)
            
            ' Release unmanaged memory allocated for rop.
            mpfr_lib.mpfr_clear(rop)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_uj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set the value of <paramref name="rop"/> from <paramref name="op"/> rounded toward the given direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            Note that the input 0 is converted to +0 regardless of the rounding mode.
            </para>
            <para>
            This function assigns new values to already initialized floats
            (see <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Initialization-Functions">GNU MPFR - Initialization Functions</a>).
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_si(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_sj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_sj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_flt(Math.Mpfr.Native.mpfr_t,System.Single,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_flt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_d(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_f</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_ui_2exp(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_ui_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_si_2exp(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_si_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_uj_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_uj_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_sj_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_sj_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_z_2exp(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_z_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_str(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.char_ptr,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_str</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_nan(Math.Mpfr.Native.mpfr_t)">mpfr_set_nan</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_inf(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_set_inf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_zero(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_set_zero</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_swap(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_swap</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Assignment_Functions">Assignment Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Assignment-Functions">GNU MPFR - Assignment Functions</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize a new floating-point number.
            mpfr_t x = new mpfr_t();
            mpfr_lib.mpfr_init2(x, 128U);
            
            // Set x to 100.
            Assert.IsTrue(mpfr_lib.mpfr_set_uj(x, 100U, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of x is 100.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(x, mpfr_rnd_t.MPFR_RNDN) == 100.0);
            
            // Release unmanaged memory allocated for x.
            mpfr_lib.mpfr_clear(x);
            </code> 
            <code language="VB.NET">
            ' Create and initialize a new floating-point number.
            Dim x As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(x, 128U)
            
            ' Set x to 100.
            Assert.IsTrue(mpfr_lib.mpfr_set_uj(x, 100U, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of x is 100.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(x, mpfr_rnd_t.MPFR_RNDN) = 100.0)
            
            ' Release unmanaged memory allocated for x.
            mpfr_lib.mpfr_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_sj_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set the value of <paramref name="rop"/> from <paramref name="op"/> multiplied by two to the power <paramref name="e"/>, rounded toward the given direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="e"></param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            Note that the input 0 is converted to +0.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_si(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_uj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_uj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_sj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_sj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_flt(Math.Mpfr.Native.mpfr_t,System.Single,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_flt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_d(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_f</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_ui_2exp(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_ui_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_uj_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_uj_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_sj_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_sj_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_z_2exp(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_z_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_str(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.char_ptr,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_str</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_nan(Math.Mpfr.Native.mpfr_t)">mpfr_set_nan</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_inf(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_set_inf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_zero(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_set_zero</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_swap(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_swap</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Assignment_Functions">Assignment Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Assignment-Functions">GNU MPFR - Assignment Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number rop to 10.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = 10 * 2^5.
            Assert.IsTrue(mpfr_lib.mpfr_set_sj_2exp(rop, 10, 5, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that op is 320.
            Assert.IsTrue(mpfr_lib.mpfr_get_sj(rop, mpfr_rnd_t.MPFR_RNDN) == 320);
            
            // Release unmanaged memory allocated for rop.
            mpfr_lib.mpfr_clear(rop);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number rop to 10.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = 10 * 2^5.
            Assert.IsTrue(mpfr_lib.mpfr_set_sj_2exp(rop, 10, 5, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that op is 320.
            Assert.IsTrue(mpfr_lib.mpfr_get_sj(rop, mpfr_rnd_t.MPFR_RNDN) = 320)
            
            ' Release unmanaged memory allocated for rop.
            mpfr_lib.mpfr_clear(rop)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_uj_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set the value of <paramref name="rop"/> from <paramref name="op"/> multiplied by two to the power <paramref name="e"/>, rounded toward the given direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="e"></param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            Note that the input 0 is converted to +0.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_si(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_uj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_uj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_sj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_sj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_flt(Math.Mpfr.Native.mpfr_t,System.Single,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_flt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_d(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_f</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_ui_2exp(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_ui_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_si_2exp(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_si_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_sj_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_sj_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_z_2exp(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_z_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_str(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.char_ptr,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_str</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_nan(Math.Mpfr.Native.mpfr_t)">mpfr_set_nan</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_inf(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_set_inf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_zero(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_set_zero</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_swap(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_swap</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Assignment_Functions">Assignment Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Assignment-Functions">GNU MPFR - Assignment Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number rop to 10.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = 10 * 2^5.
            Assert.IsTrue(mpfr_lib.mpfr_set_uj_2exp(rop, 10U, 5, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that op is 320.
            Assert.IsTrue(mpfr_lib.mpfr_get_uj(rop, mpfr_rnd_t.MPFR_RNDN) == 320);
            
            // Release unmanaged memory allocated for rop.
            mpfr_lib.mpfr_clear(rop);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number rop to 10.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = 10 * 2^5.
            Assert.IsTrue(mpfr_lib.mpfr_set_uj_2exp(rop, 10U, 5, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that op is 320.
            Assert.IsTrue(mpfr_lib.mpfr_get_uj(rop, mpfr_rnd_t.MPFR_RNDN) = 320)
            
            ' Release unmanaged memory allocated for rop.
            mpfr_lib.mpfr_clear(rop)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_version">
            <summary>
            Return the MPFR version, as a null-terminated string. 
            </summary>
            <returns>Return the MPFR version, as a null-terminated string.</returns>
            <seealso cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION">MPFR_VERSION</seealso>
            <seealso cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION_MAJOR">MPFR_VERSION_MAJOR</seealso>
            <seealso cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION_MINOR">MPFR_VERSION_MINOR</seealso>
            <seealso cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION_PATCHLEVEL">MPFR_VERSION_PATCHLEVEL</seealso>
            <seealso cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION_STRING">MPFR_VERSION_STRING</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.MPFR_VERSION_NUM(System.Int32,System.Int32,System.Int32)">MPFR_VERSION_NUM</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
            <example>
            <code language="C#">
            // Assert MPFR version.
            Assert.IsTrue(mpfr_lib.mpfr_get_version().ToString() == "3.1.6");
            </code> 
            <code language="VB.NET">
            ' Assert MPFR version.
            Assert.IsTrue(mpfr_lib.mpfr_get_version().ToString() = "3.1.6")
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_patches">
            <summary>
            Return a null-terminated string containing the ids of the patches applied to the MPFR library (contents of the PATCHES file), separated by spaces.
            </summary>
            <returns>Return a null-terminated string containing the ids of the patches applied to the MPFR library (contents of the PATCHES file), separated by spaces.</returns>
            <remarks>
            <para>
            Note: If the program has been compiled with an older MPFR version and is dynamically linked with a new MPFR library version,
            the identifiers of the patches applied to the old (compile-time) MPFR version are not available (however this information
            should not have much interest in general). 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_buildopt_tls_p">mpfr_buildopt_tls_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_buildopt_float128_p">mpfr_buildopt_float128_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_buildopt_decimal_p">mpfr_buildopt_decimal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_buildopt_gmpinternals_p">mpfr_buildopt_gmpinternals_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_buildopt_tune_case">mpfr_buildopt_tune_case</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_buildopt_sharedcache_p">mpfr_buildopt_sharedcache_p </seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
            <example>
            <code language="C#">
            // Assert no patch applied.
            Assert.IsTrue(mpfr_lib.mpfr_get_patches().ToString() == "");
            </code> 
            <code language="VB.NET">
            ' Assert no patch applied.
            Assert.IsTrue(mpfr_lib.mpfr_get_patches().ToString() = "")
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_buildopt_tls_p">
            <summary>
            Return a non-zero value if MPFR was compiled as thread safe using compiler-level Thread Local Storage, return zero otherwise.
            </summary>
            <returns>Return a non-zero value if MPFR was compiled as thread safe using compiler-level Thread Local Storage, return zero otherwise.</returns>
            <remarks>
            <para>
            Return a non-zero value if MPFR was compiled with decimal float support
            (that is, MPFR was built with the --enable-decimal-float configure option),
            return zero otherwise. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_patches">mpfr_get_patches</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_buildopt_float128_p">mpfr_buildopt_float128_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_buildopt_decimal_p">mpfr_buildopt_decimal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_buildopt_gmpinternals_p">mpfr_buildopt_gmpinternals_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_buildopt_tune_case">mpfr_buildopt_tune_case</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_buildopt_sharedcache_p">mpfr_buildopt_sharedcache_p </seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
            <example>
            <code language="C#">
            // Assert that --enable-thread-safe compile option was used.
            Assert.IsTrue(mpfr_lib.mpfr_buildopt_tls_p() != 0);
            </code> 
            <code language="VB.NET">
            ' Assert that --enable-thread-safe compile option was used.
            Assert.IsTrue(mpfr_lib.mpfr_buildopt_tls_p() &lt;&gt; 0)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_buildopt_float128_p">
            <summary>
            Return a non-zero value if MPFR was compiled with ‘__float128’ support, return zero otherwise.
            </summary>
            <returns>Return a non-zero value if MPFR was compiled with ‘__float128’ support, return zero otherwise.</returns>
            <remarks>
            <para>
            Return a non-zero value if MPFR was compiled with ‘__float128’ support (that is, MPFR was built with the
            ‘--enable-float128’ configure option), return zero otherwise.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_patches">mpfr_get_patches</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_buildopt_tls_p">mpfr_buildopt_tls_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_buildopt_decimal_p">mpfr_buildopt_decimal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_buildopt_gmpinternals_p">mpfr_buildopt_gmpinternals_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_buildopt_tune_case">mpfr_buildopt_tune_case</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_buildopt_sharedcache_p">mpfr_buildopt_sharedcache_p </seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
            <example>
            <code language="C#">
            // Assert that ‘__float128’ support is not available.
            Assert.IsTrue(mpfr_lib.mpfr_buildopt_float128_p() == 0);
            </code> 
            <code language="VB.NET">
            ' Assert that ‘__float128’ support is not available.
            Assert.IsTrue(mpfr_lib.mpfr_buildopt_float128_p() = 0)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_buildopt_decimal_p">
            <summary>
            Return a non-zero value if MPFR was compiled with decimal float support, return zero otherwise. 
            </summary>
            <returns>Return a non-zero value if MPFR was compiled with decimal float support, return zero otherwise.</returns>
            <remarks>
            <para>
            Return a non-zero value if MPFR was compiled with decimal float support
            (that is, MPFR was built with the --enable-decimal-float configure option), return zero otherwise. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_patches">mpfr_get_patches</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_buildopt_tls_p">mpfr_buildopt_tls_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_buildopt_float128_p">mpfr_buildopt_float128_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_buildopt_gmpinternals_p">mpfr_buildopt_gmpinternals_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_buildopt_tune_case">mpfr_buildopt_tune_case</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_buildopt_sharedcache_p">mpfr_buildopt_sharedcache_p </seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
            <example>
            <code language="C#">
            // Assert that Decimal float is not available.
            Assert.IsTrue(mpfr_lib.mpfr_buildopt_decimal_p() == 0);
            </code> 
            <code language="VB.NET">
            ' Assert that Decimal float is not available.
            Assert.IsTrue(mpfr_lib.mpfr_buildopt_decimal_p() = 0)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_buildopt_gmpinternals_p">
            <summary>
            Return a non-zero value if MPFR was compiled with GMP internals, return zero otherwise. 
            </summary>
            <returns>Return a non-zero value if MPFR was compiled with GMP internals, return zero otherwise.</returns>
            <remarks>
            <para>
            Return a non-zero value if MPFR was compiled with GMP internals
            (that is, MPFR was built with either --with-gmp-build or --enable-gmp-internals configure option), return zero otherwise. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_patches">mpfr_get_patches</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_buildopt_tls_p">mpfr_buildopt_tls_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_buildopt_float128_p">mpfr_buildopt_float128_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_buildopt_decimal_p">mpfr_buildopt_decimal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_buildopt_tune_case">mpfr_buildopt_tune_case</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_buildopt_sharedcache_p">mpfr_buildopt_sharedcache_p </seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
            <example>
            <code language="C#">
            // Assert that --with-gmp-build compile option was used.
            Assert.IsTrue(mpfr_lib.mpfr_buildopt_gmpinternals_p() == 0);
            </code> 
            <code language="VB.NET">
            ' Assert that --with-gmp-build compile option was used.
            Assert.IsTrue(mpfr_lib.mpfr_buildopt_gmpinternals_p() = 0)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_buildopt_sharedcache_p">
            <summary>
            Return a non-zero value if MPFR was compiled so that all threads share the same cache for one MPFR constant, return zero otherwise. 
            </summary>
            <returns>Return a non-zero value if MPFR was compiled so that all threads share the same cache for one MPFR constant, return zero otherwise.</returns>
            <remarks>
            <para>
            Return a non-zero value if MPFR was compiled so that all threads share the same cache for one MPFR constant,
            like <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_const_pi(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)"/> or <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_const_log2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)"/> (that is, MPFR was built with the
            ‘--enable-shared-cache’ configure option), return zero otherwise.
            If the return value is non-zero, MPFR applications may need to be compiled with the ‘-pthread’ option.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_patches">mpfr_get_patches</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_buildopt_tls_p">mpfr_buildopt_tls_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_buildopt_float128_p">mpfr_buildopt_float128_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_buildopt_decimal_p">mpfr_buildopt_decimal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_buildopt_gmpinternals_p">mpfr_buildopt_gmpinternals_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_buildopt_tune_case">mpfr_buildopt_tune_case</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
            <example>
            <code language="C#">
            // Assert that --enable-shared-cache compile option was used.
            Assert.IsTrue(mpfr_lib.mpfr_buildopt_sharedcache_p() == 0);
            </code> 
            <code language="VB.NET">
            ' Assert that --enable-shared-cache compile option was used.
            Assert.IsTrue(mpfr_lib.mpfr_buildopt_sharedcache_p() = 0)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_buildopt_tune_case">
            <summary>
            Return a string saying which thresholds file has been used at compile time.
            </summary>
            <returns>Return a string saying which thresholds file has been used at compile time.</returns>
            <remarks>
            <para>
            This file is normally selected from the processor type. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_patches">mpfr_get_patches</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_buildopt_tls_p">mpfr_buildopt_tls_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_buildopt_float128_p">mpfr_buildopt_float128_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_buildopt_decimal_p">mpfr_buildopt_decimal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_buildopt_gmpinternals_p">mpfr_buildopt_gmpinternals_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
            <example>
            <code language="C#">
            if (gmp_lib.mp_bytes_per_limb == 4)
                Assert.IsTrue(mpfr_lib.mpfr_buildopt_tune_case().ToString() == "src/x86/mparam.h");
            else
                Assert.IsTrue(mpfr_lib.mpfr_buildopt_tune_case().ToString() == "default");
            </code> 
            <code language="VB.NET">
            If gmp_lib.mp_bytes_per_limb = 4 Then
                Assert.IsTrue(mpfr_lib.mpfr_buildopt_tune_case().ToString() = "src/x86/mparam.h")
            Else
                Assert.IsTrue(mpfr_lib.mpfr_buildopt_tune_case().ToString() = "default")
            End If
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emin">
            <summary>
            Return the (current) smallest exponent allowed for a floating-point variable.
            </summary>
            <returns>Return the (current) smallest exponent allowed for a floating-point variable.</returns>
            <remarks>
            <para>
            The smallest positive value of a floating-point variable is one half times 2 raised to the smallest exponent
            and the largest value has the form (1 - epsilon) times 2 raised to the largest exponent,
            where epsilon depends on the precision of the considered variable. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emax">mpfr_get_emax</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_emin(Math.Mpfr.Native.mpfr_exp_t)">mpfr_set_emin</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_emax(Math.Mpfr.Native.mpfr_exp_t)">mpfr_set_emax</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emin_min">mpfr_get_emin_min</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emin_max">mpfr_get_emin_max</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emax_min">mpfr_get_emax_min</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emax_max">mpfr_get_emax_max</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_check_range(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_check_range</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_subnormalize(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_subnormalize</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Assert minimum exponent.
            Assert.IsTrue(mpfr_lib.mpfr_get_emin() == -1073741823);
            </code> 
            <code language="VB.NET">
            ' Assert minimum exponent.
            Assert.IsTrue(mpfr_lib.mpfr_get_emin() = -1073741823)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_emin(Math.Mpfr.Native.mpfr_exp_t)">
            <summary>
            Set the smallest exponent allowed for a floating-point variable.
            </summary>
            <param name="exp">The exponent.</param>
            <returns>Return a nonzero value when <paramref name="exp"/> is not in the range accepted by the implementation (in that case the smallest exponent is not changed), and zero otherwise.</returns>
            <remarks>
            <para>
            For the subsequent operations, it is the user’s responsibility to check that any floating-point value used as an input is in the
            new exponent range (for example using <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_check_range(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)"/>).
            If a floating-point value outside the new exponent range is used as an input, the default behavior is undefined, in the sense of
            the ISO C standard; the behavior may also be explicitly documented, such as for <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_check_range(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)"/>.
            </para>
            <para>
            Note: Caches may still have values outside the current exponent range.
            This is not an issue as the user cannot use these caches directly via the API (MPFR extends the exponent range internally
            when need be).
            </para>
            <para>
            If emin &gt; emax and a floating-point value needs to be produced as output, the behavior is undefined
            (<see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_emin(Math.Mpfr.Native.mpfr_exp_t)"/> and <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_emax(Math.Mpfr.Native.mpfr_exp_t)"/> do not check this condition as it might occur between
            successive calls to these two functions).
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emin">mpfr_get_emin</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emax">mpfr_get_emax</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_emax(Math.Mpfr.Native.mpfr_exp_t)">mpfr_set_emax</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emin_min">mpfr_get_emin_min</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emin_max">mpfr_get_emin_max</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emax_min">mpfr_get_emax_min</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emax_max">mpfr_get_emax_max</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_check_range(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_check_range</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_subnormalize(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_subnormalize</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Set max exponent.
            mpfr_lib.mpfr_set_emin(1000);
            Assert.IsTrue(mpfr_lib.mpfr_get_emin() == 1000);
            </code> 
            <code language="VB.NET">
            ' Set max exponent.
            mpfr_lib.mpfr_set_emin(1000)
            Assert.IsTrue(mpfr_lib.mpfr_get_emin() = 1000)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emin_min">
            <summary>
            Return the minimum exponent allowed for <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_emin(Math.Mpfr.Native.mpfr_exp_t)">mpfr_set_emin</see>. 
            </summary>
            <returns>Return the minimum exponent allowed for <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_emin(Math.Mpfr.Native.mpfr_exp_t)">mpfr_set_emin</see>.</returns>
            <remarks>
            <para>
            This value is implementation dependent, thus a program using <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_emax(Math.Mpfr.Native.mpfr_exp_t)">mpfr_set_emax</see>(<see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emax_max">mpfr_get_emax_max</see>())
            or <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_emin(Math.Mpfr.Native.mpfr_exp_t)">mpfr_set_emin</see>(<see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emin_min">mpfr_get_emin_min</see>()) may not be portable. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emin">mpfr_get_emin</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emax">mpfr_get_emax</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_emin(Math.Mpfr.Native.mpfr_exp_t)">mpfr_set_emin</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_emax(Math.Mpfr.Native.mpfr_exp_t)">mpfr_set_emax</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emin_max">mpfr_get_emin_max</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emax_min">mpfr_get_emax_min</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emax_max">mpfr_get_emax_max</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_check_range(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_check_range</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_subnormalize(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_subnormalize</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Assert mpfr_set_emin minimum exponent.
            Assert.IsTrue(mpfr_lib.mpfr_get_emin_min() == -1073741823);
            </code> 
            <code language="VB.NET">
            ' Assert mpfr_set_emin minimum exponent.
            Assert.IsTrue(mpfr_lib.mpfr_get_emin_min() = -1073741823)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emin_max">
            <summary>
            Return the maximum exponent allowed for <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_emin(Math.Mpfr.Native.mpfr_exp_t)">mpfr_set_emin</see>. 
            </summary>
            <returns>Return the maximum of the exponent allowed for <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_emin(Math.Mpfr.Native.mpfr_exp_t)">mpfr_set_emin</see>.</returns>
            <remarks>
            <para>
            This value is implementation dependent, thus a program using <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_emax(Math.Mpfr.Native.mpfr_exp_t)">mpfr_set_emax</see>(<see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emax_max">mpfr_get_emax_max</see>())
            or <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_emin(Math.Mpfr.Native.mpfr_exp_t)">mpfr_set_emin</see>(<see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emin_min">mpfr_get_emin_min</see>()) may not be portable. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emin">mpfr_get_emin</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emax">mpfr_get_emax</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_emin(Math.Mpfr.Native.mpfr_exp_t)">mpfr_set_emin</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_emax(Math.Mpfr.Native.mpfr_exp_t)">mpfr_set_emax</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emin_min">mpfr_get_emin_min</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emax_min">mpfr_get_emax_min</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emax_max">mpfr_get_emax_max</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_check_range(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_check_range</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_subnormalize(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_subnormalize</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Assert mpfr_set_emin maximum exponent.
            Assert.IsTrue(mpfr_lib.mpfr_get_emin_max() == 1073741823);
            </code> 
            <code language="VB.NET">
            ' Assert mpfr_set_emin maximum exponent.
            Assert.IsTrue(mpfr_lib.mpfr_get_emin_max() = 1073741823)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emax">
            <summary>
            Return the (current) largest exponent allowed for a floating-point variable.
            </summary>
            <returns>Return the (current) largest exponent allowed for a floating-point variable.</returns>
            <remarks>
            <para>
            The smallest positive value of a floating-point variable is one half times 2 raised to the smallest exponent
            and the largest value has the form (1 - epsilon) times 2 raised to the largest exponent,
            where epsilon depends on the precision of the considered variable. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emin">mpfr_get_emin</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_emin(Math.Mpfr.Native.mpfr_exp_t)">mpfr_set_emin</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_emax(Math.Mpfr.Native.mpfr_exp_t)">mpfr_set_emax</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emin_min">mpfr_get_emin_min</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emin_max">mpfr_get_emin_max</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emax_min">mpfr_get_emax_min</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emax_max">mpfr_get_emax_max</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_check_range(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_check_range</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_subnormalize(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_subnormalize</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Assert maximum exponent.
            Assert.IsTrue(mpfr_lib.mpfr_get_emax() == 1073741823);
            </code> 
            <code language="VB.NET">
            ' Assert maximum exponent.
            Assert.IsTrue(mpfr_lib.mpfr_get_emax() = 1073741823)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_emax(Math.Mpfr.Native.mpfr_exp_t)">
            <summary>
            Set the largest exponent allowed for a floating-point variable.
            </summary>
            <param name="exp">The exponent.</param>
            <returns>Return a non-zero value when <paramref name="exp"/> is not in the range accepted by the implementation (in that case the largest exponent is not changed), and zero otherwise.</returns>
            <remarks>
            <para>
            If the user changes the exponent range, it is her/his responsibility to check that all current floating-point variables 
            are in the new allowed range (for example using <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_check_range(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_check_range</see>), otherwise the subsequent behavior will
            be undefined, in the sense of the ISO C standard. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emin">mpfr_get_emin</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emax">mpfr_get_emax</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_emin(Math.Mpfr.Native.mpfr_exp_t)">mpfr_set_emin</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emin_min">mpfr_get_emin_min</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emin_max">mpfr_get_emin_max</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emax_min">mpfr_get_emax_min</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emax_max">mpfr_get_emax_max</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_check_range(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_check_range</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_subnormalize(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_subnormalize</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Set max exponent.
            mpfr_lib.mpfr_set_emax(1000);
            Assert.IsTrue(mpfr_lib.mpfr_get_emax() == 1000);
            </code> 
            <code language="VB.NET">
            ' Set max exponent.
            mpfr_lib.mpfr_set_emax(1000)
            Assert.IsTrue(mpfr_lib.mpfr_get_emax() = 1000)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emax_min">
            <summary>
            Return the minimum exponent allowed for <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_emax(Math.Mpfr.Native.mpfr_exp_t)">mpfr_set_emax</see>. 
            </summary>
            <returns>Return the minimum exponent allowed for <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_emax(Math.Mpfr.Native.mpfr_exp_t)">mpfr_set_emax</see>.</returns>
            <remarks>
            <para>
            This value is implementation dependent, thus a program using <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_emax(Math.Mpfr.Native.mpfr_exp_t)">mpfr_set_emax</see>(<see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emax_max">mpfr_get_emax_max</see>())
            or <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_emin(Math.Mpfr.Native.mpfr_exp_t)">mpfr_set_emin</see>(<see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emin_min">mpfr_get_emin_min</see>()) may not be portable. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emin">mpfr_get_emin</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emax">mpfr_get_emax</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_emin(Math.Mpfr.Native.mpfr_exp_t)">mpfr_set_emin</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_emax(Math.Mpfr.Native.mpfr_exp_t)">mpfr_set_emax</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emin_min">mpfr_get_emin_min</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emin_max">mpfr_get_emin_max</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emax_max">mpfr_get_emax_max</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_check_range(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_check_range</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_subnormalize(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_subnormalize</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Assert mpfr_set_emax minimum exponent.
            Assert.IsTrue(mpfr_lib.mpfr_get_emax_min() == -1073741823);
            </code> 
            <code language="VB.NET">
            ' Assert mpfr_set_emax minimum exponent.
            Assert.IsTrue(mpfr_lib.mpfr_get_emax_min() = -1073741823)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emax_max">
            <summary>
            Return the maximum exponent allowed for <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_emax(Math.Mpfr.Native.mpfr_exp_t)">mpfr_set_emax</see>. 
            </summary>
            <returns>Return the maximum exponent allowed for <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_emax(Math.Mpfr.Native.mpfr_exp_t)">mpfr_set_emax</see>.</returns>
            <remarks>
            <para>
            This value is implementation dependent, thus a program using <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_emax(Math.Mpfr.Native.mpfr_exp_t)">mpfr_set_emax</see>(<see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emax_max">mpfr_get_emax_max</see>())
            or <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_emin(Math.Mpfr.Native.mpfr_exp_t)">mpfr_set_emin</see>(<see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emin_min">mpfr_get_emin_min</see>()) may not be portable. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emin">mpfr_get_emin</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emax">mpfr_get_emax</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_emin(Math.Mpfr.Native.mpfr_exp_t)">mpfr_set_emin</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_emax(Math.Mpfr.Native.mpfr_exp_t)">mpfr_set_emax</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emin_min">mpfr_get_emin_min</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emin_max">mpfr_get_emin_max</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emax_min">mpfr_get_emax_min</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_check_range(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_check_range</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_subnormalize(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_subnormalize</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Assert mpfr_set_emax maximum exponent.
            Assert.IsTrue(mpfr_lib.mpfr_get_emax_max() == 1073741823);
            </code> 
            <code language="VB.NET">
            ' Assert mpfr_set_emax maximum exponent.
            Assert.IsTrue(mpfr_lib.mpfr_get_emax_max() = 1073741823)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_default_rounding_mode(Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set the default rounding mode to <paramref name="rnd"/>.
            </summary>
            <param name="rnd">The rounding direction.</param>
            <remarks>
            <para>
            The default rounding mode is to nearest initially. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_default_rounding_mode">mpfr_get_default_rounding_mode </seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_prec_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_prec_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_prec_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_can_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t,Math.Mpfr.Native.mpfr_rnd_t,Math.Mpfr.Native.mpfr_prec_t)">mpfr_can_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_min_prec(Math.Mpfr.Native.mpfr_t)">mpfr_min_prec</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_print_rnd_mode(Math.Mpfr.Native.mpfr_rnd_t)">mpfr_print_rnd_mode</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Rounding_Related_Functions">Rounding Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Related-Functions">GNU MPFR - Rounding Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Set default rounding mode.
            mpfr_lib.mpfr_set_default_rounding_mode(mpfr_rnd_t.MPFR_RNDN);
            
            // Assert default rounding mode.
            Assert.IsTrue(mpfr_lib.mpfr_get_default_rounding_mode() == mpfr_rnd_t.MPFR_RNDN);
            </code> 
            <code language="VB.NET">
            ' Set default rounding mode.
            mpfr_lib.mpfr_set_default_rounding_mode(mpfr_rnd_t.MPFR_RNDN)
            
            ' Assert default rounding mode.
            Assert.IsTrue(mpfr_lib.mpfr_get_default_rounding_mode() = mpfr_rnd_t.MPFR_RNDN)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_default_rounding_mode">
            <summary>
            Get the default rounding mode. 
            </summary>
            <returns>The default rounding mode.</returns>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_default_rounding_mode(Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_default_rounding_mode</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_prec_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_prec_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_prec_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_can_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t,Math.Mpfr.Native.mpfr_rnd_t,Math.Mpfr.Native.mpfr_prec_t)">mpfr_can_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_min_prec(Math.Mpfr.Native.mpfr_t)">mpfr_min_prec</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_print_rnd_mode(Math.Mpfr.Native.mpfr_rnd_t)">mpfr_print_rnd_mode</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Rounding_Related_Functions">Rounding Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Related-Functions">GNU MPFR - Rounding Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Set default rounding mode.
            mpfr_lib.mpfr_set_default_rounding_mode(mpfr_rnd_t.MPFR_RNDN);
            
            // Assert default rounding mode.
            Assert.IsTrue(mpfr_lib.mpfr_get_default_rounding_mode() == mpfr_rnd_t.MPFR_RNDN);
            </code> 
            <code language="VB.NET">
            ' Set default rounding mode.
            mpfr_lib.mpfr_set_default_rounding_mode(mpfr_rnd_t.MPFR_RNDN)
            
            ' Assert default rounding mode.
            Assert.IsTrue(mpfr_lib.mpfr_get_default_rounding_mode() = mpfr_rnd_t.MPFR_RNDN)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_print_rnd_mode(Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Return a string ("MPFR_RNDD", "MPFR_RNDU", "MPFR_RNDN", "MPFR_RNDZ", "MPFR_RNDA") corresponding to the rounding mode <paramref name="rnd"/>, or a null pointer if <paramref name="rnd"/> is an invalid rounding mode. 
            </summary>
            <param name="rnd">The rounding direction.</param>
            <returns>Return a string ("MPFR_RNDD", "MPFR_RNDU", "MPFR_RNDN", "MPFR_RNDZ", "MPFR_RNDA") corresponding to the rounding mode <paramref name="rnd"/>, or a null pointer if <paramref name="rnd"/> is an invalid rounding mode. </returns>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_default_rounding_mode(Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_default_rounding_mode</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_default_rounding_mode">mpfr_get_default_rounding_mode </seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_prec_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_prec_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_prec_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_can_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t,Math.Mpfr.Native.mpfr_rnd_t,Math.Mpfr.Native.mpfr_prec_t)">mpfr_can_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_min_prec(Math.Mpfr.Native.mpfr_t)">mpfr_min_prec</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Rounding_Related_Functions">Rounding Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Related-Functions">GNU MPFR - Rounding Related Functions</a></seealso>
            <example>
            <code language="C#">
            Assert.IsTrue(mpfr_lib.mpfr_print_rnd_mode(mpfr_rnd_t.MPFR_RNDA).ToString() == "MPFR_RNDA");
            Assert.IsTrue(mpfr_lib.mpfr_print_rnd_mode(mpfr_rnd_t.MPFR_RNDD).ToString() == "MPFR_RNDD");
            Assert.IsTrue(mpfr_lib.mpfr_print_rnd_mode(mpfr_rnd_t.MPFR_RNDF) == char_ptr.Zero);
            Assert.IsTrue(mpfr_lib.mpfr_print_rnd_mode(mpfr_rnd_t.MPFR_RNDN).ToString() == "MPFR_RNDN");
            Assert.IsTrue(mpfr_lib.mpfr_print_rnd_mode(mpfr_rnd_t.MPFR_RNDU).ToString() == "MPFR_RNDU");
            Assert.IsTrue(mpfr_lib.mpfr_print_rnd_mode(mpfr_rnd_t.MPFR_RNDZ).ToString() == "MPFR_RNDZ");
            Assert.IsTrue(mpfr_lib.mpfr_print_rnd_mode(mpfr_rnd_t.MPFR_RNDNA) == char_ptr.Zero);
            </code> 
            <code language="VB.NET">
            Assert.IsTrue(mpfr_lib.mpfr_print_rnd_mode(mpfr_rnd_t.MPFR_RNDA).ToString() = "MPFR_RNDA")
            Assert.IsTrue(mpfr_lib.mpfr_print_rnd_mode(mpfr_rnd_t.MPFR_RNDD).ToString() = "MPFR_RNDD")
            Assert.IsTrue(mpfr_lib.mpfr_print_rnd_mode(mpfr_rnd_t.MPFR_RNDF) = char_ptr.Zero)
            Assert.IsTrue(mpfr_lib.mpfr_print_rnd_mode(mpfr_rnd_t.MPFR_RNDN).ToString() = "MPFR_RNDN")
            Assert.IsTrue(mpfr_lib.mpfr_print_rnd_mode(mpfr_rnd_t.MPFR_RNDU).ToString() = "MPFR_RNDU")
            Assert.IsTrue(mpfr_lib.mpfr_print_rnd_mode(mpfr_rnd_t.MPFR_RNDZ).ToString() = "MPFR_RNDZ")
            Assert.IsTrue(mpfr_lib.mpfr_print_rnd_mode(mpfr_rnd_t.MPFR_RNDNA) = char_ptr.Zero)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_flags">
            <summary>
            Clear (lower) all global flags (underflow, overflow, divide-by-zero, invalid, inexact, erange). 
            </summary>
            <remarks>
            <para>
            Note: a group of flags can be cleared by using <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_flags_clear(Math.Mpfr.Native.mpfr_flags_t)"/>.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_underflow">mpfr_clear_underflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_overflow">mpfr_clear_overflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_divby0">mpfr_clear_divby0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_nanflag">mpfr_clear_nanflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_inexflag">mpfr_clear_inexflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_erangeflag">mpfr_clear_erangeflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_underflow">mpfr_set_underflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_overflow">mpfr_set_overflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_divby0">mpfr_set_divby0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_nanflag">mpfr_set_nanflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_inexflag">mpfr_set_inexflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_erangeflag">mpfr_set_erangeflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_underflow_p">mpfr_underflow_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_overflow_p">mpfr_overflow_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_divby0_p">mpfr_divby0_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nanflag_p">mpfr_nanflag_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inexflag_p">mpfr_inexflag_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erangeflag_p">mpfr_erangeflag_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Clear all flags and assert that flags are clear.
            mpfr_lib.mpfr_clear_flags();
            Assert.IsTrue(mpfr_lib.mpfr_underflow_p() == 0);
            Assert.IsTrue(mpfr_lib.mpfr_overflow_p() == 0);
            Assert.IsTrue(mpfr_lib.mpfr_divby0_p() == 0);
            Assert.IsTrue(mpfr_lib.mpfr_nanflag_p() == 0);
            Assert.IsTrue(mpfr_lib.mpfr_inexflag_p() == 0);
            Assert.IsTrue(mpfr_lib.mpfr_erangeflag_p() == 0);
            </code> 
            <code language="VB.NET">
            ' Clear all flags and assert that flags are clear.
            mpfr_lib.mpfr_clear_flags()
            Assert.IsTrue(mpfr_lib.mpfr_underflow_p() = 0)
            Assert.IsTrue(mpfr_lib.mpfr_overflow_p() = 0)
            Assert.IsTrue(mpfr_lib.mpfr_divby0_p() = 0)
            Assert.IsTrue(mpfr_lib.mpfr_nanflag_p() = 0)
            Assert.IsTrue(mpfr_lib.mpfr_inexflag_p() = 0)
            Assert.IsTrue(mpfr_lib.mpfr_erangeflag_p() = 0)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_underflow">
            <summary>
            Clear (lower) the underflow flag. 
            </summary>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_overflow">mpfr_clear_overflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_divby0">mpfr_clear_divby0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_nanflag">mpfr_clear_nanflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_inexflag">mpfr_clear_inexflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_erangeflag">mpfr_clear_erangeflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_underflow">mpfr_set_underflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_overflow">mpfr_set_overflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_divby0">mpfr_set_divby0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_nanflag">mpfr_set_nanflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_inexflag">mpfr_set_inexflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_erangeflag">mpfr_set_erangeflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_flags">mpfr_clear_flags</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_underflow_p">mpfr_underflow_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_overflow_p">mpfr_overflow_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_divby0_p">mpfr_divby0_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nanflag_p">mpfr_nanflag_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inexflag_p">mpfr_inexflag_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erangeflag_p">mpfr_erangeflag_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Clear flag and assert that flag is clear.
            mpfr_lib.mpfr_clear_underflow();
            Assert.IsTrue(mpfr_lib.mpfr_underflow_p() == 0);
            </code> 
            <code language="VB.NET">
            ' Clear flag and assert that flag is clear.
            mpfr_lib.mpfr_clear_underflow()
            Assert.IsTrue(mpfr_lib.mpfr_underflow_p() = 0)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_overflow">
            <summary>
            Clear (lower) the overflow flag. 
            </summary>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_underflow">mpfr_clear_underflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_divby0">mpfr_clear_divby0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_nanflag">mpfr_clear_nanflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_inexflag">mpfr_clear_inexflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_erangeflag">mpfr_clear_erangeflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_underflow">mpfr_set_underflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_overflow">mpfr_set_overflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_divby0">mpfr_set_divby0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_nanflag">mpfr_set_nanflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_inexflag">mpfr_set_inexflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_erangeflag">mpfr_set_erangeflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_flags">mpfr_clear_flags</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_underflow_p">mpfr_underflow_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_overflow_p">mpfr_overflow_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_divby0_p">mpfr_divby0_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nanflag_p">mpfr_nanflag_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inexflag_p">mpfr_inexflag_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erangeflag_p">mpfr_erangeflag_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Clear flag and assert that flag is clear.
            mpfr_lib.mpfr_clear_overflow();
            Assert.IsTrue(mpfr_lib.mpfr_overflow_p() == 0);
            </code> 
            <code language="VB.NET">
            ' Clear flag and assert that flag is clear.
            mpfr_lib.mpfr_clear_overflow()
            Assert.IsTrue(mpfr_lib.mpfr_overflow_p() = 0)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_divby0">
            <summary>
            Clear (lower) the divide-by-zero flag. 
            </summary>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_underflow">mpfr_clear_underflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_overflow">mpfr_clear_overflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_nanflag">mpfr_clear_nanflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_inexflag">mpfr_clear_inexflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_erangeflag">mpfr_clear_erangeflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_underflow">mpfr_set_underflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_overflow">mpfr_set_overflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_divby0">mpfr_set_divby0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_nanflag">mpfr_set_nanflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_inexflag">mpfr_set_inexflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_erangeflag">mpfr_set_erangeflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_flags">mpfr_clear_flags</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_underflow_p">mpfr_underflow_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_overflow_p">mpfr_overflow_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_divby0_p">mpfr_divby0_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nanflag_p">mpfr_nanflag_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inexflag_p">mpfr_inexflag_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erangeflag_p">mpfr_erangeflag_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Clear flag and assert that flag is clear.
            mpfr_lib.mpfr_clear_divby0();
            Assert.IsTrue(mpfr_lib.mpfr_divby0_p() == 0);
            </code> 
            <code language="VB.NET">
            ' Clear flag and assert that flag is clear.
            mpfr_lib.mpfr_clear_divby0()
            Assert.IsTrue(mpfr_lib.mpfr_divby0_p() = 0)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_nanflag">
            <summary>
            Clear (lower) the invalid flag. 
            </summary>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_underflow">mpfr_clear_underflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_overflow">mpfr_clear_overflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_divby0">mpfr_clear_divby0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_inexflag">mpfr_clear_inexflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_erangeflag">mpfr_clear_erangeflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_underflow">mpfr_set_underflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_overflow">mpfr_set_overflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_divby0">mpfr_set_divby0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_nanflag">mpfr_set_nanflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_inexflag">mpfr_set_inexflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_erangeflag">mpfr_set_erangeflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_flags">mpfr_clear_flags</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_underflow_p">mpfr_underflow_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_overflow_p">mpfr_overflow_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_divby0_p">mpfr_divby0_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nanflag_p">mpfr_nanflag_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inexflag_p">mpfr_inexflag_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erangeflag_p">mpfr_erangeflag_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Clear flag and assert that flag is clear.
            mpfr_lib.mpfr_clear_nanflag();
            Assert.IsTrue(mpfr_lib.mpfr_nanflag_p() == 0);
            </code> 
            <code language="VB.NET">
            ' Clear flag and assert that flag is clear.
            mpfr_lib.mpfr_clear_nanflag()
            Assert.IsTrue(mpfr_lib.mpfr_nanflag_p() = 0)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_inexflag">
            <summary>
            Clear (lower) the inexact flag. 
            </summary>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_underflow">mpfr_clear_underflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_overflow">mpfr_clear_overflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_divby0">mpfr_clear_divby0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_nanflag">mpfr_clear_nanflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_erangeflag">mpfr_clear_erangeflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_underflow">mpfr_set_underflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_overflow">mpfr_set_overflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_divby0">mpfr_set_divby0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_nanflag">mpfr_set_nanflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_inexflag">mpfr_set_inexflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_erangeflag">mpfr_set_erangeflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_flags">mpfr_clear_flags</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_underflow_p">mpfr_underflow_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_overflow_p">mpfr_overflow_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_divby0_p">mpfr_divby0_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nanflag_p">mpfr_nanflag_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inexflag_p">mpfr_inexflag_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erangeflag_p">mpfr_erangeflag_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Clear flag and assert that flag is clear.
            mpfr_lib.mpfr_clear_inexflag();
            Assert.IsTrue(mpfr_lib.mpfr_inexflag_p() == 0);
            </code> 
            <code language="VB.NET">
            ' Clear flag and assert that flag is clear.
            mpfr_lib.mpfr_clear_inexflag()
            Assert.IsTrue(mpfr_lib.mpfr_inexflag_p() = 0)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_erangeflag">
            <summary>
            Clear (lower) the erange flag. 
            </summary>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_underflow">mpfr_clear_underflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_overflow">mpfr_clear_overflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_divby0">mpfr_clear_divby0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_nanflag">mpfr_clear_nanflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_inexflag">mpfr_clear_inexflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_underflow">mpfr_set_underflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_overflow">mpfr_set_overflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_divby0">mpfr_set_divby0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_nanflag">mpfr_set_nanflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_inexflag">mpfr_set_inexflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_erangeflag">mpfr_set_erangeflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_flags">mpfr_clear_flags</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_underflow_p">mpfr_underflow_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_overflow_p">mpfr_overflow_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_divby0_p">mpfr_divby0_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nanflag_p">mpfr_nanflag_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inexflag_p">mpfr_inexflag_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erangeflag_p">mpfr_erangeflag_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Clear flag and assert that flag is clear.
            mpfr_lib.mpfr_clear_erangeflag();
            Assert.IsTrue(mpfr_lib.mpfr_erangeflag_p() == 0);
            </code> 
            <code language="VB.NET">
            ' Clear flag and assert that flag is clear.
            mpfr_lib.mpfr_clear_erangeflag()
            Assert.IsTrue(mpfr_lib.mpfr_erangeflag_p() = 0)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_underflow">
            <summary>
            Set (raised) the underflow flag.
            </summary>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_underflow">mpfr_clear_underflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_overflow">mpfr_clear_overflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_divby0">mpfr_clear_divby0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_nanflag">mpfr_clear_nanflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_inexflag">mpfr_clear_inexflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_erangeflag">mpfr_clear_erangeflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_overflow">mpfr_set_overflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_divby0">mpfr_set_divby0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_nanflag">mpfr_set_nanflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_inexflag">mpfr_set_inexflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_erangeflag">mpfr_set_erangeflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_flags">mpfr_clear_flags</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_underflow_p">mpfr_underflow_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_overflow_p">mpfr_overflow_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_divby0_p">mpfr_divby0_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nanflag_p">mpfr_nanflag_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inexflag_p">mpfr_inexflag_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erangeflag_p">mpfr_erangeflag_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Set flag and assert that flag is set.
            mpfr_lib.mpfr_set_underflow();
            Assert.IsTrue(mpfr_lib.mpfr_underflow_p() != 0);
            </code> 
            <code language="VB.NET">
            ' Set flag and assert that flag is set.
            mpfr_lib.mpfr_set_underflow()
            Assert.IsTrue(mpfr_lib.mpfr_underflow_p() &lt;&gt; 0)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_overflow">
            <summary>
            Set (raised) the overflow flag.
            </summary>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_underflow">mpfr_clear_underflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_overflow">mpfr_clear_overflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_divby0">mpfr_clear_divby0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_nanflag">mpfr_clear_nanflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_inexflag">mpfr_clear_inexflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_erangeflag">mpfr_clear_erangeflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_underflow">mpfr_set_underflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_divby0">mpfr_set_divby0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_nanflag">mpfr_set_nanflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_inexflag">mpfr_set_inexflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_erangeflag">mpfr_set_erangeflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_flags">mpfr_clear_flags</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_underflow_p">mpfr_underflow_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_overflow_p">mpfr_overflow_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_divby0_p">mpfr_divby0_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nanflag_p">mpfr_nanflag_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inexflag_p">mpfr_inexflag_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erangeflag_p">mpfr_erangeflag_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Set flag and assert that flag is set.
            mpfr_lib.mpfr_set_overflow();
            Assert.IsTrue(mpfr_lib.mpfr_overflow_p() != 0);
            </code> 
            <code language="VB.NET">
            ' Set flag and assert that flag is set.
            mpfr_lib.mpfr_set_overflow()
            Assert.IsTrue(mpfr_lib.mpfr_overflow_p() &lt;&gt; 0)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_divby0">
            <summary>
            Set (raised) the divide-by-zero flag.
            </summary>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_underflow">mpfr_clear_underflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_overflow">mpfr_clear_overflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_divby0">mpfr_clear_divby0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_nanflag">mpfr_clear_nanflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_inexflag">mpfr_clear_inexflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_erangeflag">mpfr_clear_erangeflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_underflow">mpfr_set_underflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_overflow">mpfr_set_overflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_nanflag">mpfr_set_nanflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_inexflag">mpfr_set_inexflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_erangeflag">mpfr_set_erangeflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_flags">mpfr_clear_flags</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_underflow_p">mpfr_underflow_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_overflow_p">mpfr_overflow_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_divby0_p">mpfr_divby0_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nanflag_p">mpfr_nanflag_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inexflag_p">mpfr_inexflag_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erangeflag_p">mpfr_erangeflag_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Set flag and assert that flag is set.
            mpfr_lib.mpfr_set_divby0();
            Assert.IsTrue(mpfr_lib.mpfr_divby0_p() != 0);
            </code> 
            <code language="VB.NET">
            ' Set flag and assert that flag is set.
            mpfr_lib.mpfr_set_divby0()
            Assert.IsTrue(mpfr_lib.mpfr_divby0_p() &lt;&gt; 0)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_nanflag">
            <summary>
            Set (raised) the invalid flag.
            </summary>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_underflow">mpfr_clear_underflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_overflow">mpfr_clear_overflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_divby0">mpfr_clear_divby0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_nanflag">mpfr_clear_nanflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_inexflag">mpfr_clear_inexflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_erangeflag">mpfr_clear_erangeflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_underflow">mpfr_set_underflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_overflow">mpfr_set_overflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_divby0">mpfr_set_divby0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_inexflag">mpfr_set_inexflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_erangeflag">mpfr_set_erangeflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_flags">mpfr_clear_flags</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_underflow_p">mpfr_underflow_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_overflow_p">mpfr_overflow_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_divby0_p">mpfr_divby0_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nanflag_p">mpfr_nanflag_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inexflag_p">mpfr_inexflag_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erangeflag_p">mpfr_erangeflag_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Set flag and assert that flag is set.
            mpfr_lib.mpfr_set_nanflag();
            Assert.IsTrue(mpfr_lib.mpfr_nanflag_p() != 0);
            </code> 
            <code language="VB.NET">
            ' Set flag and assert that flag is set.
            mpfr_lib.mpfr_set_nanflag()
            Assert.IsTrue(mpfr_lib.mpfr_nanflag_p() &lt;&gt; 0)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_inexflag">
            <summary>
            Set (raised) the inexact flag.
            </summary>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_underflow">mpfr_clear_underflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_overflow">mpfr_clear_overflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_divby0">mpfr_clear_divby0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_nanflag">mpfr_clear_nanflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_inexflag">mpfr_clear_inexflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_erangeflag">mpfr_clear_erangeflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_underflow">mpfr_set_underflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_overflow">mpfr_set_overflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_divby0">mpfr_set_divby0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_nanflag">mpfr_set_nanflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_erangeflag">mpfr_set_erangeflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_flags">mpfr_clear_flags</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_underflow_p">mpfr_underflow_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_overflow_p">mpfr_overflow_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_divby0_p">mpfr_divby0_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nanflag_p">mpfr_nanflag_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inexflag_p">mpfr_inexflag_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erangeflag_p">mpfr_erangeflag_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Set flag and assert that flag is set.
            mpfr_lib.mpfr_set_inexflag();
            Assert.IsTrue(mpfr_lib.mpfr_inexflag_p() != 0);
            </code> 
            <code language="VB.NET">
            ' Set flag and assert that flag is set.
            mpfr_lib.mpfr_set_inexflag()
            Assert.IsTrue(mpfr_lib.mpfr_inexflag_p() &lt;&gt; 0)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_erangeflag">
            <summary>
            Set (raised) the erange flag.
            </summary>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_underflow">mpfr_clear_underflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_overflow">mpfr_clear_overflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_divby0">mpfr_clear_divby0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_nanflag">mpfr_clear_nanflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_inexflag">mpfr_clear_inexflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_erangeflag">mpfr_clear_erangeflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_underflow">mpfr_set_underflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_overflow">mpfr_set_overflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_divby0">mpfr_set_divby0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_nanflag">mpfr_set_nanflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_inexflag">mpfr_set_inexflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_flags">mpfr_clear_flags</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_underflow_p">mpfr_underflow_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_overflow_p">mpfr_overflow_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_divby0_p">mpfr_divby0_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nanflag_p">mpfr_nanflag_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inexflag_p">mpfr_inexflag_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erangeflag_p">mpfr_erangeflag_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Set flag and assert that flag is set.
            mpfr_lib.mpfr_set_erangeflag();
            Assert.IsTrue(mpfr_lib.mpfr_erangeflag_p() != 0);
            </code> 
            <code language="VB.NET">
            ' Set flag and assert that flag is set.
            mpfr_lib.mpfr_set_erangeflag()
            Assert.IsTrue(mpfr_lib.mpfr_erangeflag_p() &lt;&gt; 0)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_underflow_p">
            <summary>
            Return the underflow flag, which is non-zero iff the flag is set. 
            </summary>
            <returns>Return the underflow flag, which is non-zero iff the flag is set.</returns>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_underflow">mpfr_clear_underflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_overflow">mpfr_clear_overflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_divby0">mpfr_clear_divby0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_nanflag">mpfr_clear_nanflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_inexflag">mpfr_clear_inexflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_erangeflag">mpfr_clear_erangeflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_underflow">mpfr_set_underflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_overflow">mpfr_set_overflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_divby0">mpfr_set_divby0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_nanflag">mpfr_set_nanflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_inexflag">mpfr_set_inexflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_erangeflag">mpfr_set_erangeflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_flags">mpfr_clear_flags</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_overflow_p">mpfr_overflow_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_divby0_p">mpfr_divby0_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nanflag_p">mpfr_nanflag_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inexflag_p">mpfr_inexflag_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erangeflag_p">mpfr_erangeflag_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Clear flag and assert that flag is clear.
            mpfr_lib.mpfr_clear_underflow();
            Assert.IsTrue(mpfr_lib.mpfr_underflow_p() == 0);
            </code> 
            <code language="VB.NET">
            ' Clear flag and assert that flag is clear.
            mpfr_lib.mpfr_clear_underflow()
            Assert.IsTrue(mpfr_lib.mpfr_underflow_p() = 0)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_overflow_p">
            <summary>
            Return the overflow flag, which is non-zero iff the flag is set. 
            </summary>
            <returns>Return the overflow flag, which is non-zero iff the flag is set.</returns>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_underflow">mpfr_clear_underflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_overflow">mpfr_clear_overflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_divby0">mpfr_clear_divby0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_nanflag">mpfr_clear_nanflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_inexflag">mpfr_clear_inexflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_erangeflag">mpfr_clear_erangeflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_underflow">mpfr_set_underflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_overflow">mpfr_set_overflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_divby0">mpfr_set_divby0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_nanflag">mpfr_set_nanflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_inexflag">mpfr_set_inexflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_erangeflag">mpfr_set_erangeflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_flags">mpfr_clear_flags</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_underflow_p">mpfr_underflow_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_divby0_p">mpfr_divby0_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nanflag_p">mpfr_nanflag_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inexflag_p">mpfr_inexflag_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erangeflag_p">mpfr_erangeflag_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Clear flag and assert that flag is clear.
            mpfr_lib.mpfr_clear_overflow();
            Assert.IsTrue(mpfr_lib.mpfr_overflow_p() == 0);
            </code> 
            <code language="VB.NET">
            ' Clear flag and assert that flag is clear.
            mpfr_lib.mpfr_clear_overflow()
            Assert.IsTrue(mpfr_lib.mpfr_overflow_p() = 0)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_divby0_p">
            <summary>
            Return the divide-by-zero flag, which is non-zero iff the flag is set. 
            </summary>
            <returns>Return the divide-by-zero flag, which is non-zero iff the flag is set.</returns>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_underflow">mpfr_clear_underflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_overflow">mpfr_clear_overflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_divby0">mpfr_clear_divby0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_nanflag">mpfr_clear_nanflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_inexflag">mpfr_clear_inexflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_erangeflag">mpfr_clear_erangeflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_underflow">mpfr_set_underflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_overflow">mpfr_set_overflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_divby0">mpfr_set_divby0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_nanflag">mpfr_set_nanflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_inexflag">mpfr_set_inexflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_erangeflag">mpfr_set_erangeflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_flags">mpfr_clear_flags</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_underflow_p">mpfr_underflow_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_overflow_p">mpfr_overflow_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nanflag_p">mpfr_nanflag_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inexflag_p">mpfr_inexflag_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erangeflag_p">mpfr_erangeflag_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Clear flag and assert that flag is clear.
            mpfr_lib.mpfr_clear_divby0();
            Assert.IsTrue(mpfr_lib.mpfr_divby0_p() == 0);
            </code> 
            <code language="VB.NET">
            ' Clear flag and assert that flag is clear.
            mpfr_lib.mpfr_clear_divby0()
            Assert.IsTrue(mpfr_lib.mpfr_divby0_p() = 0)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_nanflag_p">
            <summary>
            Return the invalid flag, which is non-zero iff the flag is set. 
            </summary>
            <returns>Return the invalid flag, which is non-zero iff the flag is set.</returns>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_underflow">mpfr_clear_underflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_overflow">mpfr_clear_overflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_divby0">mpfr_clear_divby0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_nanflag">mpfr_clear_nanflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_inexflag">mpfr_clear_inexflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_erangeflag">mpfr_clear_erangeflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_underflow">mpfr_set_underflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_overflow">mpfr_set_overflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_divby0">mpfr_set_divby0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_nanflag">mpfr_set_nanflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_inexflag">mpfr_set_inexflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_erangeflag">mpfr_set_erangeflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_flags">mpfr_clear_flags</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_underflow_p">mpfr_underflow_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_overflow_p">mpfr_overflow_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_divby0_p">mpfr_divby0_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inexflag_p">mpfr_inexflag_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erangeflag_p">mpfr_erangeflag_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Clear flag and assert that flag is clear.
            mpfr_lib.mpfr_clear_nanflag();
            Assert.IsTrue(mpfr_lib.mpfr_nanflag_p() == 0);
            </code> 
            <code language="VB.NET">
            ' Clear flag and assert that flag is clear.
            mpfr_lib.mpfr_clear_nanflag()
            Assert.IsTrue(mpfr_lib.mpfr_nanflag_p() = 0)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_inexflag_p">
            <summary>
            Return the inexact flag, which is non-zero iff the flag is set. 
            </summary>
            <returns>Return the inexact flag, which is non-zero iff the flag is set.</returns>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_underflow">mpfr_clear_underflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_overflow">mpfr_clear_overflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_divby0">mpfr_clear_divby0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_nanflag">mpfr_clear_nanflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_inexflag">mpfr_clear_inexflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_erangeflag">mpfr_clear_erangeflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_underflow">mpfr_set_underflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_overflow">mpfr_set_overflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_divby0">mpfr_set_divby0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_nanflag">mpfr_set_nanflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_inexflag">mpfr_set_inexflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_erangeflag">mpfr_set_erangeflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_flags">mpfr_clear_flags</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_underflow_p">mpfr_underflow_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_overflow_p">mpfr_overflow_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_divby0_p">mpfr_divby0_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nanflag_p">mpfr_nanflag_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erangeflag_p">mpfr_erangeflag_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Clear flag and assert that flag is clear.
            mpfr_lib.mpfr_clear_inexflag();
            Assert.IsTrue(mpfr_lib.mpfr_inexflag_p() == 0);
            </code> 
            <code language="VB.NET">
            ' Clear flag and assert that flag is clear.
            mpfr_lib.mpfr_clear_inexflag()
            Assert.IsTrue(mpfr_lib.mpfr_inexflag_p() = 0)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_erangeflag_p">
            <summary>
            Return the erange flag, which is non-zero iff the flag is set. 
            </summary>
            <returns>Return the erange flag, which is non-zero iff the flag is set.</returns>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_underflow">mpfr_clear_underflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_overflow">mpfr_clear_overflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_divby0">mpfr_clear_divby0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_nanflag">mpfr_clear_nanflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_inexflag">mpfr_clear_inexflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_erangeflag">mpfr_clear_erangeflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_underflow">mpfr_set_underflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_overflow">mpfr_set_overflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_divby0">mpfr_set_divby0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_nanflag">mpfr_set_nanflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_inexflag">mpfr_set_inexflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_erangeflag">mpfr_set_erangeflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_flags">mpfr_clear_flags</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_underflow_p">mpfr_underflow_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_overflow_p">mpfr_overflow_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_divby0_p">mpfr_divby0_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nanflag_p">mpfr_nanflag_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inexflag_p">mpfr_inexflag_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Clear flag and assert that flag is clear.
            mpfr_lib.mpfr_clear_erangeflag();
            Assert.IsTrue(mpfr_lib.mpfr_erangeflag_p() == 0);
            </code> 
            <code language="VB.NET">
            ' Clear flag and assert that flag is clear.
            mpfr_lib.mpfr_clear_erangeflag()
            Assert.IsTrue(mpfr_lib.mpfr_erangeflag_p() = 0)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_flags_clear(Math.Mpfr.Native.mpfr_flags_t)">
            <summary>
            Clear (lower) the group of flags specified by <paramref name="mask"/>.
            </summary>
            <param name="mask">The bit flags mask.</param>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_underflow">mpfr_clear_underflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_overflow">mpfr_clear_overflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_divby0">mpfr_clear_divby0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_nanflag">mpfr_clear_nanflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_inexflag">mpfr_clear_inexflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_erangeflag">mpfr_clear_erangeflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_underflow">mpfr_set_underflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_overflow">mpfr_set_overflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_divby0">mpfr_set_divby0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_nanflag">mpfr_set_nanflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_inexflag">mpfr_set_inexflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_erangeflag">mpfr_set_erangeflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_flags">mpfr_clear_flags</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_underflow_p">mpfr_underflow_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_overflow_p">mpfr_overflow_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_divby0_p">mpfr_divby0_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nanflag_p">mpfr_nanflag_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inexflag_p">mpfr_inexflag_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erangeflag_p">mpfr_erangeflag_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_flags_set(Math.Mpfr.Native.mpfr_flags_t)">mpfr_flags_set</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_flags_test(Math.Mpfr.Native.mpfr_flags_t)">mpfr_flags_test</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_flags_save">mpfr_flags_save</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_flags_restore(Math.Mpfr.Native.mpfr_flags_t,Math.Mpfr.Native.mpfr_flags_t)">mpfr_flags_restore</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Clear erange and inexact flags, and assert that they are clear.
            mpfr_lib.mpfr_flags_clear(mpfr_flags_t.MPFR_FLAGS_ERANGE | mpfr_flags_t.MPFR_FLAGS_INEXACT);
            Assert.IsTrue(mpfr_lib.mpfr_erangeflag_p() == 0);
            Assert.IsTrue(mpfr_lib.mpfr_inexflag_p() == 0);
            </code> 
            <code language="VB.NET">
            ' Clear erange and inexact flags, and assert that they are clear.
            mpfr_lib.mpfr_flags_clear(mpfr_flags_t.MPFR_FLAGS_ERANGE Or mpfr_flags_t.MPFR_FLAGS_INEXACT)
            Assert.IsTrue(mpfr_lib.mpfr_erangeflag_p() = 0)
            Assert.IsTrue(mpfr_lib.mpfr_inexflag_p() = 0)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_flags_set(Math.Mpfr.Native.mpfr_flags_t)">
            <summary>
            Set (raise) the group of flags specified by <paramref name="mask"/>.
            </summary>
            <param name="mask">The bit flags mask.</param>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_underflow">mpfr_clear_underflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_overflow">mpfr_clear_overflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_divby0">mpfr_clear_divby0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_nanflag">mpfr_clear_nanflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_inexflag">mpfr_clear_inexflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_erangeflag">mpfr_clear_erangeflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_underflow">mpfr_set_underflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_overflow">mpfr_set_overflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_divby0">mpfr_set_divby0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_nanflag">mpfr_set_nanflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_inexflag">mpfr_set_inexflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_erangeflag">mpfr_set_erangeflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_flags">mpfr_clear_flags</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_underflow_p">mpfr_underflow_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_overflow_p">mpfr_overflow_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_divby0_p">mpfr_divby0_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nanflag_p">mpfr_nanflag_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inexflag_p">mpfr_inexflag_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erangeflag_p">mpfr_erangeflag_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_flags_clear(Math.Mpfr.Native.mpfr_flags_t)">mpfr_flags_clear</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_flags_test(Math.Mpfr.Native.mpfr_flags_t)">mpfr_flags_test</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_flags_save">mpfr_flags_save</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_flags_restore(Math.Mpfr.Native.mpfr_flags_t,Math.Mpfr.Native.mpfr_flags_t)">mpfr_flags_restore</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Set erange and inexact flags, and assert that they are set.
            mpfr_lib.mpfr_flags_set(mpfr_flags_t.MPFR_FLAGS_ERANGE | mpfr_flags_t.MPFR_FLAGS_INEXACT);
            Assert.IsTrue(mpfr_lib.mpfr_erangeflag_p() != 0);
            Assert.IsTrue(mpfr_lib.mpfr_inexflag_p() != 0);
            </code> 
            <code language="VB.NET">
            ' Set erange and inexact flags, and assert that they are set.
            mpfr_lib.mpfr_flags_set(mpfr_flags_t.MPFR_FLAGS_ERANGE Or mpfr_flags_t.MPFR_FLAGS_INEXACT)
            Assert.IsTrue(mpfr_lib.mpfr_erangeflag_p() &lt;&gt; 0)
            Assert.IsTrue(mpfr_lib.mpfr_inexflag_p() &lt;&gt; 0)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_flags_test(Math.Mpfr.Native.mpfr_flags_t)">
            <summary>
            Return the flags specified by <paramref name="mask"/>.
            </summary>
            <param name="mask">The bit flags mask.</param>
            <returns>Return the flags specified by <paramref name="mask"/>.</returns>
            <remarks>
            <para>
            To test whether any flag from <paramref name="mask"/> is set, compare the return value to 0.
            You can also test individual flags by AND’ing the result with the <see cref="T:Math.Mpfr.Native.mpfr_flags_t"/> values. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_underflow">mpfr_clear_underflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_overflow">mpfr_clear_overflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_divby0">mpfr_clear_divby0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_nanflag">mpfr_clear_nanflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_inexflag">mpfr_clear_inexflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_erangeflag">mpfr_clear_erangeflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_underflow">mpfr_set_underflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_overflow">mpfr_set_overflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_divby0">mpfr_set_divby0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_nanflag">mpfr_set_nanflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_inexflag">mpfr_set_inexflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_erangeflag">mpfr_set_erangeflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_flags">mpfr_clear_flags</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_underflow_p">mpfr_underflow_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_overflow_p">mpfr_overflow_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_divby0_p">mpfr_divby0_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nanflag_p">mpfr_nanflag_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inexflag_p">mpfr_inexflag_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erangeflag_p">mpfr_erangeflag_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_flags_clear(Math.Mpfr.Native.mpfr_flags_t)">mpfr_flags_clear</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_flags_set(Math.Mpfr.Native.mpfr_flags_t)">mpfr_flags_set</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_flags_save">mpfr_flags_save</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_flags_restore(Math.Mpfr.Native.mpfr_flags_t,Math.Mpfr.Native.mpfr_flags_t)">mpfr_flags_restore</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Set erange and divby0 flags.
            mpfr_lib.mpfr_flags_set(mpfr_flags_t.MPFR_FLAGS_ERANGE | mpfr_flags_t.MPFR_FLAGS_DIVBY0);
            
            // Get the erange and inexact flags, and assert that their values.
            mpfr_flags_t flags = mpfr_lib.mpfr_flags_test(mpfr_flags_t.MPFR_FLAGS_ERANGE | mpfr_flags_t.MPFR_FLAGS_INEXACT);
            Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_ERANGE) != 0);
            Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_INEXACT) == 0);
            </code> 
            <code language="VB.NET">
            ' Set erange and divby0 flags.
            mpfr_lib.mpfr_flags_set(mpfr_flags_t.MPFR_FLAGS_ERANGE Or mpfr_flags_t.MPFR_FLAGS_DIVBY0)
            
            ' Get the erange and inexact flags, and assert that their values.
            Dim flags As mpfr_flags_t = mpfr_lib.mpfr_flags_test(mpfr_flags_t.MPFR_FLAGS_ERANGE Or mpfr_flags_t.MPFR_FLAGS_INEXACT)
            Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_ERANGE) &lt;&gt; 0)
            Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_INEXACT) = 0)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_flags_save">
            <summary>
            Return all the flags.
            </summary>
            <returns>Return all the flags.</returns>
            <remarks>
            <para>
            It is equivalent to <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_flags_test(Math.Mpfr.Native.mpfr_flags_t)"/>(<see cref="F:Math.Mpfr.Native.mpfr_flags_t.MPFR_FLAGS_ALL"/>).
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_underflow">mpfr_clear_underflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_overflow">mpfr_clear_overflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_divby0">mpfr_clear_divby0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_nanflag">mpfr_clear_nanflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_inexflag">mpfr_clear_inexflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_erangeflag">mpfr_clear_erangeflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_underflow">mpfr_set_underflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_overflow">mpfr_set_overflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_divby0">mpfr_set_divby0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_nanflag">mpfr_set_nanflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_inexflag">mpfr_set_inexflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_erangeflag">mpfr_set_erangeflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_flags">mpfr_clear_flags</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_underflow_p">mpfr_underflow_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_overflow_p">mpfr_overflow_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_divby0_p">mpfr_divby0_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nanflag_p">mpfr_nanflag_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inexflag_p">mpfr_inexflag_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erangeflag_p">mpfr_erangeflag_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_flags_clear(Math.Mpfr.Native.mpfr_flags_t)">mpfr_flags_clear</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_flags_set(Math.Mpfr.Native.mpfr_flags_t)">mpfr_flags_set</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_flags_test(Math.Mpfr.Native.mpfr_flags_t)">mpfr_flags_test</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_flags_restore(Math.Mpfr.Native.mpfr_flags_t,Math.Mpfr.Native.mpfr_flags_t)">mpfr_flags_restore</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Set erange and divby0 flags.
            mpfr_lib.mpfr_flags_set(mpfr_flags_t.MPFR_FLAGS_ERANGE | mpfr_flags_t.MPFR_FLAGS_DIVBY0);
            
            // Get all flags, and assert their values.
            mpfr_flags_t flags = mpfr_lib.mpfr_flags_save();
            Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_DIVBY0) != 0);
            Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_ERANGE) != 0);
            Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_INEXACT) == 0);
            Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_NAN) == 0);
            Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_OVERFLOW) == 0);
            Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_UNDERFLOW) == 0);
            </code> 
            <code language="VB.NET">
            ' Set erange and divby0 flags.
            mpfr_lib.mpfr_flags_set(mpfr_flags_t.MPFR_FLAGS_ERANGE Or mpfr_flags_t.MPFR_FLAGS_DIVBY0)
            
            ' Get all flags, and assert their values.
            Dim flags As mpfr_flags_t = mpfr_lib.mpfr_flags_save()
            Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_DIVBY0) &lt;&gt; 0)
            Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_ERANGE) &lt;&gt; 0)
            Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_INEXACT) = 0)
            Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_NAN) = 0)
            Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_OVERFLOW) = 0)
            Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_UNDERFLOW) = 0)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_flags_restore(Math.Mpfr.Native.mpfr_flags_t,Math.Mpfr.Native.mpfr_flags_t)">
            <summary>
            Restore the flags specified by <paramref name="mask"/> to their state represented in <paramref name="flags"/>.
            </summary>
            <param name="flags">The bit flags.</param>
            <param name="mask">The bit flags mask.</param>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_underflow">mpfr_clear_underflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_overflow">mpfr_clear_overflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_divby0">mpfr_clear_divby0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_nanflag">mpfr_clear_nanflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_inexflag">mpfr_clear_inexflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_erangeflag">mpfr_clear_erangeflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_underflow">mpfr_set_underflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_overflow">mpfr_set_overflow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_divby0">mpfr_set_divby0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_nanflag">mpfr_set_nanflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_inexflag">mpfr_set_inexflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_erangeflag">mpfr_set_erangeflag</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear_flags">mpfr_clear_flags</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_underflow_p">mpfr_underflow_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_overflow_p">mpfr_overflow_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_divby0_p">mpfr_divby0_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nanflag_p">mpfr_nanflag_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inexflag_p">mpfr_inexflag_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erangeflag_p">mpfr_erangeflag_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_flags_clear(Math.Mpfr.Native.mpfr_flags_t)">mpfr_flags_clear</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_flags_set(Math.Mpfr.Native.mpfr_flags_t)">mpfr_flags_set</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_flags_test(Math.Mpfr.Native.mpfr_flags_t)">mpfr_flags_test</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_flags_save">mpfr_flags_save</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Set erange and divby0 flags.
            mpfr_lib.mpfr_flags_restore(mpfr_flags_t.MPFR_FLAGS_ERANGE | mpfr_flags_t.MPFR_FLAGS_DIVBY0, mpfr_flags_t.MPFR_FLAGS_ALL);
            
            // Get all flags, and assert their values.
            mpfr_flags_t flags = mpfr_lib.mpfr_flags_save();
            Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_DIVBY0) != 0);
            Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_ERANGE) != 0);
            Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_INEXACT) == 0);
            Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_NAN) == 0);
            Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_OVERFLOW) == 0);
            Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_UNDERFLOW) == 0);
            </code> 
            <code language="VB.NET">
            ' Set erange and divby0 flags.
            mpfr_lib.mpfr_flags_restore(mpfr_flags_t.MPFR_FLAGS_ERANGE Or mpfr_flags_t.MPFR_FLAGS_DIVBY0, mpfr_flags_t.MPFR_FLAGS_ALL)
            
            ' Get all flags, and assert their values.
            Dim flags As mpfr_flags_t = mpfr_lib.mpfr_flags_save()
            Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_DIVBY0) &lt;&gt; 0)
            Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_ERANGE) &lt;&gt; 0)
            Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_INEXACT) = 0)
            Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_NAN) = 0)
            Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_OVERFLOW) = 0)
            Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_UNDERFLOW) = 0)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_check_range(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Check that <paramref name="x"/> is within the current range of acceptable values.
            </summary>
            <param name="x">The operand floating-point number.</param>
            <param name="t">The input <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">ternary value</a>.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>This function returns zero if the new value of <paramref name="x"/> equals the exact one y, a positive value if that new value is larger than y, and a negative value if it is smaller than y.</returns>
            <remarks>
            <para>
            This function assumes that <paramref name="x"/> is the correctly-rounded value of some real value y in the
            direction <paramref name="rnd"/> and some extended exponent range, and that t is the 
            corresponding <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">ternary value</a>.
            For example, one performed t = <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_log(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_log</see>(<paramref name="x"/>, u, <paramref name="rnd"/>),
            and y is the exact logarithm of u.
            Thus <paramref name="t"/> is negative if <paramref name="x"/> is smaller than y, positive if <paramref name="x"/>
            is larger than y, and zero if <paramref name="x"/> equals y.
            This function modifies <paramref name="x"/> if needed to be in the current range of acceptable values:
            It generates an underflow or an overflow if the exponent of <paramref name="x"/> is outside the current allowed range;
            the value of <paramref name="t"/> may be used to avoid a double rounding.
            This function returns zero if the new value of <paramref name="x"/> equals the exact one y, a positive value if that
            new value is larger than y, and a negative value if it is smaller than y.
            Note that unlike most functions, the new result <paramref name="x"/> is compared to the (unknown) exact one y,
            not the input value <paramref name="x"/>, i.e., the <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">ternary value</a> is propagated. 
            </para>
            <para>
            Note: If <paramref name="x"/> is an infinity and <paramref name="t"/> is different from zero (i.e., if the rounded result is an inexact infinity),
            then the overflow flag is set.
            This is useful because <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_check_range(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_check_range</see> is typically called (at least in MPFR functions) after restoring the flags that could
            have been set due to internal computations. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emin">mpfr_get_emin</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emax">mpfr_get_emax</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_emin(Math.Mpfr.Native.mpfr_exp_t)">mpfr_set_emin</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_emax(Math.Mpfr.Native.mpfr_exp_t)">mpfr_set_emax</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emin_min">mpfr_get_emin_min</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emin_max">mpfr_get_emin_max</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emax_min">mpfr_get_emax_min</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emax_max">mpfr_get_emax_max</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_subnormalize(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_subnormalize</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number x to 0.100146.
            mpfr_t x = new mpfr_t();
            mpfr_lib.mpfr_init2(x, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_d(x, 0.100146, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that return value is -1.
            Assert.IsTrue(mpfr_lib.mpfr_check_range(x, -1, mpfr_rnd_t.MPFR_RNDZ) == -1);
            
            // Release unmanaged memory allocated for x.
            mpfr_lib.mpfr_clear(x);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number x to 0.100146.
            Dim x As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(x, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_d(x, 0.100146, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that return value is -1.
            Assert.IsTrue(mpfr_lib.mpfr_check_range(x, -1, mpfr_rnd_t.MPFR_RNDZ) = -1)
            
            ' Release unmanaged memory allocated for x.
            mpfr_lib.mpfr_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_init2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_prec_t)">
            <summary>
            Initialize <paramref name="x"/>, set its precision to be exactly <paramref name="prec"/> bits and its value to NaN.
            </summary>
            <param name="x">The floating-point number to initialize.</param>
            <param name="prec">The precision of the significand in bits.</param>
            <remarks>
            <para>
            (Warning: the corresponding MPF function initializes to zero instead.)
            </para>
            <para>
            Normally, a variable should be initialized once only or at least be cleared, using <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear(Math.Mpfr.Native.mpfr_t)">mpfr_clear</see>, between initializations.
            To change the precision of a variable which has already been initialized, use <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_prec(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_prec_t)">mpfr_set_prec</see>.
            The precision <paramref name="prec"/> must be an integer between <see cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_PREC_MIN">MPFR_PREC_MIN</see>
            and <see cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_PREC_MAX">MPFR_PREC_MAX</see> (otherwise the behavior is undefined). 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inits2(Math.Mpfr.Native.mpfr_prec_t,Math.Mpfr.Native.mpfr_t[])">mpfr_inits2(mpfr_prec_t, mpfr_t[])</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear(Math.Mpfr.Native.mpfr_t)">mpfr_clear(mpfr_t)</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clears(Math.Mpfr.Native.mpfr_t[])">mpfr_clears(mpfr_t[])</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init(Math.Mpfr.Native.mpfr_t)">mpfr_init(mpfr_t)</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inits(Math.Mpfr.Native.mpfr_t[])">mpfr_inits(mpfr_t[])</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_default_prec(Math.Mpfr.Native.mpfr_prec_t)">mpfr_set_default_prec(mpfr_prec_t)</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_default_prec">mpfr_get_default_prec</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_prec(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_prec_t)">mpfr_set_prec(mpfr_t, mpfr_prec_t)</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_prec(Math.Mpfr.Native.mpfr_t)">mpfr_get_prec(mpfr_t)</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"/>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Initialization_Functions">Initialization Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Initialization-Functions">GNU MPFR - Initialization Functions</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize a new floating-point number x with 64-bit precision.
            mpfr_t x = new mpfr_t();
            mpfr_lib.mpfr_init2(x, 64U);
            
            // Assert that the value of x is NaN, and that its precision is 64 bits.
            Assert.IsTrue(mpfr_lib.mpfr_nan_p(x) != 0);
            uint p = mpfr_lib.mpfr_get_prec(x);
            Assert.IsTrue(mpfr_lib.mpfr_get_prec(x) == 64U);
            
            // Release unmanaged memory allocated for x.
            mpfr_lib.mpfr_clear(x);
            </code> 
            <code language="VB.NET">
            ' Create and initialize a new floating-point number x with 64-bit precision.
            Dim x As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(x, 64U)
            
            ' Assert that the value of x is NaN, and that its precision is 64 bits.
            Assert.IsTrue(mpfr_lib.mpfr_nan_p(x) &lt;&gt; 0)
            Dim p As System.UInt32 =  mpfr_lib.mpfr_get_prec(x)
            Assert.IsTrue(mpfr_lib.mpfr_get_prec(x) = 64U)
            
            ' Release unmanaged memory allocated for x.
            mpfr_lib.mpfr_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_init(Math.Mpfr.Native.mpfr_t)">
            <summary>
            Initialize <paramref name="x"/>, set its precision to the default precision, and set its value to NaN.
            </summary>
            <param name="x">The floating-point number.</param>
            <remarks>
            <para>
            The default precision can be changed by a call to <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_default_prec(Math.Mpfr.Native.mpfr_prec_t)">mpfr_set_default_prec</see>. 
            </para>
            <para>
            Warning!
            In a given program, some other libraries might change the default precision and not restore it.
            Thus it is safer to use <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_prec_t)">mpfr_init2</see>. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_prec_t)">mpfr_init2(mpfr_t, mpfr_prec_t)</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inits2(Math.Mpfr.Native.mpfr_prec_t,Math.Mpfr.Native.mpfr_t[])">mpfr_inits2(mpfr_prec_t, mpfr_t[])</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear(Math.Mpfr.Native.mpfr_t)">mpfr_clear(mpfr_t)</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clears(Math.Mpfr.Native.mpfr_t[])">mpfr_clears(mpfr_t[])</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inits(Math.Mpfr.Native.mpfr_t[])">mpfr_inits(mpfr_t[])</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_default_prec(Math.Mpfr.Native.mpfr_prec_t)">mpfr_set_default_prec(mpfr_prec_t)</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_default_prec">mpfr_get_default_prec</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_prec(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_prec_t)">mpfr_set_prec(mpfr_t, mpfr_prec_t)</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_prec(Math.Mpfr.Native.mpfr_t)">mpfr_get_prec(mpfr_t)</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"/>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Initialization_Functions">Initialization Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Initialization-Functions">GNU MPFR - Initialization Functions</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize a new floating-point number x.
            mpfr_t x = new mpfr_t();
            mpfr_lib.mpfr_init2(x, 64U);
            
            // Assert that the value of x is NaN.
            Assert.IsTrue(mpfr_lib.mpfr_nan_p(x) != 0);
            
            // Release unmanaged memory allocated for x.
            mpfr_lib.mpfr_clear(x);
            </code> 
            <code language="VB.NET">
            ' Create and initialize a new floating-point number x.
            Dim x As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(x, 64U)
            
            ' Assert that the value of x is NaN.
            Assert.IsTrue(mpfr_lib.mpfr_nan_p(x) &lt;&gt; 0)
            
            ' Release unmanaged memory allocated for x.
            mpfr_lib.mpfr_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Initialize <paramref name="rop"/> and set its value from <paramref name="op"/>, rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            The precision of <paramref name="rop"/> will be taken from the active default precision, as set by <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_default_prec(Math.Mpfr.Native.mpfr_prec_t)">mpfr_set_default_prec</see>. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_si(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_d(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_f</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_str(Math.Mpfr.Native.mpfr_t,System.String,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_str</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Combined_Initialization_and_Assignment_Functions">Combined Initialization and Assignment Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Combined-Initialization-and-Assignment-Functions">GNU MPFR - Combined Initialization and Assignment Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 1.
            mpfr_t op = new mpfr_t();
            Assert.IsTrue(mpfr_lib.mpfr_init_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new floating-point number rop to op.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that op is not infinity.
            Assert.IsTrue(mpfr_lib.mpfr_get_si(rop, mpfr_rnd_t.MPFR_RNDN) == 1);
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 1.
            Dim op As mpfr_t = New mpfr_t()
            Assert.IsTrue(mpfr_lib.mpfr_init_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new floating-point number rop to op.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that op is not infinity.
            Assert.IsTrue(mpfr_lib.mpfr_get_si(rop, mpfr_rnd_t.MPFR_RNDN) = 1)
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Initialize <paramref name="rop"/> and set its value from <paramref name="op"/>, rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            The precision of <paramref name="rop"/> will be taken from the active default precision, as set by <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_default_prec(Math.Mpfr.Native.mpfr_prec_t)">mpfr_set_default_prec</see>. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_si(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_d(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_f</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_str(Math.Mpfr.Native.mpfr_t,System.String,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_str</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Combined_Initialization_and_Assignment_Functions">Combined Initialization and Assignment Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Combined-Initialization-and-Assignment-Functions">GNU MPFR - Combined Initialization and Assignment Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number rop to 10.
            mpfr_t rop = new mpfr_t();
            Assert.IsTrue(mpfr_lib.mpfr_init_set_ui(rop, 10U, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that op is not infinity.
            Assert.IsTrue(mpfr_lib.mpfr_get_ui(rop, mpfr_rnd_t.MPFR_RNDN) == 10U);
            
            // Release unmanaged memory allocated for rop.
            mpfr_lib.mpfr_clear(rop);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number rop to 10.
            Dim rop As mpfr_t = New mpfr_t()
            Assert.IsTrue(mpfr_lib.mpfr_init_set_ui(rop, 10U, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that op is not infinity.
            Assert.IsTrue(mpfr_lib.mpfr_get_ui(rop, mpfr_rnd_t.MPFR_RNDN) = 10U)
            
            ' Release unmanaged memory allocated for rop.
            mpfr_lib.mpfr_clear(rop)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_si(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Initialize <paramref name="rop"/> and set its value from <paramref name="op"/>, rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            The precision of <paramref name="rop"/> will be taken from the active default precision, as set by <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_default_prec(Math.Mpfr.Native.mpfr_prec_t)">mpfr_set_default_prec</see>. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_d(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_f</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_str(Math.Mpfr.Native.mpfr_t,System.String,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_str</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Combined_Initialization_and_Assignment_Functions">Combined Initialization and Assignment Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Combined-Initialization-and-Assignment-Functions">GNU MPFR - Combined Initialization and Assignment Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number rop to 10.
            mpfr_t rop = new mpfr_t();
            Assert.IsTrue(mpfr_lib.mpfr_init_set_si(rop, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that op is 10.
            Assert.IsTrue(mpfr_lib.mpfr_get_si(rop, mpfr_rnd_t.MPFR_RNDN) == 10);
            
            // Release unmanaged memory allocated for rop.
            mpfr_lib.mpfr_clear(rop);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number rop to 10.
            Dim rop As mpfr_t = New mpfr_t()
            Assert.IsTrue(mpfr_lib.mpfr_init_set_si(rop, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that op is 10.
            Assert.IsTrue(mpfr_lib.mpfr_get_si(rop, mpfr_rnd_t.MPFR_RNDN) = 10)
            
            ' Release unmanaged memory allocated for rop.
            mpfr_lib.mpfr_clear(rop)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_d(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Initialize <paramref name="rop"/> and set its value from <paramref name="op"/>, rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            The precision of <paramref name="rop"/> will be taken from the active default precision, as set by <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_default_prec(Math.Mpfr.Native.mpfr_prec_t)">mpfr_set_default_prec</see>. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_si(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_f</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_str(Math.Mpfr.Native.mpfr_t,System.String,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_str</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Combined_Initialization_and_Assignment_Functions">Combined Initialization and Assignment Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Combined-Initialization-and-Assignment-Functions">GNU MPFR - Combined Initialization and Assignment Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number rop to 10.0.
            mpfr_t rop = new mpfr_t();
            Assert.IsTrue(mpfr_lib.mpfr_init_set_d(rop, 10.0, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that op is 10.
            Assert.IsTrue(mpfr_lib.mpfr_get_si(rop, mpfr_rnd_t.MPFR_RNDN) == 10);
            
            // Release unmanaged memory allocated for rop.
            mpfr_lib.mpfr_clear(rop);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number rop to 10.0.
            Dim rop As mpfr_t = New mpfr_t()
            Assert.IsTrue(mpfr_lib.mpfr_init_set_d(rop, 10.0, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that op is 10.
            Assert.IsTrue(mpfr_lib.mpfr_get_si(rop, mpfr_rnd_t.MPFR_RNDN) = 10)
            
            ' Release unmanaged memory allocated for rop.
            mpfr_lib.mpfr_clear(rop)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Initialize <paramref name="rop"/> and set its value from <paramref name="op"/>, rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            The precision of <paramref name="rop"/> will be taken from the active default precision, as set by <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_default_prec(Math.Mpfr.Native.mpfr_prec_t)">mpfr_set_default_prec</see>. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_si(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_d(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_f</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_str(Math.Mpfr.Native.mpfr_t,System.String,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_str</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Combined_Initialization_and_Assignment_Functions">Combined Initialization and Assignment Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Combined-Initialization-and-Assignment-Functions">GNU MPFR - Combined Initialization and Assignment Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new integer op to 1.
            mpz_t op = "1";
            
            // Create, initialize, and set a new floating-point number rop to op.
            mpfr_t rop = new mpfr_t();
            Assert.IsTrue(mpfr_lib.mpfr_init_set_z(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that op is not infinity.
            Assert.IsTrue(mpfr_lib.mpfr_get_si(rop, mpfr_rnd_t.MPFR_RNDN) == 1);
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clear(rop);
            gmp_lib.mpz_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new integer op to 1.
            Dim op As mpz_t = "1" 
            
            ' Create, initialize, and set a new floating-point number rop to op.
            Dim rop As mpfr_t = New mpfr_t()
            Assert.IsTrue(mpfr_lib.mpfr_init_set_z(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that op is not infinity.
            Assert.IsTrue(mpfr_lib.mpfr_get_si(rop, mpfr_rnd_t.MPFR_RNDN) = 1)
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clear(rop)
            gmp_lib.mpz_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Initialize <paramref name="rop"/> and set its value from <paramref name="op"/>, rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            The precision of <paramref name="rop"/> will be taken from the active default precision, as set by <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_default_prec(Math.Mpfr.Native.mpfr_prec_t)">mpfr_set_default_prec</see>. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_si(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_d(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_f</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_str(Math.Mpfr.Native.mpfr_t,System.String,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_str</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Combined_Initialization_and_Assignment_Functions">Combined Initialization and Assignment Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Combined-Initialization-and-Assignment-Functions">GNU MPFR - Combined Initialization and Assignment Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new rational op to 1.
            mpq_t op = "1/1";
            
            // Create, initialize, and set a new floating-point number rop to op.
            mpfr_t rop = new mpfr_t();
            Assert.IsTrue(mpfr_lib.mpfr_init_set_q(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that op is 1.
            Assert.IsTrue(mpfr_lib.mpfr_get_si(rop, mpfr_rnd_t.MPFR_RNDN) == 1);
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clear(rop);
            gmp_lib.mpq_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new rational op to 1.
            Dim op As mpq_t = "1/1" 
            
            ' Create, initialize, and set a new floating-point number rop to op.
            Dim rop As mpfr_t = New mpfr_t()
            Assert.IsTrue(mpfr_lib.mpfr_init_set_q(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that op is 1.
            Assert.IsTrue(mpfr_lib.mpfr_get_si(rop, mpfr_rnd_t.MPFR_RNDN) = 1)
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clear(rop)
            gmp_lib.mpq_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Initialize <paramref name="rop"/> and set its value from <paramref name="op"/>, rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            The precision of <paramref name="rop"/> will be taken from the active default precision, as set by <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_default_prec(Math.Mpfr.Native.mpfr_prec_t)">mpfr_set_default_prec</see>. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_si(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_d(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_str(Math.Mpfr.Native.mpfr_t,System.String,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_str</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Combined_Initialization_and_Assignment_Functions">Combined Initialization and Assignment Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Combined-Initialization-and-Assignment-Functions">GNU MPFR - Combined Initialization and Assignment Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"/>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="">GNU MPFR - </a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 1.
            mpf_t op = new mpf_t();
            gmp_lib.mpf_init_set_si(op, 1);
            
            // Create, initialize, and set a new floating-point number rop to op.
            mpfr_t rop = new mpfr_t();
            Assert.IsTrue(mpfr_lib.mpfr_init_set_f(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that op is 1.
            Assert.IsTrue(mpfr_lib.mpfr_get_si(rop, mpfr_rnd_t.MPFR_RNDN) == 1);
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clear(rop);
            gmp_lib.mpf_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 1.
            Dim op As mpf_t = New mpf_t()
            gmp_lib.mpf_init_set_si(op, 1)
            
            ' Create, initialize, and set a new floating-point number rop to op.
            Dim rop As mpfr_t = New mpfr_t()
            Assert.IsTrue(mpfr_lib.mpfr_init_set_f(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that op is 1.
            Assert.IsTrue(mpfr_lib.mpfr_get_si(rop, mpfr_rnd_t.MPFR_RNDN) = 1)
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clear(rop)
            gmp_lib.mpf_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear(Math.Mpfr.Native.mpfr_t)">
            <summary>
            Free the space occupied by the significand of <paramref name="x"/>. 
            </summary>
            <param name="x">The floating-point number.</param>
            <remarks>
            <para>
            Make sure to call this function for all <see cref="T:Math.Mpfr.Native.mpfr_t">mpfr_t</see> variables when you are done with them.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_prec_t)">mpfr_init2(mpfr_t, mpfr_prec_t)</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inits2(Math.Mpfr.Native.mpfr_prec_t,Math.Mpfr.Native.mpfr_t[])">mpfr_inits2(mpfr_prec_t, mpfr_t[])</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clears(Math.Mpfr.Native.mpfr_t[])">mpfr_clears(mpfr_t[])</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init(Math.Mpfr.Native.mpfr_t)">mpfr_init(mpfr_t)</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inits(Math.Mpfr.Native.mpfr_t[])">mpfr_inits(mpfr_t[])</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_default_prec(Math.Mpfr.Native.mpfr_prec_t)">mpfr_set_default_prec(mpfr_prec_t)</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_default_prec">mpfr_get_default_prec</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_prec(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_prec_t)">mpfr_set_prec(mpfr_t, mpfr_prec_t)</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_prec(Math.Mpfr.Native.mpfr_t)">mpfr_get_prec(mpfr_t)</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"/>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Initialization_Functions">Initialization Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Initialization-Functions">GNU MPFR - Initialization Functions</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize a new floating-point number x.
            mpfr_t x = new mpfr_t();
            mpfr_lib.mpfr_init2(x, 64U);
            
            // Assert that the value of x is NaN.
            Assert.IsTrue(mpfr_lib.mpfr_nan_p(x) != 0);
            
            // Release unmanaged memory allocated for x.
             mpfr_lib.mpfr_clear(x);
            </code> 
            <code language="VB.NET">
            ' Create and initialize a new floating-point number x.
            Dim x As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(x, 64U)
            
            ' Assert that the value of x is NaN.
            Assert.IsTrue(mpfr_lib.mpfr_nan_p(x) &lt;&gt; 0)
            
            ' Release unmanaged memory allocated for x.
            mpfr_lib.mpfr_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_inits2(Math.Mpfr.Native.mpfr_prec_t,Math.Mpfr.Native.mpfr_t[])">
            <summary>
            Initialize all the <see cref="T:Math.Mpfr.Native.mpfr_t">mpfr_t</see> variables of the given variable argument <paramref name="x"/>, set their precision to be exactly <paramref name="prec"/> bits and their value to NaN.
            </summary>
            <param name="prec">The precision of the significand in bits.</param>
            <param name="x">List of floating-point numbers to initialize.</param>
            <remarks>
            <para>
            See <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_prec_t)">mpfr_init2</see> for more details.
            The list of floating-pointer numbers ends when it encounters a null pointer (whose type must also be <see cref="T:Math.Mpfr.Native.mpfr_t">mpfr_t</see>).
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_prec_t)">mpfr_init2(mpfr_t, mpfr_prec_t)</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear(Math.Mpfr.Native.mpfr_t)">mpfr_clear(mpfr_t)</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clears(Math.Mpfr.Native.mpfr_t[])">mpfr_clears(mpfr_t[])</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init(Math.Mpfr.Native.mpfr_t)">mpfr_init(mpfr_t)</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inits(Math.Mpfr.Native.mpfr_t[])">mpfr_inits(mpfr_t[])</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_default_prec(Math.Mpfr.Native.mpfr_prec_t)">mpfr_set_default_prec(mpfr_prec_t)</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_default_prec">mpfr_get_default_prec</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_prec(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_prec_t)">mpfr_set_prec(mpfr_t, mpfr_prec_t)</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_prec(Math.Mpfr.Native.mpfr_t)">mpfr_get_prec(mpfr_t)</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"/>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Initialization_Functions">Initialization Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Initialization-Functions">GNU MPFR - Initialization Functions</a></seealso>
            <example>
            <code language="C#">
            // Create new floating-point numbers x1, x2 and x3.
            mpfr_t x1 = new mpfr_t();
            mpfr_t x2 = new mpfr_t();
            mpfr_t x3 = new mpfr_t();
            
            // Initialize the floating-point numbers.
            mpfr_lib.mpfr_inits2(64U, x1, x2, x3, null);
            
            // Assert that their value is 0 and precision is 64 bits.
            Assert.IsTrue(mpfr_lib.mpfr_nan_p(x1) != 0 &amp;&amp; mpfr_lib.mpfr_get_prec(x1) == 64U);
            Assert.IsTrue(mpfr_lib.mpfr_nan_p(x2) != 0 &amp;&amp; mpfr_lib.mpfr_get_prec(x2) == 64U);
            Assert.IsTrue(mpfr_lib.mpfr_nan_p(x3) != 0 &amp;&amp; mpfr_lib.mpfr_get_prec(x3) == 64U);
            
            // Release unmanaged memory allocated for the floating-point numbers.
            mpfr_lib.mpfr_clears(x1, x2, x3, null);
            </code> 
            <code language="VB.NET">
            ' Create new floating-point numbers x1, x2 and x3.
            Dim x1 As mpfr_t = New mpfr_t()
            Dim x2 As mpfr_t = New mpfr_t()
            Dim x3 As mpfr_t = New mpfr_t()
            
            ' Initialize the floating-point numbers.
            mpfr_lib.mpfr_inits2(64U, x1, x2, x3, Nothing)
            
            ' Assert that their value is 0 and precision is 64 bits.
            Assert.IsTrue(mpfr_lib.mpfr_nan_p(x1) &lt;&gt; 0 And mpfr_lib.mpfr_get_prec(x1)  =  64U)
            Assert.IsTrue(mpfr_lib.mpfr_nan_p(x2) &lt;&gt; 0 And mpfr_lib.mpfr_get_prec(x2)  =  64U)
            Assert.IsTrue(mpfr_lib.mpfr_nan_p(x3) &lt;&gt; 0 And mpfr_lib.mpfr_get_prec(x3)  =  64U)
            
            ' Release unmanaged memory allocated for the floating-point numbers.
            mpfr_lib.mpfr_clears(x1, x2, x3, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_inits(Math.Mpfr.Native.mpfr_t[])">
            <summary>
            Initialize all the <see cref="T:Math.Mpfr.Native.mpfr_t">mpfr_t</see> variables of the given list <paramref name="x"/>, set their precision to the default precision and their value to NaN.
            </summary>
            <param name="x">The list of floating-point numbers.</param>
            <remarks>
            <para>
            See <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init(Math.Mpfr.Native.mpfr_t)">mpfr_init</see> for more details.
            The list of floating-point numbers ends when it encounters a null pointer (whose type must also be <see cref="T:Math.Mpfr.Native.mpfr_t">mpfr_t</see>). 
            </para>
            <para>
            Warning!
            In a given program, some other libraries might change the default precision and not restore it.
            Thus it is safer to use <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inits2(Math.Mpfr.Native.mpfr_prec_t,Math.Mpfr.Native.mpfr_t[])">mpfr_inits2</see>. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_prec_t)">mpfr_init2(mpfr_t, mpfr_prec_t)</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inits2(Math.Mpfr.Native.mpfr_prec_t,Math.Mpfr.Native.mpfr_t[])">mpfr_inits2(mpfr_prec_t, mpfr_t[])</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear(Math.Mpfr.Native.mpfr_t)">mpfr_clear(mpfr_t)</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clears(Math.Mpfr.Native.mpfr_t[])">mpfr_clears(mpfr_t[])</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init(Math.Mpfr.Native.mpfr_t)">mpfr_init(mpfr_t)</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_default_prec(Math.Mpfr.Native.mpfr_prec_t)">mpfr_set_default_prec(mpfr_prec_t)</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_default_prec">mpfr_get_default_prec</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_prec(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_prec_t)">mpfr_set_prec(mpfr_t, mpfr_prec_t)</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_prec(Math.Mpfr.Native.mpfr_t)">mpfr_get_prec(mpfr_t)</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"/>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Initialization_Functions">Initialization Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Initialization-Functions">GNU MPFR - Initialization Functions</a></seealso>
            <example>
            <code language="C#">
            // Create new floating-point numbers x1, x2 and x3.
            mpfr_t x1 = new mpfr_t();
            mpfr_t x2 = new mpfr_t();
            mpfr_t x3 = new mpfr_t();
            
            // Initialize the floating-point numbers.
            mpfr_lib.mpfr_inits(x1, x2, x3, null);
            
            // Assert that their value is 0.
            Assert.IsTrue(mpfr_lib.mpfr_nan_p(x1) != 0);
            Assert.IsTrue(mpfr_lib.mpfr_nan_p(x2) != 0);
            Assert.IsTrue(mpfr_lib.mpfr_nan_p(x3) != 0);
            
            // Release unmanaged memory allocated for the floating-point numbers.
            mpfr_lib.mpfr_clears(x1, x2, x3, null);
            </code> 
            <code language="VB.NET">
            ' Create new floating-point numbers x1, x2 and x3.
            Dim x1 As mpfr_t = New mpfr_t()
            Dim x2 As mpfr_t = New mpfr_t()
            Dim x3 As mpfr_t = New mpfr_t()
            
            ' Initialize the floating-point numbers.
            mpfr_lib.mpfr_inits(x1, x2, x3, Nothing)
            
            ' Assert that their value is 0.
            Assert.IsTrue(mpfr_lib.mpfr_nan_p(x1) &lt;&gt; 0)
            Assert.IsTrue(mpfr_lib.mpfr_nan_p(x2) &lt;&gt; 0)
            Assert.IsTrue(mpfr_lib.mpfr_nan_p(x3) &lt;&gt; 0)
            
            ' Release unmanaged memory allocated for the floating-point numbers.
            pfr_lib.mpfr_clears(x1, x2, x3, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_clears(Math.Mpfr.Native.mpfr_t[])">
            <summary>
            Free the space occupied by all the <see cref="T:Math.Mpfr.Native.mpfr_t">mpfr_t</see> variables of the given list <paramref name="x"/>.
            </summary>
            <param name="x">The list of floating-point numbers.</param>
            <remarks>
            <para>
            See <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear(Math.Mpfr.Native.mpfr_t)">mpfr_clear</see> for more details.
            The list of floating-point numbers ends when it encounters a null pointer (whose type must also be <see cref="T:Math.Mpfr.Native.mpfr_t">mpfr_t</see>). 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_prec_t)">mpfr_init2(mpfr_t, mpfr_prec_t)</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inits2(Math.Mpfr.Native.mpfr_prec_t,Math.Mpfr.Native.mpfr_t[])">mpfr_inits2(mpfr_prec_t, mpfr_t[])</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear(Math.Mpfr.Native.mpfr_t)">mpfr_clear(mpfr_t)</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init(Math.Mpfr.Native.mpfr_t)">mpfr_init(mpfr_t)</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inits(Math.Mpfr.Native.mpfr_t[])">mpfr_inits(mpfr_t[])</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_default_prec(Math.Mpfr.Native.mpfr_prec_t)">mpfr_set_default_prec(mpfr_prec_t)</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_default_prec">mpfr_get_default_prec</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_prec(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_prec_t)">mpfr_set_prec(mpfr_t, mpfr_prec_t)</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_prec(Math.Mpfr.Native.mpfr_t)">mpfr_get_prec(mpfr_t)</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"/>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Initialization_Functions">Initialization Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Initialization-Functions">GNU MPFR - Initialization Functions</a></seealso>
            <example>
            <code language="C#">
            // Create new floating-point numbers x1, x2 and x3.
            mpfr_t x1 = new mpfr_t();
            mpfr_t x2 = new mpfr_t();
            mpfr_t x3 = new mpfr_t();
            
            // Initialize the floating-point numbers.
            mpfr_lib.mpfr_inits(x1, x2, x3, null);
            
            // Assert that their value is NaN.
            Assert.IsTrue(mpfr_lib.mpfr_nan_p(x1) != 0);
            Assert.IsTrue(mpfr_lib.mpfr_nan_p(x2) != 0);
            Assert.IsTrue(mpfr_lib.mpfr_nan_p(x3) != 0);
            
            // Release unmanaged memory allocated for the floating-point numbers.
            mpfr_lib.mpfr_clears(x1, x2, x3, null);
            </code> 
            <code language="VB.NET">
            ' Create new floating-point numbers x1, x2 and x3.
            Dim x1 As mpfr_t = New mpfr_t()
            Dim x2 As mpfr_t = New mpfr_t()
            Dim x3 As mpfr_t = New mpfr_t()
            
            ' Initialize the floating-point numbers.
            mpfr_lib.mpfr_inits(x1, x2, x3, Nothing)
            
            ' Assert that their value is NaN.
            Assert.IsTrue(mpfr_lib.mpfr_nan_p(x1) &lt;&gt;  0)
            Assert.IsTrue(mpfr_lib.mpfr_nan_p(x2) &lt;&gt;  0)
            Assert.IsTrue(mpfr_lib.mpfr_nan_p(x3) &lt;&gt;  0)
            
            ' Release unmanaged memory allocated for the floating-point numbers.
            mpfr_lib.mpfr_clears(x1, x2, x3, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_prec_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_prec_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Round <paramref name="x"/> according to <paramref name="rnd"/> with precision <paramref name="prec"/>, which must be an integer between <see cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_PREC_MIN">MPFR_PREC_MIN</see> and <see cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_PREC_MAX">MPFR_PREC_MAX</see> (otherwise the behavior is undefined).
            </summary>
            <param name="x">The operand floating-point number.</param>
            <param name="prec">The precision in bits.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="x"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            If <paramref name="prec"/> is greater or equal to the precision of <paramref name="x"/>, then new space is allocated for the
            significand, and it is filled with zeros.
            Otherwise, the significand is rounded to precision <paramref name="prec"/> with the given direction.
            In both cases, the precision of <paramref name="x"/> is changed to <paramref name="prec"/>. 
            </para>
            <para>
            Here is an example of how to use <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_prec_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_prec_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_prec_round</see> to implement Newton’s algorithm to compute
            the inverse of a, assuming x is already an approximation to n bits: 
            </para>
            <code language="C#">
            mpfr_set_prec (t, 2 * n);
            mpfr_set(t, a, mpfr_rnd_t.MPFR_RNDN);            /* round a to 2n bits */
            mpfr_mul(t, t, x, mpfr_rnd_t.MPFR_RNDN);         /* t is correct to 2n bits */
            mpfr_ui_sub(t, 1, t, mpfr_rnd_t.MPFR_RNDN);      /* high n bits cancel with 1 */
            mpfr_prec_round(t, n, mpfr_rnd_t.MPFR_RNDN);     /* t is correct to n bits */
            mpfr_mul(t, t, x, mpfr_rnd_t.MPFR_RNDN);         /* t is correct to n bits */
            mpfr_prec_round(x, 2 * n, mpfr_rnd_t.MPFR_RNDN); /* exact */
            mpfr_add(x, x, t, mpfr_rnd_t.MPFR_RNDN);         /* x is correct to 2n bits */
            </code> 
            <para>
            Warning! You must not use this function if x was initialized with <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_init_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_kind_t,Math.Mpfr.Native.mpfr_exp_t,System.UInt32,Math.Gmp.Native.void_ptr)">mpfr_custom_init_set</see>
            (see <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Custom-Interface">GNU MPFR - Custom Interface</a>). 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_default_rounding_mode(Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_default_rounding_mode</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_default_rounding_mode">mpfr_get_default_rounding_mode </seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_can_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t,Math.Mpfr.Native.mpfr_rnd_t,Math.Mpfr.Native.mpfr_prec_t)">mpfr_can_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_min_prec(Math.Mpfr.Native.mpfr_t)">mpfr_min_prec</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_print_rnd_mode(Math.Mpfr.Native.mpfr_rnd_t)">mpfr_print_rnd_mode</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Rounding_Related_Functions">Rounding Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Related-Functions">GNU MPFR - Rounding Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize a new floating-point number x with 64-bit precision.
            mpfr_t x = new mpfr_t();
            mpfr_lib.mpfr_init2(x, 64U);
            
            // Round x to precision 128 bits.
            Assert.IsTrue(mpfr_lib.mpfr_prec_round(x, 128U, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that precision has changed to 128 bits.
            Assert.IsTrue(mpfr_lib.mpfr_get_prec(x) == 128U);
            
            // Release unmanaged memory allocated for x.
            mpfr_lib.mpfr_clear(x);
            </code> 
            <code language="VB.NET">
            ' Create and initialize a new floating-point number x with 64-bit precision.
            Dim x As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(x, 64U)
            
            ' Round x to precision 128 bits.
            Assert.IsTrue(mpfr_lib.mpfr_prec_round(x, 128U, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that precision has changed to 128 bits.
            Assert.IsTrue(mpfr_lib.mpfr_get_prec(x) = 128U)
            
            ' Release unmanaged memory allocated for x.
            mpfr_lib.mpfr_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_can_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t,Math.Mpfr.Native.mpfr_rnd_t,Math.Mpfr.Native.mpfr_prec_t)">
            <summary>
            Return non-zero value if one is able to round correctly x to precision <paramref name="prec"/> with the direction <paramref name="rnd2"/>, and 0 otherwise.
            </summary>
            <param name="b">Floating-point number that approximates x.</param>
            <param name="err">The approximation error.</param>
            <param name="rnd1">The rounding direction of the approximation.</param>
            <param name="rnd2">The rounding direction of x.</param>
            <param name="prec">The precision of x.</param>
            <returns>Return non-zero value if one is able to round correctly x to precision <paramref name="prec"/> with the direction <paramref name="rnd2"/>, and 0 otherwise.</returns>
            <remarks>
            <para>
            Assuming <paramref name="b"/> is an approximation of an unknown number x in the direction <paramref name="rnd1"/>
            with error at most two to the power E(<paramref name="b"/>) - <paramref name="err"/> where E(<paramref name="b"/>)
            is the exponent of <paramref name="b"/>, return a non-zero value if one is able to round correctly x to precision
            <paramref name="prec"/> with the direction <paramref name="rnd2"/> assuming an unbounded exponent range,
            and 0 otherwise (including for NaN and Inf).
            In other words, if the error on <paramref name="b"/> is bounded by two to the power k ulps, and <paramref name="b"/>
            has precision <paramref name="prec"/>, you should give err = <paramref name="prec"/> − k. 
            This function <b>does not modify</b> its arguments. 
            </para>
            <para>
            If <paramref name="rnd1"/> is <see cref="F:Math.Mpfr.Native.mpfr_rnd_t.MPFR_RNDN">mpfr_rnd_t.MPFR_RNDN</see> or
            <see cref="F:Math.Mpfr.Native.mpfr_rnd_t.MPFR_RNDF">mpfr_rnd_t.MPFR_RNDF</see>, then the the error is considered to be either positive
            or negative, thus the possible range is twice as large as with a directed rounding for <paramref name="rnd1"/>
            (with the same value of err). 
            </para>
            <para>
            When <paramref name="rnd2"/> is <see cref="F:Math.Mpfr.Native.mpfr_rnd_t.MPFR_RNDF"/>, let rnd3 be the opposite direction
            if <paramref name="rnd1"/> is a directed rounding, and <see cref="F:Math.Mpfr.Native.mpfr_rnd_t.MPFR_RNDN"/> if <paramref name="rnd1"/> is
            <see cref="F:Math.Mpfr.Native.mpfr_rnd_t.MPFR_RNDN"/> or <see cref="F:Math.Mpfr.Native.mpfr_rnd_t.MPFR_RNDF"/>.
            The returned value of <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_can_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t,Math.Mpfr.Native.mpfr_rnd_t,Math.Mpfr.Native.mpfr_prec_t)"/>(<paramref name="b"/>, err, <paramref name="rnd1"/>, <see cref="F:Math.Mpfr.Native.mpfr_rnd_t.MPFR_RNDF"/>, <paramref name="prec"/>) 
            is non-zero iff after the call <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)"/>(y, <paramref name="b"/>, rnd3) with y of
            precision <paramref name="prec"/>, y is guaranteed to be a faithful rounding of x.
            </para>
            <para>
            Note: The <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">ternary value</a> cannot be determined
            in general with this function. However, if it is known that the exact value is not exactly representable in precision
            prec, then one can use the following trick to determine the (non-zero) ternary value in any rounding mode <paramref name="rnd2"/>
            (note that <see cref="F:Math.Mpfr.Native.mpfr_rnd_t.MPFR_RNDZ"/> below can be replaced by any directed rounding mode):
            </para>
            <code language="C#">
            if (mpfr_can_round(b, err, MPFR_RNDN, MPFR_RNDZ, prec + (rnd2 == mpfr_rnd_t.MPFR_RNDN)))
            {
                 /* round the approximation ’b’ to the result ’r’ of ’prec’ bits with rounding mode ’rnd2’ and get the ternary value ’inex’ */
                 inex = mpfr_set(r, b, rnd2);
            }
            </code> 
            <para>
            Indeed, if <paramref name="rnd2"/> is <see cref="F:Math.Mpfr.Native.mpfr_rnd_t.MPFR_RNDN">mpfr_rnd_t.MPFR_RNDN</see>, this will check if one can round to prec + 1 bits with a directed rounding:
            if so, one can surely round to nearest to prec bits, and in addition one can determine the correct <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">ternary value</a>,
            which would not be the case when b is near from a value exactly representable on prec bits. 
            </para>
            <para>
            A detailed example is available in the examples subdirectory, file can_round.c.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_default_rounding_mode(Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_default_rounding_mode</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_default_rounding_mode">mpfr_get_default_rounding_mode </seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_prec_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_prec_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_prec_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_min_prec(Math.Mpfr.Native.mpfr_t)">mpfr_min_prec</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_print_rnd_mode(Math.Mpfr.Native.mpfr_rnd_t)">mpfr_print_rnd_mode</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Rounding_Related_Functions">Rounding Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Related-Functions">GNU MPFR - Rounding Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number x to 0.100146.
            mpfr_t b = new mpfr_t();
            mpfr_lib.mpfr_init2(b, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_d(b, 0.100146, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            mpfr_exp_t err = 63;
            mpfr_rnd_t rnd1 = mpfr_rnd_t.MPFR_RNDN;
            mpfr_rnd_t rnd2 = mpfr_rnd_t.MPFR_RNDN;
            mpfr_prec_t prec = 53;
            
            // Assert that we can round to 53 bits.
            Assert.IsTrue(mpfr_lib.mpfr_can_round(b, err, rnd1, rnd2, prec) != 0);
            
            // Release unmanaged memory allocated for b.
            mpfr_lib.mpfr_clear(b);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number x to 0.100146.
            Dim b As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(b, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_d(b, 0.100146, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            Dim err As mpfr_exp_t = 63
            Dim rnd1 As mpfr_rnd_t = mpfr_rnd_t.MPFR_RNDN
            Dim rnd2 As mpfr_rnd_t = mpfr_rnd_t.MPFR_RNDN
            Dim prec As mpfr_prec_t = 53 
            
            ' Assert that we can round to 53 bits.
            Assert.IsTrue(mpfr_lib.mpfr_can_round(b,err,rnd1,rnd2,prec) &lt;&gt;  0)
            
            ' Release unmanaged memory allocated for b.
            mpfr_lib.mpfr_clear(b)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_min_prec(Math.Mpfr.Native.mpfr_t)">
            <summary>
            Return the minimal number of bits required to store the significand of <paramref name="x"/>, and 0 for special values, including 0.
            </summary>
            <param name="x">The operand floating-point number.</param>
            <returns>Return the minimal number of bits required to store the significand of <paramref name="x"/>, and 0 for special values, including 0.</returns>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_default_rounding_mode(Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_default_rounding_mode</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_default_rounding_mode">mpfr_get_default_rounding_mode </seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_prec_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_prec_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_prec_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_can_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t,Math.Mpfr.Native.mpfr_rnd_t,Math.Mpfr.Native.mpfr_prec_t)">mpfr_can_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_print_rnd_mode(Math.Mpfr.Native.mpfr_rnd_t)">mpfr_print_rnd_mode</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Rounding_Related_Functions">Rounding Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Related-Functions">GNU MPFR - Rounding Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize a new floating-point number x.
            mpfr_t x = new mpfr_t();
            mpfr_lib.mpfr_init2(x, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_d(x, 10.0, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert the minimum precision in bits to store the value of x.
            Assert.IsTrue(mpfr_lib.mpfr_min_prec(x) == 3);
            
            // Release unmanaged memory allocated for x.
            mpfr_lib.mpfr_clear(x);
            </code> 
            <code language="VB.NET">
            ' Create and initialize a new floating-point number x.
            Dim x As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(x, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_d(x, 10.0, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert the minimum precision in bits to store the value of x.
            Assert.IsTrue(mpfr_lib.mpfr_min_prec(x) = 3)
            
            ' Release unmanaged memory allocated for x.
            mpfr_lib.mpfr_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_exp(Math.Mpfr.Native.mpfr_t)">
            <summary>
            Return the exponent of <paramref name="x"/>, assuming that <paramref name="x"/> is a non-zero ordinary number and the significand is considered in [1/2,1).
            </summary>
            <param name="x">The operand floating-point number.</param>
            <returns>Return the exponent of <paramref name="x"/>, assuming that <paramref name="x"/> is a non-zero ordinary number and the significand is considered in [1/2,1).</returns>
            <remarks>
            <para>
            The behavior for NaN, infinity or zero is undefined. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emin">mpfr_get_emin</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emax">mpfr_get_emax</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_emin(Math.Mpfr.Native.mpfr_exp_t)">mpfr_set_emin</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_emax(Math.Mpfr.Native.mpfr_exp_t)">mpfr_set_emax</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emin_min">mpfr_get_emin_min</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emin_max">mpfr_get_emin_max</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emax_min">mpfr_get_emax_min</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emax_max">mpfr_get_emax_max</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number x to 100.
            mpfr_t x = new mpfr_t();
            mpfr_lib.mpfr_init2(x, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 100, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert exp of x.
            Assert.IsTrue(mpfr_lib.mpfr_get_exp(x) == 7);
            
            // Release unmanaged memory allocated for x.
            mpfr_lib.mpfr_clear(x);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number x to 100.
            Dim x As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(x, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 100, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert exp of x.
            Assert.IsTrue(mpfr_lib.mpfr_get_exp(x) = 7)
            
            ' Release unmanaged memory allocated for x.
            mpfr_lib.mpfr_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_exp_t)">
            <summary>
            Set the exponent of <paramref name="x"/> if <paramref name="e"/> is in the current exponent range.
            </summary>
            <param name="x">The operand floating-point number.</param>
            <param name="e">The exponent value.</param>
            <returns>Return 0 (even if <paramref name="x"/> is not a non-zero ordinary number); otherwise, return a non-zero value.</returns>
            <remarks>
            <para>
            Set the exponent of <paramref name="x"/> to <paramref name="e"/> if x is a non-zero ordinary number and <paramref name="e"/>
            is in the current exponent range, and return 0; otherwise, return a non-zero value (<paramref name="x"/> is not changed). 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_exp(Math.Mpfr.Native.mpfr_t)">mpfr_get_exp</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number x to 100.
            mpfr_t x = new mpfr_t();
            mpfr_lib.mpfr_init2(x, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 100, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert exp of x.
            Assert.IsTrue(mpfr_lib.mpfr_get_exp(x) == 7);
            
            // Set exponent of x.
            Assert.IsTrue(mpfr_lib.mpfr_set_exp(x, 5) == 0);
            
            // Assert x and its exp.
            Assert.IsTrue(mpfr_lib.mpfr_get_exp(x) == 5);
            Assert.IsTrue(mpfr_lib.mpfr_get_d(x, mpfr_rnd_t.MPFR_RNDN) == 25.0);
            
            // Release unmanaged memory allocated for x.
            mpfr_lib.mpfr_clear(x);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number x to 100.
            Dim x As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(x, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 100, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert exp of x.
            Assert.IsTrue(mpfr_lib.mpfr_get_exp(x) = 7)
            
            ' Set exponent of x.
            Assert.IsTrue(mpfr_lib.mpfr_set_exp(x, 5) = 0)
            
            ' Assert x and its exp.
            Assert.IsTrue(mpfr_lib.mpfr_get_exp(x) = 5)
            Assert.IsTrue(mpfr_lib.mpfr_get_d(x, mpfr_rnd_t.MPFR_RNDN) = 25.0)
            
            ' Release unmanaged memory allocated for x.
            mpfr_lib.mpfr_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_prec(Math.Mpfr.Native.mpfr_t)">
            <summary>
            Return the precision of <paramref name="x"/>, i.e., the number of bits used to store its significand. 
            </summary>
            <param name="x">The floating-point number.</param>
            <returns>The precision of <paramref name="x"/>, i.e., the number of bits used to store its significand.</returns>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_prec_t)">mpfr_init2(mpfr_t, mpfr_prec_t)</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inits2(Math.Mpfr.Native.mpfr_prec_t,Math.Mpfr.Native.mpfr_t[])">mpfr_inits2(mpfr_prec_t, mpfr_t[])</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear(Math.Mpfr.Native.mpfr_t)">mpfr_clear(mpfr_t)</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clears(Math.Mpfr.Native.mpfr_t[])">mpfr_clears(mpfr_t[])</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init(Math.Mpfr.Native.mpfr_t)">mpfr_init(mpfr_t)</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inits(Math.Mpfr.Native.mpfr_t[])">mpfr_inits(mpfr_t[])</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_default_prec(Math.Mpfr.Native.mpfr_prec_t)">mpfr_set_default_prec(mpfr_prec_t)</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_default_prec">mpfr_get_default_prec</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_prec(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_prec_t)">mpfr_set_prec(mpfr_t, mpfr_prec_t)</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_prec(Math.Mpfr.Native.mpfr_t)">mpfr_get_prec(mpfr_t)</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"/>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Initialization_Functions">Initialization Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Initialization-Functions">GNU MPFR - Initialization Functions</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize a new floating-point number x with 64-bit precision.
            mpfr_t x = new mpfr_t();
            mpfr_lib.mpfr_init2(x, 64U);
            
            // Assert that the value of x is 0.0, and that its precision is 64 bits.
            Assert.IsTrue(mpfr_lib.mpfr_nan_p(x) != 0);
            Assert.IsTrue(mpfr_lib.mpfr_get_prec(x) == 64U);
            
            // Release unmanaged memory allocated for x.
            mpfr_lib.mpfr_clear(x);
            </code> 
            <code language="VB.NET">
            ' Create and initialize a new floating-point number x with 64-bit precision.
            Dim x As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(x, 64U)
            
            ' Assert that the value of x is 0.0, and that its precision is 64 bits.
            Assert.IsTrue(mpfr_lib.mpfr_nan_p(x) &lt;&gt; 0)
            Assert.IsTrue(mpfr_lib.mpfr_get_prec(x) = 64U)
            
            ' Release unmanaged memory allocated for x.
            mpfr_lib.mpfr_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_prec(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_prec_t)">
            <summary>
            Reset the precision of <paramref name="x"/> to be exactly <paramref name="prec"/> bits, and set its value to NaN.
            </summary>
            <param name="x">The floating-point number.</param>
            <param name="prec">The precision of the significand in bits.</param>
            <remarks>
            <para>
            The previous value stored in <paramref name="x"/> is lost.
            It is equivalent to a call to <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear(Math.Mpfr.Native.mpfr_t)">mpfr_clear</see>(x) followed by a call to <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_prec_t)">mpfr_init2</see>(x, prec),
            but more efficient as no allocation is done in case the current allocated space for the significand of
            <paramref name="x"/> is enough.
            The precision <paramref name="prec"/> can be any integer between <see cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_PREC_MIN">MPFR_PREC_MIN</see> and <see cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_PREC_MAX">MPFR_PREC_MAX</see>.
            In case you want to keep the previous value stored in <paramref name="x"/>, use <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_prec_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_prec_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_prec_round</see> instead. 
            </para>
            <para>
            Warning!
            You must not use this function if <paramref name="x"/> was initialized with <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_init_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_kind_t,Math.Mpfr.Native.mpfr_exp_t,System.UInt32,Math.Gmp.Native.void_ptr)">mpfr_custom_init_set</see>
            (see <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Initialization-Functions">GNU MPFR - Custom Interface</a>).
            </para>
            <para>
            The function is useful for changing the precision during a calculation.
            A typical use would be for adjusting the precision gradually in iterative algorithms like Newton-Raphson, making the
            computation precision closely match the actual accurate part of the numbers. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_prec_t)">mpfr_init2(mpfr_t, mpfr_prec_t)</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inits2(Math.Mpfr.Native.mpfr_prec_t,Math.Mpfr.Native.mpfr_t[])">mpfr_inits2(mpfr_prec_t, mpfr_t[])</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear(Math.Mpfr.Native.mpfr_t)">mpfr_clear(mpfr_t)</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clears(Math.Mpfr.Native.mpfr_t[])">mpfr_clears(mpfr_t[])</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init(Math.Mpfr.Native.mpfr_t)">mpfr_init(mpfr_t)</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inits(Math.Mpfr.Native.mpfr_t[])">mpfr_inits(mpfr_t[])</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_default_prec(Math.Mpfr.Native.mpfr_prec_t)">mpfr_set_default_prec(mpfr_prec_t)</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_default_prec">mpfr_get_default_prec</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_prec(Math.Mpfr.Native.mpfr_t)">mpfr_get_prec(mpfr_t)</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"/>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Initialization_Functions">Initialization Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Custom-Interface">GNU MPFR - Initialization Functions</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize a new floating-point number x.
            mpfr_t x = new mpfr_t();
            mpfr_lib.mpfr_init(x);
            
            // Set its precision to 64 bits.
            mpfr_lib.mpfr_set_prec(x, 64U);
            
            // Assert that the value of x is 0.0, and that its precision is 64 bits.
            Assert.IsTrue(mpfr_lib.mpfr_nan_p(x) != 0);
            Assert.IsTrue(mpfr_lib.mpfr_get_prec(x) == 64U);
            
            // Release unmanaged memory allocated for x.
            mpfr_lib.mpfr_clear(x);
            </code> 
            <code language="VB.NET">
            ' Create and initialize a new floating-point number x.
            Dim x As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init(x)
            
            ' Set its precision to 64 bits.
            mpfr_lib.mpfr_set_prec(x, 64U)
            
            ' Assert that the value of x is 0.0, and that its precision is 64 bits.
            Assert.IsTrue(mpfr_lib.mpfr_nan_p(x) &lt;&gt; 0)
            Assert.IsTrue(mpfr_lib.mpfr_get_prec(x) = 64U)
            
            ' Release unmanaged memory allocated for x.
            mpfr_lib.mpfr_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_prec_raw(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_prec_t)">
            <summary>
            Reset the precision of <paramref name="x"/> to be exactly <paramref name="prec"/> bits.
            </summary>
            <param name="x">The operand floating-point number.</param>
            <param name="prec">The precision in bits.</param>
            <remarks>
            <para>
            The only difference with <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_prec(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_prec_t)">mpfr_set_prec</see> is that <paramref name="prec"/> is assumed to be small enough
            so that the significand fits into the current allocated memory space for <paramref name="x"/>.
            Otherwise the behavior is undefined. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_eq(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32)">mpfr_eq</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_reldiff(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_reldiff</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_2exp</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Compatibility_With_MPF">Compatibility With MPF</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Compatibility-with-MPF">GNU MPFR - Compatibility With MPF</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new rational y to 200 / 3.
            mpq_t y = new mpq_t();
            gmp_lib.mpq_init(y);
            gmp_lib.mpq_set_ui(y, 200, 3U);
            
            // Create, initialize, and set a new floating-point number x to y.
            mpfr_t x = new mpfr_t();
            mpfr_lib.mpfr_init2(x, 128U);
            Assert.IsTrue(mpfr_lib.mpfr_set_q(x, y, mpfr_rnd_t.MPFR_RNDN) == -1);
            
            Assert.IsTrue(x.ToString() == "0.6666666666666666666666666666666666666654e2");
            
            // Change precision of x, and set its value to 10000 / 3.
            mpfr_lib.mpfr_set_prec_raw(x, 8U);
            gmp_lib.mpq_set_ui(y, 10000, 3U);
            Assert.IsTrue(mpfr_lib.mpfr_set_q(x, y, mpfr_rnd_t.MPFR_RNDN) == -1);
            
            Assert.IsTrue(x.ToString() == "0.3328e4");
            
            // Restore precision of x.
            mpfr_lib.mpfr_set_prec_raw(x, 128U);
            
            // Release unmanaged memory allocated for x and y.
            mpfr_lib.mpfr_clear(x);
            gmp_lib.mpq_clear(y);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new rational y to 200 / 3.
            Dim y As mpq_t = New mpq_t()
            gmp_lib.mpq_init(y)
            gmp_lib.mpq_set_ui(y, 200, 3U)
            
            ' Create, initialize, and set a new floating-point number x to y.
            Dim x As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(x, 128U)
            Assert.IsTrue(mpfr_lib.mpfr_set_q(x, y, mpfr_rnd_t.MPFR_RNDN) = -1)
            
            Assert.IsTrue(x.ToString() = "0.6666666666666666666666666666666666666654e2")
            
            ' Change precision of x, and set its value to 10000 / 3.
            mpfr_lib.mpfr_set_prec_raw(x, 8U)
            gmp_lib.mpq_set_ui(y, 10000, 3U)
            Assert.IsTrue(mpfr_lib.mpfr_set_q(x, y, mpfr_rnd_t.MPFR_RNDN) = -1)
            
            Assert.IsTrue(x.ToString() = "0.3328e4")
            
            ' Restore precision of x.
            mpfr_lib.mpfr_set_prec_raw(x, 128U)
            
            ' Release unmanaged memory allocated for x and y.
            mpfr_lib.mpfr_clear(x)
            gmp_lib.mpq_clear(y)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_default_prec(Math.Mpfr.Native.mpfr_prec_t)">
            <summary>
            Set the default precision to be exactly <paramref name="prec"/> bits, where <paramref name="prec"/> can be any integer between <see cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_PREC_MIN">MPFR_PREC_MIN</see>and <see cref="F:Math.Mpfr.Native.mpfr_lib.MPFR_PREC_MAX">MPFR_PREC_MAX</see>.
            </summary>
            <param name="prec">The new default precision in bits.</param>
            <remarks>
            <para>
            The precision of a variable means the number of bits used to store its significand.
            All subsequent calls to <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init(Math.Mpfr.Native.mpfr_t)">mpfr_init</see> or <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inits(Math.Mpfr.Native.mpfr_t[])">mpfr_inits</see> will use this precision,
            but previously initialized variables are unaffected.
            The default precision is set to 53 bits initially. 
            </para>
            <para>
            Note: when MPFR is built with the --enable-thread-safe configure option (<see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_buildopt_tls_p">mpfr_buildopt_tls_p</see>), the default precision is local to each thread.
            See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Memory-Handling">GNU MPFR - Memory Handling</a>, for more information. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_prec_t)">mpfr_init2(mpfr_t, mpfr_prec_t)</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inits2(Math.Mpfr.Native.mpfr_prec_t,Math.Mpfr.Native.mpfr_t[])">mpfr_inits2(mpfr_prec_t, mpfr_t[])</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear(Math.Mpfr.Native.mpfr_t)">mpfr_clear(mpfr_t)</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clears(Math.Mpfr.Native.mpfr_t[])">mpfr_clears(mpfr_t[])</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init(Math.Mpfr.Native.mpfr_t)">mpfr_init(mpfr_t)</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inits(Math.Mpfr.Native.mpfr_t[])">mpfr_inits(mpfr_t[])</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_default_prec">mpfr_get_default_prec</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_prec(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_prec_t)">mpfr_set_prec(mpfr_t, mpfr_prec_t)</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_prec(Math.Mpfr.Native.mpfr_t)">mpfr_get_prec(mpfr_t)</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"/>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Initialization_Functions">Initialization Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Initialization-Functions">GNU MPFR - Initialization Functions</a></seealso>
            <example>
            <code language="C#">
            // Set default precision to 128 bits.
            mpfr_lib.mpfr_set_default_prec(128U);
            
            // Assert that the value of x is 128 bits.
            Assert.IsTrue(mpfr_lib.mpfr_get_default_prec() == 128U);
            </code> 
            <code language="VB.NET">
            ' Set default precision to 128 bits.
            mpfr_lib.mpfr_set_default_prec(128U)
            
            ' Assert that the value of x is 128 bits.
            Assert.IsTrue(mpfr_lib.mpfr_get_default_prec() = 128U)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_default_prec">
            <summary>
            Return the current default MPFR precision in bits.
            </summary>
            <returns>The current default MPFR precision in bits.</returns>
            <remarks>
            <para>
            See the documentation of <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_default_prec(Math.Mpfr.Native.mpfr_prec_t)">mpfr_set_default_prec</see>. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_prec_t)">mpfr_init2(mpfr_t, mpfr_prec_t)</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inits2(Math.Mpfr.Native.mpfr_prec_t,Math.Mpfr.Native.mpfr_t[])">mpfr_inits2(mpfr_prec_t, mpfr_t[])</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear(Math.Mpfr.Native.mpfr_t)">mpfr_clear(mpfr_t)</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clears(Math.Mpfr.Native.mpfr_t[])">mpfr_clears(mpfr_t[])</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init(Math.Mpfr.Native.mpfr_t)">mpfr_init(mpfr_t)</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inits(Math.Mpfr.Native.mpfr_t[])">mpfr_inits(mpfr_t[])</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_default_prec(Math.Mpfr.Native.mpfr_prec_t)">mpfr_set_default_prec(mpfr_prec_t)</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_prec(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_prec_t)">mpfr_set_prec(mpfr_t, mpfr_prec_t)</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_prec(Math.Mpfr.Native.mpfr_t)">mpfr_get_prec(mpfr_t)</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"/>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Initialization_Functions">Initialization Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Initialization-Functions">GNU MPFR - Initialization Functions</a></seealso>
            <example>
            <code language="C#">
            // Assert that default precision is 53 bits.
            Assert.IsTrue(mpfr_lib.mpfr_get_default_prec() == 53U);
            </code> 
            <code language="VB.NET">
            ' Assert that default precision is 53 bits.
            Assert.IsTrue(mpfr_lib.mpfr_get_default_prec() = 53U)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_d(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set the value of <paramref name="rop"/> from <paramref name="op"/> rounded toward the given direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            If the system does not support the IEEE 754 standard, <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_d(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_d</see> might not preserve the signed zeros.
            </para>
            <para>
            Note: If you want to store a floating-point constant to a <see cref="T:Math.Mpfr.Native.mpfr_t">mpfr_t</see>, you should use <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_str(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.char_ptr,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_str</see>
            (or one of the MPFR constant functions, such as <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_const_pi(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_const_pi</see> for Pi) instead of <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_d(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_d</see>.
            Otherwise the floating-point constant will be first converted into a reduced-precision (e.g., 53-bit) binary number before MPFR can work with it. 
            </para>
            <para>
            This function assigns new values to already initialized floats
            (see <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Initialization-Functions">GNU MPFR - Initialization Functions</a>).
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_si(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_uj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_uj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_sj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_sj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_flt(Math.Mpfr.Native.mpfr_t,System.Single,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_flt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_f</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_ui_2exp(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_ui_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_si_2exp(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_si_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_uj_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_uj_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_sj_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_sj_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_z_2exp(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_z_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_str(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.char_ptr,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_str</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_nan(Math.Mpfr.Native.mpfr_t)">mpfr_set_nan</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_inf(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_set_inf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_zero(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_set_zero</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_swap(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_swap</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Assignment_Functions">Assignment Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Assignment-Functions">GNU MPFR - Assignment Functions</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize a new floating-point number.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 128U);
            
            // Set rop to -123.0.
            Assert.IsTrue(mpfr_lib.mpfr_set_d(rop, -123.0, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of x is -123.0.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == -123.0);
            
            // Release unmanaged memory allocated for rop.
            mpfr_lib.mpfr_clear(rop);
            </code> 
            <code language="VB.NET">
            ' Create and initialize a new floating-point number.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 128U)
            
            ' Set rop to -123.0.
            Assert.IsTrue(mpfr_lib.mpfr_set_d(rop, -123.0, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of x is -123.0.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = -123.0)
            
            ' Release unmanaged memory allocated for rop.
            mpfr_lib.mpfr_clear(rop)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_flt(Math.Mpfr.Native.mpfr_t,System.Single,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set the value of <paramref name="rop"/> from <paramref name="op"/> rounded toward the given direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            If the system does not support the IEEE 754 standard, <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_flt(Math.Mpfr.Native.mpfr_t,System.Single,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_flt</see> might not preserve the signed zeros.
            </para>
            <para>
            Note: If you want to store a floating-point constant to a <see cref="T:Math.Mpfr.Native.mpfr_t">mpfr_t</see>, you should use <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_str(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.char_ptr,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_str</see>
            (or one of the MPFR constant functions, such as <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_const_pi(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_const_pi</see> for Pi) instead of <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_flt(Math.Mpfr.Native.mpfr_t,System.Single,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_flt</see>.
            Otherwise the floating-point constant will be first converted into a reduced-precision (e.g., 53-bit) binary number before MPFR can work with it. 
            </para>
            <para>
            This function assigns new values to already initialized floats
            (see <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Initialization-Functions">GNU MPFR - Initialization Functions</a>).
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_si(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_uj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_uj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_sj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_sj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_d(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_f</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_ui_2exp(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_ui_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_si_2exp(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_si_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_uj_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_uj_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_sj_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_sj_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_z_2exp(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_z_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_str(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.char_ptr,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_str</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_nan(Math.Mpfr.Native.mpfr_t)">mpfr_set_nan</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_inf(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_set_inf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_zero(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_set_zero</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_swap(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_swap</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Assignment_Functions">Assignment Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Assignment-Functions">GNU MPFR - Assignment Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number rop to 10.0.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_flt(rop, (float)10.0, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that rop is 10.
            Assert.IsTrue(mpfr_lib.mpfr_get_si(rop, mpfr_rnd_t.MPFR_RNDN) == 10);
            
            // Release unmanaged memory allocated for rop.
            mpfr_lib.mpfr_clear(rop);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number rop to 10.0.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_flt(rop, (single)10.0, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that rop is 10.
            Assert.IsTrue(mpfr_lib.mpfr_get_si(rop, mpfr_rnd_t.MPFR_RNDN) = 10)
            
            ' Release unmanaged memory allocated for rop.
            mpfr_lib.mpfr_clear(rop)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set the value of <paramref name="rop"/> from <paramref name="op"/> rounded toward the given direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            Note that the input 0 is converted to +0 regardless of the rounding mode.
            </para>
            <para>
            This function assigns new values to already initialized floats
            (see <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Initialization-Functions">GNU MPFR - Initialization Functions</a>).
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_si(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_uj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_uj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_sj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_sj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_flt(Math.Mpfr.Native.mpfr_t,System.Single,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_flt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_d(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_f</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_ui_2exp(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_ui_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_si_2exp(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_si_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_uj_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_uj_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_sj_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_sj_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_z_2exp(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_z_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_str(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.char_ptr,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_str</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_nan(Math.Mpfr.Native.mpfr_t)">mpfr_set_nan</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_inf(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_set_inf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_zero(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_set_zero</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_swap(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_swap</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Assignment_Functions">Assignment Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Assignment-Functions">GNU MPFR - Assignment Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new integer op to 200.
            mpz_t op = new mpz_t();
            gmp_lib.mpz_init(op);
            gmp_lib.mpz_set_ui(op, 200U);
            
            // Create, initialize, and set a new floating-point number rop to op.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_z(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that rop is 200.
            Assert.IsTrue(rop.ToString() == "0.200000000000000000000e3");
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clear(rop);
            gmp_lib.mpz_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new integer op to 200.
            Dim op As mpz_t = New mpz_t()
            gmp_lib.mpz_init(op)
            gmp_lib.mpz_set_ui(op, 200U)
            
            ' Create, initialize, and set a new floating-point number rop to op.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_z(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that rop is 200.
            Assert.IsTrue(rop.ToString() = "0.200000000000000000000e3")
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clear(rop)
            gmp_lib.mpz_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_z_2exp(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set the value of <paramref name="rop"/> from <paramref name="op"/> multiplied by two to the power <paramref name="e"/>, rounded toward the given direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="e"></param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            Note that the input 0 is converted to +0.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_si(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_uj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_uj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_sj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_sj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_flt(Math.Mpfr.Native.mpfr_t,System.Single,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_flt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_d(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_f</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_ui_2exp(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_ui_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_si_2exp(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_si_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_uj_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_uj_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_sj_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_sj_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_str(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.char_ptr,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_str</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_nan(Math.Mpfr.Native.mpfr_t)">mpfr_set_nan</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_inf(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_set_inf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_zero(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_set_zero</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_swap(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_swap</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Assignment_Functions">Assignment Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Assignment-Functions">GNU MPFR - Assignment Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new integer op to 200.
            mpz_t op = new mpz_t();
            gmp_lib.mpz_init(op);
            gmp_lib.mpz_set_ui(op, 200U);
            
            // Create, initialize, and set a new floating-point number rop to op.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = op * 2^5.
            Assert.IsTrue(mpfr_lib.mpfr_set_z_2exp(rop, op, 5, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that rop is 200.
            Assert.IsTrue(rop.ToString() == "0.640000000000000000000e4");
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clear(rop);
            gmp_lib.mpz_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new integer op to 200.
            Dim op As mpz_t = New mpz_t()
            gmp_lib.mpz_init(op)
            gmp_lib.mpz_set_ui(op, 200U)
            
            ' Create, initialize, and set a new floating-point number rop to op.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = op * 2^5.
            Assert.IsTrue(mpfr_lib.mpfr_set_z_2exp(rop, op, 5, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that rop is 200.
            Assert.IsTrue(rop.ToString() = "0.640000000000000000000e4")
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clear(rop)
            gmp_lib.mpz_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_nan(Math.Mpfr.Native.mpfr_t)">
            <summary>
            Set the variable <paramref name="x"/> to NaN (Not-a-Number).
            </summary>
            <param name="x">The result floating-point number.</param>
            <remarks>
            <para>
            In <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_nan(Math.Mpfr.Native.mpfr_t)">mpfr_set_nan</see>, the sign bit of the result is unspecified. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_si(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_uj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_uj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_sj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_sj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_flt(Math.Mpfr.Native.mpfr_t,System.Single,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_flt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_d(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_f</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_ui_2exp(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_ui_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_si_2exp(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_si_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_uj_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_uj_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_sj_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_sj_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_z_2exp(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_z_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_str(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.char_ptr,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_str</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_inf(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_set_inf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_zero(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_set_zero</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_swap(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_swap</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Assignment_Functions">Assignment Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Assignment-Functions">GNU MPFR - Assignment Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number x to NaN.
            mpfr_t x = new mpfr_t();
            mpfr_lib.mpfr_init2(x, 64U);
            mpfr_lib.mpfr_set_nan(x);
            
            // Assert x is NaN.
            Assert.IsTrue(mpfr_lib.mpfr_nan_p(x) != 0);
            
            // Release unmanaged memory allocated for x.
            mpfr_lib.mpfr_clear(x);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number x to NaN.
            Dim x As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(x, 64U)
            mpfr_lib.mpfr_set_nan(x)
            
            ' Assert x is NaN.
            Assert.IsTrue(mpfr_lib.mpfr_nan_p(x) &lt;&gt; 0)
            
            ' Release unmanaged memory allocated for x.
            mpfr_lib.mpfr_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_inf(Math.Mpfr.Native.mpfr_t,System.Int32)">
            <summary>
            Set the variable <paramref name="x"/> to infinity.
            </summary>
            <param name="x">The result floating-point number.</param>
            <param name="sign">The sign of the result.</param>
            <remarks>
            <para>
            In <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_inf(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_set_inf</see>, <paramref name="x"/> is set to plus infinity iff <paramref name="sign"/> is nonnegative.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_si(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_uj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_uj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_sj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_sj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_flt(Math.Mpfr.Native.mpfr_t,System.Single,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_flt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_d(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_f</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_ui_2exp(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_ui_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_si_2exp(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_si_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_uj_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_uj_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_sj_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_sj_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_z_2exp(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_z_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_str(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.char_ptr,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_str</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_nan(Math.Mpfr.Native.mpfr_t)">mpfr_set_nan</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_zero(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_set_zero</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_swap(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_swap</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Assignment_Functions">Assignment Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Assignment-Functions">GNU MPFR - Assignment Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number x to -infinity.
            mpfr_t x = new mpfr_t();
            mpfr_lib.mpfr_init2(x, 64U);
            mpfr_lib.mpfr_set_inf(x, -1);
            
            // Assert x is infinity.
            Assert.IsTrue(mpfr_lib.mpfr_inf_p(x) != 0);
            
            // Release unmanaged memory allocated for x.
            mpfr_lib.mpfr_clear(x);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number x to -infinity.
            Dim x As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(x, 64U)
            mpfr_lib.mpfr_set_inf(x, -1)
            
            ' Assert x is infinity.
            Assert.IsTrue(mpfr_lib.mpfr_inf_p(x) &lt;&gt; 0)
            
            ' Release unmanaged memory allocated for x.
            mpfr_lib.mpfr_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_zero(Math.Mpfr.Native.mpfr_t,System.Int32)">
            <summary>
            Set the variable <paramref name="x"/> to zero.
            </summary>
            <param name="x">The result floating-point number.</param>
            <param name="sign">The sign of the result.</param>
            <remarks>
            <para>
            In<see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_zero(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_set_zero</see>, <paramref name="x"/> is set to plus zero iff <paramref name="sign"/> is nonnegative.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_si(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_uj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_uj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_sj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_sj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_flt(Math.Mpfr.Native.mpfr_t,System.Single,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_flt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_d(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_f</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_ui_2exp(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_ui_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_si_2exp(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_si_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_uj_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_uj_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_sj_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_sj_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_z_2exp(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_z_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_str(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.char_ptr,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_str</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_nan(Math.Mpfr.Native.mpfr_t)">mpfr_set_nan</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_inf(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_set_inf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_swap(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_swap</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Assignment_Functions">Assignment Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Assignment-Functions">GNU MPFR - Assignment Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number x to +0.
            mpfr_t x = new mpfr_t();
            mpfr_lib.mpfr_init2(x, 64U);
            mpfr_lib.mpfr_set_zero(x, 1);
            
            // Assert x is 0.
            Assert.IsTrue(mpfr_lib.mpfr_zero_p(x) != 0);
            
            // Release unmanaged memory allocated for x.
            mpfr_lib.mpfr_clear(x);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number x to +0.
            Dim x As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(x, 64U)
            mpfr_lib.mpfr_set_zero(x, 1)
            
            ' Assert x is 0.
            Assert.IsTrue(mpfr_lib.mpfr_zero_p(x) &lt;&gt; 0)
            
            ' Release unmanaged memory allocated for x.
            mpfr_lib.mpfr_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set the value of <paramref name="rop"/> from <paramref name="op"/> rounded toward the given direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            Note that the input 0 is converted to +0 regardless of the rounding mode.
            </para>
            <para>
            This function assigns new values to already initialized floats
            (see <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Initialization-Functions">GNU MPFR - Initialization Functions</a>).
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_si(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_uj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_uj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_sj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_sj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_flt(Math.Mpfr.Native.mpfr_t,System.Single,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_flt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_d(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_ui_2exp(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_ui_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_si_2exp(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_si_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_uj_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_uj_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_sj_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_sj_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_z_2exp(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_z_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_str(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.char_ptr,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_str</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_nan(Math.Mpfr.Native.mpfr_t)">mpfr_set_nan</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_inf(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_set_inf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_zero(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_set_zero</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_swap(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_swap</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Assignment_Functions">Assignment Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Assignment-Functions">GNU MPFR - Assignment Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 1.
            mpf_t op = new mpf_t();
            gmp_lib.mpf_init_set_si(op, 1);
            
            // Create and initialize new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = op.
            Assert.IsTrue(mpfr_lib.mpfr_set_f(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that rop is 1.
            Assert.IsTrue(mpfr_lib.mpfr_get_si(rop, mpfr_rnd_t.MPFR_RNDN) == 1);
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clear(rop);
            gmp_lib.mpf_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 1.
            Dim op As mpf_t = New mpf_t()
            gmp_lib.mpf_init_set_si(op, 1)
            
            ' Create and initialize new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = op.
            Assert.IsTrue(mpfr_lib.mpfr_set_f(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that rop is 1.
            Assert.IsTrue(mpfr_lib.mpfr_get_si(rop, mpfr_rnd_t.MPFR_RNDN) = 1)
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clear(rop)
            gmp_lib.mpf_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_f(Math.Gmp.Native.mpf_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Convert <paramref name="op"/> to a <a href="https://machinecognitis.github.io/Math.Gmp.Native/html/37c88d6c-8d02-2330-ad77-f20fb73d1677.htm">mpf_t</a>, after rounding it with respect to <paramref name="rnd"/>. 
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            The erange flag is set if <paramref name="op"/> is NaN or an infinity, which do not exist in MPF.
            If <paramref name="op"/> is NaN, then <paramref name="rop"/> is undefined.
            If <paramref name="op"/> is +Inf (resp. -Inf), then <paramref name="rop"/> is set to the maximum (resp. minimum) value in the precision of the MPF number;
            if a future MPF version supports infinities, this behavior will be considered incorrect and will change (portable programs should assume that <paramref name="rop"/>
            is set either to this finite number or to an infinite number).
            Note that since MPFR currently has the same exponent type as MPF (but not with the same radix), the range of values is much larger in MPF than in MPFR, so that an
            overflow or underflow is not possible. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_flt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_flt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_sj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_sj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_uj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_uj</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_d_2exp"/>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_frexp"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_z_2exp(Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_t)">mpfr_get_z_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_z(Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_q(Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_t)">mpfr_get_q</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_str"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_str(Math.Gmp.Native.char_ptr)">mpfr_free_str</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Conversion_Functions">Conversion Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Conversion-Functions">GNU MPFR - Conversion Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 10.4.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpf_t rop = new mpf_t();
            gmp_lib.mpf_init(rop);
            
            // Set rop = op.
            Assert.IsTrue(mpfr_lib.mpfr_get_f(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is 10.4.
            Assert.IsTrue(gmp_lib.mpf_get_d(rop) == 10.4);
            
            // Release unmanaged memory allocated for rop and op.
            gmp_lib.mpf_clear(rop);
            mpfr_lib.mpfr_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 10.4.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpf_t = New mpf_t()
            gmp_lib.mpf_init(rop)
            
            ' Set rop = op.
            Assert.IsTrue(mpfr_lib.mpfr_get_f(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is 10.4.
            Assert.IsTrue(gmp_lib.mpf_get_d(rop) = 10.4)
            
            ' Release unmanaged memory allocated for rop and op.
            gmp_lib.mpf_clear(rop)
            mpfr_lib.mpfr_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_si(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set the value of <paramref name="rop"/> from <paramref name="op"/> rounded toward the given direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            Note that the input 0 is converted to +0 regardless of the rounding mode.
            </para>
            <para>
            This function assigns new values to already initialized floats
            (see <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Initialization-Functions">GNU MPFR - Initialization Functions</a>).
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_uj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_uj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_sj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_sj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_flt(Math.Mpfr.Native.mpfr_t,System.Single,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_flt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_d(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_f</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_ui_2exp(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_ui_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_si_2exp(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_si_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_uj_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_uj_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_sj_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_sj_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_z_2exp(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_z_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_str(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.char_ptr,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_str</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_nan(Math.Mpfr.Native.mpfr_t)">mpfr_set_nan</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_inf(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_set_inf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_zero(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_set_zero</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_swap(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_swap</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Assignment_Functions">Assignment Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Assignment-Functions">GNU MPFR - Assignment Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number rop to 10.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(rop, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that op is 10.
            Assert.IsTrue(mpfr_lib.mpfr_get_si(rop, mpfr_rnd_t.MPFR_RNDN) == 10);
            
            // Release unmanaged memory allocated for rop.
            mpfr_lib.mpfr_clear(rop);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number rop to 10.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(rop, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that op is 10.
            Assert.IsTrue(mpfr_lib.mpfr_get_si(rop, mpfr_rnd_t.MPFR_RNDN) = 10)
            
            ' Release unmanaged memory allocated for rop.
            mpfr_lib.mpfr_clear(rop)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set the value of <paramref name="rop"/> from <paramref name="op"/> rounded toward the given direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            Note that the input 0 is converted to +0 regardless of the rounding mode.
            </para>
            <para>
            This function assigns new values to already initialized floats
            (see <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Initialization-Functions">GNU MPFR - Initialization Functions</a>).
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_si(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_uj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_uj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_sj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_sj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_flt(Math.Mpfr.Native.mpfr_t,System.Single,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_flt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_d(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_f</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_ui_2exp(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_ui_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_si_2exp(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_si_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_uj_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_uj_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_sj_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_sj_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_z_2exp(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_z_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_str(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.char_ptr,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_str</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_nan(Math.Mpfr.Native.mpfr_t)">mpfr_set_nan</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_inf(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_set_inf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_zero(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_set_zero</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_swap(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_swap</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Assignment_Functions">Assignment Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Assignment-Functions">GNU MPFR - Assignment Functions</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize a new floating-point number.
            mpfr_t x = new mpfr_t();
            mpfr_lib.mpfr_init2(x, 128U);
            
            // Set x to 100.
            Assert.IsTrue(mpfr_lib.mpfr_set_ui(x, 100U, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of x is 100.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(x, mpfr_rnd_t.MPFR_RNDN) == 100.0);
            
            // Release unmanaged memory allocated for x.
            mpfr_lib.mpfr_clear(x);
            </code> 
            <code language="VB.NET">
            ' Create and initialize a new floating-point number.
            Dim x As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(x, 128U)
            
            ' Set x to 100.
            Assert.IsTrue(mpfr_lib.mpfr_set_ui(x, 100U, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of x is 100.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(x, mpfr_rnd_t.MPFR_RNDN) = 100.0)
            
            ' Release unmanaged memory allocated for x.
            mpfr_lib.mpfr_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_si_2exp(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set the value of <paramref name="rop"/> from <paramref name="op"/> multiplied by two to the power <paramref name="e"/>, rounded toward the given direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="e"></param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            Note that the input 0 is converted to +0.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_si(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_uj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_uj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_sj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_sj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_flt(Math.Mpfr.Native.mpfr_t,System.Single,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_flt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_d(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_f</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_ui_2exp(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_ui_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_uj_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_uj_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_sj_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_sj_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_z_2exp(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_z_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_str(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.char_ptr,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_str</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_nan(Math.Mpfr.Native.mpfr_t)">mpfr_set_nan</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_inf(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_set_inf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_zero(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_set_zero</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_swap(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_swap</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Assignment_Functions">Assignment Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Assignment-Functions">GNU MPFR - Assignment Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number rop to 10.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = 10 * 2^5.
            Assert.IsTrue(mpfr_lib.mpfr_set_si_2exp(rop, 10, 5, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that op is 320.
            Assert.IsTrue(mpfr_lib.mpfr_get_si(rop, mpfr_rnd_t.MPFR_RNDN) == 320);
            
            // Release unmanaged memory allocated for rop.
            mpfr_lib.mpfr_clear(rop);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number rop to 10.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = 10 * 2^5.
            Assert.IsTrue(mpfr_lib.mpfr_set_si_2exp(rop, 10, 5, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that op is 320.
            Assert.IsTrue(mpfr_lib.mpfr_get_si(rop, mpfr_rnd_t.MPFR_RNDN) = 320)
            
            ' Release unmanaged memory allocated for rop.
            mpfr_lib.mpfr_clear(rop)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_ui_2exp(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set the value of <paramref name="rop"/> from <paramref name="op"/> multiplied by two to the power <paramref name="e"/>, rounded toward the given direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="e"></param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            Note that the input 0 is converted to +0.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_si(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_uj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_uj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_sj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_sj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_flt(Math.Mpfr.Native.mpfr_t,System.Single,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_flt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_d(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_f</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_si_2exp(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_si_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_uj_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_uj_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_sj_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_sj_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_z_2exp(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_z_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_str(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.char_ptr,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_str</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_nan(Math.Mpfr.Native.mpfr_t)">mpfr_set_nan</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_inf(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_set_inf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_zero(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_set_zero</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_swap(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_swap</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Assignment_Functions">Assignment Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Assignment-Functions">GNU MPFR - Assignment Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number rop to 10.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = 10 * 2^5.
            Assert.IsTrue(mpfr_lib.mpfr_set_ui_2exp(rop, 10U, 5, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that op is 320.
            Assert.IsTrue(mpfr_lib.mpfr_get_si(rop, mpfr_rnd_t.MPFR_RNDN) == 320);
            
            // Release unmanaged memory allocated for rop.
            mpfr_lib.mpfr_clear(rop);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number rop to 10.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = 10 * 2^5.
            Assert.IsTrue(mpfr_lib.mpfr_set_ui_2exp(rop, 10U, 5, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that op is 320.
            Assert.IsTrue(mpfr_lib.mpfr_get_si(rop, mpfr_rnd_t.MPFR_RNDN) = 320)
            
            ' Release unmanaged memory allocated for rop.
            mpfr_lib.mpfr_clear(rop)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set the value of <paramref name="rop"/> from <paramref name="op"/> rounded toward the given direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            Note that the input 0 is converted to +0 regardless of the rounding mode.
            <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_q</see> might fail if the numerator (or the denominator) can not be represented as a <see cref="T:Math.Mpfr.Native.mpfr_t">mpfr_t</see>. 
            </para>
            <para>
            This function assigns new values to already initialized floats
            (see <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Initialization-Functions">GNU MPFR - Initialization Functions</a>).
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_si(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_uj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_uj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_sj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_sj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_flt(Math.Mpfr.Native.mpfr_t,System.Single,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_flt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_d(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_f</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_ui_2exp(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_ui_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_si_2exp(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_si_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_uj_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_uj_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_sj_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_sj_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_z_2exp(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_z_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_str(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.char_ptr,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_str</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_nan(Math.Mpfr.Native.mpfr_t)">mpfr_set_nan</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_inf(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_set_inf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_zero(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_set_zero</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_swap(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_swap</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Assignment_Functions">Assignment Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Assignment-Functions">GNU MPFR - Assignment Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new rational op to 1.
            mpq_t op = "1/1";
            
            // Create, initialize, and set a new floating-point number rop to op.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_q(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that op is 1.
            Assert.IsTrue(mpfr_lib.mpfr_get_si(rop, mpfr_rnd_t.MPFR_RNDN) == 1);
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clear(rop);
            gmp_lib.mpq_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new rational op to 1.
            Dim op As mpq_t = "1/1" 
            
            ' Create, initialize, and set a new floating-point number rop to op.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_q(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that op is 1.
            Assert.IsTrue(mpfr_lib.mpfr_get_si(rop, mpfr_rnd_t.MPFR_RNDN) = 1)
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clear(rop)
            gmp_lib.mpq_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_str(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.char_ptr,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the value of the string <paramref name="s"/> in base <paramref name="base"/>, rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="s"></param>
            <param name="base"></param>
            <param name="rnd">The rounding direction.</param>
            <returns>Retturn 0 if the entire string up to the final null character is a valid number in base <paramref name="base"/>; otherwise it is -1.</returns>
            <remarks>
            <para>
            See the documentation of <see cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr">O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr</see> for a detailed description of the valid string formats.
            Contrary to <see cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr">O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr</see>,<see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_str(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.char_ptr,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_str</see> requires the whole string to represent a valid floating-point number. 
            </para>
            <para>
            The meaning of the return value differs from other MPFR functions:
            it is 0 if the entire string up to the final null character is a valid number in base <paramref name="base"/>; otherwise it is -1,
            and <paramref name="rop"/> may have changed (users interested in the 
            <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">ternary value</a> should use <see cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr">O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr</see> instead). 
            </para>
            <para>
            Note: it is preferable to use <see cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr">O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr</see> if one wants to distinguish between an infinite <paramref name="rop"/> value
            coming from an infinite <paramref name="s"/> or from an overflow. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_si(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_uj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_uj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_sj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_sj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_flt(Math.Mpfr.Native.mpfr_t,System.Single,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_flt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_d(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_f</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_ui_2exp(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_ui_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_si_2exp(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_si_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_uj_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_uj_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_sj_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_sj_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_z_2exp(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_z_2exp</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_nan(Math.Mpfr.Native.mpfr_t)">mpfr_set_nan</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_inf(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_set_inf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_zero(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_set_zero</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_swap(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_swap</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Assignment_Functions">Assignment Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Assignment-Functions">GNU MPFR - Assignment Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number x to 0.0234.
            mpfr_t x = new mpfr_t();
            mpfr_lib.mpfr_init2(x, 64U);
            char_ptr value = new char_ptr("0.234e-4");
            Assert.IsTrue(mpfr_lib.mpfr_set_str(x, value, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that x is 0.0234.
            Assert.IsTrue(x.ToString() == "0.233999999999999999999e-4");
            
            // Release unmanaged memory allocated for x and value.
            mpfr_lib.mpfr_clear(x);
            gmp_lib.free(value);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number x to 0.0234.
            Dim x As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(x, 64U)
            Dim value As char_ptr = New char_ptr("0.234e-4")
            Assert.IsTrue(mpfr_lib.mpfr_set_str(x, value, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that x is 0.0234.
            Assert.IsTrue(x.ToString() = "0.233999999999999999999e-4")
            
            ' Release unmanaged memory allocated for x and value.
            mpfr_lib.mpfr_clear(x)
            gmp_lib.free(value)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_str(Math.Mpfr.Native.mpfr_t,System.String,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Initialize <paramref name="x"/> and set its value from the string <paramref name="s"/> in base <paramref name="base"/>, rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="x">The result floating-point number.</param>
            <param name="s">String containing a floating-point number.</param>
            <param name="base">The base.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="x"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            See <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_str(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.char_ptr,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_str</see>.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_si(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_d(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_init_set_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_init_set_f</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Combined_Initialization_and_Assignment_Functions">Combined Initialization and Assignment Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Combined-Initialization-and-Assignment-Functions">GNU MPFR - Combined Initialization and Assignment Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number rop to 10.
            mpfr_t x = new mpfr_t();
            Assert.IsTrue(mpfr_lib.mpfr_init_set_str(x, "10.4", 10, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that op is not infinity.
            Assert.IsTrue(mpfr_lib.mpfr_get_si(x, mpfr_rnd_t.MPFR_RNDN) == 10);
            
            // Release unmanaged memory allocated for x.
            mpfr_lib.mpfr_clear(x);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number rop to 10.
            Dim x As mpfr_t = New mpfr_t()
            Assert.IsTrue(mpfr_lib.mpfr_init_set_str(x, "10.4", 10, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that op is not infinity.
            Assert.IsTrue(mpfr_lib.mpfr_get_si(x, mpfr_rnd_t.MPFR_RNDN) = 10)
            
            ' Release unmanaged memory allocated for x.
            mpfr_lib.mpfr_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the absolute value of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            Just changes or adjusts the sign if <paramref name="rop"/> and <paramref name="op"/> are the same variable,
            otherwise a rounding might occur if the precision of <paramref name="rop"/> is less than that of <paramref name="op"/>. 
            </para>
            <para>
            The sign rule also applies to NaN in order to mimic the IEEE 754 negate and abs operations, i.e.,
            for <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)"/>, the sign is reversed, and for <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)"/>, the sign is set
            to positive. But contrary to IEEE 754, the NaN flag is set as usual.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqr(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqr</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cbrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cbrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rootn_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_root(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_neg</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_abs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_dim(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_dim</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to -10.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, -10, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = |op|.
            Assert.IsTrue(mpfr_lib.mpfr_abs(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is 10.
            Assert.IsTrue(mpfr_lib.mpfr_cmp_si(rop, 10) == 0);
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to -10.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, -10, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = |op|.
            Assert.IsTrue(mpfr_lib.mpfr_abs(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is 10.
            Assert.IsTrue(mpfr_lib.mpfr_cmp_si(rop, 10) = 0)
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set the value of <paramref name="rop"/> from <paramref name="op"/> rounded toward the given direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            This function assigns new values to already initialized floats
            (see <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Initialization-Functions">GNU MPFR - Initialization Functions</a>).
            </para>
            <para>
            For <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)"/>, the sign of a NaN is propagated in order to mimic the IEEE 754 copy operation.
            But contrary to IEEE 754, the NaN flag is set as usual.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_si(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_uj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_uj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_sj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_sj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_flt(Math.Mpfr.Native.mpfr_t,System.Single,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_flt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_d(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_f</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_ui_2exp(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_ui_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_si_2exp(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_si_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_uj_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_uj_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_sj_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_sj_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_z_2exp(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_z_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_str(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.char_ptr,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_str</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_nan(Math.Mpfr.Native.mpfr_t)">mpfr_set_nan</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_inf(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_set_inf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_zero(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_set_zero</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_swap(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_swap</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Assignment_Functions">Assignment Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Assignment-Functions">GNU MPFR - Assignment Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number rop to 10.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 128U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(rop, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new floating-point number op to -210.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 128U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, -210, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assign the value of op to rop.
            Assert.IsTrue(mpfr_lib.mpfr_set(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of x is -210.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == -210.0);
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number rop to 10.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 128U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(rop, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new floating-point number op to -210.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 128U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, -210, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assign the value of op to rop.
            Assert.IsTrue(mpfr_lib.mpfr_set(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of x is -210.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = -210.0)
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to -<paramref name="op"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            Just changes or adjusts the sign if <paramref name="rop"/> and <paramref name="op"/> are the same variable,
            otherwise a rounding might occur if the precision of <paramref name="rop"/> is less than that of <paramref name="op"/>. 
            </para>
            <para>
            The sign rule also applies to NaN in order to mimic the IEEE 754 negate and abs operations, i.e.,
            for <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)"/>, the sign is reversed, and for <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)"/>, the sign is set
            to positive. But contrary to IEEE 754, the NaN flag is set as usual.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqr(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqr</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cbrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cbrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rootn_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_root(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_neg</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_abs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_dim(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_dim</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number  to 10.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = -op1.
            Assert.IsTrue(mpfr_lib.mpfr_neg(rop, op1, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of z is -10.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == -10.0);
            
            // Release unmanaged memory allocated for rop and op1.
            mpfr_lib.mpfr_clears(rop, op1, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number  to 10.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = -op1.
            Assert.IsTrue(mpfr_lib.mpfr_neg(rop, op1, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of z is -10.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = -10.0)
            
            ' Release unmanaged memory allocated for rop and op1.
            mpfr_lib.mpfr_clears(rop, op1, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_signbit(Math.Mpfr.Native.mpfr_t)">
            <summary>
            Return a non-zero value iff <paramref name="op"/> has its sign bit set (i.e., if it is negative, -0, or a NaN whose representation has its sign bit set). 
            </summary>
            <param name="op">The operand floating-point number.</param>
            <returns>Return a non-zero value iff <paramref name="op"/> has its sign bit set (i.e., if it is negative, -0, or a NaN whose representation has its sign bit set).</returns>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_setsign(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_setsign</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_copysign(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_copysign</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new integer op to 200.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_init_set_ui(op, 200U, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert sign of op..
            Assert.IsTrue(mpfr_lib.mpfr_signbit(op) == 0);
            
            // Release unmanaged memory allocated for op.
            mpfr_lib.mpfr_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new integer op to 200.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_init_set_ui(op, 200U, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert sign of op..
            Assert.IsTrue(mpfr_lib.mpfr_signbit(op) = 0)
            
            ' Release unmanaged memory allocated for op.
            mpfr_lib.mpfr_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_setsign(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set the value of <paramref name="rop"/> from <paramref name="op"/>, rounded toward the given direction <paramref name="rnd"/>, then set (resp. clear) its sign bit if <paramref name="s"/> is non-zero (resp. zero), even when <paramref name="op"/> is a NaN. 
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="s">The sign bit.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_signbit(Math.Mpfr.Native.mpfr_t)">mpfr_signbit</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_copysign(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_copysign</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new integer op to 200.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_ui(op, 200U, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new floating-point number rop to op.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init(rop);
            
            // Set rop = -op.
            Assert.IsTrue(mpfr_lib.mpfr_setsign(rop, op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that rop is -200.
            Assert.IsTrue(rop.ToString() == "-0.20000000000000000e3");
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new integer op to 200.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_ui(op, 200U, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new floating-point number rop to op.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init(rop)
            
            ' Set rop = -op.
            Assert.IsTrue(mpfr_lib.mpfr_setsign(rop, op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that rop is -200.
            Assert.IsTrue(rop.ToString() = "-0.20000000000000000e3")
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_copysign(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set the value of <paramref name="rop"/> from <paramref name="op1"/>, rounded toward the given direction <paramref name="rnd"/>, then set its sign bit to that of <paramref name="op2"/> (even when <paramref name="op1"/> or <paramref name="op2"/> is a NaN). 
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            This function is equivalent to <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_setsign(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_setsign</see>(<paramref name="rop"/>, <paramref name="op1"/>, <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_signbit(Math.Mpfr.Native.mpfr_t)">mpfr_signbit</see>(<paramref name="op2"/>), <paramref name="rnd"/>).
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_signbit(Math.Mpfr.Native.mpfr_t)">mpfr_signbit</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_setsign(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_setsign</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to 512.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new floating-point number op2 to -5.
            mpfr_t op2 = new mpfr_t();
            mpfr_lib.mpfr_init2(op2, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, -5, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Assert that rop = -512.
            Assert.IsTrue(mpfr_lib.mpfr_copysign(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) == 0);
            Assert.IsTrue(mpfr_lib.mpfr_cmp_si(rop, -512) == 0);
            
            // Release unmanaged memory allocated for rop, op1, and op2.
            mpfr_lib.mpfr_clears(rop, op1, op2, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to 512.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new floating-point number op2 to -5.
            Dim op2 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op2, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, -5, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Assert that rop = -512.
            Assert.IsTrue(mpfr_lib.mpfr_copysign(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) = 0)
            Assert.IsTrue(mpfr_lib.mpfr_cmp_si(rop, -512) = 0)
            
            ' Release unmanaged memory allocated for rop, op1, and op2.
            mpfr_lib.mpfr_clears(rop, op1, op2, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_z_2exp(Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_t)">
            <summary>
            Put the scaled significand of <paramref name="op"/> (regarded as an integer, with the precision of <paramref name="op"/>) into <paramref name="rop"/>, and return the exponent exp (which may be outside the current exponent range) such that <paramref name="op"/> = <paramref name="rop"/> * 2^exp.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <returns>Return the exponent exp (which may be outside the current exponent range) such that <paramref name="op"/> = <paramref name="rop"/> * 2^exp.</returns>
            <remarks>
            <para>
            If <paramref name="op"/> is zero, the minimal exponent emin is returned.
            If <paramref name="op"/> is NaN or an infinity, the erange flag is set, <paramref name="rop"/> is set to 0, and the the minimal exponent emin is returned.
            The returned exponent may be less than the minimal exponent emin of MPFR numbers in the current exponent range;
            in case the exponent is not representable in the <see cref="T:Math.Mpfr.Native.mpfr_exp_t">mpfr_exp_t</see> type, the erange flag is set and the minimal value of the <see cref="T:Math.Mpfr.Native.mpfr_exp_t">mpfr_exp_t</see> type is returned. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_flt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_flt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_sj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_sj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_uj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_uj</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_d_2exp"/>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_frexp"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_z(Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_q(Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_t)">mpfr_get_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_f(Math.Gmp.Native.mpf_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_f</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_str"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_str(Math.Gmp.Native.char_ptr)">mpfr_free_str</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Conversion_Functions">Conversion Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Conversion-Functions">GNU MPFR - Conversion Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 8.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 8, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new integer rop.
            mpz_t rop = new mpz_t();
            gmp_lib.mpz_init(rop);
            
            // Set rop such that op = rop * 2^exp.
            mpfr_exp_t exp = mpfr_lib.mpfr_get_z_2exp(rop, op);
            
            // Assert rop and exp.
            Assert.IsTrue(rop.ToString() == "9223372036854775808" &amp;&amp; exp == -60);
            
            // Release unmanaged memory allocated for rop and op.
            gmp_lib.mpz_clear(rop);
            mpfr_lib.mpfr_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 8.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 8, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new integer rop.
            Dim rop As mpz_t = New mpz_t()
            gmp_lib.mpz_init(rop)
            
            ' Set rop such that op = rop * 2^exp.
            Dim exp As mpfr_exp_t = mpfr_lib.mpfr_get_z_2exp(rop, op) 
            
            ' Assert rop and exp.
            Assert.IsTrue(rop.ToString() = "9223372036854775808" AndAlso exp = -60)
            
            ' Release unmanaged memory allocated for rop and op.
            gmp_lib.mpz_clear(rop)
            mpfr_lib.mpfr_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_flt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Convert <paramref name="op"/> to a float, using the rounding mode <paramref name="rnd"/>.
            </summary>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>The converted floating-point number.</returns>
            <remarks>
            <para>
            If <paramref name="op"/> is NaN, some fixed NaN (either quiet or signaling) or the result of 0.0/0.0 is returned.
            If <paramref name="op"/> is ±Inf, an infinity of the same sign or the result of ±1.0/0.0 is returned.
            If <paramref name="op"/> is zero, the function returns a zero, trying to preserve its sign, if possible.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_sj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_sj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_uj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_uj</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_d_2exp"/>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_frexp"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_z_2exp(Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_t)">mpfr_get_z_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_z(Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_q(Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_t)">mpfr_get_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_f(Math.Gmp.Native.mpf_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_f</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_str"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_str(Math.Gmp.Native.char_ptr)">mpfr_free_str</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Conversion_Functions">Conversion Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Conversion-Functions">GNU MPFR - Conversion Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number to -123.0
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, -123.0, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of op is -123.0.
            Assert.IsTrue(mpfr_lib.mpfr_get_flt(op, mpfr_rnd_t.MPFR_RNDN) == -123.0);
            
            // Release unmanaged memory allocated for x.
            mpfr_lib.mpfr_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number to -123.0
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, -123.0, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of op is -123.0.
            Assert.IsTrue(mpfr_lib.mpfr_get_flt(op, mpfr_rnd_t.MPFR_RNDN) = -123.0)
            
            ' Release unmanaged memory allocated for x.
            mpfr_lib.mpfr_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Convert <paramref name="op"/> to a double, using the rounding mode <paramref name="rnd"/>.
            </summary>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>The converted floating-point number.</returns>
            <remarks>
            <para>
            If <paramref name="op"/> is NaN, some fixed NaN (either quiet or signaling) or the result of 0.0/0.0 is returned.
            If <paramref name="op"/> is ±Inf, an infinity of the same sign or the result of ±1.0/0.0 is returned.
            If <paramref name="op"/> is zero, the function returns a zero, trying to preserve its sign, if possible.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_flt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_flt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_sj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_sj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_uj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_uj</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_d_2exp"/>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_frexp"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_z_2exp(Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_t)">mpfr_get_z_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_z(Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_q(Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_t)">mpfr_get_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_f(Math.Gmp.Native.mpf_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_f</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_str"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_str(Math.Gmp.Native.char_ptr)">mpfr_free_str</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Conversion_Functions">Conversion Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Conversion-Functions">GNU MPFR - Conversion Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number to -123.0
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, -123.0, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of op is -123.0.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(op, mpfr_rnd_t.MPFR_RNDN) == -123.0);
            
            // Release unmanaged memory allocated for x.
            mpfr_lib.mpfr_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number to -123.0
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, -123.0, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of op is -123.0.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(op, mpfr_rnd_t.MPFR_RNDN) = -123.0)
            
            ' Release unmanaged memory allocated for x.
            mpfr_lib.mpfr_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_d_2exp(System.Int32@,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Return d and set <paramref name="exp"/> such that 0.5 &#8804; abs(d) &lt;1 and d * 2^<paramref name="exp"/> = <paramref name="op"/> rounded to double precision, using the given rounding mode. 
            </summary>
            <param name="exp">Pointer to returned exponent.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>The converted floating-point number.</returns>
            <remarks>
            <para>
            If <paramref name="op"/> is zero, then a zero of the same sign (or an unsigned zero, if the implementation does
            not have signed zeros) is returned, and <paramref name="exp"/> is set to 0.
            If <paramref name="op"/> is NaN or an infinity, then the corresponding double precision value is returned,
            and <paramref name="exp"/> is undefined. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_flt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_flt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_sj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_sj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_uj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_uj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_d_2exp(Math.Gmp.Native.ptr{System.Int32},Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_d_2exp(ptr{int}, mpfr_t, mpfr_rnd_t)</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_frexp"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_z(Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_q(Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_t)">mpfr_get_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_f(Math.Gmp.Native.mpf_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_f</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_str"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_str(Math.Gmp.Native.char_ptr)">mpfr_free_str</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Conversion_Functions">Conversion Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Conversion-Functions">GNU MPFR - Conversion Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number to -8.0
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, -8.0, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the absolute value of op is 0.5 * 2^4.
            int exp = 0;
            Assert.IsTrue(mpfr_lib.mpfr_get_d_2exp(ref exp, op, mpfr_rnd_t.MPFR_RNDN) == -0.5);
            Assert.IsTrue(exp == 4);
            
            // Release unmanaged memory allocated for x and exp.
            mpfr_lib.mpfr_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number to -8.0
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, -8.0, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the absolute value of op is 0.5 * 2^4.
            Dim exp As Integer = 0
            Assert.IsTrue(mpfr_lib.mpfr_get_d_2exp( exp,op,mpfr_rnd_t.MPFR_RNDN)  =  -0.5)
            Assert.IsTrue(exp = 4)
            
            ' Release unmanaged memory allocated for x and exp.
            mpfr_lib.mpfr_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_d_2exp(Math.Gmp.Native.ptr{System.Int32},Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Return d and set <paramref name="exp"/> such that 0.5 &#8804; abs(d) &lt;1 and d * 2^<paramref name="exp"/> = <paramref name="op"/> rounded to double precision, using the given rounding mode. 
            </summary>
            <param name="exp">Pointer to returned exponent.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>The converted floating-point number.</returns>
            <remarks>
            <para>
            If <paramref name="op"/> is zero, then a zero of the same sign (or an unsigned zero, if the implementation does
            not have signed zeros) is returned, and <paramref name="exp"/> is set to 0.
            If <paramref name="op"/> is NaN or an infinity, then the corresponding double precision value is returned,
            and <paramref name="exp"/> is undefined. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_flt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_flt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_sj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_sj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_uj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_uj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_d_2exp(System.Int32@,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_d_2exp(ref int, mpfr_t, mpfr_rnd_t)</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_frexp"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_z_2exp(Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_t)">mpfr_get_z_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_z(Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_q(Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_t)">mpfr_get_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_f(Math.Gmp.Native.mpf_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_f</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_str"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_str(Math.Gmp.Native.char_ptr)">mpfr_free_str</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Conversion_Functions">Conversion Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Conversion-Functions">GNU MPFR - Conversion Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number to -8.0
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, -8.0, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the absolute value of op is 0.5 * 2^4.
            ptr&lt;int&gt; exp = new ptr&lt;int&gt;(0);
            Assert.IsTrue(mpfr_lib.mpfr_get_d_2exp(exp, op, mpfr_rnd_t.MPFR_RNDN) == -0.5);
            Assert.IsTrue(exp.Value == 4);
            
            // Release unmanaged memory allocated for x and exp.
            mpfr_lib.mpfr_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number to -8.0
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, -8.0, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the absolute value of op is 0.5 * 2^4.
            Dim exp As ptr(Of int) =  New ptr(Of int)(0)
            Assert.IsTrue(mpfr_lib.mpfr_get_d_2exp(exp, op, mpfr_rnd_t.MPFR_RNDN) = -0.5)
            Assert.IsTrue(exp.Value = 4)
            
            ' Release unmanaged memory allocated for x and exp.
            mpfr_lib.mpfr_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_frexp(Math.Mpfr.Native.mpfr_exp_t@,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="exp"/> and <paramref name="y"/> such that 0.5 &#8804; abs(<paramref name="y"/>) &lt; 1 and <paramref name="y"/> * 2^<paramref name="exp"/> = <paramref name="x"/> rounded to the precision of <paramref name="y"/>, using the given rounding mode.
            </summary>
            <param name="exp">The returned exponent.</param>
            <param name="y">The returned significand.</param>
            <param name="x">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="y"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            If <paramref name="x"/> is zero, then <paramref name="y"/> is set to a zero of the same sign and <paramref name="exp"/> is set to 0.
            If <paramref name="x"/> is NaN or an infinity, then <paramref name="y"/> is set to the same value and <paramref name="exp"/> is undefined.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_flt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_flt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_sj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_sj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_uj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_uj</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_d_2exp"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_frexp(Math.Gmp.Native.ptr{Math.Mpfr.Native.mpfr_exp_t},Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_frexp(ptr{mpfr_exp_t}, mpfr_t, mpfr_t, mpfr_rnd_t)</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_z_2exp(Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_t)">mpfr_get_z_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_z(Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_q(Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_t)">mpfr_get_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_f(Math.Gmp.Native.mpf_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_f</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_str"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_str(Math.Gmp.Native.char_ptr)">mpfr_free_str</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Conversion_Functions">Conversion Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Conversion-Functions">GNU MPFR - Conversion Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number x to 100.
            mpfr_t x = new mpfr_t();
            mpfr_lib.mpfr_init2(x, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 100, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new floating-point number y.
            mpfr_t y = new mpfr_t();
            mpfr_lib.mpfr_init2(y, 64U);
            
            // Initialize exponent.
            mpfr_exp_t exp = 0;
            
            // Find y and exp such that x = y * 2^exp where y in [0.5, 1).
            Assert.IsTrue(mpfr_lib.mpfr_frexp(ref exp, y, x, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert the value of exp and y.
            Assert.IsTrue(y.ToString() == "0.781250000000000000000e0" &amp;&amp; exp == 7);
            
            // Release unmanaged memory allocated for x, and y.
            mpfr_lib.mpfr_clears(x, y, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number x to 100.
            Dim x As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(x, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 100, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new floating-point number y.
            Dim y As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(y, 64U)
            
            ' Initialize exponent.
            Dim exp As mpfr_exp_t = 0 
            
            ' Find y and exp such that x = y * 2^exp where y in [0.5, 1).
            Assert.IsTrue(mpfr_lib.mpfr_frexp( exp,y,x,mpfr_rnd_t.MPFR_RNDN)  =  0)
            
            ' Assert the value of exp and y.
            Assert.IsTrue(y.ToString() = "0.781250000000000000000e0" AndAlso exp = 7)
            
            ' Release unmanaged memory allocated for x, and y.
            mpfr_lib.mpfr_clears(x, y, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_frexp(Math.Gmp.Native.ptr{Math.Mpfr.Native.mpfr_exp_t},Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="exp"/> and <paramref name="y"/> such that 0.5 &#8804; abs(<paramref name="y"/>) &lt; 1 and <paramref name="y"/> * 2^<paramref name="exp"/> = <paramref name="x"/> rounded to the precision of <paramref name="y"/>, using the given rounding mode.
            </summary>
            <param name="exp">The returned exponent.</param>
            <param name="y">The returned significand.</param>
            <param name="x">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="y"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            If <paramref name="x"/> is zero, then <paramref name="y"/> is set to a zero of the same sign and <paramref name="exp"/> is set to 0.
            If <paramref name="x"/> is NaN or an infinity, then <paramref name="y"/> is set to the same value and <paramref name="exp"/> is undefined.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_flt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_flt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_sj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_sj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_uj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_uj</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_d_2exp"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_frexp(Math.Mpfr.Native.mpfr_exp_t@,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_frexp(ref mpfr_exp_t, mpfr_t, mpfr_t, mpfr_rnd_t)</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_z_2exp(Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_t)">mpfr_get_z_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_z(Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_q(Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_t)">mpfr_get_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_f(Math.Gmp.Native.mpf_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_f</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_str"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_str(Math.Gmp.Native.char_ptr)">mpfr_free_str</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Conversion_Functions">Conversion Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Conversion-Functions">GNU MPFR - Conversion Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number x to 100.
            mpfr_t x = new mpfr_t();
            mpfr_lib.mpfr_init2(x, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 100, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new floating-point number y.
            mpfr_t y = new mpfr_t();
            mpfr_lib.mpfr_init2(y, 64U);
            
            // Initialize exponent.
            ptr&lt;mpfr_exp_t&gt; exp = new ptr&lt;mpfr_exp_t&gt;(0);
            
            // Find y and exp such that x = y * 2^exp where y in [0.5, 1).
            Assert.IsTrue(mpfr_lib.mpfr_frexp(exp, y, x, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert the value of exp and y.
            Assert.IsTrue(y.ToString() == "0.781250000000000000000e0" &amp;&amp; exp.Value == 7);
            
            // Release unmanaged memory allocated for x, and y.
            mpfr_lib.mpfr_clears(x, y, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number x to 100.
            Dim x As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(x, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 100, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new floating-point number y.
            Dim y As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(y, 64U)
            
            ' Initialize exponent.
            Dim exp As ptr(Of mpfr_exp_t) =  New ptr(Of mpfr_exp_t)(0)
            
            ' Find y and exp such that x = y * 2^exp where y in [0.5, 1).
            Assert.IsTrue(mpfr_lib.mpfr_frexp(exp, y, x, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert the value of exp and y.
            Assert.IsTrue(y.ToString() = "0.781250000000000000000e0" AndAlso exp.Value = 7)
            
            ' Release unmanaged memory allocated for x, and y.
            mpfr_lib.mpfr_clears(x, y, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Convert <paramref name="op"/> to a long after rounding it with respect to <paramref name="rnd"/>.
            </summary>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>The converted floating-point number.</returns>
            <remarks>
            <para>
            If <paramref name="op"/> is NaN, 0 is returned and the erange flag is set.
            If <paramref name="op"/> is too big for the return type, the function returns the maximum
            or the minimum of the corresponding C type, depending on the direction of the overflow;
            the erange flag is set too.
            When there is no such range error, if the return value differs from <paramref name="op"/>,
            i.e., if <paramref name="op"/> is not an integer, the inexact flag is set.
            See also mpfr_fits_slong_p, mpfr_fits_ulong_p, mpfr_fits_intmax_p and mpfr_fits_uintmax_p.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_flt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_flt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_sj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_sj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_uj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_uj</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_d_2exp"/>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_frexp"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_z_2exp(Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_t)">mpfr_get_z_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_z(Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_q(Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_t)">mpfr_get_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_f(Math.Gmp.Native.mpf_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_f</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_str"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_str(Math.Gmp.Native.char_ptr)">mpfr_free_str</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_slong_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_slong_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_sint_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_sint_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_sshort_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_sshort_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_intmax_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_intmax_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Conversion_Functions">Conversion Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Conversion-Functions">GNU MPFR - Conversion Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number to -123.0
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, -123.0, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of op is -123.0.
            Assert.IsTrue(mpfr_lib.mpfr_get_si(op, mpfr_rnd_t.MPFR_RNDN) == -123);
            
            // Release unmanaged memory allocated for x.
            mpfr_lib.mpfr_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number to -123.0
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, -123.0, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of op is -123.0.
            Assert.IsTrue(mpfr_lib.mpfr_get_si(op, mpfr_rnd_t.MPFR_RNDN) = -123)
            
            ' Release unmanaged memory allocated for x.
            mpfr_lib.mpfr_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Convert <paramref name="op"/> to an unsigned long after rounding it with respect to <paramref name="rnd"/>.
            </summary>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>The converted floating-point number.</returns>
            <remarks>
            <para>
            If <paramref name="op"/> is NaN, 0 is returned and the erange flag is set.
            If <paramref name="op"/> is too big for the return type, the function returns the maximum
            or the minimum of the corresponding C type, depending on the direction of the overflow;
            the erange flag is set too.
            When there is no such range error, if the return value differs from <paramref name="op"/>,
            i.e., if <paramref name="op"/> is not an integer, the inexact flag is set.
            See also mpfr_fits_slong_p, mpfr_fits_ulong_p, mpfr_fits_intmax_p and mpfr_fits_uintmax_p.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_flt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_flt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_si</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_d_2exp"/>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_frexp"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_z_2exp(Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_t)">mpfr_get_z_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_z(Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_q(Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_t)">mpfr_get_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_f(Math.Gmp.Native.mpf_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_f</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_str"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_str(Math.Gmp.Native.char_ptr)">mpfr_free_str</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_ulong_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_ulong_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_uint_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_uint_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_ushort_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_ushort_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_uintmax_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_uintmax_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Conversion_Functions">Conversion Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Conversion-Functions">GNU MPFR - Conversion Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number to 123.0
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 123.0, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of op is -123.0.
            Assert.IsTrue(mpfr_lib.mpfr_get_ui(op, mpfr_rnd_t.MPFR_RNDN) == 123);
            
            // Release unmanaged memory allocated for x.
            mpfr_lib.mpfr_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number to 123.0
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 123.0, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of op is -123.0.
            Assert.IsTrue(mpfr_lib.mpfr_get_ui(op, mpfr_rnd_t.MPFR_RNDN) = 123)
            
            ' Release unmanaged memory allocated for x.
            mpfr_lib.mpfr_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_str(Math.Gmp.Native.char_ptr,Math.Mpfr.Native.mpfr_exp_t@,System.Int32,Math.Gmp.Native.size_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Convert <paramref name="op"/> to a string of digits in base <paramref name="b"/>, with rounding in the direction <paramref name="rnd"/>, where <paramref name="n"/> is either zero (see below) or the number of significant digits output in the string; in the latter case, <paramref name="n"/> must be greater or equal to 2. 
            </summary>
            <param name="str">The result string.</param>
            <param name="expptr">The returned exponent.</param>
            <param name="b">The base.</param>
            <param name="n">The number of digits in the result string.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return the converted string of digits.</returns>
            <remarks>
            <para>
            The base may vary from 2 to 62; otherwise the function does nothing and immediately returns a null pointer.
            </para>
            <para>
            If the input is NaN, then the returned string is ‘@NaN@’ and the NaN flag is set.
            If the input is +Inf (resp. −Inf), then the returned string is ‘@Inf@’ (resp. ‘-@Inf@’).
            </para>
            <para>
            If the input number is a finite number, the exponent is written through the pointer <paramref name="expptr"/>
            (for input 0, the current minimal exponent is written); the type <see cref="T:Math.Mpfr.Native.mpfr_exp_t">mpfr_exp_t</see> is large enough to hold the exponent in all cases.
            </para>
            <para>
            The generated string is a fraction, with an implicit radix point immediately to the left of the first digit.
            For example, the number -3.1416 would be returned as "-31416" in the string and 1 written at <paramref name="expptr"/>.
            If <paramref name="rnd"/> is to nearest, and <paramref name="op"/> is exactly in the middle of two consecutive possible outputs,
            the one with an even significand is chosen, where both significands are considered with the exponent of <paramref name="op"/>.
            Note that for an odd base, this may not correspond to an even last digit: for example with 2 digits in base 7, (14) and a half is rounded to (15) which is 12 in decimal,
            (16) and a half is rounded to (20) which is 14 in decimal, and (26) and a half is rounded to (26) which is 20 in decimal. 
            </para>
            <para>
            If <paramref name="n"/> is zero, the number of digits of the significand is chosen large enough so that re-reading the printed value with the same precision,
            assuming both output and input use rounding to nearest, will recover the original value of <paramref name="op"/>.
            More precisely, in most cases, the chosen precision of <paramref name="str"/> is the minimal precision m depending only on p = PREC(<paramref name="op"/>)
            and <paramref name="b"/> that satisfies the above property, i.e., m = 1 + ceil(p * log(2) / log(<paramref name="b"/>)), with p replaced by p - 1 if <paramref name="b"/>
            is a power of 2, but in some very rare cases, it might be m + 1 (the smallest case for bases up to 62 is when p equals 186564318007 for bases 7 and 49).
            </para>
            <para>
            If <paramref name="str"/> is a null pointer, space for the significand is allocated using the allocation function
            (see <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Memory-Handling">GNU MPFR - Memory Handling</a>)
            and a pointer to the string is returned (unless the base is invalid).
            To free the returned string, you must use <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_str(Math.Gmp.Native.char_ptr)">mpfr_free_str</see>. 
            </para>
            <para>
            If <paramref name="str"/> is not a null pointer, it should point to a block of storage large enough for the significand.
            A safe block size (sufficient for any value) is max(<paramref name="n"/> + 2, 7) if <paramref name="n"/> is not zero;
            if <paramref name="n"/> is zero, replace it by m + 1, as discussed above. 
            The extra two bytes are for a possible minus sign, and for the terminating null character, and the value 7 accounts
            for -@Inf@ plus the terminating null character.
            The pointer to the string <paramref name="str"/> is returned (unless the base is invalid). 
            </para>
            <para>
            Like in usual functions, the inexact flag is set iff the result is inexact.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_flt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_flt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_sj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_sj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_uj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_uj</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_d_2exp"/>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_frexp"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_z_2exp(Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_t)">mpfr_get_z_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_z(Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_q(Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_t)">mpfr_get_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_f(Math.Gmp.Native.mpf_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_f</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_str(Math.Gmp.Native.char_ptr,Math.Gmp.Native.ptr{Math.Mpfr.Native.mpfr_exp_t},System.Int32,Math.Gmp.Native.size_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_str(char_ptr, ptr{mpfr_exp_t}, int, size_t, mpfr_t, mpfr_rnd_t)</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_str(Math.Gmp.Native.char_ptr)">mpfr_free_str</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Conversion_Functions">Conversion Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Conversion-Functions">GNU MPFR - Conversion Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number to -8.0
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, -8.0, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of op is -8.
            mpfr_exp_t exp = 0;
            char_ptr value = mpfr_lib.mpfr_get_str(char_ptr.Zero, ref exp, 10, 0, op, mpfr_rnd_t.MPFR_RNDN);
            Assert.IsTrue(value.ToString() == "-800000000000000000000");
            Assert.IsTrue(exp == 1);
            
            // Release unmanaged memory allocated for op.
            mpfr_lib.mpfr_clear(op);
            gmp_lib.free(value);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number to -8.0
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, -8.0, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of op is -8.
            Dim exp As mpfr_exp_t = 0
            Dim value As char_ptr = mpfr_lib.mpfr_get_str(char_ptr.Zero, ref exp, 10, 0, op, mpfr_rnd_t.MPFR_RNDN)
            Assert.IsTrue(value.ToString() = "-800000000000000000000")
            Assert.IsTrue(exp = 1)
            
            ' Release unmanaged memory allocated for op.
            mpfr_lib.mpfr_clear(op)
            gmp_lib.free(value)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_str(Math.Gmp.Native.char_ptr,Math.Gmp.Native.ptr{Math.Mpfr.Native.mpfr_exp_t},System.Int32,Math.Gmp.Native.size_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Convert <paramref name="op"/> to a string of digits in base <paramref name="b"/>, with rounding in the direction <paramref name="rnd"/>, where <paramref name="n"/> is either zero (see below) or the number of significant digits output in the string; in the latter case, <paramref name="n"/> must be greater or equal to 2. 
            </summary>
            <param name="str">The result string.</param>
            <param name="expptr">The returned exponent.</param>
            <param name="b">The base.</param>
            <param name="n">The number of digits in the result string.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return the converted string of digits.</returns>
            <remarks>
            <para>
            The base may vary from 2 to 62; otherwise the function does nothing and immediately returns a null pointer.
            </para>
            <para>
            If the input is NaN, then the returned string is ‘@NaN@’ and the NaN flag is set.
            If the input is +Inf (resp. −Inf), then the returned string is ‘@Inf@’ (resp. ‘-@Inf@’).
            </para>
            <para>
            If the input number is a finite number, the exponent is written through the pointer <paramref name="expptr"/>
            (for input 0, the current minimal exponent is written); the type <see cref="T:Math.Mpfr.Native.mpfr_exp_t">mpfr_exp_t</see> is large enough to hold the exponent in all cases.
            </para>
            <para>
            The generated string is a fraction, with an implicit radix point immediately to the left of the first digit.
            For example, the number -3.1416 would be returned as "-31416" in the string and 1 written at <paramref name="expptr"/>.
            If <paramref name="rnd"/> is to nearest, and <paramref name="op"/> is exactly in the middle of two consecutive possible outputs,
            the one with an even significand is chosen, where both significands are considered with the exponent of <paramref name="op"/>.
            Note that for an odd base, this may not correspond to an even last digit: for example with 2 digits in base 7, (14) and a half is rounded to (15) which is 12 in decimal,
            (16) and a half is rounded to (20) which is 14 in decimal, and (26) and a half is rounded to (26) which is 20 in decimal. 
            </para>
            <para>
            If <paramref name="n"/> is zero, the number of digits of the significand is chosen large enough so that re-reading the printed value with the same precision,
            assuming both output and input use rounding to nearest, will recover the original value of <paramref name="op"/>.
            More precisely, in most cases, the chosen precision of <paramref name="str"/> is the minimal precision m depending only on p = PREC(<paramref name="op"/>)
            and <paramref name="b"/> that satisfies the above property, i.e., m = 1 + ceil(p * log(2) / log(<paramref name="b"/>)), with p replaced by p - 1 if <paramref name="b"/>
            is a power of 2, but in some very rare cases, it might be m + 1 (the smallest case for bases up to 62 is when p equals 186564318007 for bases 7 and 49).
            </para>
            <para>
            If <paramref name="str"/> is a null pointer, space for the significand is allocated using the allocation function
            (see <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Memory-Handling">GNU MPFR - Memory Handling</a>)
            and a pointer to the string is returned (unless the base is invalid).
            To free the returned string, you must use <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_str(Math.Gmp.Native.char_ptr)">mpfr_free_str</see>. 
            </para>
            <para>
            If <paramref name="str"/> is not a null pointer, it should point to a block of storage large enough for the significand.
            A safe block size (sufficient for any value) is max(<paramref name="n"/> + 2, 7) if <paramref name="n"/> is not zero;
            if <paramref name="n"/> is zero, replace it by m + 1, as discussed above. 
            The extra two bytes are for a possible minus sign, and for the terminating null character, and the value 7 accounts
            for -@Inf@ plus the terminating null character.
            The pointer to the string <paramref name="str"/> is returned (unless the base is invalid). 
            </para>
            <para>
            Like in usual functions, the inexact flag is set iff the result is inexact.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_flt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_flt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_sj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_sj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_uj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_uj</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_d_2exp"/>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_frexp"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_z_2exp(Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_t)">mpfr_get_z_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_z(Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_q(Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_t)">mpfr_get_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_f(Math.Gmp.Native.mpf_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_f</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_str(Math.Gmp.Native.char_ptr,Math.Mpfr.Native.mpfr_exp_t@,System.Int32,Math.Gmp.Native.size_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_str(char_ptr, ref mpfr_exp_t, int, size_t, mpfr_t, mpfr_rnd_t)</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_str(Math.Gmp.Native.char_ptr)">mpfr_free_str</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Conversion_Functions">Conversion Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Conversion-Functions">GNU MPFR - Conversion Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number to -8.0
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, -8.0, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of op is -8.
            ptr&lt;mpfr_exp_t&gt; exp = new ptr&lt;mpfr_exp_t&gt;(0);
            char_ptr value = mpfr_lib.mpfr_get_str(char_ptr.Zero, exp, 10, 0, op, mpfr_rnd_t.MPFR_RNDN);
            Assert.IsTrue(value.ToString() == "-800000000000000000000");
            Assert.IsTrue(exp.Value == 1);
            
            // Release unmanaged memory allocated for op.
            mpfr_lib.mpfr_clear(op);
            gmp_lib.free(value);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number to -8.0
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, -8.0, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of op is -8.
            Dim exp As ptr(Of mpfr_exp_t) =  New ptr(Of mpfr_exp_t)(0)
            Dim value As char_ptr = mpfr_lib.mpfr_get_str(char_ptr.Zero, exp, 10, 0, op, mpfr_rnd_t.MPFR_RNDN)
            Assert.IsTrue(value.ToString() = "-800000000000000000000")
            Assert.IsTrue(exp.Value = 1)
            
            ' Release unmanaged memory allocated for op.
            mpfr_lib.mpfr_clear(op)
            gmp_lib.free(value)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_z(Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Convert <paramref name="op"/> to a <see cref="T:Math.Gmp.Native.mpz_t"/>, after rounding it with respect to <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            If <paramref name="op"/> is NaN or an infinity, the erange flag is set, <paramref name="rop"/> is set to 0, and 0 is returned.
            Otherwise the return value is zero when rop is equal to op (i.e., when <paramref name="op"/> is an integer), positive when it
            is greater than <paramref name="op"/>, and negative when it is smaller than <paramref name="op"/>; moreover, if <paramref name="rop"/>
            differs from <paramref name="op"/>, i.e., if <paramref name="op"/> is not an integer, the inexact flag is set.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_flt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_flt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_sj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_sj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_uj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_uj</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_d_2exp"/>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_frexp"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_z_2exp(Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_t)">mpfr_get_z_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_q(Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_t)">mpfr_get_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_f(Math.Gmp.Native.mpf_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_f</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_str"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_str(Math.Gmp.Native.char_ptr)">mpfr_free_str</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Conversion_Functions">Conversion Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Conversion-Functions">GNU MPFR - Conversion Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 10.6.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.6, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new integer rop.
            mpz_t rop = new mpz_t();
            gmp_lib.mpz_init(rop);
            
            // Set rop = op.
            Assert.IsTrue(mpfr_lib.mpfr_get_z(rop, op, mpfr_rnd_t.MPFR_RNDN) == 2);
            
            // Assert that the value of rop is 11.
            Assert.IsTrue(gmp_lib.mpz_get_ui(rop) == 11);
            
            // Release unmanaged memory allocated for rop and op.
            gmp_lib.mpz_clear(rop);
            mpfr_lib.mpfr_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 10.6.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.6, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new integer rop.
            Dim rop As mpz_t = New mpz_t()
            gmp_lib.mpz_init(rop)
            
            ' Set rop = op.
            Assert.IsTrue(mpfr_lib.mpfr_get_z(rop, op, mpfr_rnd_t.MPFR_RNDN) = 2)
            
            ' Assert that the value of rop is 11.
            Assert.IsTrue(gmp_lib.mpz_get_ui(rop) = 11)
            
            ' Release unmanaged memory allocated for rop and op.
            gmp_lib.mpz_clear(rop)
            mpfr_lib.mpfr_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_q(Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_t)">
            <summary>
            Convert <paramref name="op"/> to a <see cref="T:Math.Gmp.Native.mpq_t"/>. 
            </summary>
            <param name="rop">The result rational number.</param>
            <param name="op">The operand floating-point number.</param>
            <remarks>
            <para>
            If <paramref name="op"/> is NaN or an infinity, the erange flag is set, <paramref name="rop"/> is set to 0, and 0 is returned.
            Otherwise the conversion is always exact.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_flt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_flt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_sj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_sj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_uj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_uj</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_d_2exp"/>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_frexp"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_z_2exp(Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_t)">mpfr_get_z_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_z(Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_f(Math.Gmp.Native.mpf_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_f</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_str"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_str(Math.Gmp.Native.char_ptr)">mpfr_free_str</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Conversion_Functions">Conversion Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Conversion-Functions">GNU MPFR - Conversion Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 10.6.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.6, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new rational rop.
            mpq_t rop = new mpq_t();
            gmp_lib.mpq_init(rop);
            
            // Set rop = op.
            mpfr_lib.mpfr_get_q(rop, op);
            
            // Assert the value of rop.
            Assert.IsTrue(rop.ToString() == "5967269506265907/562949953421312");
            
            // Release unmanaged memory allocated for rop and op.
            gmp_lib.mpq_clear(rop);
            mpfr_lib.mpfr_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 10.6.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.6, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new rational rop.
            Dim rop As mpq_t = New mpq_t()
            gmp_lib.mpq_init(rop)
            
            ' Set rop = op.
            mpfr_lib.mpfr_get_q(rop, op)
            
            ' Assert the value of rop.
            Assert.IsTrue(rop.ToString() = "5967269506265907/562949953421312")
            
            ' Release unmanaged memory allocated for rop and op.
            gmp_lib.mpq_clear(rop)
            mpfr_lib.mpfr_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_str(Math.Gmp.Native.char_ptr)">
            <summary>
            Free a string allocated by <see cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_str">O:Math.Mpfr.Native.mpfr_lib.mpfr_get_str</see> using the unallocation function (see <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Memory-Handling">GNU MPFR - Memory Handling</a>).
            </summary>
            <param name="str">Pointer to string.</param>
            <remarks>
            <para>
            The block is assumed to be strlen(<paramref name="str"/>) + 1 bytes.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_flt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_flt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_sj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_sj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_uj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_uj</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_d_2exp"/>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_frexp"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_z_2exp(Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_t)">mpfr_get_z_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_z(Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_q(Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_t)">mpfr_get_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_f(Math.Gmp.Native.mpf_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_f</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_str"/>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Conversion_Functions">Conversion Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Conversion-Functions">GNU MPFR - Conversion Functions</a></seealso>
            <example>
            <code language="C#">
            // Create pointer to unmanaged character string pointer.
            ptr&lt;char_ptr&gt; str = new ptr&lt;char_ptr&gt;();
            mpfr_t r = "12345e6";
            
            Assert.IsTrue(mpfr_lib.mpfr_asprintf(str, "%Re", r) == 10);
            Assert.IsTrue(str.Value.ToString() == "1.2345e+10");
            mpfr_lib.mpfr_free_str(str.Value);
            
            // Release unmanaged memory allocated for r.
            mpfr_lib.mpfr_clear(r);
            </code> 
            <code language="VB.NET">
            ' Create pointer to unmanaged character string pointer.
            Dim str As ptr(Of char_ptr) =  New ptr(Of char_ptr)()
            Dim r As mpfr_t = "12345e6"
            
            Assert.IsTrue(mpfr_lib.mpfr_asprintf(str, "%Re", r) = 10)
            Assert.IsTrue(str.Value.ToString() = "1.2345e+10")
            mpfr_lib.mpfr_free_str(str.Value)
            
            ' Release unmanaged memory allocated for r.
            mpfr_lib.mpfr_clear(r)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_urandom(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.gmp_randstate_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Generate a uniformly distributed random float.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="state">The state of the random number generator.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            The floating-point number <paramref name="rop"/> can be seen as if a random real number is generated according to the continuous
            uniform distribution on the interval [0, 1] and then rounded in the direction <paramref name="rnd"/>. 
            </para>
            <para>
            The second argument is a <a href="https://machinecognitis.github.io/Math.Gmp.Native/html/f7e5846d-548d-3bf3-74ac-219fde42a041.htm">gmp_randstate_t</a>
            structure which should be created using the GMP gmp_randinit function (see the GMP manual). 
            </para>
            <para>
            Note: the note for <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_urandomb(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.gmp_randstate_t)">mpfr_urandomb</see> holds too.
            Moreover, the exact number (the random value to be rounded) and the next random state do not depend on the current exponent
            range and the rounding mode.
            However, they depend on the target precision: from the same state of the random generator, if the precision of the destination
            is changed, then the value may be completely different (and the state of the random generator is different too).
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_urandomb(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.gmp_randstate_t)">mpfr_urandomb</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nrandom(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.gmp_randstate_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_nrandom</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_grandom(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.gmp_randstate_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_grandom</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erandom(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.gmp_randstate_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erandom</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and seed a new random number generator.
            gmp_randstate_t state = new gmp_randstate_t();
            gmp_lib.gmp_randinit_mt(state);
            gmp_lib.gmp_randseed_ui(state, 100000U);
            
            // Create, initialize, and set the value of rop to NaN.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Generate a random integer in the range [0, 1].
            Assert.IsTrue(mpfr_lib.mpfr_urandom(rop, state, mpfr_rnd_t.MPFR_RNDN) == -1);
            
            // Free all memory occupied by state and rop.
            gmp_lib.gmp_randclear(state);
            mpfr_lib.mpfr_clear(rop);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and seed a new random number generator.
            Dim state As gmp_randstate_t = New gmp_randstate_t()
            gmp_lib.gmp_randinit_mt(state)
            gmp_lib.gmp_randseed_ui(state, 100000U)
            
            ' Create, initialize, and set the value of rop to NaN.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Generate a random integer in the range [0, 1].
            Assert.IsTrue(mpfr_lib.mpfr_urandom(rop, state, mpfr_rnd_t.MPFR_RNDN) = -1)
            
            ' Free all memory occupied by state and rop.
            gmp_lib.gmp_randclear(state)
            mpfr_lib.mpfr_clear(rop)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_nrandom(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.gmp_randstate_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Generate one random float according to a standard normal gaussian distribution (with mean zero and variance one).
            </summary>
            <param name="rop">The first result operand floating-point number.</param>
            <param name="state">The state of the random number generator.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>The return value is the <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">ternary value</a> corresponding to <paramref name="rop"/>. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            The floating-point number <paramref name="rop"/> can be seen as if a random real number were
            generated according to the standard normal gaussian distribution and then rounded in the direction <paramref name="rnd"/>. 
            </para>
            <para>
            The <see cref="T:Math.Gmp.Native.gmp_randstate_t"/> argument should be created using the GMP gmp_randinit function (see the GMP manual). 
            </para>
            <para>
            Note: the note for <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_urandomb(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.gmp_randstate_t)">mpfr_urandomb</see> holds too.
            In addition, the exponent range and the rounding mode might have a side effect on the next random state. 
            </para>
            <para>
            Note: <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nrandom(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.gmp_randstate_t,Math.Mpfr.Native.mpfr_rnd_t)"/> is much more efficient than <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_grandom(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.gmp_randstate_t,Math.Mpfr.Native.mpfr_rnd_t)"/>, especially for large precision.
            Thus <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_grandom(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.gmp_randstate_t,Math.Mpfr.Native.mpfr_rnd_t)"/> is marked as deprecated and will be removed in a future release.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_urandomb(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.gmp_randstate_t)">mpfr_urandomb</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_urandom(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.gmp_randstate_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_urandom</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erandom(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.gmp_randstate_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erandom</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and seed a new random number generator.
            gmp_randstate_t state = new gmp_randstate_t();
            gmp_lib.gmp_randinit_mt(state);
            gmp_lib.gmp_randseed_ui(state, 100000U);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Generate one Gaussian random floating-point number.
            Assert.IsTrue(mpfr_lib.mpfr_nrandom(rop, state, mpfr_rnd_t.MPFR_RNDN) == 10);
            
            // Free all memory occupied by state and rop.
            gmp_lib.gmp_randclear(state);
            mpfr_lib.mpfr_clear(rop);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and seed a new random number generator.
            Dim state As gmp_randstate_t = New gmp_randstate_t()
            gmp_lib.gmp_randinit_mt(state)
            gmp_lib.gmp_randseed_ui(state, 100000U)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Generate one Gaussian random floating-point number.
            Assert.IsTrue(mpfr_lib.mpfr_grandom(rop, state, mpfr_rnd_t.MPFR_RNDN) = 1)
            
            ' Free all memory occupied by state and rop.
            gmp_lib.gmp_randclear(state)
            mpfr_lib.mpfr_clear(rop)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_erandom(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.gmp_randstate_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Generate one random float according to an exponential distribution, with mean one.
            </summary>
            <param name="rop">The first result operand floating-point number.</param>
            <param name="state">The state of the random number generator.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>The return value is the <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">ternary value</a> corresponding to <paramref name="rop"/>. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            Generate one random floating-point number according to an exponential distribution, with mean one.
            Other characteristics are identical to <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nrandom(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.gmp_randstate_t,Math.Mpfr.Native.mpfr_rnd_t)"/>. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_urandomb(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.gmp_randstate_t)">mpfr_urandomb</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_urandom(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.gmp_randstate_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_urandom</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nrandom(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.gmp_randstate_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erandom</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and seed a new random number generator.
            gmp_randstate_t state = new gmp_randstate_t();
            gmp_lib.gmp_randinit_mt(state);
            gmp_lib.gmp_randseed_ui(state, 100000U);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Generate one exponential random floating-point number.
            Assert.IsTrue(mpfr_lib.mpfr_erandom(rop, state, mpfr_rnd_t.MPFR_RNDN) &lt; 0);
            
            // Free all memory occupied by state and rop.
            gmp_lib.gmp_randclear(state);
            mpfr_lib.mpfr_clear(rop);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and seed a new random number generator.
            Dim state As gmp_randstate_t = New gmp_randstate_t()
            gmp_lib.gmp_randinit_mt(state)
            gmp_lib.gmp_randseed_ui(state, 100000U)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Generate one exponential random floating-point number.
            Assert.IsTrue(mpfr_lib.mpfr_erandom(rop, state, mpfr_rnd_t.MPFR_RNDN) &lt; 0)
            
            ' Free all memory occupied by state and rop.
            gmp_lib.gmp_randclear(state)
            mpfr_lib.mpfr_clear(rop)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_grandom(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.gmp_randstate_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Generate two random floats according to a standard normal gaussian distribution (with mean zero and variance one).
            </summary>
            <param name="rop1">The first result operand floating-point number.</param>
            <param name="rop2">The second result operand floating-point number.</param>
            <param name="state">The state of the random number generator.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>The combination of the ternary values is returned like with <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sin_cos(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sin_cos</see>. If <paramref name="rop2"/> is a null pointer, the second ternary value is assumed to be 0 (note that the encoding of the only ternary value is not the same as the usual encoding for functions that return only one result). Otherwise the ternary value of a random number is always non-zero.</returns>
            <remarks>
            <para>
            If <paramref name="rop2"/> is a null pointer, then only one value is generated and stored in <paramref name="rop1"/>. 
            </para>
            <para>
            The floating-point number <paramref name="rop1"/> (and <paramref name="rop2"/>) can be seen as if a random real number were
            generated according to the standard normal Gaussian distribution and then rounded
            in the direction <paramref name="rnd"/>. 
            </para>
            <para>
            The <see cref="T:Math.Gmp.Native.gmp_randstate_t"/> argument should be created using the GMP gmp_randinit function (see the GMP manual). 
            </para>
            <para>
            Note: the note for <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_urandomb(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.gmp_randstate_t)">mpfr_urandomb</see> holds too.
            In addition, the exponent range and the rounding mode might have a side effect on the next random state. 
            </para>
            <para>
            Note: <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nrandom(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.gmp_randstate_t,Math.Mpfr.Native.mpfr_rnd_t)"/> is much more efficient than <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_grandom(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.gmp_randstate_t,Math.Mpfr.Native.mpfr_rnd_t)"/>, especially for large precision.
            Thus <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_grandom(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.gmp_randstate_t,Math.Mpfr.Native.mpfr_rnd_t)"/> is marked as deprecated and will be removed in a future release.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_urandomb(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.gmp_randstate_t)">mpfr_urandomb</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_urandom(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.gmp_randstate_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_urandom</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nrandom(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.gmp_randstate_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_nrandom</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erandom(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.gmp_randstate_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erandom</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and seed a new random number generator.
            gmp_randstate_t state = new gmp_randstate_t();
            gmp_lib.gmp_randinit_mt(state);
            gmp_lib.gmp_randseed_ui(state, 100000U);
            
            // Create and initialize a new floating-point number rop1.
            mpfr_t rop1 = new mpfr_t();
            mpfr_lib.mpfr_init2(rop1, 64U);
            
            // Create and initialize a new floating-point number rop2.
            mpfr_t rop2 = new mpfr_t();
            mpfr_lib.mpfr_init2(rop2, 64U);
            
            // Generate two Gaussian random floating-point numbers.
            Assert.IsTrue(mpfr_lib.mpfr_grandom(rop1, rop2, state, mpfr_rnd_t.MPFR_RNDN) == 10);
            
            // Generate one Gaussian random floating-point number.
            Assert.IsTrue(mpfr_lib.mpfr_grandom(rop1, null, state, mpfr_rnd_t.MPFR_RNDN) == 1);
            
            // Free all memory occupied by state, rop1, and rop2.
            gmp_lib.gmp_randclear(state);
            mpfr_lib.mpfr_clears(rop1, rop2, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and seed a new random number generator.
            Dim state As gmp_randstate_t = New gmp_randstate_t()
            gmp_lib.gmp_randinit_mt(state)
            gmp_lib.gmp_randseed_ui(state, 100000U)
            
            ' Create and initialize a new floating-point number rop1.
            Dim rop1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop1, 64U)
            
            ' Create and initialize a new floating-point number rop2.
            Dim rop2 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop2, 64U)
            
            ' Generate two Gaussian random floating-point numbers.
            Assert.IsTrue(mpfr_lib.mpfr_grandom(rop1, rop2, state, mpfr_rnd_t.MPFR_RNDN) = 10)
            
            ' Generate one Gaussian random floating-point number.
            Assert.IsTrue(mpfr_lib.mpfr_grandom(rop1, Nothing, state, mpfr_rnd_t.MPFR_RNDN) = 1)
            
            ' Free all memory occupied by state, rop1, and rop2.
            gmp_lib.gmp_randclear(state)
            mpfr_lib.mpfr_clears(rop1, rop2, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_urandomb(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.gmp_randstate_t)">
            <summary>
            Generate a uniformly distributed random float in the interval 0 &#8804; <paramref name="rop"/> &lt; 1.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="state">The state of the random number generator.</param>
            <returns>Return 0, unless the exponent is not in the current exponent range, in which case <paramref name="rop"/> is set to NaN and a non-zero value is returned (this should never happen in practice, except in very specific cases).</returns>
            <remarks>
            <para>
            More precisely, the number can be seen as a float with a random non-normalized significand and exponent 0,
            which is then normalized (thus if e denotes the exponent after normalization, then the least -e significant bits of the significand are always 0).
            </para>
            <para>
            The second argument is a <a href="https://machinecognitis.github.io/Math.Gmp.Native/html/f7e5846d-548d-3bf3-74ac-219fde42a041.htm">gmp_randstate_t</a> structure
            which should be created using the GMP gmp_randinit function (see the GMP manual).
            </para>
            <para>
            Note: for a given version of MPFR, the returned value of rop and the new value of state (which controls further random values) do not depend on the machine word size.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_urandom(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.gmp_randstate_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_urandom</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nrandom(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.gmp_randstate_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_nrandom</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_grandom(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.gmp_randstate_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_grandom</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erandom(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.gmp_randstate_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erandom</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and seed a new random number generator.
            gmp_randstate_t state = new gmp_randstate_t();
            gmp_lib.gmp_randinit_mt(state);
            gmp_lib.gmp_randseed_ui(state, 100000U);
            
            // Create, initialize, and set the value of rop to NaN.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Generate a random integer in the range [0, 1).
            Assert.IsTrue(mpfr_lib.mpfr_urandomb(rop, state) == 0);
            
            // Free all memory occupied by state and rop.
            gmp_lib.gmp_randclear(state);
            mpfr_lib.mpfr_clear(rop);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and seed a new random number generator.
            Dim state As gmp_randstate_t = New gmp_randstate_t()
            gmp_lib.gmp_randinit_mt(state)
            gmp_lib.gmp_randseed_ui(state, 100000U)
            
            ' Create, initialize, and set the value of rop to NaN.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Generate a random integer in the range [0, 1).
            Assert.IsTrue(mpfr_lib.mpfr_urandomb(rop, state) = 0)
            
            ' Free all memory occupied by state and rop.
            gmp_lib.gmp_randclear(state)
            mpfr_lib.mpfr_clear(rop)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_nextabove(Math.Mpfr.Native.mpfr_t)">
            <summary>
            Equivalent to <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nexttoward(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_nexttoward</see> where y is plus infinity. 
            </summary>
            <param name="x">The operand floating-point number.</param>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nexttoward(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_nexttoward</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nextbelow(Math.Mpfr.Native.mpfr_t)">mpfr_nextbelow</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number x to 10.
            mpfr_t x = new mpfr_t();
            mpfr_lib.mpfr_init2(x, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Move x to next above and then next below.
            mpfr_lib.mpfr_nextabove(x);
            mpfr_lib.mpfr_nextbelow(x);
            
            // Assert that the value of x is 10.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(x, mpfr_rnd_t.MPFR_RNDN) == 10.0);
            
            // Release unmanaged memory allocated for x.
            mpfr_lib.mpfr_clear(x);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number x to 10.
            Dim x As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(x, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Move x to next above and then next below.
            mpfr_lib.mpfr_nextabove(x)
            mpfr_lib.mpfr_nextbelow(x)
            
            ' Assert that the value of x is 10.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(x, mpfr_rnd_t.MPFR_RNDN) = 10.0)
            
            ' Release unmanaged memory allocated for x.
            mpfr_lib.mpfr_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_nextbelow(Math.Mpfr.Native.mpfr_t)">
            <summary>
            Equivalent to <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nexttoward(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_nexttoward</see> where y is minus infinity. 
            </summary>
            <param name="x">The operand floating-point number.</param>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nexttoward(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_nexttoward</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nextabove(Math.Mpfr.Native.mpfr_t)">mpfr_nextabove</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number x to 10.
            mpfr_t x = new mpfr_t();
            mpfr_lib.mpfr_init2(x, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Move x to next above and then next below.
            mpfr_lib.mpfr_nextabove(x);
            mpfr_lib.mpfr_nextbelow(x);
            
            // Assert that the value of x is 10.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(x, mpfr_rnd_t.MPFR_RNDN) == 10.0);
            
            // Release unmanaged memory allocated for x.
            mpfr_lib.mpfr_clear(x);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number x to 10.
            Dim x As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(x, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Move x to next above and then next below.
            mpfr_lib.mpfr_nextabove(x)
            mpfr_lib.mpfr_nextbelow(x)
            
            ' Assert that the value of x is 10.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(x, mpfr_rnd_t.MPFR_RNDN) = 10.0)
            
            ' Release unmanaged memory allocated for x.
            mpfr_lib.mpfr_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_nexttoward(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">
            <summary>
            Replace <paramref name="x"/> by the next floating-point number in the direction of <paramref name="y"/>. 
            </summary>
            <param name="x">The first operand floating-point number.</param>
            <param name="y">The second operand floating-point number.</param>
            <remarks>
            <para>
            If <paramref name="x"/> or <paramref name="y"/> is NaN, set <paramref name="x"/> to NaN; note that the NaN flag is set as usual.
            If <paramref name="x"/> and <paramref name="y"/> are equal, <paramref name="x"/> is unchanged.
            Otherwise, if <paramref name="x"/> is different from <paramref name="y"/>, replace <paramref name="x"/>
            by the next floating-point number (with the precision of <paramref name="x"/> and the current exponent range)
            in the direction of <paramref name="y"/> (the infinite values are seen as the smallest and largest
            floating-point numbers).
            If the result is zero, it keeps the same sign.
            No underflow, overflow, or inexact exception is raised. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nextabove(Math.Mpfr.Native.mpfr_t)">mpfr_nextabove</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nextbelow(Math.Mpfr.Native.mpfr_t)">mpfr_nextbelow</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number x to 10.
            mpfr_t x = new mpfr_t();
            mpfr_lib.mpfr_init2(x, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            mpfr_t y1 = "11.0";
            mpfr_t y2 = "12.0";
            
            // Move x toward y1 then y2.
            mpfr_lib.mpfr_nexttoward(x, y1);
            mpfr_lib.mpfr_nexttoward(x, y2);
            
            // Assert that the value of x is 10.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(x, mpfr_rnd_t.MPFR_RNDN) == 10.0);
            
            // Release unmanaged memory allocated for x, y1, and y2.
            mpfr_lib.mpfr_clears(x, y1, y2, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number x to 10.
            Dim x As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(x, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            Dim y1 As mpfr_t = "11.0"
            Dim y2 As mpfr_t = "12.0" 
            
            ' Move x toward y1 then y2.
            mpfr_lib.mpfr_nexttoward(x, y1)
            mpfr_lib.mpfr_nexttoward(x, y2)
            
            ' Assert that the value of x is 10.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(x, mpfr_rnd_t.MPFR_RNDN) = 10.0)
            
            ' Release unmanaged memory allocated for x, y1, and y2.
            mpfr_lib.mpfr_clears(x, y1, y2, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_printf(System.String,System.Object[])">
            <summary>
            Print to stdout the optional <paramref name="arguments"/> under the control of the template string <paramref name="template"/>.
            </summary>
            <param name="template">Format string. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Formatted-Output-Functions">Formatted Output Functions</a>.</param>
            <param name="arguments">Arguments.</param>
            <returns>Return the number of characters written or a negative value if an error occurred.</returns>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.String,System.Object[])">mpfr_fprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_vfprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.String,System.Object[])">mpfr_vfprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_vprintf(System.String,System.Object[])">mpfr_vprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sprintf(Math.Gmp.Native.char_ptr,System.String,System.Object[])">mpfr_sprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_vsprintf(Math.Gmp.Native.char_ptr,System.String,System.Object[])">mpfr_vsprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_snprintf(Math.Gmp.Native.char_ptr,Math.Gmp.Native.size_t,System.String,System.Object[])">mpfr_snprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_vsnprintf(Math.Gmp.Native.char_ptr,Math.Gmp.Native.size_t,System.String,System.Object[])">mpfr_vsnprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_asprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.char_ptr},System.String,System.Object[])">mpfr_asprintf</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_vasprintf"/>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Formatted_Output_Functions">Formatted Output Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Formatted-Output-Functions">GNU MPFR - Formatted Output Functions</a></seealso>
            <example>
            <code language="C#">
            </code> 
            <code language="VB.NET">
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_vprintf(System.String,System.Object[])">
            <summary>
            Print to stdout the optional <paramref name="arguments"/> under the control of the template string <paramref name="template"/>.
            </summary>
            <param name="template">Format string. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Formatted-Output-Functions">Formatted Output Functions</a>.</param>
            <param name="arguments">Arguments.</param>
            <returns>Return the number of characters written or a negative value if an error occurred.</returns>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.String,System.Object[])">mpfr_fprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_vfprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.String,System.Object[])">mpfr_vfprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_printf(System.String,System.Object[])">mpfr_printf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sprintf(Math.Gmp.Native.char_ptr,System.String,System.Object[])">mpfr_sprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_vsprintf(Math.Gmp.Native.char_ptr,System.String,System.Object[])">mpfr_vsprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_snprintf(Math.Gmp.Native.char_ptr,Math.Gmp.Native.size_t,System.String,System.Object[])">mpfr_snprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_vsnprintf(Math.Gmp.Native.char_ptr,Math.Gmp.Native.size_t,System.String,System.Object[])">mpfr_vsnprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_asprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.char_ptr},System.String,System.Object[])">mpfr_asprintf</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_vasprintf"/>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Formatted_Output_Functions">Formatted Output Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Formatted-Output-Functions">GNU MPFR - Formatted Output Functions</a></seealso>
            <example>
            <code language="C#">
            </code> 
            <code language="VB.NET">
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_fprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.String,System.Object[])">
            <summary>
            Print to the stream <paramref name="stream"/> the optional <paramref name="arguments"/> under the control of the template string <paramref name="template"/>.
            </summary>
            <param name="stream">The output stream.</param>
            <param name="template">Format string. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Formatted-Output-Functions">Formatted Output Functions</a>.</param>
            <param name="arguments">Arguments.</param>
            <returns>Return the number of characters written or a negative value if an error occurred.</returns>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_vfprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.String,System.Object[])">mpfr_vfprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_printf(System.String,System.Object[])">mpfr_printf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_vprintf(System.String,System.Object[])">mpfr_vprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sprintf(Math.Gmp.Native.char_ptr,System.String,System.Object[])">mpfr_sprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_vsprintf(Math.Gmp.Native.char_ptr,System.String,System.Object[])">mpfr_vsprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_snprintf(Math.Gmp.Native.char_ptr,Math.Gmp.Native.size_t,System.String,System.Object[])">mpfr_snprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_vsnprintf(Math.Gmp.Native.char_ptr,Math.Gmp.Native.size_t,System.String,System.Object[])">mpfr_vsnprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_asprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.char_ptr},System.String,System.Object[])">mpfr_asprintf</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_vasprintf"/>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Formatted_Output_Functions">Formatted Output Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Formatted-Output-Functions">GNU MPFR - Formatted Output Functions</a></seealso>
            <example>
            <code language="C#">
            </code> 
            <code language="VB.NET">
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_vfprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.String,System.Object[])">
            <summary>
            Print to the stream <paramref name="stream"/> the optional <paramref name="arguments"/> under the control of the template string <paramref name="template"/>.
            </summary>
            <param name="stream">The output stream.</param>
            <param name="template">Format string. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Formatted-Output-Functions">Formatted Output Functions</a>.</param>
            <param name="arguments">Arguments.</param>
            <returns>Return the number of characters written or a negative value if an error occurred.</returns>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.String,System.Object[])">mpfr_fprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_printf(System.String,System.Object[])">mpfr_printf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_vprintf(System.String,System.Object[])">mpfr_vprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sprintf(Math.Gmp.Native.char_ptr,System.String,System.Object[])">mpfr_sprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_vsprintf(Math.Gmp.Native.char_ptr,System.String,System.Object[])">mpfr_vsprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_snprintf(Math.Gmp.Native.char_ptr,Math.Gmp.Native.size_t,System.String,System.Object[])">mpfr_snprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_vsnprintf(Math.Gmp.Native.char_ptr,Math.Gmp.Native.size_t,System.String,System.Object[])">mpfr_vsnprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_asprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.char_ptr},System.String,System.Object[])">mpfr_asprintf</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_vasprintf"/>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Formatted_Output_Functions">Formatted Output Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Formatted-Output-Functions">GNU MPFR - Formatted Output Functions</a></seealso>
            <example>
            <code language="C#">
            </code> 
            <code language="VB.NET">
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_asprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.char_ptr},System.String,System.Object[])">
            <summary>
            Write output as a null terminated string in a block of memory allocated using the allocation function (see <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Memory-Handling">GNU MPFR - Memory Handling</a>).
            </summary>
            <param name="str">The output string.</param>
            <param name="template">Format string. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Formatted-Output-Functions">Formatted Output Functions</a>.</param>
            <param name="arguments">Arguments.</param>
            <returns>The return value is the number of characters written in the string, excluding the null-terminator, or a negative value if an error occurred, in which case the contents of <paramref name="str"/> are undefined.</returns>
            <remarks>
            <para>
            A pointer to the block is stored in <paramref name="str"/>. The block of memory must be freed using <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_str(Math.Gmp.Native.char_ptr)">mpfr_free_str</see>.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.String,System.Object[])">mpfr_fprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_vfprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.String,System.Object[])">mpfr_vfprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_printf(System.String,System.Object[])">mpfr_printf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_vprintf(System.String,System.Object[])">mpfr_vprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sprintf(Math.Gmp.Native.char_ptr,System.String,System.Object[])">mpfr_sprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_vsprintf(Math.Gmp.Native.char_ptr,System.String,System.Object[])">mpfr_vsprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_snprintf(Math.Gmp.Native.char_ptr,Math.Gmp.Native.size_t,System.String,System.Object[])">mpfr_snprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_vsnprintf(Math.Gmp.Native.char_ptr,Math.Gmp.Native.size_t,System.String,System.Object[])">mpfr_vsnprintf</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_vasprintf"/>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Formatted_Output_Functions">Formatted Output Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Formatted-Output-Functions">GNU MPFR - Formatted Output Functions</a></seealso>
            <example>
            <code language="C#">
            // Create pointer to unmanaged character string pointer.
            ptr&lt;char_ptr&gt; str = new ptr&lt;char_ptr&gt;();
            mpfr_t r = "12345e6";
            
            Assert.IsTrue(mpfr_lib.mpfr_asprintf(str, "%Re", r) == 10);
            Assert.IsTrue(str.Value.ToString() == "1.2345e+10");
            gmp_lib.free(str.Value);
            </code> 
            <code language="VB.NET">
            ' Create pointer to unmanaged character string pointer.
            Dim str As ptr(Of char_ptr) =  New ptr(Of char_ptr)()
            Dim r As mpfr_t = "12345e6"
            
            Assert.IsTrue(mpfr_lib.mpfr_asprintf(str, "%Re", r) = 10)
            Assert.IsTrue(str.Value.ToString() = "1.2345e+10")
            gmp_lib.free(str.Value)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_vasprintf(Math.Gmp.Native.char_ptr@,System.String,System.Object[])">
            <summary>
            Write output as a null terminated string in a block of memory allocated using the allocation function (see <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Memory-Handling">GNU MPFR - Memory Handling</a>).
            </summary>
            <param name="str">The output string.</param>
            <param name="template">Format string. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Formatted-Output-Functions">Formatted Output Functions</a>.</param>
            <param name="arguments">Arguments.</param>
            <returns>The return value is the number of characters written in the string, excluding the null-terminator, or a negative value if an error occurred, in which case the contents of <paramref name="str"/> are undefined.</returns>
            <remarks>
            <para>
            A pointer to the block is stored in <paramref name="str"/>. The block of memory must be freed using <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_str(Math.Gmp.Native.char_ptr)">mpfr_free_str</see>.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.String,System.Object[])">mpfr_fprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_vfprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.String,System.Object[])">mpfr_vfprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_printf(System.String,System.Object[])">mpfr_printf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_vprintf(System.String,System.Object[])">mpfr_vprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sprintf(Math.Gmp.Native.char_ptr,System.String,System.Object[])">mpfr_sprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_vsprintf(Math.Gmp.Native.char_ptr,System.String,System.Object[])">mpfr_vsprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_snprintf(Math.Gmp.Native.char_ptr,Math.Gmp.Native.size_t,System.String,System.Object[])">mpfr_snprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_vsnprintf(Math.Gmp.Native.char_ptr,Math.Gmp.Native.size_t,System.String,System.Object[])">mpfr_vsnprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_asprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.char_ptr},System.String,System.Object[])">mpfr_asprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_vasprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.char_ptr},System.String,System.Object[])">mpfr_vasprintf(ptr{char_ptr}, string, object[])</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Formatted_Output_Functions">Formatted Output Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Formatted-Output-Functions">GNU MPFR - Formatted Output Functions</a></seealso>
            <example>
            <code language="C#">
            char_ptr str = new char_ptr();
            
            mpfr_t r = "12345e6";
            Assert.IsTrue(mpfr_lib.mpfr_vasprintf(ref str, "%Re", r) == 10);
            Assert.IsTrue(str.ToString() == "1.2345e+10");
            gmp_lib.free(str);
            Assert.IsTrue(mpfr_lib.mpfr_vasprintf(ref str, "%Rf", r) == 18);
            Assert.IsTrue(str.ToString() == "12345000000.000000");
            gmp_lib.free(str);
            Assert.IsTrue(mpfr_lib.mpfr_vasprintf(ref str, "%Rg", r) == 10);
            Assert.IsTrue(str.ToString() == "1.2345e+10");
            gmp_lib.free(str);
            Assert.IsTrue(mpfr_lib.mpfr_vasprintf(ref str, "%Ra", r) == 15);
            Assert.IsTrue(str.ToString() == "0x2.dfd1c04p+32");
            gmp_lib.free(str);
            mpfr_lib.mpfr_clear(r);
            </code> 
            <code language="VB.NET">
            Dim str As char_ptr = New char_ptr()
            
            Dim r As mpfr_t = "12345e6"
            Assert.IsTrue(mpfr_lib.mpfr_vasprintf( str,"%Re",r)  =  10)
            Assert.IsTrue(str.ToString() = "1.2345e+10")
            gmp_lib.free(str)
            Assert.IsTrue(mpfr_lib.mpfr_vasprintf( str,"%Rf",r)  =  18)
            Assert.IsTrue(str.ToString() = "12345000000.000000")
            gmp_lib.free(str)
            Assert.IsTrue(mpfr_lib.mpfr_vasprintf( str,"%Rg",r)  =  10)
            Assert.IsTrue(str.ToString() = "1.2345e+10")
            gmp_lib.free(str)
            Assert.IsTrue(mpfr_lib.mpfr_vasprintf( str,"%Ra",r)  =  15)
            Assert.IsTrue(str.ToString() = "0x2.dfd1c04p+32")
            gmp_lib.free(str)
            mpfr_lib.mpfr_clear(r)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_vasprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.char_ptr},System.String,System.Object[])">
            <summary>
            Write output as a null terminated string in a block of memory allocated using the allocation function (see <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Memory-Handling">GNU MPFR - Memory Handling</a>).
            </summary>
            <param name="str">The output string.</param>
            <param name="template">Format string. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Formatted-Output-Functions">Formatted Output Functions</a>.</param>
            <param name="arguments">Arguments.</param>
            <returns>The return value is the number of characters written in the string, excluding the null-terminator, or a negative value if an error occurred, in which case the contents of <paramref name="str"/> are undefined.</returns>
            <remarks>
            <para>
            A pointer to the block is stored in <paramref name="str"/>. The block of memory must be freed using <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_str(Math.Gmp.Native.char_ptr)">mpfr_free_str</see>.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.String,System.Object[])">mpfr_fprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_vfprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.String,System.Object[])">mpfr_vfprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_printf(System.String,System.Object[])">mpfr_printf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_vprintf(System.String,System.Object[])">mpfr_vprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sprintf(Math.Gmp.Native.char_ptr,System.String,System.Object[])">mpfr_sprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_vsprintf(Math.Gmp.Native.char_ptr,System.String,System.Object[])">mpfr_vsprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_snprintf(Math.Gmp.Native.char_ptr,Math.Gmp.Native.size_t,System.String,System.Object[])">mpfr_snprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_vsnprintf(Math.Gmp.Native.char_ptr,Math.Gmp.Native.size_t,System.String,System.Object[])">mpfr_vsnprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_asprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.char_ptr},System.String,System.Object[])">mpfr_asprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_vasprintf(Math.Gmp.Native.char_ptr@,System.String,System.Object[])">mpfr_vasprintf(ref char_ptr, string, object[])</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Formatted_Output_Functions">Formatted Output Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Formatted-Output-Functions">GNU MPFR - Formatted Output Functions</a></seealso>
            <example>
            <code language="C#">
            ptr&lt;char_ptr&gt; str = new ptr&lt;char_ptr&gt;();
            
            mpfr_t r = "12345e6";
            Assert.IsTrue(mpfr_lib.mpfr_vasprintf(str, "%Re", r) == 10);
            Assert.IsTrue(str.Value.ToString() == "1.2345e+10");
            gmp_lib.free(str.Value);
            Assert.IsTrue(mpfr_lib.mpfr_vasprintf(str, "%Rf", r) == 18);
            Assert.IsTrue(str.Value.ToString() == "12345000000.000000");
            gmp_lib.free(str.Value);
            Assert.IsTrue(mpfr_lib.mpfr_vasprintf(str, "%Rg", r) == 10);
            Assert.IsTrue(str.Value.ToString() == "1.2345e+10");
            gmp_lib.free(str.Value);
            Assert.IsTrue(mpfr_lib.mpfr_vasprintf(str, "%Ra", r) == 15);
            Assert.IsTrue(str.Value.ToString() == "0x2.dfd1c04p+32");
            gmp_lib.free(str.Value);
             mpfr_lib.mpfr_clear(r);
            </code> 
            <code language="VB.NET">
            Dim str As ptr(Of char_ptr) =  New ptr(Of char_ptr)()
            
            Dim r As mpfr_t = "12345e6"
            Assert.IsTrue(mpfr_lib.mpfr_vasprintf(str, "%Re", r) = 10)
            Assert.IsTrue(str.Value.ToString() = "1.2345e+10")
            gmp_lib.free(str.Value)
            Assert.IsTrue(mpfr_lib.mpfr_vasprintf(str, "%Rf", r) = 18)
            Assert.IsTrue(str.Value.ToString() = "12345000000.000000")
            gmp_lib.free(str.Value)
            Assert.IsTrue(mpfr_lib.mpfr_vasprintf(str, "%Rg", r) = 10)
            Assert.IsTrue(str.Value.ToString() = "1.2345e+10")
            gmp_lib.free(str.Value)
            Assert.IsTrue(mpfr_lib.mpfr_vasprintf(str, "%Ra", r) = 15)
             Assert.IsTrue(str.Value.ToString() = "0x2.dfd1c04p+32")
            gmp_lib.free(str.Value)
            mpfr_lib.mpfr_clear(r)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_sprintf(Math.Gmp.Native.char_ptr,System.String,System.Object[])">
            <summary>
            Form a null-terminated string corresponding to the optional <paramref name="arguments"/> under the control of the template string <paramref name="template"/>, and print it in <paramref name="buf"/>.
            </summary>
            <param name="buf">The output buffer.</param>
            <param name="template">Format string. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Formatted-Output-Functions">Formatted Output Functions</a>.</param>
            <param name="arguments">Arguments.</param>
            <returns>Return the number of characters written in the array buf not counting the terminating null character or a negative value if an error occurred.</returns>
            <remarks>
            <para>
            No overlap is permitted between buf and the other arguments.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.String,System.Object[])">mpfr_fprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_vfprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.String,System.Object[])">mpfr_vfprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_printf(System.String,System.Object[])">mpfr_printf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_vprintf(System.String,System.Object[])">mpfr_vprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_vsprintf(Math.Gmp.Native.char_ptr,System.String,System.Object[])">mpfr_vsprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_snprintf(Math.Gmp.Native.char_ptr,Math.Gmp.Native.size_t,System.String,System.Object[])">mpfr_snprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_vsnprintf(Math.Gmp.Native.char_ptr,Math.Gmp.Native.size_t,System.String,System.Object[])">mpfr_vsnprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_asprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.char_ptr},System.String,System.Object[])">mpfr_asprintf</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_vasprintf"/>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Formatted_Output_Functions">Formatted Output Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Formatted-Output-Functions">GNU MPFR - Formatted Output Functions</a></seealso>
            <example>
            <code language="C#">
            // Allocate unmanaged string with 50 characters.
            char_ptr str = new char_ptr(".................................................");
            mpfr_t r = "12345e6";
            
            // Print to string.
            Assert.IsTrue(mpfr_lib.mpfr_sprintf(str, "%Re", r) == 10);
            Assert.IsTrue(str.ToString() == "1.2345e+10");
            Assert.IsTrue(mpfr_lib.mpfr_sprintf(str, "%Rf", r) == 18);
            Assert.IsTrue(str.ToString() == "12345000000.000000");
            Assert.IsTrue(mpfr_lib.mpfr_sprintf(str, "%Rg", r) == 10);
            Assert.IsTrue(str.ToString() == "1.2345e+10");
            Assert.IsTrue(mpfr_lib.mpfr_sprintf(str, "%Ra", r) == 15);
            Assert.IsTrue(str.ToString() == "0x2.dfd1c04p+32");
            mpfr_lib.mpfr_clear(r);
            gmp_lib.free(str);
            </code> 
            <code language="VB.NET">
            ' Allocate unmanaged string with 50 characters.
            Dim str As char_ptr = New char_ptr(".................................................")
            Dim r As mpfr_t = "12345e6" 
            
            ' Print to string.
            Assert.IsTrue(mpfr_lib.mpfr_sprintf(str, "%Re", r) = 10)
            Assert.IsTrue(str.ToString() = "1.2345e+10")
            Assert.IsTrue(mpfr_lib.mpfr_sprintf(str, "%Rf", r) = 18)
            Assert.IsTrue(str.ToString() = "12345000000.000000")
            Assert.IsTrue(mpfr_lib.mpfr_sprintf(str, "%Rg", r) = 10)
            Assert.IsTrue(str.ToString() = "1.2345e+10")
            Assert.IsTrue(mpfr_lib.mpfr_sprintf(str, "%Ra", r) = 15)
            Assert.IsTrue(str.ToString() = "0x2.dfd1c04p+32")
            mpfr_lib.mpfr_clear(r)
            gmp_lib.free(str)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_vsprintf(Math.Gmp.Native.char_ptr,System.String,System.Object[])">
            <summary>
            Form a null-terminated string corresponding to the optional <paramref name="arguments"/> under the control of the template string <paramref name="template"/>, and print it in <paramref name="buf"/>.
            </summary>
            <param name="buf">The output buffer.</param>
            <param name="template">Format string. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Formatted-Output-Functions">Formatted Output Functions</a>.</param>
            <param name="arguments">Arguments.</param>
            <returns>Return the number of characters written in the array buf not counting the terminating null character or a negative value if an error occurred.</returns>
            <remarks>
            <para>
            No overlap is permitted between buf and the other arguments.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.String,System.Object[])">mpfr_fprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_vfprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.String,System.Object[])">mpfr_vfprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_printf(System.String,System.Object[])">mpfr_printf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_vprintf(System.String,System.Object[])">mpfr_vprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sprintf(Math.Gmp.Native.char_ptr,System.String,System.Object[])">mpfr_sprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_snprintf(Math.Gmp.Native.char_ptr,Math.Gmp.Native.size_t,System.String,System.Object[])">mpfr_snprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_vsnprintf(Math.Gmp.Native.char_ptr,Math.Gmp.Native.size_t,System.String,System.Object[])">mpfr_vsnprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_asprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.char_ptr},System.String,System.Object[])">mpfr_asprintf</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_vasprintf"/>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Formatted_Output_Functions">Formatted Output Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Formatted-Output-Functions">GNU MPFR - Formatted Output Functions</a></seealso>
            <example>
            <code language="C#">
            // Create string.
            char_ptr str = new char_ptr(".........................................");
            
            mpfr_t r = "12345e6";
            Assert.IsTrue(mpfr_lib.mpfr_vsprintf(str, "%Re", r) == 10);
            Assert.IsTrue(str.ToString() == "1.2345e+10");
            Assert.IsTrue(mpfr_lib.mpfr_vsprintf(str, "%Rf", r) == 18);
            Assert.IsTrue(str.ToString() == "12345000000.000000");
            Assert.IsTrue(mpfr_lib.mpfr_vsprintf(str, "%Rg", r) == 10);
            Assert.IsTrue(str.ToString() == "1.2345e+10");
            Assert.IsTrue(mpfr_lib.mpfr_vsprintf(str, "%Ra", r) == 15);
            Assert.IsTrue(str.ToString() == "0x2.dfd1c04p+32");
            mpfr_lib.mpfr_clear(r);
            
            // Free allocated unmanaged memory.
            gmp_lib.free(str);
            </code> 
            <code language="VB.NET">
            ' Create string.
            Dim str As char_ptr = New char_ptr(".........................................")
            
            Dim r As mpfr_t = "12345e6"
            Assert.IsTrue(mpfr_lib.mpfr_vsprintf(str, "%Re", r) = 10)
            Assert.IsTrue(str.ToString() = "1.2345e+10")
            Assert.IsTrue(mpfr_lib.mpfr_vsprintf(str, "%Rf", r) = 18)
            Assert.IsTrue(str.ToString() = "12345000000.000000")
            Assert.IsTrue(mpfr_lib.mpfr_vsprintf(str, "%Rg", r) = 10)
            Assert.IsTrue(str.ToString() = "1.2345e+10")
            Assert.IsTrue(mpfr_lib.mpfr_vsprintf(str, "%Ra", r) = 15)
            Assert.IsTrue(str.ToString() = "0x2.dfd1c04p+32")
            mpfr_lib.mpfr_clear(r)
            
            ' Free allocated unmanaged memory.
            gmp_lib.free(str)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_snprintf(Math.Gmp.Native.char_ptr,Math.Gmp.Native.size_t,System.String,System.Object[])">
            <summary>
            Form a null-terminated string corresponding to the optional <paramref name="arguments"/> under the control of the template string <paramref name="template"/>, and print it in <paramref name="buf"/>.
            </summary>
            <param name="buf">The output buffer.</param>
            <param name="n">The number of characters written to the output buffer.</param>
            <param name="template">Format string. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Formatted-Output-Functions">Formatted Output Functions</a>.</param>
            <param name="arguments">Arguments.</param>
            <returns>Return the number of characters that would have been written had n been sufficiently large, not counting the terminating null character, or a negative value if an error occurred.</returns>
            <remarks>
            <para>
            If <paramref name="n"/> is zero, nothing is written and <paramref name="buf"/> may be a null pointer,
            otherwise, the <paramref name="n"/> - 1 first characters are written in <paramref name="buf"/> and
            the <paramref name="n"/>-th is a null character.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.String,System.Object[])">mpfr_fprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_vfprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.String,System.Object[])">mpfr_vfprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_printf(System.String,System.Object[])">mpfr_printf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_vprintf(System.String,System.Object[])">mpfr_vprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sprintf(Math.Gmp.Native.char_ptr,System.String,System.Object[])">mpfr_sprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_vsprintf(Math.Gmp.Native.char_ptr,System.String,System.Object[])">mpfr_vsprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_vsnprintf(Math.Gmp.Native.char_ptr,Math.Gmp.Native.size_t,System.String,System.Object[])">mpfr_vsnprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_asprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.char_ptr},System.String,System.Object[])">mpfr_asprintf</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_vasprintf"/>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Formatted_Output_Functions">Formatted Output Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Formatted-Output-Functions">GNU MPFR - Formatted Output Functions</a></seealso>
            <example>
            <code language="C#">
            // Allocate unmanaged string with 50 characters.
            char_ptr str = new char_ptr(".................................................");
            mpfr_t r = "12345e6";
            
            // Print to string.
            Assert.IsTrue(mpfr_lib.mpfr_snprintf(str, 41, "%Re", r) == 10);
            Assert.IsTrue(str.ToString() == "1.2345e+10");
            Assert.IsTrue(mpfr_lib.mpfr_snprintf(str, 41, "%Rf", r) == 18);
            Assert.IsTrue(str.ToString() == "12345000000.000000");
            Assert.IsTrue(mpfr_lib.mpfr_snprintf(str, 41, "%Rg", r) == 10);
            Assert.IsTrue(str.ToString() == "1.2345e+10");
            Assert.IsTrue(mpfr_lib.mpfr_snprintf(str, 41, "%Ra", r) == 15);
            Assert.IsTrue(str.ToString() == "0x2.dfd1c04p+32");
            mpfr_lib.mpfr_clear(r);
            gmp_lib.free(str);
            </code> 
            <code language="VB.NET">
            ' Allocate unmanaged string with 50 characters.
            Dim str As char_ptr = New char_ptr(".................................................")
            Dim r As mpfr_t = "12345e6" 
            
            ' Print to string.
            Assert.IsTrue(mpfr_lib.mpfr_snprintf(str, 41, "%Re", r) = 10)
            Assert.IsTrue(str.ToString() = "1.2345e+10")
            Assert.IsTrue(mpfr_lib.mpfr_snprintf(str, 41, "%Rf", r) = 18)
            Assert.IsTrue(str.ToString() = "12345000000.000000")
            Assert.IsTrue(mpfr_lib.mpfr_snprintf(str, 41, "%Rg", r) = 10)
            Assert.IsTrue(str.ToString() = "1.2345e+10")
            Assert.IsTrue(mpfr_lib.mpfr_snprintf(str, 41, "%Ra", r) = 15)
            Assert.IsTrue(str.ToString() = "0x2.dfd1c04p+32")
            mpfr_lib.mpfr_clear(r)
            gmp_lib.free(str)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_vsnprintf(Math.Gmp.Native.char_ptr,Math.Gmp.Native.size_t,System.String,System.Object[])">
            <summary>
            Form a null-terminated string corresponding to the optional <paramref name="arguments"/> under the control of the template string <paramref name="template"/>, and print it in <paramref name="buf"/>.
            </summary>
            <param name="buf">The output buffer.</param>
            <param name="n">The number of characters written to the output buffer.</param>
            <param name="template">Format string. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Formatted-Output-Functions">Formatted Output Functions</a>.</param>
            <param name="arguments">Arguments.</param>
            <returns>Return the number of characters that would have been written had n been sufficiently large, not counting the terminating null character, or a negative value if an error occurred.</returns>
            <remarks>
            <para>
            If <paramref name="n"/> is zero, nothing is written and <paramref name="buf"/> may be a null pointer,
            otherwise, the <paramref name="n"/> - 1 first characters are written in <paramref name="buf"/> and
            the <paramref name="n"/>-th is a null character.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.String,System.Object[])">mpfr_fprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_vfprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.String,System.Object[])">mpfr_vfprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_printf(System.String,System.Object[])">mpfr_printf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_vprintf(System.String,System.Object[])">mpfr_vprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sprintf(Math.Gmp.Native.char_ptr,System.String,System.Object[])">mpfr_sprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_vsprintf(Math.Gmp.Native.char_ptr,System.String,System.Object[])">mpfr_vsprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_snprintf(Math.Gmp.Native.char_ptr,Math.Gmp.Native.size_t,System.String,System.Object[])">mpfr_snprintf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_asprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.char_ptr},System.String,System.Object[])">mpfr_asprintf</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_vasprintf"/>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Formatted_Output_Functions">Formatted Output Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Formatted-Output-Functions">GNU MPFR - Formatted Output Functions</a></seealso>
            <example>
            <code language="C#">
            char_ptr str = new char_ptr(".........................................");
            
            mpfr_t r = "12345e6";
            Assert.IsTrue(mpfr_lib.mpfr_vsnprintf(str, 41, "%Re", r) == 10);
            Assert.IsTrue(str.ToString() == "1.2345e+10");
            Assert.IsTrue(mpfr_lib.mpfr_vsnprintf(str, 41, "%Rf", r) == 18);
            Assert.IsTrue(str.ToString() == "12345000000.000000");
            Assert.IsTrue(mpfr_lib.mpfr_vsnprintf(str, 41, "%Rg", r) == 10);
            Assert.IsTrue(str.ToString() == "1.2345e+10");
            Assert.IsTrue(mpfr_lib.mpfr_vsnprintf(str, 41, "%Ra", r) == 15);
            Assert.IsTrue(str.ToString() == "0x2.dfd1c04p+32");
            mpfr_lib.mpfr_clear(r);
            
            gmp_lib.free(str);
            </code> 
            <code language="VB.NET">
            Dim str As char_ptr = New char_ptr(".........................................")
            
            Dim r As mpfr_t = "12345e6"
            Assert.IsTrue(mpfr_lib.mpfr_vsnprintf(str, 41, "%Re", r) = 10)
            Assert.IsTrue(str.ToString() = "1.2345e+10")
            Assert.IsTrue(mpfr_lib.mpfr_vsnprintf(str, 41, "%Rf", r) = 18)
            Assert.IsTrue(str.ToString() = "12345000000.000000")
            Assert.IsTrue(mpfr_lib.mpfr_vsnprintf(str, 41, "%Rg", r) = 10)
            Assert.IsTrue(str.ToString() = "1.2345e+10")
            Assert.IsTrue(mpfr_lib.mpfr_vsnprintf(str, 41, "%Ra", r) = 15)
            Assert.IsTrue(str.ToString() = "0x2.dfd1c04p+32")
            mpfr_lib.mpfr_clear(r)
            
            gmp_lib.free(str)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> raised to <paramref name="op2"/>, rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            Special values are handled as described in the ISO C99 and IEEE 754-2008 standards for the pow function: 
            </para>
            <list type="bullet">
            <item>
            <description>
            pow(±0, y) returns plus or minus infinity for y a negative odd integer. 
            </description>
            </item>
            <item>
            <description>
            pow(±0, y) returns plus infinity for y negative and not an odd integer. 
            </description>
            </item>
            <item>
            <description>
            pow(±0, y) returns plus or minus zero for y a positive odd integer. 
            </description>
            </item>
            <item>
            <description>
            pow(±0, y) returns plus zero for y positive and not an odd integer. 
            </description>
            </item>
            <item>
            <description>
            pow(-1, ±Inf) returns 1. 
            </description>
            </item>
            <item>
            <description>
            pow(+1, y) returns 1 for any y, even a NaN. 
            </description>
            </item>
            <item>
            <description>
            pow(x, ±0) returns 1 for any x, even a NaN. 
            </description>
            </item>
            <item>
            <description>
            pow(x, y) returns NaN for finite negative x and finite non-integer y. 
            </description>
            </item>
            <item>
            <description>
            pow(x, -Inf) returns plus infinity for 0 &lt; abs(x) &lt; 1, and plus zero for abs(x) &gt; 1. 
            </description>
            </item>
            <item>
            <description>
            pow(x, +Inf) returns plus zero for 0 &lt; abs(x) &lt; 1, and plus infinity for abs(x) &gt; 1. 
            </description>
            </item>
            <item>
            <description>
            pow(-Inf, y) returns minus zero for y a negative odd integer. 
            </description>
            </item>
            <item>
            <description>
            pow(-Inf, y) returns plus zero for y negative and not an odd integer. 
            </description>
            </item>
            <item>
            <description>
            pow(-Inf, y) returns minus infinity for y a positive odd integer. 
            </description>
            </item>
            <item>
            <description>
            pow(-Inf, y) returns plus infinity for y positive and not an odd integer. 
            </description>
            </item>
            <item>
            <description>
            pow(+Inf, y) returns plus zero for y negative, and plus infinity for y positive. 
            </description>
            </item>
            </list>
            <para>
            Note: When 0 is of integer type, it is regarded as +0 by these functions.
            We do not use the usual limit rules in this case, as these rules are not used for pow.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqr(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqr</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cbrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cbrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rootn_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_root(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow_z(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ui_pow_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ui_pow_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ui_pow(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ui_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_neg</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_abs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_dim(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_dim</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to 10.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new floating-point number op2 to 3.
            mpfr_t op2 = new mpfr_t();
            mpfr_lib.mpfr_init2(op2, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 3, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = op1^op2.
            Assert.IsTrue(mpfr_lib.mpfr_pow(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is 1000.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 1000.0);
            
            // Release unmanaged memory allocated for rop, op1, and op2.
            mpfr_lib.mpfr_clears(rop, op1, op2, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to 10.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new floating-point number op2 to 3.
            Dim op2 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op2, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 3, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = op1^op2.
            Assert.IsTrue(mpfr_lib.mpfr_pow(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is 1000.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 1000.0)
            
            ' Release unmanaged memory allocated for rop, op1, and op2.
            mpfr_lib.mpfr_clears(rop, op1, op2, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> raised to <paramref name="op2"/>, rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            Special values are handled as described in the ISO C99 and IEEE 754-2008 standards for the pow function: 
            </para>
            <list type="bullet">
            <item>
            <description>
            pow(±0, y) returns plus or minus infinity for y a negative odd integer. 
            </description>
            </item>
            <item>
            <description>
            pow(±0, y) returns plus infinity for y negative and not an odd integer. 
            </description>
            </item>
            <item>
            <description>
            pow(±0, y) returns plus or minus zero for y a positive odd integer. 
            </description>
            </item>
            <item>
            <description>
            pow(±0, y) returns plus zero for y positive and not an odd integer. 
            </description>
            </item>
            <item>
            <description>
            pow(-1, ±Inf) returns 1. 
            </description>
            </item>
            <item>
            <description>
            pow(+1, y) returns 1 for any y, even a NaN. 
            </description>
            </item>
            <item>
            <description>
            pow(x, ±0) returns 1 for any x, even a NaN. 
            </description>
            </item>
            <item>
            <description>
            pow(x, y) returns NaN for finite negative x and finite non-integer y. 
            </description>
            </item>
            <item>
            <description>
            pow(x, -Inf) returns plus infinity for 0 &lt; abs(x) &lt; 1, and plus zero for abs(x) &gt; 1. 
            </description>
            </item>
            <item>
            <description>
            pow(x, +Inf) returns plus zero for 0 &lt; abs(x) &lt; 1, and plus infinity for abs(x) &gt; 1. 
            </description>
            </item>
            <item>
            <description>
            pow(-Inf, y) returns minus zero for y a negative odd integer. 
            </description>
            </item>
            <item>
            <description>
            pow(-Inf, y) returns plus zero for y negative and not an odd integer. 
            </description>
            </item>
            <item>
            <description>
            pow(-Inf, y) returns minus infinity for y a positive odd integer. 
            </description>
            </item>
            <item>
            <description>
            pow(-Inf, y) returns plus infinity for y positive and not an odd integer. 
            </description>
            </item>
            <item>
            <description>
            pow(+Inf, y) returns plus zero for y negative, and plus infinity for y positive. 
            </description>
            </item>
            </list>
            <para>
            Note: When 0 is of integer type, it is regarded as +0 by these functions.
            We do not use the usual limit rules in this case, as these rules are not used for pow.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqr(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqr</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cbrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cbrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rootn_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_root(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow_z(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ui_pow_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ui_pow_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ui_pow(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ui_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_neg</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_abs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_dim(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_dim</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to 10.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_init_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = op1^3.
            Assert.IsTrue(mpfr_lib.mpfr_pow_si(rop, op1, 3, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is 1000.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 1000.0);
            
            // Release unmanaged memory allocated for rop and op1.
            mpfr_lib.mpfr_clears(rop, op1, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to 10.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_init_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = op1^3.
            Assert.IsTrue(mpfr_lib.mpfr_pow_si(rop, op1, 3, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is 1000.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 1000.0)
            
            ' Release unmanaged memory allocated for rop and op1.
            mpfr_lib.mpfr_clears(rop, op1, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> raised to <paramref name="op2"/>, rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            Special values are handled as described in the ISO C99 and IEEE 754-2008 standards for the pow function: 
            </para>
            <list type="bullet">
            <item>
            <description>
            pow(±0, y) returns plus or minus infinity for y a negative odd integer. 
            </description>
            </item>
            <item>
            <description>
            pow(±0, y) returns plus infinity for y negative and not an odd integer. 
            </description>
            </item>
            <item>
            <description>
            pow(±0, y) returns plus or minus zero for y a positive odd integer. 
            </description>
            </item>
            <item>
            <description>
            pow(±0, y) returns plus zero for y positive and not an odd integer. 
            </description>
            </item>
            <item>
            <description>
            pow(-1, ±Inf) returns 1. 
            </description>
            </item>
            <item>
            <description>
            pow(+1, y) returns 1 for any y, even a NaN. 
            </description>
            </item>
            <item>
            <description>
            pow(x, ±0) returns 1 for any x, even a NaN. 
            </description>
            </item>
            <item>
            <description>
            pow(x, y) returns NaN for finite negative x and finite non-integer y. 
            </description>
            </item>
            <item>
            <description>
            pow(x, -Inf) returns plus infinity for 0 &lt; abs(x) &lt; 1, and plus zero for abs(x) &gt; 1. 
            </description>
            </item>
            <item>
            <description>
            pow(x, +Inf) returns plus zero for 0 &lt; abs(x) &lt; 1, and plus infinity for abs(x) &gt; 1. 
            </description>
            </item>
            <item>
            <description>
            pow(-Inf, y) returns minus zero for y a negative odd integer. 
            </description>
            </item>
            <item>
            <description>
            pow(-Inf, y) returns plus zero for y negative and not an odd integer. 
            </description>
            </item>
            <item>
            <description>
            pow(-Inf, y) returns minus infinity for y a positive odd integer. 
            </description>
            </item>
            <item>
            <description>
            pow(-Inf, y) returns plus infinity for y positive and not an odd integer. 
            </description>
            </item>
            <item>
            <description>
            pow(+Inf, y) returns plus zero for y negative, and plus infinity for y positive. 
            </description>
            </item>
            </list>
            <para>
            Note: When 0 is of integer type, it is regarded as +0 by these functions.
            We do not use the usual limit rules in this case, as these rules are not used for pow.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqr(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqr</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cbrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cbrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rootn_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_root(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow_z(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ui_pow_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ui_pow_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ui_pow(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ui_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_neg</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_abs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_dim(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_dim</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to 10.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = op1^3.
            Assert.IsTrue(mpfr_lib.mpfr_pow_ui(rop, op1, 3U, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is 1000.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 1000.0);
            
            // Release unmanaged memory allocated for rop and op1.
            mpfr_lib.mpfr_clears(rop, op1, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to 10.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = op1^3.
            Assert.IsTrue(mpfr_lib.mpfr_pow_ui(rop, op1, 3U, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is 1000.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 1000.0)
            
            ' Release unmanaged memory allocated for rop and op1.
            mpfr_lib.mpfr_clears(rop, op1, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_ui_pow_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> raised to <paramref name="op2"/>, rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            Special values are handled as described in the ISO C99 and IEEE 754-2008 standards for the pow function: 
            </para>
            <list type="bullet">
            <item>
            <description>
            pow(±0, y) returns plus or minus infinity for y a negative odd integer. 
            </description>
            </item>
            <item>
            <description>
            pow(±0, y) returns plus infinity for y negative and not an odd integer. 
            </description>
            </item>
            <item>
            <description>
            pow(±0, y) returns plus or minus zero for y a positive odd integer. 
            </description>
            </item>
            <item>
            <description>
            pow(±0, y) returns plus zero for y positive and not an odd integer. 
            </description>
            </item>
            <item>
            <description>
            pow(-1, ±Inf) returns 1. 
            </description>
            </item>
            <item>
            <description>
            pow(+1, y) returns 1 for any y, even a NaN. 
            </description>
            </item>
            <item>
            <description>
            pow(x, ±0) returns 1 for any x, even a NaN. 
            </description>
            </item>
            <item>
            <description>
            pow(x, y) returns NaN for finite negative x and finite non-integer y. 
            </description>
            </item>
            <item>
            <description>
            pow(x, -Inf) returns plus infinity for 0 &lt; abs(x) &lt; 1, and plus zero for abs(x) &gt; 1. 
            </description>
            </item>
            <item>
            <description>
            pow(x, +Inf) returns plus zero for 0 &lt; abs(x) &lt; 1, and plus infinity for abs(x) &gt; 1. 
            </description>
            </item>
            <item>
            <description>
            pow(-Inf, y) returns minus zero for y a negative odd integer. 
            </description>
            </item>
            <item>
            <description>
            pow(-Inf, y) returns plus zero for y negative and not an odd integer. 
            </description>
            </item>
            <item>
            <description>
            pow(-Inf, y) returns minus infinity for y a positive odd integer. 
            </description>
            </item>
            <item>
            <description>
            pow(-Inf, y) returns plus infinity for y positive and not an odd integer. 
            </description>
            </item>
            <item>
            <description>
            pow(+Inf, y) returns plus zero for y negative, and plus infinity for y positive. 
            </description>
            </item>
            </list>
            <para>
            Note: When 0 is of integer type, it is regarded as +0 by these functions.
            We do not use the usual limit rules in this case, as these rules are not used for pow.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqr(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqr</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cbrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cbrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rootn_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_root(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow_z(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ui_pow_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ui_pow_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ui_pow(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ui_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_neg</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_abs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_dim(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_dim</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = 2^10.
            Assert.IsTrue(mpfr_lib.mpfr_ui_pow_ui(rop, 2, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is 1024.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 1024.0);
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clear(rop);
            </code> 
            <code language="VB.NET">
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = 2^10.
            Assert.IsTrue(mpfr_lib.mpfr_ui_pow_ui(rop, 2, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is 1024.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 1024.0)
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clear(rop)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_ui_pow(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> raised to <paramref name="op2"/>, rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            Special values are handled as described in the ISO C99 and IEEE 754-2008 standards for the pow function: 
            </para>
            <list type="bullet">
            <item>
            <description>
            pow(±0, y) returns plus or minus infinity for y a negative odd integer. 
            </description>
            </item>
            <item>
            <description>
            pow(±0, y) returns plus infinity for y negative and not an odd integer. 
            </description>
            </item>
            <item>
            <description>
            pow(±0, y) returns plus or minus zero for y a positive odd integer. 
            </description>
            </item>
            <item>
            <description>
            pow(±0, y) returns plus zero for y positive and not an odd integer. 
            </description>
            </item>
            <item>
            <description>
            pow(-1, ±Inf) returns 1. 
            </description>
            </item>
            <item>
            <description>
            pow(+1, y) returns 1 for any y, even a NaN. 
            </description>
            </item>
            <item>
            <description>
            pow(x, ±0) returns 1 for any x, even a NaN. 
            </description>
            </item>
            <item>
            <description>
            pow(x, y) returns NaN for finite negative x and finite non-integer y. 
            </description>
            </item>
            <item>
            <description>
            pow(x, -Inf) returns plus infinity for 0 &lt; abs(x) &lt; 1, and plus zero for abs(x) &gt; 1. 
            </description>
            </item>
            <item>
            <description>
            pow(x, +Inf) returns plus zero for 0 &lt; abs(x) &lt; 1, and plus infinity for abs(x) &gt; 1. 
            </description>
            </item>
            <item>
            <description>
            pow(-Inf, y) returns minus zero for y a negative odd integer. 
            </description>
            </item>
            <item>
            <description>
            pow(-Inf, y) returns plus zero for y negative and not an odd integer. 
            </description>
            </item>
            <item>
            <description>
            pow(-Inf, y) returns minus infinity for y a positive odd integer. 
            </description>
            </item>
            <item>
            <description>
            pow(-Inf, y) returns plus infinity for y positive and not an odd integer. 
            </description>
            </item>
            <item>
            <description>
            pow(+Inf, y) returns plus zero for y negative, and plus infinity for y positive. 
            </description>
            </item>
            </list>
            <para>
            Note: When 0 is of integer type, it is regarded as +0 by these functions.
            We do not use the usual limit rules in this case, as these rules are not used for pow.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqr(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqr</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cbrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cbrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rootn_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_root(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow_z(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ui_pow_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ui_pow_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ui_pow(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ui_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_neg</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_abs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_dim(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_dim</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op2 to 10.
            mpfr_t op2 = new mpfr_t();
            mpfr_lib.mpfr_init2(op2, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = 2^op2.
            Assert.IsTrue(mpfr_lib.mpfr_ui_pow(rop, 2, op2, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is 1024.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 1024.0);
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op2, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op2 to 10.
            Dim op2 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op2, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = 2^op2.
            Assert.IsTrue(mpfr_lib.mpfr_ui_pow(rop, 2, op2, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is 1024.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 1024.0)
            
             ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op2, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow_z(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> raised to <paramref name="op2"/>, rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            Special values are handled as described in the ISO C99 and IEEE 754-2008 standards for the pow function: 
            </para>
            <list type="bullet">
            <item>
            <description>
            pow(±0, y) returns plus or minus infinity for y a negative odd integer. 
            </description>
            </item>
            <item>
            <description>
            pow(±0, y) returns plus infinity for y negative and not an odd integer. 
            </description>
            </item>
            <item>
            <description>
            pow(±0, y) returns plus or minus zero for y a positive odd integer. 
            </description>
            </item>
            <item>
            <description>
            pow(±0, y) returns plus zero for y positive and not an odd integer. 
            </description>
            </item>
            <item>
            <description>
            pow(-1, ±Inf) returns 1. 
            </description>
            </item>
            <item>
            <description>
            pow(+1, y) returns 1 for any y, even a NaN. 
            </description>
            </item>
            <item>
            <description>
            pow(x, ±0) returns 1 for any x, even a NaN. 
            </description>
            </item>
            <item>
            <description>
            pow(x, y) returns NaN for finite negative x and finite non-integer y. 
            </description>
            </item>
            <item>
            <description>
            pow(x, -Inf) returns plus infinity for 0 &lt; abs(x) &lt; 1, and plus zero for abs(x) &gt; 1. 
            </description>
            </item>
            <item>
            <description>
            pow(x, +Inf) returns plus zero for 0 &lt; abs(x) &lt; 1, and plus infinity for abs(x) &gt; 1. 
            </description>
            </item>
            <item>
            <description>
            pow(-Inf, y) returns minus zero for y a negative odd integer. 
            </description>
            </item>
            <item>
            <description>
            pow(-Inf, y) returns plus zero for y negative and not an odd integer. 
            </description>
            </item>
            <item>
            <description>
            pow(-Inf, y) returns minus infinity for y a positive odd integer. 
            </description>
            </item>
            <item>
            <description>
            pow(-Inf, y) returns plus infinity for y positive and not an odd integer. 
            </description>
            </item>
            <item>
            <description>
            pow(+Inf, y) returns plus zero for y negative, and plus infinity for y positive. 
            </description>
            </item>
            </list>
            <para>
            Note: When 0 is of integer type, it is regarded as +0 by these functions.
            We do not use the usual limit rules in this case, as these rules are not used for pow.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqr(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqr</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cbrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cbrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rootn_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_root(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow_z(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ui_pow_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ui_pow_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ui_pow(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ui_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_neg</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_abs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_dim(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_dim</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to 10.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new integer op2 to -210.
            mpz_t op2 = "3";
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = op1^op2.
            Assert.IsTrue(mpfr_lib.mpfr_pow_z(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is 1000.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 1000.0);
            
            // Release unmanaged memory allocated for rop, op1, and op2.
            mpfr_lib.mpfr_clears(rop, op1, null);
            gmp_lib.mpz_clear(op2);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to 10.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new integer op2 to -210.
            Dim op2 As mpz_t = "3" 
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = op1^op2.
            Assert.IsTrue(mpfr_lib.mpfr_pow_z(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is 1000.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 1000.0)
            
            ' Release unmanaged memory allocated for rop, op1, and op2.
            mpfr_lib.mpfr_clears(rop, op1, Nothing)
            gmp_lib.mpz_clear(op2)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the square root of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            Set <paramref name="rop"/> to -0 if <paramref name="op"/> is -0, to be consistent with the IEEE 754 standard.
            Set <paramref name="rop"/> to NaN if <paramref name="op"/> is negative. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqr(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqr</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rec_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rec_sqrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cbrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cbrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rootn_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_root(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_neg</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_abs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_dim(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_dim</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 100.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_init_set_si(op, 100, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = sqrt(op).
            Assert.IsTrue(mpfr_lib.mpfr_sqrt(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of z is 10.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 10.0);
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 100.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_init_set_si(op, 100, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            ' Set rop = sqrt(op).
            Assert.IsTrue(mpfr_lib.mpfr_sqrt(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of z is 10.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 10.0)
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the square root of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            Set <paramref name="rop"/> to -0 if <paramref name="op"/> is -0, to be consistent with the IEEE 754 standard.
            Set <paramref name="rop"/> to NaN if <paramref name="op"/> is negative. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqr(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqr</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rec_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rec_sqrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cbrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cbrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rootn_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_root(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_neg</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_abs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_dim(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_dim</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = sqrt(100).
            Assert.IsTrue(mpfr_lib.mpfr_sqrt_ui(rop, 100U, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is 10.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 10.0);
            
            // Release unmanaged memory allocated for rop.
            mpfr_lib.mpfr_clear(rop);
            </code> 
            <code language="VB.NET">
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = sqrt(100).
            Assert.IsTrue(mpfr_lib.mpfr_sqrt_ui(rop, 100U, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is 10.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 10.0)
            
            ' Release unmanaged memory allocated for rop.
            mpfr_lib.mpfr_clear(rop)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_rec_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the reciprocal square root of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            Set <paramref name="rop"/> to +Inf if <paramref name="op"/> is ±0, +0 if <paramref name="op"/> is +Inf,
            and NaN if <paramref name="op"/> is negative.
            Warning!
            Therefore the result on -0 is different from the one of the rSqrt function recommended by the IEEE 754-2008 standard (Section 9.2.1), which is -Inf instead of +Inf. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqr(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqr</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rec_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rec_sqrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cbrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cbrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rootn_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_root(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_neg</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_abs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_dim(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_dim</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 25.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 25, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = 1 / sqrt(op).
            Assert.IsTrue(mpfr_lib.mpfr_rec_sqrt(rop, op, mpfr_rnd_t.MPFR_RNDN) == 1);
            
            // Assert the value of rop.
            Assert.IsTrue(rop.ToString() == "0.200000000000000000003e0");
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 25.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 25, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = 1 / sqrt(op).
            Assert.IsTrue(mpfr_lib.mpfr_rec_sqrt(rop, op, mpfr_rnd_t.MPFR_RNDN) = 1)
            
            ' Assert the value of rop.
            Assert.IsTrue(rop.ToString() = "0.200000000000000000003e0")
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> + <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            The IEEE-754 rules are used, in particular for signed zeros.
            But for types having no signed zeros, 0 is considered unsigned
            (i.e., (+0) + 0 = (+0) and (-0) + 0 = (-0)).
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add_z(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add_q(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sum(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t[],System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sum</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqr(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqr</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cbrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cbrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rootn_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_root(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_neg</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_abs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_dim(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_dim</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to 10.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new floating-point number op2 to -210.
            mpfr_t op2 = new mpfr_t();
            mpfr_lib.mpfr_init2(op2, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, -210, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
             mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = op1 + op2.
            Assert.IsTrue(mpfr_lib.mpfr_add(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is -200.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == -200.0);
            
            // Release unmanaged memory allocated for rop, op1, and op2.
            mpfr_lib.mpfr_clears(rop, op1, op2, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to 10.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new floating-point number op2 to -210.
            Dim op2 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op2, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, -210, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = op1 + op2.
            Assert.IsTrue(mpfr_lib.mpfr_add(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is -200.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = -200.0)
            
            ' Release unmanaged memory allocated for rop, op1, and op2.
            mpfr_lib.mpfr_clears(rop, op1, op2, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> - <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            The IEEE-754 rules are used, in particular for signed zeros.
            But for types having no signed zeros, 0 is considered unsigned
            (i.e., (+0) - 0 = (+0), (-0) - 0 = (-0), 0 - (+0) = (-0) and 0 - (-0) = (+0)).
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ui_sub(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ui_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_si_sub(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_si_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_d_sub(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_d_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_z_sub(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_z_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_z(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_q(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqr(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqr</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cbrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cbrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rootn_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_root(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_neg</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_abs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_dim(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_dim</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to 10.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new floating-point number op2 to -210.
            mpfr_t op2 = new mpfr_t();
            mpfr_lib.mpfr_init2(op2, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, -210, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = op1 - op2.
            Assert.IsTrue(mpfr_lib.mpfr_sub(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is 220.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 220.0);
            
            // Release unmanaged memory allocated for rop, op1, and op2.
            mpfr_lib.mpfr_clears(rop, op1, op2, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to 10.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new floating-point number op2 to -210.
            Dim op2 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op2, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, -210, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = op1 - op2.
            Assert.IsTrue(mpfr_lib.mpfr_sub(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is 220.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 220.0)
            
            ' Release unmanaged memory allocated for rop, op1, and op2.
            mpfr_lib.mpfr_clears(rop, op1, op2, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> * <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            When a result is zero, its sign is the product of the signs of the operands
            (for types having no signed zeros, 0 is considered positive).
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_z(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_q(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqr(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqr</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cbrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cbrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rootn_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_root(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_neg</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_abs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_dim(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_dim</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_2ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_2ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_2si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_2si</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to 10.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new floating-point number op2 to -210.
            mpfr_t op2 = new mpfr_t();
            mpfr_lib.mpfr_init2(op2, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, -210, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = op1 * op2.
            Assert.IsTrue(mpfr_lib.mpfr_mul(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is -2100.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == -2100.0);
            
            // Release unmanaged memory allocated for rop, op1, and op2.
            mpfr_lib.mpfr_clears(rop, op1, op2, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to 10.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new floating-point number op2 to -210.
            Dim op2 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op2, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, -210, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = op1 * op2.
            Assert.IsTrue(mpfr_lib.mpfr_mul(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is -2100.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = -2100.0)
            
            ' Release unmanaged memory allocated for rop, op1, and op2.
            mpfr_lib.mpfr_clears(rop, op1, op2, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_div(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> / <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            When a result is zero, its sign is the product of the signs of the operands.
            For types having no signed zeros, 0 is considered positive; but note that if 
            <paramref name="op1"/> is non-zero and <paramref name="op2"/> is zero, the result might change from
            ±Inf to NaN in future MPFR versions if there is an opposite decision on the IEEE 754 side. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqr(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqr</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ui_div(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ui_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_si_div(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_si_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_d_div(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_d_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_z(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_q(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cbrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cbrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rootn_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_root(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_neg</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_abs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_dim(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_dim</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to -210.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new floating-point number op2 to 10.
            mpfr_t op2 = new mpfr_t();
            mpfr_lib.mpfr_init2(op2, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = op1 / op2.
            Assert.IsTrue(mpfr_lib.mpfr_div(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is -21.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == -21.0);
            
            // Release unmanaged memory allocated for rop, op1, and op2.
            mpfr_lib.mpfr_clears(rop, op1, op2, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to -210.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new floating-point number op2 to 10.
            Dim op2 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op2, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = op1 / op2.
            Assert.IsTrue(mpfr_lib.mpfr_div(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is -21.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = -21.0)
            
            ' Release unmanaged memory allocated for rop, op1, and op2.
            mpfr_lib.mpfr_clears(rop, op1, op2, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_add_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> + <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            The IEEE-754 rules are used, in particular for signed zeros.
            But for types having no signed zeros, 0 is considered unsigned
            (i.e., (+0) + 0 = (+0) and (-0) + 0 = (-0)).
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add_z(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add_q(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sum(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t[],System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sum</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqr(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqr</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cbrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cbrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rootn_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_root(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_neg</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_abs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_dim(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_dim</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to 10.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = op1 + 210.
            Assert.IsTrue(mpfr_lib.mpfr_add_ui(rop, op1, 210, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is 220.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 220.0);
            
            // Release unmanaged memory allocated for rop and op1.
            mpfr_lib.mpfr_clears(rop, op1, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to 10.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = op1 + 210.
            Assert.IsTrue(mpfr_lib.mpfr_add_ui(rop, op1, 210, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is 220.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 220.0)
            
            ' Release unmanaged memory allocated for rop and op1.
            mpfr_lib.mpfr_clears(rop, op1, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> - <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            The IEEE-754 rules are used, in particular for signed zeros.
            But for types having no signed zeros, 0 is considered unsigned
            (i.e., (+0) - 0 = (+0), (-0) - 0 = (-0), 0 - (+0) = (-0) and 0 - (-0) = (+0)).
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ui_sub(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ui_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_si_sub(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_si_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_d_sub(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_d_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_z_sub(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_z_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_z(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_q(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqr(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqr</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cbrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cbrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rootn_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_root(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_neg</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_abs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_dim(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_dim</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to 100.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 100, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set z = op1 - 8.
            Assert.IsTrue(mpfr_lib.mpfr_sub_ui(rop, op1, 8U, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is 92.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 92.0);
            
            // Release unmanaged memory allocated for rop and op1.
            mpfr_lib.mpfr_clears(rop, op1, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to 100.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 100, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set z = op1 - 8.
            Assert.IsTrue(mpfr_lib.mpfr_sub_ui(rop, op1, 8U, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is 92.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 92.0)
            
            ' Release unmanaged memory allocated for rop and op1.
            mpfr_lib.mpfr_clears(rop, op1, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_ui_sub(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> - <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            The IEEE-754 rules are used, in particular for signed zeros.
            But for types having no signed zeros, 0 is considered unsigned
            (i.e., (+0) - 0 = (+0), (-0) - 0 = (-0), 0 - (+0) = (-0) and 0 - (-0) = (+0)).
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ui_sub(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ui_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_si_sub(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_si_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_d_sub(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_d_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_z_sub(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_z_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_z(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_q(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqr(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqr</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cbrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cbrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rootn_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_root(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_neg</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_abs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_dim(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_dim</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op2 to -210.
            mpfr_t op2 = new mpfr_t();
            mpfr_lib.mpfr_init2(op2, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, -210, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = 10 - y.
            Assert.IsTrue(mpfr_lib.mpfr_ui_sub(rop, 10U, op2, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of z is 220.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 220.0);
            
            // Release unmanaged memory allocated for rop, and op2.
            mpfr_lib.mpfr_clears(rop, op2, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op2 to -210.
            Dim op2 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op2, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, -210, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            im rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = 10 - y.
            Assert.IsTrue(mpfr_lib.mpfr_ui_sub(rop, 10U, op2, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of z is 220.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 220.0)
            
            ' Release unmanaged memory allocated for rop, and op2.
            mpfr_lib.mpfr_clears(rop, op2, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> * <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            When a result is zero, its sign is the product of the signs of the operands
            (for types having no signed zeros, 0 is considered positive).
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_z(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_q(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqr(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqr</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cbrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cbrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rootn_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_root(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_neg</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_abs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_dim(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_dim</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_2ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_2ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_2si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_2si</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to 100.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 100, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set z = op1 * 8.
            Assert.IsTrue(mpfr_lib.mpfr_mul_ui(rop, op1, 8U, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is 800.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 800.0);
            
            // Release unmanaged memory allocated for rop and op1.
            mpfr_lib.mpfr_clears(rop, op1, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to 100.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 100, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set z = op1 * 8.
            Assert.IsTrue(mpfr_lib.mpfr_mul_ui(rop, op1, 8U, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is 800.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 800.0)
            
            ' Release unmanaged memory allocated for rop and op1.
            mpfr_lib.mpfr_clears(rop, op1, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> / <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            When a result is zero, its sign is the product of the signs of the operands.
            For types having no signed zeros, 0 is considered positive; but note that if 
            <paramref name="op1"/> is non-zero and <paramref name="op2"/> is zero, the result might change from
            ±Inf to NaN in future MPFR versions if there is an opposite decision on the IEEE 754 side. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqr(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqr</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ui_div(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ui_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_si_div(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_si_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_d_div(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_d_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_z(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_q(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cbrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cbrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rootn_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_root(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_neg</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_abs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_dim(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_dim</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to -210.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = op1 / 10.
            Assert.IsTrue(mpfr_lib.mpfr_div_ui(rop, op1, 10U, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is -21.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == -21.0);
            
            // Release unmanaged memory allocated for rop and op1.
            mpfr_lib.mpfr_clears(rop, op1, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to -210.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = op1 / 10.
            Assert.IsTrue(mpfr_lib.mpfr_div_ui(rop, op1, 10U, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is -21.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = -21.0)
            
            ' Release unmanaged memory allocated for rop and op1.
            mpfr_lib.mpfr_clears(rop, op1, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_ui_div(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> / <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            When a result is zero, its sign is the product of the signs of the operands.
            For types having no signed zeros, 0 is considered positive; but note that if 
            <paramref name="op1"/> is non-zero and <paramref name="op2"/> is zero, the result might change from
            ±Inf to NaN in future MPFR versions if there is an opposite decision on the IEEE 754 side. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqr(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqr</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ui_div(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ui_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_si_div(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_si_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_d_div(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_d_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_z(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_q(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cbrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cbrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rootn_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_root(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_neg</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_abs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_dim(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_dim</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 10.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = 210 / op.
            Assert.IsTrue(mpfr_lib.mpfr_ui_div(rop, 210U, op, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is 21.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 21.0);
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 10.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = 210 / op.
            Assert.IsTrue(mpfr_lib.mpfr_ui_div(rop, 210U, op, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is 21.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 21.0)
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_add_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> + <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            The IEEE-754 rules are used, in particular for signed zeros.
            But for types having no signed zeros, 0 is considered unsigned
            (i.e., (+0) + 0 = (+0) and (-0) + 0 = (-0)).
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add_z(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add_q(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sum(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t[],System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sum</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqr(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqr</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cbrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cbrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rootn_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_root(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_neg</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_abs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_dim(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_dim</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to 10.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = op1 + 210.
            Assert.IsTrue(mpfr_lib.mpfr_add_si(rop, op1, 210, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is 220.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 220.0);
            
            // Release unmanaged memory allocated for rop and op1.
            mpfr_lib.mpfr_clears(rop, op1, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to 10.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = op1 + 210.
            Assert.IsTrue(mpfr_lib.mpfr_add_si(rop, op1, 210, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is 220.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 220.0)
            
            ' Release unmanaged memory allocated for rop and op1.
            mpfr_lib.mpfr_clears(rop, op1, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> - <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            The IEEE-754 rules are used, in particular for signed zeros.
            But for types having no signed zeros, 0 is considered unsigned
            (i.e., (+0) - 0 = (+0), (-0) - 0 = (-0), 0 - (+0) = (-0) and 0 - (-0) = (+0)).
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ui_sub(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ui_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_si_sub(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_si_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_d_sub(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_d_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_z_sub(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_z_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_z(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_q(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqr(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqr</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cbrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cbrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rootn_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_root(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_neg</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_abs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_dim(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_dim</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to 100.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 100, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set z = op1 - 8.
            Assert.IsTrue(mpfr_lib.mpfr_sub_si(rop, op1, 8, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is 92.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 92.0);
            
            // Release unmanaged memory allocated for rop and op1.
            mpfr_lib.mpfr_clears(rop, op1, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to 100.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 100, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set z = op1 - 8.
            Assert.IsTrue(mpfr_lib.mpfr_sub_si(rop, op1, 8, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is 92.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 92.0)
            
            ' Release unmanaged memory allocated for rop and op1.
            mpfr_lib.mpfr_clears(rop, op1, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_si_sub(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> - <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            The IEEE-754 rules are used, in particular for signed zeros.
            But for types having no signed zeros, 0 is considered unsigned
            (i.e., (+0) - 0 = (+0), (-0) - 0 = (-0), 0 - (+0) = (-0) and 0 - (-0) = (+0)).
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ui_sub(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ui_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_si_sub(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_si_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_d_sub(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_d_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_z_sub(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_z_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_z(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_q(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqr(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqr</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cbrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cbrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rootn_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_root(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_neg</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_abs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_dim(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_dim</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op2 to 4.
            mpfr_t op2 = new mpfr_t();
            mpfr_lib.mpfr_init2(op2, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 4, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set z = 100 - op2.
            Assert.IsTrue(mpfr_lib.mpfr_si_sub(rop, 100, op2, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is 96.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 96.0);
            
            // Release unmanaged memory allocated for rop and op2.
            mpfr_lib.mpfr_clears(rop, op2, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op2 to 4.
            Dim op2 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op2, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 4, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set z = 100 - op2.
            Assert.IsTrue(mpfr_lib.mpfr_si_sub(rop, 100, op2, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is 96.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 96.0)
            
            ' Release unmanaged memory allocated for rop and op2.
            mpfr_lib.mpfr_clears(rop, op2, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> * <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            When a result is zero, its sign is the product of the signs of the operands
            (for types having no signed zeros, 0 is considered positive).
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_z(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_q(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqr(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqr</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cbrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cbrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rootn_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_root(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_neg</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_abs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_dim(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_dim</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_2ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_2ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_2si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_2si</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to 100.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 100, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set z = op1 * 8.
            Assert.IsTrue(mpfr_lib.mpfr_mul_si(rop, op1, 8, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is 800.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 800.0);
            
            // Release unmanaged memory allocated for rop and op1.
            mpfr_lib.mpfr_clears(rop, op1, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to 100.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 100, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set z = op1 * 8.
            Assert.IsTrue(mpfr_lib.mpfr_mul_si(rop, op1, 8, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is 800.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 800.0)
            
            ' Release unmanaged memory allocated for rop and op1.
            mpfr_lib.mpfr_clears(rop, op1, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> / <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            When a result is zero, its sign is the product of the signs of the operands.
            For types having no signed zeros, 0 is considered positive; but note that if 
            <paramref name="op1"/> is non-zero and <paramref name="op2"/> is zero, the result might change from
            ±Inf to NaN in future MPFR versions if there is an opposite decision on the IEEE 754 side. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqr(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqr</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ui_div(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ui_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_si_div(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_si_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_d_div(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_d_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_z(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_q(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cbrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cbrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rootn_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_root(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_neg</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_abs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_dim(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_dim</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to -210.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = op1 / 10.
            Assert.IsTrue(mpfr_lib.mpfr_div_si(rop, op1, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is -21.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == -21.0);
            
            // Release unmanaged memory allocated for rop and op1.
            mpfr_lib.mpfr_clears(rop, op1, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to -210.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = op1 / 10.
            Assert.IsTrue(mpfr_lib.mpfr_div_si(rop, op1, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is -21.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = -21.0)
            
            ' Release unmanaged memory allocated for rop and op1.
            mpfr_lib.mpfr_clears(rop, op1, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_si_div(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> / <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            When a result is zero, its sign is the product of the signs of the operands.
            For types having no signed zeros, 0 is considered positive; but note that if 
            <paramref name="op1"/> is non-zero and <paramref name="op2"/> is zero, the result might change from
            ±Inf to NaN in future MPFR versions if there is an opposite decision on the IEEE 754 side. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqr(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqr</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ui_div(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ui_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_si_div(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_si_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_d_div(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_d_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_z(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_q(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cbrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cbrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rootn_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_root(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_neg</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_abs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_dim(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_dim</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op2 to 4.
            mpfr_t op2 = new mpfr_t();
            mpfr_lib.mpfr_init2(op2, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 4, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set z = 100 / op2.
            Assert.IsTrue(mpfr_lib.mpfr_si_div(rop, 100, op2, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is 25.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 25.0);
            
            // Release unmanaged memory allocated for rop and op2.
            mpfr_lib.mpfr_clears(rop, op2, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op2 to 4.
            Dim op2 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op2, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 4, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set z = 100 / op2.
            Assert.IsTrue(mpfr_lib.mpfr_si_div(rop, 100, op2, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is 25.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 25.0)
            
            ' Release unmanaged memory allocated for rop and op2.
            mpfr_lib.mpfr_clears(rop, op2, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_add_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> + <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            The IEEE-754 rules are used, in particular for signed zeros.
            But for types having no signed zeros, 0 is considered unsigned
            (i.e., (+0) + 0 = (+0) and (-0) + 0 = (-0)).
            The <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add_d</see> function assumes that the radix of the double type is a power of 2,
            with a precision at most that declared by the C implementation
            (macro IEEE_DBL_MANT_DIG, and if not defined 53 bits). 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add_z(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add_q(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sum(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t[],System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sum</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqr(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqr</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cbrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cbrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rootn_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_root(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_neg</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_abs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_dim(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_dim</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to 10.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = op1 + 210.
            Assert.IsTrue(mpfr_lib.mpfr_add_d(rop, op1, 210.0, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is 220.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 220.0);
            
            // Release unmanaged memory allocated for rop and op1.
            mpfr_lib.mpfr_clears(rop, op1, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to 10.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = op1 + 210.
            Assert.IsTrue(mpfr_lib.mpfr_add_d(rop, op1, 210.0, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is 220.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 220.0)
            
            ' Release unmanaged memory allocated for rop and op1.
            mpfr_lib.mpfr_clears(rop, op1, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> - <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            The IEEE-754 rules are used, in particular for signed zeros.
            But for types having no signed zeros, 0 is considered unsigned
            (i.e., (+0) - 0 = (+0), (-0) - 0 = (-0), 0 - (+0) = (-0) and 0 - (-0) = (+0)).
            The same restrictions than for <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add_d</see> apply to <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_d</see>. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ui_sub(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ui_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_si_sub(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_si_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_d_sub(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_d_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_z_sub(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_z_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_z(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_q(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqr(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqr</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cbrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cbrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rootn_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_root(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_neg</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_abs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_dim(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_dim</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to 100.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 100, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set z = op1 - 8.
            Assert.IsTrue(mpfr_lib.mpfr_sub_d(rop, op1, 8.0, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is 92.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 92.0);
            
            // Release unmanaged memory allocated for rop and op1.
            mpfr_lib.mpfr_clears(rop, op1, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to 100.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 100, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set z = op1 - 8.
            Assert.IsTrue(mpfr_lib.mpfr_sub_d(rop, op1, 8.0, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is 92.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 92.0)
            
            ' Release unmanaged memory allocated for rop and op1.
            mpfr_lib.mpfr_clears(rop, op1, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_d_sub(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> - <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            The IEEE-754 rules are used, in particular for signed zeros.
            But for types having no signed zeros, 0 is considered unsigned
            (i.e., (+0) - 0 = (+0), (-0) - 0 = (-0), 0 - (+0) = (-0) and 0 - (-0) = (+0)).
            The same restrictions than for <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add_d</see> apply to <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_d_sub(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_d_sub</see> and <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_d</see>. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ui_sub(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ui_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_si_sub(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_si_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_d_sub(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_d_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_z_sub(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_z_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_z(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_q(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqr(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqr</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cbrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cbrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rootn_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_root(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_neg</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_abs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_dim(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_dim</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op2 to -210.
            mpfr_t op2 = new mpfr_t();
            mpfr_lib.mpfr_init2(op2, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, -210, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = 10.0 - op2.
            Assert.IsTrue(mpfr_lib.mpfr_d_sub(rop, 10.0, op2, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is 220.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 220.0);
            
            // Release unmanaged memory allocated for rop and op2.
            mpfr_lib.mpfr_clears(rop, op2, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op2 to -210.
            Dim op2 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op2, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, -210, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = 10.0 - op2.
            Assert.IsTrue(mpfr_lib.mpfr_d_sub(rop, 10.0, op2, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is 220.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 220.0)
            
            ' Release unmanaged memory allocated for rop and op2.
            mpfr_lib.mpfr_clears(rop, op2, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> * <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            When a result is zero, its sign is the product of the signs of the operands
            (for types having no signed zeros, 0 is considered positive).
            The same restrictions than for <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add_d</see> apply to <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_d</see>. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_z(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_q(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqr(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqr</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cbrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cbrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rootn_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_root(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_neg</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_abs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_dim(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_dim</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_2ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_2ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_2si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_2si</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to 100.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 100, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set z = op1 * 8.
            Assert.IsTrue(mpfr_lib.mpfr_mul_d(rop, op1, 8.0, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is 800.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 800.0);
            
            // Release unmanaged memory allocated for rop and op1.
            mpfr_lib.mpfr_clears(rop, op1, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to 100.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 100, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set z = op1 * 8.
            Assert.IsTrue(mpfr_lib.mpfr_mul_d(rop, op1, 8.0, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is 800.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 800.0)
            
            ' Release unmanaged memory allocated for rop and op1.
            mpfr_lib.mpfr_clears(rop, op1, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> / <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            When a result is zero, its sign is the product of the signs of the operands.
            For types having no signed zeros, 0 is considered positive; but note that if 
            <paramref name="op1"/> is non-zero and <paramref name="op2"/> is zero, the result might change from
            ±Inf to NaN in future MPFR versions if there is an opposite decision on the IEEE 754 side. 
            The same restrictions than for <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add_d</see> apply to <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_d_div(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_d_div</see> and <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_d</see>. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqr(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqr</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ui_div(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ui_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_si_div(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_si_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_d_div(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_d_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_z(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_q(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cbrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cbrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rootn_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_root(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_neg</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_abs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_dim(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_dim</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to -210.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = op1 / 10.0.
            Assert.IsTrue(mpfr_lib.mpfr_div_d(rop, op1, 10.0, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is -21.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == -21.0);
            
            // Release unmanaged memory allocated for rop and op1.
            mpfr_lib.mpfr_clears(rop, op1, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to -210.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = op1 / 10.0.
            Assert.IsTrue(mpfr_lib.mpfr_div_d(rop, op1, 10.0, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is -21.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = -21.0)
            
            ' Release unmanaged memory allocated for rop and op1.
            mpfr_lib.mpfr_clears(rop, op1, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_d_div(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> / <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            When a result is zero, its sign is the product of the signs of the operands.
            For types having no signed zeros, 0 is considered positive; but note that if 
            <paramref name="op1"/> is non-zero and <paramref name="op2"/> is zero, the result might change from
            ±Inf to NaN in future MPFR versions if there is an opposite decision on the IEEE 754 side. 
            The same restrictions than for <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add_d</see> apply to <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_d_div(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_d_div</see> and <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_d</see>. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqr(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqr</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ui_div(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ui_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_si_div(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_si_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_d_div(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_d_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_z(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_q(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cbrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cbrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rootn_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_root(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_neg</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_abs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_dim(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_dim</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op2 to 10.
            mpfr_t op2 = new mpfr_t();
            mpfr_lib.mpfr_init2(op2, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_init_set_si(op2, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = -210.0 / op2.
            Assert.IsTrue(mpfr_lib.mpfr_d_div(rop, -210.0, op2, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is -21.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == -21.0);
            
            // Release unmanaged memory allocated for rop and op2.
            mpfr_lib.mpfr_clears(rop, op2, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op2 to 10.
            Dim op2 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op2, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_init_set_si(op2, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = -210.0 / op2.
            Assert.IsTrue(mpfr_lib.mpfr_d_div(rop, -210.0, op2, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is -21.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = -21.0)
            
            ' Release unmanaged memory allocated for rop and op2.
            mpfr_lib.mpfr_clears(rop, op2, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqr(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the square of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqr(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqr</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cbrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cbrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rootn_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_root(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_neg</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_abs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_dim(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_dim</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 1.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = op^2.
            Assert.IsTrue(mpfr_lib.mpfr_sqr(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert the value of rop.
            Assert.IsTrue(rop.ToString() == "0.100000000000000000000e1");
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 1.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = op^2.
            Assert.IsTrue(mpfr_lib.mpfr_sqr(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert the value of rop.
            Assert.IsTrue(rop.ToString() = "0.100000000000000000000e1")
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_const_pi(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the value of Pi rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            This function caches the computed values to avoid other calculations if a lower or equal precision is requested.
            To free the cache, use <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_cache">mpfr_free_cache</see>.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_const_log2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_const_log2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_const_euler(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_const_euler</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_const_catalan(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_const_catalan</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_cache">mpfr_free_cache</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_cache2(Math.Mpfr.Native.mpfr_free_cache_t)">mpfr_free_cache2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_pool">mpfr_free_pool</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mp_memory_cleanup">mpfr_mp_memory_cleanup</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Assert that z is the Catalan's constant.
            Assert.IsTrue(mpfr_lib.mpfr_const_pi(rop, mpfr_rnd_t.MPFR_RNDN) == 1);
            Assert.IsTrue(rop.ToString() == "0.314159265358979323851e1");
            
            // Release unmanaged memory allocated for rop.
            mpfr_lib.mpfr_clear(rop);
            </code> 
            <code language="VB.NET">
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Assert that z is the Catalan's constant.
            Assert.IsTrue(mpfr_lib.mpfr_const_pi(rop, mpfr_rnd_t.MPFR_RNDN) = 1)
            Assert.IsTrue(rop.ToString() = "0.314159265358979323851e1")
            
            ' Release unmanaged memory allocated for rop.
            mpfr_lib.mpfr_clear(rop)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_const_log2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the logarithm of 2 rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            This function caches the computed values to avoid other calculations if a lower or equal precision is requested.
            To free the cache, use <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_cache">mpfr_free_cache</see>.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_const_pi(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_const_pi</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_const_euler(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_const_euler</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_const_catalan(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_const_catalan</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_cache">mpfr_free_cache</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_cache2(Math.Mpfr.Native.mpfr_free_cache_t)">mpfr_free_cache2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_pool">mpfr_free_pool</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mp_memory_cleanup">mpfr_mp_memory_cleanup</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Assert that rop is log(2).
            Assert.IsTrue(mpfr_lib.mpfr_const_log2(rop, mpfr_rnd_t.MPFR_RNDN) == 1);
            Assert.IsTrue(rop.ToString() == "0.693147180559945309429e0");
            
            // Release unmanaged memory allocated for rop.
            mpfr_lib.mpfr_clear(rop);
            </code> 
            <code language="VB.NET">
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Assert that rop is log(2).
            Assert.IsTrue(mpfr_lib.mpfr_const_log2(rop, mpfr_rnd_t.MPFR_RNDN) = 1)
            Assert.IsTrue(rop.ToString() = "0.693147180559945309429e0")
            
            ' Release unmanaged memory allocated for rop.
            mpfr_lib.mpfr_clear(rop)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_const_euler(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the value of Euler’s constant 0.577… rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            This function caches the computed values to avoid other calculations if a lower or equal precision is requested.
            To free the cache, use <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_cache">mpfr_free_cache</see>.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_const_log2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_const_log2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_const_pi(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_const_pi</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_const_catalan(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_const_catalan</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_cache">mpfr_free_cache</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_cache2(Math.Mpfr.Native.mpfr_free_cache_t)">mpfr_free_cache2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_pool">mpfr_free_pool</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mp_memory_cleanup">mpfr_mp_memory_cleanup</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Assert that rop is the Euler's constant.
            Assert.IsTrue(mpfr_lib.mpfr_const_euler(rop, mpfr_rnd_t.MPFR_RNDN) == 1);
             Assert.IsTrue(rop.ToString() == "0.577215664901532860616e0");
            
            // Release unmanaged memory allocated for rop.
            mpfr_lib.mpfr_clear(rop);
            </code> 
            <code language="VB.NET">
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Assert that rop is the Euler's constant.
            Assert.IsTrue(mpfr_lib.mpfr_const_euler(rop, mpfr_rnd_t.MPFR_RNDN) = 1)
            Assert.IsTrue(rop.ToString() = "0.577215664901532860616e0")
            
            ' Release unmanaged memory allocated for rop.
            mpfr_lib.mpfr_clear(rop)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_const_catalan(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the value of Catalan’s constant 0.915… rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            This function caches the computed values to avoid other calculations if a lower or equal precision is requested.
            To free the cache, use <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_cache">mpfr_free_cache</see>.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_const_log2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_const_log2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_const_pi(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_const_pi</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_const_euler(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_const_euler</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_cache">mpfr_free_cache</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_cache2(Math.Mpfr.Native.mpfr_free_cache_t)">mpfr_free_cache2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_pool">mpfr_free_pool</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mp_memory_cleanup">mpfr_mp_memory_cleanup</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Assert that rop is the Catalan's constant.
            Assert.IsTrue(mpfr_lib.mpfr_const_catalan(rop, mpfr_rnd_t.MPFR_RNDN) == -1);
            Assert.IsTrue(rop.ToString() == "0.915965594177219015048e0");
            
            // Release unmanaged memory allocated for rop.
            mpfr_lib.mpfr_clear(rop);
            </code> 
            <code language="VB.NET">
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Assert that rop is the Catalan's constant.
            Assert.IsTrue(mpfr_lib.mpfr_const_catalan(rop, mpfr_rnd_t.MPFR_RNDN) = -1)
            Assert.IsTrue(rop.ToString() = "0.915965594177219015048e0")
            
            ' Release unmanaged memory allocated for rop.
            mpfr_lib.mpfr_clear(rop)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_agm(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the arithmetic-geometric mean of <paramref name="op1"/> and <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            The arithmetic-geometric mean is the common limit of the sequences u(n) and v(n), where u(0) = <paramref name="op1"/>, v(0) = <paramref name="op2"/>,
            u(n + 1) is the arithmetic mean of u(n) and v(n), and v(n + 1) is the geometric mean of u(n) and v(n).
            If any operand is negative and the other one is not zero, set <paramref name="rop"/> to NaN.
            If any operand is zero and the other one is finite (resp. infinite), set <paramref name="rop"/> to +0 (resp. NaN).
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fac_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fac_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_eint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_eint</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_li2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_li2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_gamma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma_inc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_gamma_inc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lngamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_lngamma</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_digamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_digamma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_beta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_beta</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_zeta</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_zeta_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erf(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erfc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erfc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_j0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_j0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_j1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_j1</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_jn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_jn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_y0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_y0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_y1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_y1</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_yn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_yn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fms</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmms</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_hypot(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_hypot</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ai(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ai</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to 24.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 24, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new floating-point number op2 to 6.
            mpfr_t op2 = new mpfr_t();
            mpfr_lib.mpfr_init2(op2, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_init_set_si(op2, 6, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = agm(op1, op2).
            Assert.IsTrue(mpfr_lib.mpfr_agm(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) == -1);
            
            // Assert the value of rop.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 13.458171481725615420766813156);
            
            // Release unmanaged memory allocated for rop, op1, and op2.
            mpfr_lib.mpfr_clears(rop, op1, op2, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to 24.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 24, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new floating-point number op2 to 6.
            Dim op2 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op2, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_init_set_si(op2, 6, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = agm(op1, op2).
            Assert.IsTrue(mpfr_lib.mpfr_agm(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) = -1)
            
            ' Assert the value of rop.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 13.458171481725615420766813156)
            
            ' Release unmanaged memory allocated for rop, op1, and op2.
            mpfr_lib.mpfr_clears(rop, op1, op2, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_log(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the natural logarithm of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            Set <paramref name="rop"/> to +0 if <paramref name="op"/> is 1 (in all rounding modes), for consistency with the ISO C99 and IEEE 754-2008 standards.
            Set <paramref name="rop"/> to -Inf if <paramref name="op"/> is ±0 (i.e., the sign of the zero has no influence on the result). 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_log2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_log2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_log10(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_log10</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_log1p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_log1p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_exp2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_exp2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_exp10(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_exp10</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_expm1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_expm1</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 10.4.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop to log(op).
            Assert.IsTrue(mpfr_lib.mpfr_log(rop, op, mpfr_rnd_t.MPFR_RNDN) == 1);
            
            // Assert the value of rop.
            Assert.IsTrue(rop.ToString() == "0.234180580614732701452e1");
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 10.4.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop to log(op).
            Assert.IsTrue(mpfr_lib.mpfr_log(rop, op, mpfr_rnd_t.MPFR_RNDN) = 1)
            
            ' Assert the value of rop.
            Assert.IsTrue(rop.ToString() = "0.234180580614732701452e1")
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_log_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the natural logarithm of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand integer number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            Set <paramref name="rop"/> to +0 if <paramref name="op"/> is 1 (in all rounding modes), for consistency with the ISO C99 and IEEE 754-2008 standards.
            Set <paramref name="rop"/> to -Inf if <paramref name="op"/> is ±0 (i.e., the sign of the zero has no influence on the result). 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_log(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_log</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_log2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_log2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_log10(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_log10</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_log1p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_log1p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_exp2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_exp2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_exp10(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_exp10</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_expm1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_expm1</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop to log(10).
            Assert.IsTrue(mpfr_lib.mpfr_log_ui(rop, 10U, mpfr_rnd_t.MPFR_RNDN) == 1);
            
            // Assert the value of rop.
            Assert.IsTrue(rop.ToString() == "0.230258509299404568404e1");
            
            // Release unmanaged memory allocated for rop.
            mpfr_lib.mpfr_clear(rop);
            </code> 
            <code language="VB.NET">
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop to log(10).
            Assert.IsTrue(mpfr_lib.mpfr_log_ui(rop, 10U, mpfr_rnd_t.MPFR_RNDN) = 1)
            
            ' Assert the value of rop.
            Assert.IsTrue(rop.ToString() = "0.230258509299404568404e1")
            
            ' Release unmanaged memory allocated for rop.
            mpfr_lib.mpfr_clear(rop)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_log2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to log2(<paramref name="op"/>) rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            Set <paramref name="rop"/> to +0 if <paramref name="op"/> is 1 (in all rounding modes), for consistency with the ISO C99 and IEEE 754-2008 standards.
            Set <paramref name="rop"/> to -Inf if <paramref name="op"/> is ±0 (i.e., the sign of the zero has no influence on the result). 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_log(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_log</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_log_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_log_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_log10(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_log10</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_log1p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_log1p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_exp2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_exp2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_exp10(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_exp10</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_expm1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_expm1</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 10.4.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_init_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop to log10(op).
            Assert.IsTrue(mpfr_lib.mpfr_log2(rop, op, mpfr_rnd_t.MPFR_RNDN) == -1);
            
            // Assert the value of rop and sign.
            Assert.IsTrue(rop.ToString() == "0.337851162325372986173e1");
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 10.4.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_init_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop to log10(op).
            Assert.IsTrue(mpfr_lib.mpfr_log2(rop, op, mpfr_rnd_t.MPFR_RNDN) = -1)
            
            ' Assert the value of rop and sign.
            Assert.IsTrue(rop.ToString() = "0.337851162325372986173e1")
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_log10(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to log10(<paramref name="op"/>) rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            Set <paramref name="rop"/> to +0 if <paramref name="op"/> is 1 (in all rounding modes), for consistency with the ISO C99 and IEEE 754-2008 standards.
            Set <paramref name="rop"/> to -Inf if <paramref name="op"/> is ±0 (i.e., the sign of the zero has no influence on the result). 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_log(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_log</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_log_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_log_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_log2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_log2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_log1p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_log1p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_exp2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_exp2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_exp10(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_exp10</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_expm1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_expm1</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 10.4.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_init_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop to log10(op).
            Assert.IsTrue(mpfr_lib.mpfr_log10(rop, op, mpfr_rnd_t.MPFR_RNDN) == -1);
            
            // Assert the value of rop and sign.
            Assert.IsTrue(rop.ToString() == "0.101703333929878036968e1");
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 10.4.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_init_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop to log10(op).
            Assert.IsTrue(mpfr_lib.mpfr_log10(rop, op, mpfr_rnd_t.MPFR_RNDN) = -1)
            
            ' Assert the value of rop and sign.
            Assert.IsTrue(rop.ToString() = "0.101703333929878036968e1")
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_log1p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the logarithm of one plus <paramref name="op"/>, rounded in the direction <paramref name="rnd"/>. 
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            Set <paramref name="rop"/> to −Inf if <paramref name="op"/> is −1.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_log(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_log</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_log_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_log_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_log2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_log2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_log10(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_log10</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_exp2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_exp2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_exp10(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_exp10</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_expm1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_expm1</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 10.4.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop to log(1 + op).
            Assert.IsTrue(mpfr_lib.mpfr_log1p(rop, op, mpfr_rnd_t.MPFR_RNDN) == -1);
            
            // Assert the value of rop and sign.
            Assert.IsTrue(rop.ToString() == "0.243361335540044980788e1");
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 10.4.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop to log(1 + op).
            Assert.IsTrue(mpfr_lib.mpfr_log1p(rop, op, mpfr_rnd_t.MPFR_RNDN) = -1)
            
            ' Assert the value of rop and sign.
            Assert.IsTrue(rop.ToString() = "0.243361335540044980788e1")
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the exponential of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_log(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_log</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_log_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_log_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_log2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_log2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_log10(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_log10</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_log1p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_log1p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_exp2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_exp2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_exp10(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_exp10</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_expm1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_expm1</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 1.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = e^op.
            Assert.IsTrue(mpfr_lib.mpfr_exp(rop, op, mpfr_rnd_t.MPFR_RNDN) == 1);
            
            // Assert the value of rop.
            Assert.IsTrue(rop.ToString() == "0.271828182845904523543e1");
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 1.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = e^op.
            Assert.IsTrue(mpfr_lib.mpfr_exp(rop, op, mpfr_rnd_t.MPFR_RNDN) = 1)
            
            ' Assert the value of rop.
            Assert.IsTrue(rop.ToString() = "0.271828182845904523543e1")
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_exp2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to 2^<paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_log(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_log</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_log_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_log_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_log2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_log2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_log10(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_log10</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_log1p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_log1p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_exp10(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_exp10</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_expm1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_expm1</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 1.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = 2^op.
            Assert.IsTrue(mpfr_lib.mpfr_exp2(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert the value of rop.
            Assert.IsTrue(rop.ToString() == "0.200000000000000000000e1");
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 1.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = 2^op.
            Assert.IsTrue(mpfr_lib.mpfr_exp2(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert the value of rop.
            Assert.IsTrue(rop.ToString() = "0.200000000000000000000e1")
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_exp10(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to 10^<paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_log(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_log</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_log_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_log_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_log2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_log2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_log10(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_log10</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_log1p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_log1p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_exp2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_exp2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_expm1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_expm1</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 1.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = 10^op.
            Assert.IsTrue(mpfr_lib.mpfr_exp10(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert the value of rop.
            Assert.IsTrue(rop.ToString() == "0.100000000000000000000e2");
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 1.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = 10^op.
            Assert.IsTrue(mpfr_lib.mpfr_exp10(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert the value of rop.
            Assert.IsTrue(rop.ToString() = "0.100000000000000000000e2")
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_expm1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the e^<paramref name="op"/> - 1, rounded in the direction <paramref name="rnd"/>. 
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_log(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_log</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_log_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_log_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_log2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_log2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_log10(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_log10</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_log1p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_log1p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_exp2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_exp2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_exp10(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_exp10</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 1.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = e^op - 1.
            Assert.IsTrue(mpfr_lib.mpfr_expm1(rop, op, mpfr_rnd_t.MPFR_RNDN) == -1);
            
            // Assert the value of rop.
            Assert.IsTrue(rop.ToString() == "0.171828182845904523532e1");
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 1.
             Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = e^op - 1.
            Assert.IsTrue(mpfr_lib.mpfr_expm1(rop, op, mpfr_rnd_t.MPFR_RNDN) = -1)
            
            ' Assert the value of rop.
            Assert.IsTrue(rop.ToString() = "0.171828182845904523532e1")
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_eint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the exponential integral of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            This is the sum of Euler’s constant, of the logarithm of the absolute value of <paramref name="op"/>,
            and of the sum for k from 1 to infinity of (op^k)/(k · k!).
            For positive <paramref name="op"/>, it corresponds to the Ei function at op (see formula 5.1.10 from
            the Handbook of Mathematical Functions from Abramowitz and Stegun), and for negative <paramref name="op"/>,
            to the opposite of the E1 function (sometimes called eint1) at −op (formula 5.1.1 from the same reference).
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fac_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fac_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_li2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_li2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_gamma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma_inc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_gamma_inc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lngamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_lngamma</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_digamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_digamma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_beta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_beta</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_zeta</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_zeta_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erf(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erfc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erfc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_j0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_j0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_j1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_j1</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_jn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_jn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_y0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_y0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_y1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_y1</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_yn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_yn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fms</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmms</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_agm(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_agm</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_hypot(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_hypot</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ai(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ai</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 1.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop to exponential integral of op.
            Assert.IsTrue(mpfr_lib.mpfr_eint(rop, op, mpfr_rnd_t.MPFR_RNDN) == 1);
            
            // Assert the value of rop.
            Assert.IsTrue(rop.ToString() == "0.189511781635593675550e1");
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 1.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop to exponential integral of op.
            Assert.IsTrue(mpfr_lib.mpfr_eint(rop, op, mpfr_rnd_t.MPFR_RNDN) = 1)
            
            ' Assert the value of rop.
            Assert.IsTrue(rop.ToString() = "0.189511781635593675550e1")
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_li2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to real part of the dilogarithm of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            MPFR defines the dilogarithm function as the integral of -log(1 - t) / t from 0 to <paramref name="op"/>. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fac_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fac_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_eint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_eint</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_gamma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma_inc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_gamma_inc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lngamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_lngamma</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_digamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_digamma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_beta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_beta</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_zeta</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_zeta_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erf(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erfc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erfc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_j0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_j0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_j1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_j1</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_jn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_jn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_y0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_y0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_y1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_y1</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_yn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_yn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fms</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmms</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_agm(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_agm</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_hypot(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_hypot</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ai(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ai</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 10.4.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop to Re(Dilog(op)).
            Assert.IsTrue(mpfr_lib.mpfr_li2(rop, op, mpfr_rnd_t.MPFR_RNDN) == -1);
            
            // Assert the value of rop and sign.
            Assert.IsTrue(rop.ToString() == "0.449271207859561792596e0");
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 10.4.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
             mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop to Re(Dilog(op)).
            Assert.IsTrue(mpfr_lib.mpfr_li2(rop, op, mpfr_rnd_t.MPFR_RNDN) = -1)
            
            ' Assert the value of rop and sign.
            Assert.IsTrue(rop.ToString() = "0.449271207859561792596e0")
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">
            <summary>
            Compare <paramref name="op1"/> and <paramref name="op2"/>.
            </summary>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <returns>Return a positive value if <paramref name="op1"/> &gt; <paramref name="op2"/>, zero if <paramref name="op1"/> = <paramref name="op2"/>, and a negative value if <paramref name="op1"/> &lt; <paramref name="op2"/>.</returns>
            <remarks>
            <para>
            Both <paramref name="op1"/> and <paramref name="op2"/> are considered to their full own precision, which may differ.
            If one of the operands is NaN, set the erange flag and return zero. 
            </para>
            <para>
            Note: These functions may be useful to distinguish the three possible cases.
            If you need to distinguish two cases only, it is recommended to use the predicate functions
            (e.g., <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_equal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_equal_p</see> for the equality) described below; they behave like the IEEE 754 comparisons,
            in particular when one or both arguments are NaN.
            But only floating-point numbers can be compared (you may need to do a conversion first). 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_ui(Math.Mpfr.Native.mpfr_t,System.UInt32)">mpfr_cmp_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_si(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_cmp_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_d(Math.Mpfr.Native.mpfr_t,System.Double)">mpfr_cmp_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t)">mpfr_cmp_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t)">mpfr_cmp_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t)">mpfr_cmp_f</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_ui_2exp(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_exp_t)">mpfr_cmp_ui_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_si_2exp(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_exp_t)">mpfr_cmp_si_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmpabs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_cmpabs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nan_p(Math.Mpfr.Native.mpfr_t)">mpfr_nan_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inf_p(Math.Mpfr.Native.mpfr_t)">mpfr_inf_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_number_p(Math.Mpfr.Native.mpfr_t)">mpfr_number_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zero_p(Math.Mpfr.Native.mpfr_t)">mpfr_zero_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_regular_p(Math.Mpfr.Native.mpfr_t)">mpfr_regular_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sgn(Math.Mpfr.Native.mpfr_t)">mpfr_sgn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_greater_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_greater_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_greaterequal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_greaterequal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_less_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_less_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lessequal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_lessequal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_equal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_equal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lessgreater_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_lessgreater_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_unordered_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_unordered_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Comparison_Functions">Comparison Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Comparison-Functions">GNU MPFR - Comparison Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to 512.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number op2.
            mpfr_t op2 = new mpfr_t();
            mpfr_lib.mpfr_init2(op2, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 128, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that op1 > op2.
            Assert.IsTrue(mpfr_lib.mpfr_cmp(op1, op2) > 0);
            
            // Release unmanaged memory allocated for op1 and op2.
            mpfr_lib.mpfr_clears(op1, op2, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to 512.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number op2.
            Dim op2 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op2, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 128, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that op1 &gt; op2.
            Assert.IsTrue(mpfr_lib.mpfr_cmp(op1, op2) &gt; 0)
            
            ' Release unmanaged memory allocated for op1 and op2.
            mpfr_lib.mpfr_clears(op1, op2, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_d(Math.Mpfr.Native.mpfr_t,System.Double)">
            <summary>
            Compare <paramref name="op1"/> and <paramref name="op2"/>.
            </summary>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <returns>Return a positive value if <paramref name="op1"/> &gt; <paramref name="op2"/>, zero if <paramref name="op1"/> = <paramref name="op2"/>, and a negative value if <paramref name="op1"/> &lt; <paramref name="op2"/>.</returns>
            <remarks>
            <para>
            Both <paramref name="op1"/> and <paramref name="op2"/> are considered to their full own precision, which may differ.
            If one of the operands is NaN, set the erange flag and return zero. 
            </para>
            <para>
            Note: These functions may be useful to distinguish the three possible cases.
            If you need to distinguish two cases only, it is recommended to use the predicate functions
            (e.g., <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_equal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_equal_p</see> for the equality) described below; they behave like the IEEE 754 comparisons,
            in particular when one or both arguments are NaN.
            But only floating-point numbers can be compared (you may need to do a conversion first). 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_cmp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_ui(Math.Mpfr.Native.mpfr_t,System.UInt32)">mpfr_cmp_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_si(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_cmp_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t)">mpfr_cmp_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t)">mpfr_cmp_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t)">mpfr_cmp_f</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_ui_2exp(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_exp_t)">mpfr_cmp_ui_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_si_2exp(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_exp_t)">mpfr_cmp_si_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmpabs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_cmpabs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nan_p(Math.Mpfr.Native.mpfr_t)">mpfr_nan_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inf_p(Math.Mpfr.Native.mpfr_t)">mpfr_inf_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_number_p(Math.Mpfr.Native.mpfr_t)">mpfr_number_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zero_p(Math.Mpfr.Native.mpfr_t)">mpfr_zero_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_regular_p(Math.Mpfr.Native.mpfr_t)">mpfr_regular_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sgn(Math.Mpfr.Native.mpfr_t)">mpfr_sgn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_greater_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_greater_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_greaterequal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_greaterequal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_less_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_less_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lessequal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_lessequal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_equal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_equal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lessgreater_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_lessgreater_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_unordered_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_unordered_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Comparison_Functions">Comparison Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Comparison-Functions">GNU MPFR - Comparison Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to 512.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that op1 &gt; 128.0.
            Assert.IsTrue(mpfr_lib.mpfr_cmp_d(op1, 128.0) &gt; 0);
            
            // Release unmanaged memory allocated for op1.
            mpfr_lib.mpfr_clear(op1);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to 512.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that op1 &gt; 128.0.
            Assert.IsTrue(mpfr_lib.mpfr_cmp_d(op1, 128.0) &gt; 0)
            
            ' Release unmanaged memory allocated for op1.
            mpfr_lib.mpfr_clear(op1)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmpabs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">
            <summary>
            Compare |<paramref name="op1"/>| and |<paramref name="op2"/>|.
            </summary>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <returns>Return a positive value if |<paramref name="op1"/>| &gt; |<paramref name="op2"/>|, zero if |<paramref name="op1"/>| = |<paramref name="op2"/>|, and a negative value if |<paramref name="op1"/>| &lt; |<paramref name="op2"/>|.</returns>
            <remarks>
            <para>
            If one of the operands is NaN, set the erange flag and return zero.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_cmp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_ui(Math.Mpfr.Native.mpfr_t,System.UInt32)">mpfr_cmp_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_si(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_cmp_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_d(Math.Mpfr.Native.mpfr_t,System.Double)">mpfr_cmp_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t)">mpfr_cmp_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t)">mpfr_cmp_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t)">mpfr_cmp_f</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_ui_2exp(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_exp_t)">mpfr_cmp_ui_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_si_2exp(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_exp_t)">mpfr_cmp_si_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nan_p(Math.Mpfr.Native.mpfr_t)">mpfr_nan_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inf_p(Math.Mpfr.Native.mpfr_t)">mpfr_inf_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_number_p(Math.Mpfr.Native.mpfr_t)">mpfr_number_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zero_p(Math.Mpfr.Native.mpfr_t)">mpfr_zero_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_regular_p(Math.Mpfr.Native.mpfr_t)">mpfr_regular_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sgn(Math.Mpfr.Native.mpfr_t)">mpfr_sgn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_greater_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_greater_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_greaterequal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_greaterequal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_less_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_less_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lessequal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_lessequal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_equal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_equal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lessgreater_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_lessgreater_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_unordered_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_unordered_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Comparison_Functions">Comparison Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Comparison-Functions">GNU MPFR - Comparison Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to 512.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number op2.
            mpfr_t op2 = new mpfr_t();
            mpfr_lib.mpfr_init2(op2, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 128, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that |op1| &gt; |op2|.
            Assert.IsTrue(mpfr_lib.mpfr_cmpabs(op1, op2) &gt; 0);
            
            // Release unmanaged memory allocated for op1 and op2.
            mpfr_lib.mpfr_clears(op1, op2, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to 512.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number op2.
            Dim op2 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op2, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 128, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that |op1| &gt; |op2|.
            Assert.IsTrue(mpfr_lib.mpfr_cmpabs(op1, op2) &gt; 0)
            
            ' Release unmanaged memory allocated for op1 and op2.
            mpfr_lib.mpfr_clears(op1, op2, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_ui(Math.Mpfr.Native.mpfr_t,System.UInt32)">
            <summary>
            Compare <paramref name="op1"/> and <paramref name="op2"/>.
            </summary>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <returns>Return a positive value if <paramref name="op1"/> &gt; <paramref name="op2"/>, zero if <paramref name="op1"/> = <paramref name="op2"/>, and a negative value if <paramref name="op1"/> &lt; <paramref name="op2"/>.</returns>
            <remarks>
            <para>
            Both <paramref name="op1"/> and <paramref name="op2"/> are considered to their full own precision, which may differ.
            If one of the operands is NaN, set the erange flag and return zero. 
            </para>
            <para>
            Note: These functions may be useful to distinguish the three possible cases.
            If you need to distinguish two cases only, it is recommended to use the predicate functions
            (e.g., <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_equal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_equal_p</see> for the equality) described below; they behave like the IEEE 754 comparisons,
            in particular when one or both arguments are NaN.
            But only floating-point numbers can be compared (you may need to do a conversion first). 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_cmp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_si(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_cmp_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_d(Math.Mpfr.Native.mpfr_t,System.Double)">mpfr_cmp_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t)">mpfr_cmp_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t)">mpfr_cmp_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t)">mpfr_cmp_f</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_ui_2exp(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_exp_t)">mpfr_cmp_ui_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_si_2exp(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_exp_t)">mpfr_cmp_si_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmpabs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_cmpabs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nan_p(Math.Mpfr.Native.mpfr_t)">mpfr_nan_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inf_p(Math.Mpfr.Native.mpfr_t)">mpfr_inf_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_number_p(Math.Mpfr.Native.mpfr_t)">mpfr_number_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zero_p(Math.Mpfr.Native.mpfr_t)">mpfr_zero_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_regular_p(Math.Mpfr.Native.mpfr_t)">mpfr_regular_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sgn(Math.Mpfr.Native.mpfr_t)">mpfr_sgn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_greater_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_greater_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_greaterequal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_greaterequal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_less_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_less_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lessequal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_lessequal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_equal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_equal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lessgreater_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_lessgreater_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_unordered_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_unordered_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Comparison_Functions">Comparison Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Comparison-Functions">GNU MPFR - Comparison Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to 512.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that op1 &gt; 128.
            Assert.IsTrue(mpfr_lib.mpfr_cmp_ui(op1, 128) &gt; 0);
            
            // Release unmanaged memory allocated for op1.
            mpfr_lib.mpfr_clear(op1);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to 512.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that op1 &gt; 128.
            Assert.IsTrue(mpfr_lib.mpfr_cmp_ui(op1, 128) &gt; 0)
            
            ' Release unmanaged memory allocated for op1.
            mpfr_lib.mpfr_clear(op1)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_si(Math.Mpfr.Native.mpfr_t,System.Int32)">
            <summary>
            Compare <paramref name="op1"/> and <paramref name="op2"/>.
            </summary>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <returns>Return a positive value if <paramref name="op1"/> &gt; <paramref name="op2"/>, zero if <paramref name="op1"/> = <paramref name="op2"/>, and a negative value if <paramref name="op1"/> &lt; <paramref name="op2"/>.</returns>
            <remarks>
            <para>
            Both <paramref name="op1"/> and <paramref name="op2"/> are considered to their full own precision, which may differ.
            If one of the operands is NaN, set the erange flag and return zero. 
            </para>
            <para>
            Note: These functions may be useful to distinguish the three possible cases.
            If you need to distinguish two cases only, it is recommended to use the predicate functions
            (e.g., <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_equal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_equal_p</see> for the equality) described below; they behave like the IEEE 754 comparisons,
            in particular when one or both arguments are NaN.
            But only floating-point numbers can be compared (you may need to do a conversion first). 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_cmp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_ui(Math.Mpfr.Native.mpfr_t,System.UInt32)">mpfr_cmp_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_d(Math.Mpfr.Native.mpfr_t,System.Double)">mpfr_cmp_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t)">mpfr_cmp_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t)">mpfr_cmp_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t)">mpfr_cmp_f</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_ui_2exp(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_exp_t)">mpfr_cmp_ui_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_si_2exp(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_exp_t)">mpfr_cmp_si_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmpabs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_cmpabs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nan_p(Math.Mpfr.Native.mpfr_t)">mpfr_nan_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inf_p(Math.Mpfr.Native.mpfr_t)">mpfr_inf_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_number_p(Math.Mpfr.Native.mpfr_t)">mpfr_number_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zero_p(Math.Mpfr.Native.mpfr_t)">mpfr_zero_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_regular_p(Math.Mpfr.Native.mpfr_t)">mpfr_regular_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sgn(Math.Mpfr.Native.mpfr_t)">mpfr_sgn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_greater_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_greater_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_greaterequal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_greaterequal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_less_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_less_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lessequal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_lessequal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_equal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_equal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lessgreater_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_lessgreater_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_unordered_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_unordered_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Comparison_Functions">Comparison Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Comparison-Functions">GNU MPFR - Comparison Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to 512.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that op1 &gt; 128.
            Assert.IsTrue(mpfr_lib.mpfr_cmp_si(op1, 128) &gt; 0);
            
            // Release unmanaged memory allocated for op1.
            mpfr_lib.mpfr_clear(op1);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to 512.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that op1 &gt; 128.
            Assert.IsTrue(mpfr_lib.mpfr_cmp_si(op1, 128) &gt; 0)
            
            ' Release unmanaged memory allocated for op1.
            mpfr_lib.mpfr_clear(op1)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_ui_2exp(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_exp_t)">
            <summary>
            Compare <paramref name="op1"/> and <paramref name="op2"/> * 2^<paramref name="e"/>.
            </summary>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="e">The exponent.</param>
            <returns>Return a positive value if <paramref name="op1"/> &gt; <paramref name="op2"/> * 2^<paramref name="e"/>, zero if <paramref name="op1"/> = <paramref name="op2"/> * 2^<paramref name="e"/>, and a negative value if <paramref name="op1"/> &lt; <paramref name="op2"/> * 2^<paramref name="e"/>.</returns>
            <remarks>
            <para>
            Similar as <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_cmp</see>.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_cmp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_ui(Math.Mpfr.Native.mpfr_t,System.UInt32)">mpfr_cmp_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_si(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_cmp_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_d(Math.Mpfr.Native.mpfr_t,System.Double)">mpfr_cmp_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t)">mpfr_cmp_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t)">mpfr_cmp_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t)">mpfr_cmp_f</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_si_2exp(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_exp_t)">mpfr_cmp_si_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmpabs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_cmpabs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nan_p(Math.Mpfr.Native.mpfr_t)">mpfr_nan_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inf_p(Math.Mpfr.Native.mpfr_t)">mpfr_inf_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_number_p(Math.Mpfr.Native.mpfr_t)">mpfr_number_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zero_p(Math.Mpfr.Native.mpfr_t)">mpfr_zero_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_regular_p(Math.Mpfr.Native.mpfr_t)">mpfr_regular_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sgn(Math.Mpfr.Native.mpfr_t)">mpfr_sgn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_greater_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_greater_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_greaterequal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_greaterequal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_less_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_less_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lessequal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_lessequal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_equal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_equal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lessgreater_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_lessgreater_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_unordered_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_unordered_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Comparison_Functions">Comparison Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Comparison-Functions">GNU MPFR - Comparison Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to 512.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that op1 = 128 * 2^2.
            Assert.IsTrue(mpfr_lib.mpfr_cmp_ui_2exp(op1, 128, 2) == 0);
            
            // Release unmanaged memory allocated for op1.
            mpfr_lib.mpfr_clear(op1);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to 512.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that op1 = 128 * 2^2.
            Assert.IsTrue(mpfr_lib.mpfr_cmp_ui_2exp(op1, 128, 2) = 0)
            
            ' Release unmanaged memory allocated for op1.
            mpfr_lib.mpfr_clear(op1)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_si_2exp(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_exp_t)">
            <summary>
            Compare <paramref name="op1"/> and <paramref name="op2"/> * 2^<paramref name="e"/>.
            </summary>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="e">The exponent.</param>
            <returns>Return a positive value if <paramref name="op1"/> &gt; <paramref name="op2"/> * 2^<paramref name="e"/>, zero if <paramref name="op1"/> = <paramref name="op2"/> * 2^<paramref name="e"/>, and a negative value if <paramref name="op1"/> &lt; <paramref name="op2"/> * 2^<paramref name="e"/>.</returns>
            <remarks>
            <para>
            Similar as <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_cmp</see>.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_cmp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_ui(Math.Mpfr.Native.mpfr_t,System.UInt32)">mpfr_cmp_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_si(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_cmp_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_d(Math.Mpfr.Native.mpfr_t,System.Double)">mpfr_cmp_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t)">mpfr_cmp_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t)">mpfr_cmp_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t)">mpfr_cmp_f</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_ui_2exp(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_exp_t)">mpfr_cmp_ui_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmpabs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_cmpabs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nan_p(Math.Mpfr.Native.mpfr_t)">mpfr_nan_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inf_p(Math.Mpfr.Native.mpfr_t)">mpfr_inf_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_number_p(Math.Mpfr.Native.mpfr_t)">mpfr_number_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zero_p(Math.Mpfr.Native.mpfr_t)">mpfr_zero_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_regular_p(Math.Mpfr.Native.mpfr_t)">mpfr_regular_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sgn(Math.Mpfr.Native.mpfr_t)">mpfr_sgn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_greater_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_greater_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_greaterequal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_greaterequal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_less_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_less_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lessequal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_lessequal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_equal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_equal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lessgreater_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_lessgreater_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_unordered_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_unordered_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Comparison_Functions">Comparison Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Comparison-Functions">GNU MPFR - Comparison Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to 512.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that op1 = 128 * 2^2.
            Assert.IsTrue(mpfr_lib.mpfr_cmp_si_2exp(op1, 128, 2) == 0);
            
            // Release unmanaged memory allocated for op1.
            mpfr_lib.mpfr_clear(op1);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to 512.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that op1 = 128 * 2^2.
            Assert.IsTrue(mpfr_lib.mpfr_cmp_si_2exp(op1, 128, 2) = 0)
            
            ' Release unmanaged memory allocated for op1.
            mpfr_lib.mpfr_clear(op1)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_reldiff(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Compute the relative difference between <paramref name="op1"/> and <paramref name="op2"/> and store the result in <paramref name="rop"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <remarks>
            <para>
            This function does not guarantee the correct rounding on the relative difference;
            it just computes |<paramref name="op1"/> - <paramref name="op2"/>| / <paramref name="op1"/>,
            using the precision of <paramref name="rop"/> and the rounding mode <paramref name="rnd"/> for all operations. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_prec_raw(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_prec_t)">mpfr_set_prec_raw</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_eq(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32)">mpfr_eq</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_2exp</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Compatibility_With_MPF">Compatibility With MPF</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Compatibility-with-MPF">GNU MPFR - Compatibility With MPF</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to 10.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new floating-point number op2 to -210.
            mpfr_t op2 = new mpfr_t();
            mpfr_lib.mpfr_init2(op2, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, -210, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = |op1 - op2| / op1.
            mpfr_lib.mpfr_reldiff(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN);
            
            // Assert that the value of z is 22.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 22.0);
            
            // Release unmanaged memory allocated for rop, op1, and op2.
            mpfr_lib.mpfr_clears(rop, op1, op2, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to 10.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new floating-point number op2 to -210.
            Dim op2 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op2, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, -210, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = |op1 - op2| / op1.
            mpfr_lib.mpfr_reldiff(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN)
            
            ' Assert that the value of z is 22.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 22.0)
            
            ' Release unmanaged memory allocated for rop, op1, and op2.
            mpfr_lib.mpfr_clears(rop, op1, op2, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_eq(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32)">
            <summary>
            Return non-zero if <paramref name="op1"/> and <paramref name="op2"/> are both non-zero ordinary numbers with the same exponent and the same first <paramref name="op3"/> bits.
            </summary>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="op3">The third operand integer.</param>
            <returns>Return non-zero if <paramref name="op1"/> and <paramref name="op2"/> are both non-zero ordinary numbers with the same exponent and the same first <paramref name="op3"/> bits, both zero, or both infinities of the same sign. Return zero otherwise.</returns>
            <remarks>
            <para>
            This function is defined for compatibility with MPF, we do not recommend to use it otherwise.
            Do not use it either if you want to know whether two numbers are close to each other;
            for instance, 1.011111 and 1.100000 are regarded as different for any value of <paramref name="op3"/> larger than 1. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_prec_raw(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_prec_t)">mpfr_set_prec_raw</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_reldiff(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_reldiff</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_2exp</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Compatibility_With_MPF">Compatibility With MPF</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Compatibility-with-MPF">GNU MPFR - Compatibility With MPF</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to 1.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new floating-point number op2 to 1.
            mpfr_t op2 = new mpfr_t();
            mpfr_lib.mpfr_init2(op2, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that op1 = op2 to 10 bits.
            Assert.IsTrue(mpfr_lib.mpfr_eq(op1, op2, 10U) != 0);
            
            // Release unmanaged memory allocated for op1 and op2.
            mpfr_lib.mpfr_clears(op1, op2, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to 1.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new floating-point number op2 to 1.
            Dim op2 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op2, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that op1 = op2 to 10 bits.
            Assert.IsTrue(mpfr_lib.mpfr_eq(op1,op2,10U) &lt;&gt; 0)
            
            ' Release unmanaged memory allocated for op1 and op2.
            mpfr_lib.mpfr_clears(op1, op2, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_sgn(Math.Mpfr.Native.mpfr_t)">
            <summary>
            Return a positive value if <paramref name="op"/> &gt; 0, zero if <paramref name="op"/> = 0, and a negative value if <paramref name="op"/> &lt; 0.
            </summary>
            <param name="op">The operand floating-point number.</param>
            <returns>Return a positive value if <paramref name="op"/> &gt; 0, zero if <paramref name="op"/> = 0, and a negative value if <paramref name="op"/> &lt; 0.</returns>
            <remarks>
            <para>
            If the operand is NaN, set the erange flag and return zero.
            This is equivalent to <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_ui(Math.Mpfr.Native.mpfr_t,System.UInt32)">mpfr_cmp_ui</see>(<paramref name="op"/>, 0), but more efficient. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_cmp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_ui(Math.Mpfr.Native.mpfr_t,System.UInt32)">mpfr_cmp_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_si(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_cmp_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_d(Math.Mpfr.Native.mpfr_t,System.Double)">mpfr_cmp_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t)">mpfr_cmp_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t)">mpfr_cmp_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t)">mpfr_cmp_f</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_ui_2exp(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_exp_t)">mpfr_cmp_ui_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_si_2exp(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_exp_t)">mpfr_cmp_si_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmpabs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_cmpabs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nan_p(Math.Mpfr.Native.mpfr_t)">mpfr_nan_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inf_p(Math.Mpfr.Native.mpfr_t)">mpfr_inf_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_number_p(Math.Mpfr.Native.mpfr_t)">mpfr_number_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zero_p(Math.Mpfr.Native.mpfr_t)">mpfr_zero_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_regular_p(Math.Mpfr.Native.mpfr_t)">mpfr_regular_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_greater_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_greater_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_greaterequal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_greaterequal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_less_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_less_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lessequal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_lessequal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_equal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_equal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lessgreater_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_lessgreater_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_unordered_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_unordered_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Comparison_Functions">Comparison Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Comparison-Functions">GNU MPFR - Comparison Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new integer op to 200.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_ui(op, 200U, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert sign of op..
            Assert.IsTrue(mpfr_lib.mpfr_sgn(op) > 0);
            
            // Release unmanaged memory allocated for op.
            mpfr_lib.mpfr_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new integer op to 200.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_ui(op, 200U, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert sign of op..
            Assert.IsTrue(mpfr_lib.mpfr_sgn(op) > 0)
            
            ' Release unmanaged memory allocated for op.
            mpfr_lib.mpfr_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            This function is identical to <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_2ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_2ui</see>. 
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            This function is only kept for compatibility with MPF, one should prefer <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_2ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_2ui</see>. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_prec_raw(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_prec_t)">mpfr_set_prec_raw</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_eq(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32)">mpfr_eq</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_reldiff(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_reldiff</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_2exp</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Compatibility_With_MPF">Compatibility With MPF</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Compatibility-with-MPF">GNU MPFR - Compatibility With MPF</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to 100.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 100, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set z = op1 * 2^8.
            Assert.IsTrue(mpfr_lib.mpfr_mul_2exp(rop, op1, 8, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is 25600.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 25600.0);
            
            // Release unmanaged memory allocated for rop and op1.
            mpfr_lib.mpfr_clears(rop, op1, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to 100.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 100, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set z = op1 * 2^8.
            Assert.IsTrue(mpfr_lib.mpfr_mul_2exp(rop, op1, 8, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is 25600.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 25600.0)
            
            ' Release unmanaged memory allocated for rop and op1.
            mpfr_lib.mpfr_clears(rop, op1, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            This function is identical to <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_2ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_2ui</see>. 
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            This function is only kept for compatibility with MPF, one should prefer <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_2ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_2ui</see>. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_prec_raw(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_prec_t)">mpfr_set_prec_raw</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_eq(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32)">mpfr_eq</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_reldiff(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_reldiff</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_2exp</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Compatibility_With_MPF">Compatibility With MPF</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Compatibility-with-MPF">GNU MPFR - Compatibility With MPF</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to 512.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = op1 / 2^8.
            Assert.IsTrue(mpfr_lib.mpfr_div_2exp(rop, op1, 8U, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is 2.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 2.0);
            
            // Release unmanaged memory allocated for rop and op1.
            mpfr_lib.mpfr_clears(rop, op1, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to 512.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = op1 / 2^8.
            Assert.IsTrue(mpfr_lib.mpfr_div_2exp(rop, op1, 8U, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is 2.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 2.0)
            
            ' Release unmanaged memory allocated for rop and op1.
            mpfr_lib.mpfr_clears(rop, op1, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_2ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> * 2^<paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            Just increases the exponent by <paramref name="op2"/> when <paramref name="rop"/> and <paramref name="op1"/> are identical. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_z(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_q(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqr(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqr</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cbrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cbrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rootn_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_root(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_neg</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_abs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_dim(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_dim</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_2ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_2ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_2si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_2si</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to 100.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 100, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set z = op1 * 2^8.
            Assert.IsTrue(mpfr_lib.mpfr_mul_2ui(rop, op1, 8U, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is 25600.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 25600.0);
            
            // Release unmanaged memory allocated for rop and op1.
            mpfr_lib.mpfr_clears(rop, op1, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to 100.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 100, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set z = op1 * 2^8.
            Assert.IsTrue(mpfr_lib.mpfr_mul_2ui(rop, op1, 8U, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is 25600.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 25600.0)
            
            ' Release unmanaged memory allocated for rop and op1.
            mpfr_lib.mpfr_clears(rop, op1, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_2ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> divided by 2^<paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            Just decreases the exponent by <paramref name="op2"/> when <paramref name="rop"/> and <paramref name="op1"/> are identical. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqr(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqr</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ui_div(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ui_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_si_div(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_si_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_d_div(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_d_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_z(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_q(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cbrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cbrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rootn_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_root(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_neg</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_abs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_dim(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_dim</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to 512.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = op1 / 2^8.
            Assert.IsTrue(mpfr_lib.mpfr_div_2ui(rop, op1, 8U, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is 2.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 2.0);
            
            // Release unmanaged memory allocated for rop and op1.
            mpfr_lib.mpfr_clears(rop, op1, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to 512.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = op1 / 2^8.
            Assert.IsTrue(mpfr_lib.mpfr_div_2ui(rop, op1, 8U, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is 2.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 2.0)
            
            ' Release unmanaged memory allocated for rop and op1.
            mpfr_lib.mpfr_clears(rop, op1, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_2si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> * 2^<paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            Just increases the exponent by <paramref name="op2"/> when <paramref name="rop"/> and <paramref name="op1"/> are identical. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_z(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_q(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqr(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqr</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cbrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cbrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rootn_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_root(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_neg</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_abs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_dim(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_dim</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_2ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_2ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_2si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_2si</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to 100.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 100, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set z = op1 * 2^8.
            Assert.IsTrue(mpfr_lib.mpfr_mul_2si(rop, op1, 8, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is 25600.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 25600.0);
            
            // Release unmanaged memory allocated for rop and op1.
            mpfr_lib.mpfr_clears(rop, op1, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to 100.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 100, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set z = op1 * 2^8.
            Assert.IsTrue(mpfr_lib.mpfr_mul_2si(rop, op1, 8, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is 25600.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 25600.0)
            
            ' Release unmanaged memory allocated for rop and op1.
            mpfr_lib.mpfr_clears(rop, op1, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_2si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> divided by 2^<paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            Just decreases the exponent by <paramref name="op2"/> when <paramref name="rop"/> and <paramref name="op1"/> are identical. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqr(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqr</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ui_div(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ui_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_si_div(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_si_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_d_div(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_d_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_z(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_q(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cbrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cbrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rootn_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_root(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_neg</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_abs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_dim(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_dim</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to 512.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = op1 / 2^8.
            Assert.IsTrue(mpfr_lib.mpfr_div_2si(rop, op1, 8, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is 2.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 2.0);
            
            // Release unmanaged memory allocated for rop and op1.
            mpfr_lib.mpfr_clears(rop, op1, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to 512.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = op1 / 2^8.
            Assert.IsTrue(mpfr_lib.mpfr_div_2si(rop, op1, 8, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is 2.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 2.0)
            
            ' Release unmanaged memory allocated for rop and op1.
            mpfr_lib.mpfr_clears(rop, op1, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op"/> rounded to the nearest representable integer in the given direction <paramref name="rnd"/>. 
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>The return value is zero when the result is exact, positive when it is greater than the original value of <paramref name="op"/>, and negative when it is smaller. More precisely, the returned value is 0 when <paramref name="op"/> is an integer representable in <paramref name="rop"/>, 1 or -1 when <paramref name="op"/> is an integer that is not representable in <paramref name="rop"/>, 2 or -2 when <paramref name="op"/> is not an integer.</returns>
            <remarks>
            <para>
            When <paramref name="op"/> is NaN, the NaN flag is set as usual.
            In the other cases, the inexact flag is set when <paramref name="rop"/> differs from <paramref name="op"/>, following the ISO C99 rule for the rint function.
            If you want the behavior to be more like IEEE 754 / ISO TS 18661-1, i.e., the usual behavior where the round-to-integer function is regarded as any other
            mathematical function, you should use one the mpfr_rint_* functions instead (however it is not possible to round to nearest with the even rounding rule yet). 
            </para>
            <para>
            Note that <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_round</see> is different from <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint</see> called with the rounding to nearest mode (where halfway cases are rounded to an
            even integer or significand).
            Note also that no double rounding is performed; for instance, 10.5 (1010.1 in binary) is rounded by <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint</see> with rounding to nearest
            to 12 (1100 in binary) in 2-bit precision, because the two enclosing numbers representable on two bits are 8 and 12, and the closest is 12.
            (If one first rounded to an integer, one would round 10.5 to 10 with even rounding, and then 10 would be rounded to 8 again with even rounding.) 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ceil(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_ceil</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_floor(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_floor</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_roundeven(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_trunc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_trunc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_ceil(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_ceil</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_floor(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_floor</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_roundeven(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_trunc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_trunc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_frac(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_frac</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_modf(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_modf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmod(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmod</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_fmodquo">mpfr_fmod</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_remainder(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_remainder</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_integer_p(Math.Mpfr.Native.mpfr_t)">mpfr_integer_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Integer_and_Remainder_Related_Functions">Integer and Remainder Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Integer-Related-Functions">GNU MPFR - Integer and Remainder Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 25.2.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 25.2, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = round(op).
            Assert.IsTrue(mpfr_lib.mpfr_rint(rop, op, mpfr_rnd_t.MPFR_RNDN) == -2);
            
            // Assert the value of rop.
            Assert.IsTrue(rop.ToString() == "0.250000000000000000000e2");
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 25.2.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 25.2, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = round(op).
            Assert.IsTrue(mpfr_lib.mpfr_rint(rop, op, mpfr_rnd_t.MPFR_RNDN) = -2)
            
            ' Assert the value of rop.
            Assert.IsTrue(rop.ToString() = "0.250000000000000000000e2")
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op"/> rounded to the nearest representable integer, rounding halfway cases away from zero (as in the roundTiesToAway mode of IEEE 754-2008). 
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <returns>The return value is zero when the result is exact, positive when it is greater than the original value of <paramref name="op"/>, and negative when it is smaller. More precisely, the returned value is 0 when <paramref name="op"/> is an integer representable in <paramref name="rop"/>, 1 or -1 when <paramref name="op"/> is an integer that is not representable in <paramref name="rop"/>, 2 or -2 when <paramref name="op"/> is not an integer.</returns>
            <remarks>
            <para>
            When <paramref name="op"/> is a zero or an infinity, set <paramref name="rop"/> to the same value (with the same sign).
            </para>
            <para>
            When <paramref name="op"/> is NaN, the NaN flag is set as usual.
            In the other cases, the inexact flag is set when <paramref name="rop"/> differs from <paramref name="op"/>, following the ISO C99 rule for the rint function.
            If you want the behavior to be more like IEEE 754 / ISO TS 18661-1, i.e., the usual behavior where the round-to-integer function is regarded as any other
            mathematical function, you should use one the mpfr_rint_* functions instead (however it is not possible to round to nearest with the even rounding rule yet). 
            </para>
            <para>
            Note that no double rounding is performed; for instance, 10.5 (1010.1 in binary) is rounded by <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint</see> with rounding to nearest
            to 12 (1100 in binary) in 2-bit precision, because the two enclosing numbers representable on two bits are 8 and 12, and the closest is 12.
            (If one first rounded to an integer, one would round 10.5 to 10 with even rounding, and then 10 would be rounded to 8 again with even rounding.) 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ceil(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_ceil</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_floor(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_floor</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_roundeven(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_roundeven</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_trunc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_trunc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_ceil(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_ceil</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_floor(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_floor</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_roundeven(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_trunc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_trunc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_frac(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_frac</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_modf(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_modf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmod(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmod</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_fmodquo">mpfr_fmod</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_remainder(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_remainder</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_integer_p(Math.Mpfr.Native.mpfr_t)">mpfr_integer_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Integer_and_Remainder_Related_Functions">Integer and Remainder Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Integer-Related-Functions">GNU MPFR - Integer and Remainder Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 10.4.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = round(op).
            Assert.IsTrue(mpfr_lib.mpfr_round(rop, op) == -2);
            
            // Assert that the value of rop is 10.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 10.0);
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 10.4.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = round(op).
            Assert.IsTrue(mpfr_lib.mpfr_round(rop, op) = -2)
            
            ' Assert that the value of rop is 10.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 10.0)
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_roundeven(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">
            <summary>
            Set <i>rop</i> to <i>op</i> rounded to the nearest representable integer, rounding halfway cases with the even-rounding rule zero (like <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)"/> with <see cref="F:Math.Mpfr.Native.mpfr_rnd_t.MPFR_RNDN"/>).
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <returns>The return value is zero when the result is exact, positive when it is greater than the original value of <paramref name="op"/>, and negative when it is smaller. More precisely, the returned value is 0 when <paramref name="op"/> is an integer representable in <paramref name="rop"/>, 1 or -1 when <paramref name="op"/> is an integer that is not representable in <paramref name="rop"/>, 2 or -2 when <paramref name="op"/> is not an integer.</returns>
            <remarks>
            <para>
            When <paramref name="op"/> is a zero or an infinity, set <paramref name="rop"/> to the same value (with the same sign).
            </para>
            <para>
            When <paramref name="op"/> is NaN, the NaN flag is set as usual.
            In the other cases, the inexact flag is set when <paramref name="rop"/> differs from <paramref name="op"/>, following the ISO C99 rule for the rint function.
            If you want the behavior to be more like IEEE 754 / ISO TS 18661-1, i.e., the usual behavior where the round-to-integer function is regarded as any other
            mathematical function, you should use one the mpfr_rint_* functions instead. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ceil(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_ceil</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_floor(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_floor</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_trunc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_trunc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_ceil(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_ceil</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_floor(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_floor</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_roundeven(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_trunc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_trunc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_frac(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_frac</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_modf(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_modf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmod(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmod</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_fmodquo">mpfr_fmod</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_remainder(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_remainder</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_integer_p(Math.Mpfr.Native.mpfr_t)">mpfr_integer_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Integer_and_Remainder_Related_Functions">Integer and Remainder Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Integer-Related-Functions">GNU MPFR - Integer and Remainder Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 10.4.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = round(op).
            Assert.IsTrue(mpfr_lib.mpfr_roundeven(rop, op) == -2);
            
            // Assert that the value of rop is 10.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 10.0);
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 10.4.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = round(op).
            Assert.IsTrue(mpfr_lib.mpfr_roundeven(rop, op) = -2)
            
            ' Assert that the value of rop is 10.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 10.0)
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_trunc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op"/> rounded to the next representable integer toward zero (like <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)"/> with <see cref="F:Math.Mpfr.Native.mpfr_rnd_t.MPFR_RNDZ"/>).
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <returns>The return value is zero when the result is exact, positive when it is greater than the original value of <paramref name="op"/>, and negative when it is smaller. More precisely, the returned value is 0 when <paramref name="op"/> is an integer representable in <paramref name="rop"/>, 1 or -1 when <paramref name="op"/> is an integer that is not representable in <paramref name="rop"/>, 2 or -2 when <paramref name="op"/> is not an integer.</returns>
            <remarks>
            <para>
            When <paramref name="op"/> is a zero or an infinity, set <paramref name="rop"/> to the same value (with the same sign).
            </para>
            <para>
            When <paramref name="op"/> is NaN, the NaN flag is set as usual.
            In the other cases, the inexact flag is set when <paramref name="rop"/> differs from <paramref name="op"/>, following the ISO C99 rule for the rint function.
            If you want the behavior to be more like IEEE 754 / ISO TS 18661-1, i.e., the usual behavior where the round-to-integer function is regarded as any other
            mathematical function, you should use one the mpfr_rint_* functions instead. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ceil(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_ceil</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_floor(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_floor</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_roundeven(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_trunc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_trunc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_ceil(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_ceil</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_floor(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_floor</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_roundeven(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_trunc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_trunc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_frac(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_frac</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_modf(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_modf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmod(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmod</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_fmodquo">mpfr_fmod</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_remainder(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_remainder</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_integer_p(Math.Mpfr.Native.mpfr_t)">mpfr_integer_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Integer_and_Remainder_Related_Functions">Integer and Remainder Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Integer-Related-Functions">GNU MPFR - Integer and Remainder Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 10.4.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_init_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = trunc(op).
            Assert.IsTrue(mpfr_lib.mpfr_trunc(rop, op) == -2);
            
            // Assert that the value of rop is 10.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 10.0);
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 10.4.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_init_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = trunc(op).
            Assert.IsTrue(mpfr_lib.mpfr_trunc(rop, op) = -2)
            
            ' Assert that the value of rop is 10.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 10.0)
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_ceil(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op"/> rounded to the next higher or equal representable integer (like <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)"/> with <see cref="F:Math.Mpfr.Native.mpfr_rnd_t.MPFR_RNDU"/>).
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <returns>The return value is zero when the result is exact, positive when it is greater than the original value of <paramref name="op"/>, and negative when it is smaller. More precisely, the returned value is 0 when <paramref name="op"/> is an integer representable in <paramref name="rop"/>, 1 or -1 when <paramref name="op"/> is an integer that is not representable in <paramref name="rop"/>, 2 or -2 when <paramref name="op"/> is not an integer.</returns>
            <remarks>
            <para>
            When <paramref name="op"/> is a zero or an infinity, set <paramref name="rop"/> to the same value (with the same sign).
            </para>
            <para>
            When <paramref name="op"/> is NaN, the NaN flag is set as usual.
            In the other cases, the inexact flag is set when <paramref name="rop"/> differs from <paramref name="op"/>, following the ISO C99 rule for the rint function.
            If you want the behavior to be more like IEEE 754 / ISO TS 18661-1, i.e., the usual behavior where the round-to-integer function is regarded as any other
            mathematical function, you should use one the mpfr_rint_* functions instead. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ceil(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_ceil</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_floor(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_floor</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_roundeven(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_trunc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_trunc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_ceil(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_ceil</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_floor(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_floor</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_roundeven(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_trunc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_trunc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_frac(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_frac</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_modf(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_modf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmod(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmod</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_fmodquo">mpfr_fmod</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_remainder(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_remainder</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_integer_p(Math.Mpfr.Native.mpfr_t)">mpfr_integer_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Integer_and_Remainder_Related_Functions">Integer and Remainder Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Integer-Related-Functions">GNU MPFR - Integer and Remainder Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 10.4.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = ceil(op).
            Assert.IsTrue(mpfr_lib.mpfr_ceil(rop, op) == 2);
            
            // Assert that the value of rop is 11.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 11.0);
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 10.4.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = ceil(op).
            Assert.IsTrue(mpfr_lib.mpfr_ceil(rop, op) = 2)
            
            ' Assert that the value of rop is 11.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 11.0)
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_floor(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op"/> rounded to the next lower or equal representable integer. 
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <returns>The return value is zero when the result is exact, positive when it is greater than the original value of <paramref name="op"/>, and negative when it is smaller. More precisely, the returned value is 0 when <paramref name="op"/> is an integer representable in <paramref name="rop"/>, 1 or -1 when <paramref name="op"/> is an integer that is not representable in <paramref name="rop"/>, 2 or -2 when <paramref name="op"/> is not an integer.</returns>
            <remarks>
            <para>
            When <paramref name="op"/> is a zero or an infinity, set <paramref name="rop"/> to the same value (with the same sign).
            </para>
            <para>
            When <paramref name="op"/> is NaN, the NaN flag is set as usual.
            In the other cases, the inexact flag is set when <paramref name="rop"/> differs from <paramref name="op"/>, following the ISO C99 rule for the rint function.
            If you want the behavior to be more like IEEE 754 / ISO TS 18661-1, i.e., the usual behavior where the round-to-integer function is regarded as any other
            mathematical function, you should use one the mpfr_rint_* functions instead. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ceil(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_ceil</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_floor(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_floor</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_roundeven(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_trunc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_trunc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_ceil(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_ceil</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_floor(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_floor</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_roundeven(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_trunc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_trunc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_frac(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_frac</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_modf(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_modf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmod(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmod</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_fmodquo">mpfr_fmod</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_remainder(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_remainder</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_integer_p(Math.Mpfr.Native.mpfr_t)">mpfr_integer_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Integer_and_Remainder_Related_Functions">Integer and Remainder Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Integer-Related-Functions">GNU MPFR - Integer and Remainder Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 10.4.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = floor(op).
            Assert.IsTrue(mpfr_lib.mpfr_floor(rop, op) == -2);
            
            // Assert that the value of rop is 10.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 10.0);
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 10.4.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = floor(op).
            Assert.IsTrue(mpfr_lib.mpfr_floor(rop, op) = -2)
            
            ' Assert that the value of rop is 10.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 10.0)
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op"/> rounded to the nearest integer, rounding halfway cases away from zero.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>The return value is the <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">ternary value</a> associated with the considered round-to-integer function (regarded in the same way as any other mathematical function).</returns>
            <remarks>
            <para>
            If the result is not representable, it is rounded in the direction <paramref name="rnd"/>. 
            When <paramref name="op"/> is a zero or an infinity, set <paramref name="rop"/> to the same value (with the same sign).
            </para>
            <para>
            Contrary to <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint</see>, this function does perform a double rounding: first <paramref name="op"/> is rounded to the nearest integer
            in the direction given by the function name, then this nearest integer (if not representable) is rounded in the given direction <paramref name="rnd"/>.
            Thus these round-to-integer functions behave more like the other mathematical functions, i.e., the returned result is the correct rounding of the
            exact result of the function in the real numbers. 
            </para>
            <para>
            For example, <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_round</see> with rounding to nearest and a precision of two bits rounds 6.5 to 7 (halfway cases away from zero),
            then 7 is rounded to 8 by the round-even rule, despite the fact that 6 is also representable on two bits, and is closer to 6.5 than 8.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ceil(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_ceil</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_floor(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_floor</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_roundeven(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_trunc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_trunc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_ceil(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_ceil</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_floor(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_floor</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_trunc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_trunc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_frac(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_frac</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_modf(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_modf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmod(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmod</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_fmodquo">mpfr_fmod</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_remainder(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_remainder</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_integer_p(Math.Mpfr.Native.mpfr_t)">mpfr_integer_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Integer_and_Remainder_Related_Functions">Integer and Remainder Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Integer-Related-Functions">GNU MPFR - Integer and Remainder Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 25.2.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_init_set_d(op, 25.2, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = round(op).
            Assert.IsTrue(mpfr_lib.mpfr_rint_round(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert the value of rop.
            Assert.IsTrue(rop.ToString() == "0.250000000000000000000e2");
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 25.2.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_init_set_d(op, 25.2, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = round(op).
            Assert.IsTrue(mpfr_lib.mpfr_rint_round(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert the value of rop.
            Assert.IsTrue(rop.ToString() = "0.250000000000000000000e2")
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_roundeven(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <i>rop</i> to <i>op</i> rounded to the nearest integer, rounding halfway cases to the nearest even integer.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>The return value is the <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">ternary value</a> associated with the considered round-to-integer function (regarded in the same way as any other mathematical function).</returns>
            <remarks>
            <para>
            If the result is not representable, it is rounded in the direction <paramref name="rnd"/>. 
            When <paramref name="op"/> is a zero or an infinity, set <paramref name="rop"/> to the same value (with the same sign).
            </para>
            <para>
            Contrary to <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint</see>, this function does perform a double rounding: first <paramref name="op"/> is rounded to the nearest integer
            in the direction given by the function name, then this nearest integer (if not representable) is rounded in the given direction <paramref name="rnd"/>.
            Thus these round-to-integer functions behave more like the other mathematical functions, i.e., the returned result is the correct rounding of the
            exact result of the function in the real numbers. 
            </para>
            <para>
            For example, <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_round</see> with rounding to nearest and a precision of two bits rounds 6.5 to 7 (halfway cases away from zero),
            then 7 is rounded to 8 by the round-even rule, despite the fact that 6 is also representable on two bits, and is closer to 6.5 than 8.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ceil(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_ceil</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_floor(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_floor</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_roundeven(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_trunc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_trunc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_ceil(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_ceil</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_floor(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_floor</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_trunc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_trunc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_frac(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_frac</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_modf(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_modf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmod(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmod</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_fmodquo">mpfr_fmod</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_remainder(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_remainder</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_integer_p(Math.Mpfr.Native.mpfr_t)">mpfr_integer_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Integer_and_Remainder_Related_Functions">Integer and Remainder Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Integer-Related-Functions">GNU MPFR - Integer and Remainder Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 25.2.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_init_set_d(op, 25.2, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = round(op).
            Assert.IsTrue(mpfr_lib.mpfr_rint_roundeven(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert the value of rop.
            Assert.IsTrue(rop.ToString() == "0.250000000000000000000e2");
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 25.2.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_init_set_d(op, 25.2, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = round(op).
            Assert.IsTrue(mpfr_lib.mpfr_rint_roundeven(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert the value of rop.
            Assert.IsTrue(rop.ToString() = "0.250000000000000000000e2")
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_trunc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op"/> rounded to the next integer toward zero.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>The return value is the <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">ternary value</a> associated with the considered round-to-integer function (regarded in the same way as any other mathematical function).</returns>
            <remarks>
            <para>
            If the result is not representable, it is rounded in the direction <paramref name="rnd"/>. 
            When <paramref name="op"/> is a zero or an infinity, set <paramref name="rop"/> to the same value (with the same sign).
            </para>
            <para>
            Contrary to <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint</see>, this function does perform a double rounding: first <paramref name="op"/> is rounded to the nearest integer
            in the direction given by the function name, then this nearest integer (if not representable) is rounded in the given direction <paramref name="rnd"/>.
            Thus these round-to-integer functions behave more like the other mathematical functions, i.e., the returned result is the correct rounding of the
            exact result of the function in the real numbers. 
            </para>
            <para>
            For example, <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_round</see> with rounding to nearest and a precision of two bits rounds 6.5 to 7 (halfway cases away from zero),
            then 7 is rounded to 8 by the round-even rule, despite the fact that 6 is also representable on two bits, and is closer to 6.5 than 8.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ceil(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_ceil</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_floor(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_floor</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_roundeven(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_trunc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_trunc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_ceil(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_ceil</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_floor(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_floor</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_roundeven(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_frac(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_frac</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_modf(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_modf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmod(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmod</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_fmodquo">mpfr_fmod</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_remainder(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_remainder</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_integer_p(Math.Mpfr.Native.mpfr_t)">mpfr_integer_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Integer_and_Remainder_Related_Functions">Integer and Remainder Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Integer-Related-Functions">GNU MPFR - Integer and Remainder Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 25.2.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 25.2, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = round(op).
            Assert.IsTrue(mpfr_lib.mpfr_rint_trunc(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert the value of rop.
            Assert.IsTrue(rop.ToString() == "0.250000000000000000000e2");
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 25.2.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 25.2, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = round(op).
            Assert.IsTrue(mpfr_lib.mpfr_rint_trunc(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert the value of rop.
            Assert.IsTrue(rop.ToString() = "0.250000000000000000000e2")
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_ceil(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op"/> rounded to the next higher or equal integer.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>The return value is the <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">ternary value</a> associated with the considered round-to-integer function (regarded in the same way as any other mathematical function).</returns>
            <remarks>
            <para>
            If the result is not representable, it is rounded in the direction <paramref name="rnd"/>. 
            When <paramref name="op"/> is a zero or an infinity, set <paramref name="rop"/> to the same value (with the same sign).
            </para>
            <para>
            Contrary to <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint</see>, this function does perform a double rounding: first <paramref name="op"/> is rounded to the nearest integer
            in the direction given by the function name, then this nearest integer (if not representable) is rounded in the given direction <paramref name="rnd"/>.
            Thus these round-to-integer functions behave more like the other mathematical functions, i.e., the returned result is the correct rounding of the
            exact result of the function in the real numbers. 
            </para>
            <para>
            For example, <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_round</see> with rounding to nearest and a precision of two bits rounds 6.5 to 7 (halfway cases away from zero),
            then 7 is rounded to 8 by the round-even rule, despite the fact that 6 is also representable on two bits, and is closer to 6.5 than 8.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ceil(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_ceil</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_floor(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_floor</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_roundeven(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_trunc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_trunc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_floor(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_floor</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_roundeven(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_trunc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_trunc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_frac(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_frac</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_modf(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_modf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmod(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmod</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_fmodquo">mpfr_fmod</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_remainder(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_remainder</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_integer_p(Math.Mpfr.Native.mpfr_t)">mpfr_integer_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Integer_and_Remainder_Related_Functions">Integer and Remainder Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Integer-Related-Functions">GNU MPFR - Integer and Remainder Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 25.2.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 25.2, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = round(op).
            Assert.IsTrue(mpfr_lib.mpfr_rint_ceil(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert the value of rop.
            Assert.IsTrue(rop.ToString() == "0.260000000000000000000e2");
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 25.2.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 25.2, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = round(op).
            Assert.IsTrue(mpfr_lib.mpfr_rint_ceil(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert the value of rop.
            Assert.IsTrue(rop.ToString() = "0.260000000000000000000e2")
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_floor(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op"/> rounded to the next lower or equal integer.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>The return value is the <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">ternary value</a> associated with the considered round-to-integer function (regarded in the same way as any other mathematical function).</returns>
            <remarks>
            <para>
            If the result is not representable, it is rounded in the direction <paramref name="rnd"/>. 
            When <paramref name="op"/> is a zero or an infinity, set <paramref name="rop"/> to the same value (with the same sign).
            </para>
            <para>
            Contrary to <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint</see>, this function does perform a double rounding: first <paramref name="op"/> is rounded to the nearest integer
            in the direction given by the function name, then this nearest integer (if not representable) is rounded in the given direction <paramref name="rnd"/>.
            Thus these round-to-integer functions behave more like the other mathematical functions, i.e., the returned result is the correct rounding of the
            exact result of the function in the real numbers. 
            </para>
            <para>
            For example, <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_round</see> with rounding to nearest and a precision of two bits rounds 6.5 to 7 (halfway cases away from zero),
            then 7 is rounded to 8 by the round-even rule, despite the fact that 6 is also representable on two bits, and is closer to 6.5 than 8.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ceil(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_ceil</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_floor(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_floor</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_roundeven(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_trunc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_trunc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_ceil(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_ceil</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_roundeven(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_trunc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_trunc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_frac(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_frac</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_modf(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_modf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmod(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmod</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_fmodquo">mpfr_fmod</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_remainder(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_remainder</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_integer_p(Math.Mpfr.Native.mpfr_t)">mpfr_integer_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Integer_and_Remainder_Related_Functions">Integer and Remainder Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Integer-Related-Functions">GNU MPFR - Integer and Remainder Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 25.2.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 25.2, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = round(op).
            Assert.IsTrue(mpfr_lib.mpfr_rint_floor(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert the value of rop.
            Assert.IsTrue(rop.ToString() == "0.250000000000000000000e2");
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 25.2.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 25.2, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = round(op).
            Assert.IsTrue(mpfr_lib.mpfr_rint_floor(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert the value of rop.
            Assert.IsTrue(rop.ToString() = "0.250000000000000000000e2")
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_frac(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the fractional part of <paramref name="op"/>, having the same sign as <paramref name="op"/>, rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            Unlike in <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint</see>, <paramref name="rnd"/> affects only how the exact fractional part is rounded, not how the fractional part is generated. 
            When <paramref name="op"/> is an integer or an infinity, set <paramref name="rop"/> to zero with the same sign as op.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ceil(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_ceil</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_floor(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_floor</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_roundeven(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_trunc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_trunc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_ceil(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_ceil</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_floor(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_floor</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_roundeven(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_trunc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_trunc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_modf(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_modf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmod(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmod</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_fmodquo">mpfr_fmod</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_remainder(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_remainder</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_integer_p(Math.Mpfr.Native.mpfr_t)">mpfr_integer_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Integer_and_Remainder_Related_Functions">Integer and Remainder Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Integer-Related-Functions">GNU MPFR - Integer and Remainder Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 10.0.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.0, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = fraction(op).
            Assert.IsTrue(mpfr_lib.mpfr_frac(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is 10.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 0.0);
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 10.0.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.0, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = fraction(op).
            Assert.IsTrue(mpfr_lib.mpfr_frac(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is 10.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 0.0)
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_modf(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set simultaneously <paramref name="iop"/> to the integral part of <paramref name="op"/> and <paramref name="fop"/> to the fractional part of <paramref name="op"/>, rounded in the direction <paramref name="rnd"/> with the corresponding precision of <paramref name="iop"/> and <paramref name="fop"/>. 
            </summary>
            <param name="iop">The result integral part.</param>
            <param name="fop">The result frational part.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return 0 iff both results are exact (see <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sin_cos(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sin_cos</see> for a more detailed description of the return value.</returns>
            <remarks>
            <para>
            Equivalent to <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_trunc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_trunc</see>(<paramref name="iop"/>, <paramref name="op"/>, <paramref name="rnd"/>)
            and <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_frac(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_frac</see>(<paramref name="fop"/>, <paramref name="op"/>, <paramref name="rnd"/>). 
            </para>
            <para>
            The variables <paramref name="iop"/> and <paramref name="fop"/> must be different.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ceil(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_ceil</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_floor(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_floor</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_roundeven(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_trunc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_trunc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_ceil(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_ceil</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_floor(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_floor</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_roundeven(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_trunc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_trunc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_frac(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_frac</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmod(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmod</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_fmodquo">mpfr_fmod</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_remainder(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_remainder</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_integer_p(Math.Mpfr.Native.mpfr_t)">mpfr_integer_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Integer_and_Remainder_Related_Functions">Integer and Remainder Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Integer-Related-Functions">GNU MPFR - Integer and Remainder Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 10.4.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number iop.
            mpfr_t iop = new mpfr_t();
            mpfr_lib.mpfr_init2(iop, 64U);
            
            // Create and initialize a new floating-point number fop.
            mpfr_t fop = new mpfr_t();
            mpfr_lib.mpfr_init2(fop, 64U);
            
            // Set rop to log10(op).
            Assert.IsTrue(mpfr_lib.mpfr_modf(iop, fop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert the value of iop and fop.
            Assert.IsTrue(iop.ToString() == "0.100000000000000000000e2");
            Assert.IsTrue(fop.ToString() == "0.400000000000000355271e0");
            
            // Release unmanaged memory allocated for iop, fop, and op.
            mpfr_lib.mpfr_clears(iop, fop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 10.4.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number iop.
            Dim iop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(iop, 64U)
            
            ' Create and initialize a new floating-point number fop.
            Dim fop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(fop, 64U)
            
            ' Set rop to log10(op).
            Assert.IsTrue(mpfr_lib.mpfr_modf(iop, fop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert the value of iop and fop.
            Assert.IsTrue(iop.ToString() = "0.100000000000000000000e2")
            Assert.IsTrue(fop.ToString() = "0.400000000000000355271e0")
            
            ' Release unmanaged memory allocated for iop, fop, and op.
            mpfr_lib.mpfr_clears(iop, fop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_remquo(Math.Mpfr.Native.mpfr_t,System.Int32@,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="r"/> to the value of <paramref name="x"/> - n * <paramref name="y"/>, rounded according to the direction <paramref name="rnd"/>, where n is the integer quotient of <paramref name="x"/> divided by <paramref name="y"/>, rounded to the nearest integer (ties rounded to even). 
            </summary>
            <param name="r">The result remainder floating-point number.</param>
            <param name="q">Low significant bits of quotient.</param>
            <param name="x">The first operand floating-point number.</param>
            <param name="y">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>The return value is the <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">ternary value</a> corresponding to <paramref name="r"/>. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            Special values are handled as described in Section F.9.7.1 of the ISO C99 standard:
            If <paramref name="x"/> is infinite or <paramref name="y"/> is zero, <paramref name="r"/> is NaN.
            If <paramref name="y"/> is infinite and <paramref name="x"/> is finite, <paramref name="r"/> is <paramref name="x"/> rounded to the precision of <paramref name="r"/>.
            If <paramref name="r"/> is zero, it has the sign of <paramref name="x"/>.
            </para>
            <para>
            Additionally, <see cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo">O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo</see> stores the low significant bits from the quotient n in <paramref name="q"/>
            (more precisely the number of bits in a long minus one), with the sign of <paramref name="x"/> divided by <paramref name="y"/>
            (except if those low bits are all zero, in which case zero is returned).
            Note that <paramref name="x"/> may be so large in magnitude relative to <paramref name="y"/> that an exact representation of the quotient
            is not practical.
            The <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_remainder(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_remainder</see> and <see cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo">O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo</see> functions are useful for additive argument reduction. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ceil(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_ceil</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_floor(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_floor</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_roundeven(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_trunc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_trunc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_ceil(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_ceil</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_floor(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_floor</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_roundeven(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_trunc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_trunc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_frac(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_frac</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_modf(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_modf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmod(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmod</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_fmodquo">mpfr_fmod</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_remainder(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_remainder</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_remquo(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.ptr{System.Int32},Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_remquo(mpfr_t, ptr{int}, mpfr_t, mpfr_t, mpfr_rnd_t)</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_integer_p(Math.Mpfr.Native.mpfr_t)">mpfr_integer_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Integer_and_Remainder_Related_Functions">Integer and Remainder Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Integer-Related-Functions">GNU MPFR - Integer and Remainder Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number x to 100.
            mpfr_t x = new mpfr_t();
            mpfr_lib.mpfr_init2(x, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 100, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new floating-point number y to 7.
            mpfr_t y = new mpfr_t();
            mpfr_lib.mpfr_init2(y, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(y, 7, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number r.
            mpfr_t r = new mpfr_t();
            mpfr_lib.mpfr_init2(r, 64U);
            
            // Set r = x - n * y where n = trunc(x / y).
            int q = 0;
            Assert.IsTrue(mpfr_lib.mpfr_remquo(r, ref q, x, y, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert the value of z and q.
            Assert.IsTrue(r.ToString() == "0.200000000000000000000e1" &amp;&amp; q == 14);
            
            // Release unmanaged memory allocated for r, x, and y.
            mpfr_lib.mpfr_clears(r, x, y, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number x to 100.
            Dim x As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(x, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 100, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new floating-point number y to 7.
            Dim y As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(y, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(y, 7, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number r.
            Dim r As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(r, 64U)
            
            ' Set r = x - n * y where n = trunc(x / y).
            Dim q As Integer = 0
            Assert.IsTrue(mpfr_lib.mpfr_remquo(r,ref q,x,y,mpfr_rnd_t.MPFR_RNDN)  =  0)
            
            ' Assert the value of z and q.
            Assert.IsTrue(r.ToString() = "0.200000000000000000000e1" AndAlso q = 14)
            
            ' Release unmanaged memory allocated for r, x, and y.
            mpfr_lib.mpfr_clears(r, x, y, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_remquo(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.ptr{System.Int32},Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="r"/> to the value of <paramref name="x"/> - n * <paramref name="y"/>, rounded according to the direction <paramref name="rnd"/>, where n is the integer quotient of <paramref name="x"/> divided by <paramref name="y"/>, rounded to the nearest integer (ties rounded to even). 
            </summary>
            <param name="r">The result remainder floating-point number.</param>
            <param name="q">Low significant bits of quotient.</param>
            <param name="x">The first operand floating-point number.</param>
            <param name="y">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>The return value is the <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">ternary value</a> corresponding to <paramref name="r"/>. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            Special values are handled as described in Section F.9.7.1 of the ISO C99 standard:
            If <paramref name="x"/> is infinite or <paramref name="y"/> is zero, <paramref name="r"/> is NaN.
            If <paramref name="y"/> is infinite and <paramref name="x"/> is finite, <paramref name="r"/> is <paramref name="x"/> rounded to the precision of <paramref name="r"/>.
            If <paramref name="r"/> is zero, it has the sign of <paramref name="x"/>.
            </para>
            <para>
            Additionally, <see cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo">O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo</see> stores the low significant bits from the quotient n in <paramref name="q"/>
            (more precisely the number of bits in a long minus one), with the sign of <paramref name="x"/> divided by <paramref name="y"/>
            (except if those low bits are all zero, in which case zero is returned).
            Note that <paramref name="x"/> may be so large in magnitude relative to <paramref name="y"/> that an exact representation of the quotient
            is not practical.
            The <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_remainder(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_remainder</see> and <see cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo">O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo</see> functions are useful for additive argument reduction. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ceil(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_ceil</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_floor(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_floor</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_roundeven(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_trunc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_trunc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_ceil(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_ceil</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_floor(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_floor</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_roundeven(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_trunc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_trunc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_frac(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_frac</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_modf(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_modf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmod(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmod</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_fmodquo">mpfr_fmod</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_remainder(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_remainder</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_remquo(Math.Mpfr.Native.mpfr_t,System.Int32@,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_remquo(mpfr_t, ref int, mpfr_t, mpfr_t, mpfr_rnd_t)</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_integer_p(Math.Mpfr.Native.mpfr_t)">mpfr_integer_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Integer_and_Remainder_Related_Functions">Integer and Remainder Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Integer-Related-Functions">GNU MPFR - Integer and Remainder Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number x to 100.
            mpfr_t x = new mpfr_t();
            mpfr_lib.mpfr_init2(x, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 100, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new floating-point number y to 7.
            mpfr_t y = new mpfr_t();
            mpfr_lib.mpfr_init2(y, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(y, 7, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number r.
            mpfr_t r = new mpfr_t();
            mpfr_lib.mpfr_init2(r, 64U);
            
            // Set r = x - n * y where n = trunc(x / y).
            ptr&lt;int&gt; q = new ptr&lt;int&gt;(0);
            Assert.IsTrue(mpfr_lib.mpfr_remquo(r, q, x, y, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert the value of z and q.
            Assert.IsTrue(r.ToString() == "0.200000000000000000000e1" &amp;&amp; q.Value == 14);
            
            // Release unmanaged memory allocated for r, x, and y.
            mpfr_lib.mpfr_clears(r, x, y, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number x to 100.
            Dim x As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(x, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 100, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new floating-point number y to 7.
            Dim y As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(y, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(y, 7, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number r.
            Dim r As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(r, 64U)
            
            ' Set r = x - n * y where n = trunc(x / y).
            Dim q As ptr(Of int) =  New ptr(Of int)(0)
            Assert.IsTrue(mpfr_lib.mpfr_remquo(r, q, x, y, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert the value of z and q.
            Assert.IsTrue(r.ToString() = "0.200000000000000000000e1" AndAlso q.Value = 14)
            
            ' Release unmanaged memory allocated for r, x, and y.
            mpfr_lib.mpfr_clears(r, x, y, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_remainder(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="r"/> to the value of <paramref name="x"/> - n * <paramref name="y"/>, rounded according to the direction <paramref name="rnd"/>, where n is the integer quotient of <paramref name="x"/> divided by <paramref name="y"/>, rounded to the nearest integer (ties rounded to even). 
            </summary>
            <param name="r">The result remainder floating-point number.</param>
            <param name="x">The first operand floating-point number.</param>
            <param name="y">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>The return value is the ternary value corresponding to <paramref name="r"/>. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            Special values are handled as described in Section F.9.7.1 of the ISO C99 standard:
            If <paramref name="x"/> is infinite or <paramref name="y"/> is zero, <paramref name="r"/> is NaN.
            If <paramref name="y"/> is infinite and <paramref name="x"/> is finite, <paramref name="r"/> is <paramref name="x"/> rounded to the precision of <paramref name="r"/>.
            If <paramref name="r"/> is zero, it has the sign of <paramref name="x"/>.
            </para>
            <para>
            The <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_remainder(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_remainder</see> and <see cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo">O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo</see> functions are useful for additive argument reduction. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ceil(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_ceil</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_floor(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_floor</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_roundeven(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_trunc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_trunc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_ceil(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_ceil</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_floor(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_floor</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_roundeven(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_trunc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_trunc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_frac(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_frac</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_modf(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_modf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmod(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmod</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_fmodquo">mpfr_fmod</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_integer_p(Math.Mpfr.Native.mpfr_t)">mpfr_integer_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Integer_and_Remainder_Related_Functions">Integer and Remainder Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Integer-Related-Functions">GNU MPFR - Integer and Remainder Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number x to 100.
            mpfr_t x = new mpfr_t();
            mpfr_lib.mpfr_init2(x, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 100, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new floating-point number y to 3.
            mpfr_t y = new mpfr_t();
            mpfr_lib.mpfr_init2(y, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(y, 3, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number r.
            mpfr_t r = new mpfr_t();
            mpfr_lib.mpfr_init2(r, 64U);
            
            // Set r = x - n * y where n = trunc(x / y).
            Assert.IsTrue(mpfr_lib.mpfr_remainder(r, x, y, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert the value of z.
            Assert.IsTrue(r.ToString() == "0.100000000000000000000e1");
            
            // Release unmanaged memory allocated for r, x, and y.
            mpfr_lib.mpfr_clears(r, x, y, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number x to 100.
            Dim x As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(x, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 100, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new floating-point number y to 3.
            Dim y As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(y, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(y, 3, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number r.
            Dim r As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(r, 64U)
            
            ' Set r = x - n * y where n = trunc(x / y).
            Assert.IsTrue(mpfr_lib.mpfr_remainder(r, x, y, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert the value of z.
            Assert.IsTrue(r.ToString() = "0.100000000000000000000e1")
            
            ' Release unmanaged memory allocated for r, x, and y.
            mpfr_lib.mpfr_clears(r, x, y, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmod(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="r"/> to the value of <paramref name="x"/> - n * <paramref name="y"/>, rounded according to the direction <paramref name="rnd"/>, where n is the integer quotient of <paramref name="x"/> divided by <paramref name="y"/>, rounded toward zero. 
            </summary>
            <param name="r">The result remainder floating-point number.</param>
            <param name="x">The first operand floating-point number.</param>
            <param name="y">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>The return value is the ternary value corresponding to <paramref name="r"/>. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            Special values are handled as described in Section F.9.7.1 of the ISO C99 standard:
            If <paramref name="x"/> is infinite or <paramref name="y"/> is zero, <paramref name="r"/> is NaN.
            If <paramref name="y"/> is infinite and <paramref name="x"/> is finite, <paramref name="r"/> is <paramref name="x"/> rounded to the precision of <paramref name="r"/>.
            If <paramref name="r"/> is zero, it has the sign of <paramref name="x"/>.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ceil(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_ceil</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_floor(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_floor</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_roundeven(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_trunc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_trunc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_ceil(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_ceil</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_floor(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_floor</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_roundeven(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_trunc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_trunc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_frac(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_frac</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_modf(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_modf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_remainder(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_remainder</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_fmodquo">mpfr_fmod</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_integer_p(Math.Mpfr.Native.mpfr_t)">mpfr_integer_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Integer_and_Remainder_Related_Functions">Integer and Remainder Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Integer-Related-Functions">GNU MPFR - Integer and Remainder Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number x to 100.
            mpfr_t x = new mpfr_t();
            mpfr_lib.mpfr_init2(x, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 100, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new floating-point number y to 3.
            mpfr_t y = new mpfr_t();
            mpfr_lib.mpfr_init2(y, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(y, 3, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number r.
            mpfr_t r = new mpfr_t();
            mpfr_lib.mpfr_init2(r, 64U);
            
            // Set r = x - n * y where n = trunc(x / y).
            Assert.IsTrue(mpfr_lib.mpfr_fmod(r, x, y, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert the value of z.
            Assert.IsTrue(r.ToString() == "0.100000000000000000000e1");
            
            // Release unmanaged memory allocated for r, x, and y.
            mpfr_lib.mpfr_clears(r, x, y, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number x to 100.
            Dim x As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(x, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 100, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new floating-point number y to 3.
            Dim y As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(y, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(y, 3, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number r.
            Dim r As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(r, 64U)
            
            ' Set r = x - n * y where n = trunc(x / y).
            Assert.IsTrue(mpfr_lib.mpfr_fmod(r, x, y, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert the value of z.
            Assert.IsTrue(r.ToString() = "0.100000000000000000000e1")
            
            ' Release unmanaged memory allocated for r, x, and y.
            mpfr_lib.mpfr_clears(r, x, y, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmodquo(Math.Mpfr.Native.mpfr_t,System.Int32@,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="r"/> to the value of <paramref name="x"/> - n * <paramref name="y"/>, rounded according to the direction <paramref name="rnd"/>, where n is the integer quotient of <paramref name="x"/> divided by <paramref name="y"/>, rounded  toward zero. 
            </summary>
            <param name="r">The result remainder floating-point number.</param>
            <param name="q">Low significant bits of quotient.</param>
            <param name="x">The first operand floating-point number.</param>
            <param name="y">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>The return value is the <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">ternary value</a> corresponding to <paramref name="r"/>. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            Special values are handled as described in Section F.9.7.1 of the ISO C99 standard:
            If <paramref name="x"/> is infinite or <paramref name="y"/> is zero, <paramref name="r"/> is NaN.
            If <paramref name="y"/> is infinite and <paramref name="x"/> is finite, <paramref name="r"/> is <paramref name="x"/> rounded to the precision of <paramref name="r"/>.
            If <paramref name="r"/> is zero, it has the sign of <paramref name="x"/>.
            </para>
            <para>
            Additionally, <see cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_fmodquo">O:Math.Mpfr.Native.mpfr_lib.mpfr_fmodquo</see> stores the low significant bits from the quotient n in <paramref name="q"/>
            (more precisely the number of bits in a long minus one), with the sign of <paramref name="x"/> divided by <paramref name="y"/>
            (except if those low bits are all zero, in which case zero is returned).
            Note that <paramref name="x"/> may be so large in magnitude relative to <paramref name="y"/> that an exact representation of the quotient
            is not practical. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ceil(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_ceil</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_floor(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_floor</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_roundeven(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_trunc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_trunc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_ceil(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_ceil</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_floor(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_floor</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_roundeven(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_trunc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_trunc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_frac(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_frac</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_modf(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_modf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_remainder(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_remainder</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmod(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmod</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_integer_p(Math.Mpfr.Native.mpfr_t)">mpfr_integer_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Integer_and_Remainder_Related_Functions">Integer and Remainder Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Integer-Related-Functions">GNU MPFR - Integer and Remainder Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number x to 100.
            mpfr_t x = new mpfr_t();
            mpfr_lib.mpfr_init2(x, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 100, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new floating-point number y to 3.
            mpfr_t y = new mpfr_t();
            mpfr_lib.mpfr_init2(y, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(y, 3, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number r.
            mpfr_t r = new mpfr_t();
            mpfr_lib.mpfr_init2(r, 64U);
            
            // Set r = x - n * y where n = trunc(x / y).
            int q = 0;
            Assert.IsTrue(mpfr_lib.mpfr_fmodquo(r, ref q, x, y, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert the value of z and q.
            Assert.IsTrue(r.ToString() == "0.100000000000000000000e1" &amp;&amp; q == 33);
            
            // Release unmanaged memory allocated for r, x, and y.
            mpfr_lib.mpfr_clears(r, x, y, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number x to 100.
            Dim x As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(x, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 100, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new floating-point number y to 3.
            Dim y As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(y, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(y, 3, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number r.
            Dim r As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(r, 64U)
            
            ' Set r = x - n * y where n = trunc(x / y).
            Dim q As Integer = 0
            Assert.IsTrue(mpfr_lib.mpfr_fmodquo(r, q, x, y, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert the value of z and q.
            Assert.IsTrue(r.ToString() = "0.100000000000000000000e1" AndAlso q = 33)
            
            ' Release unmanaged memory allocated for r, x, and y.
            mpfr_lib.mpfr_clears(r, x, y, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmodquo(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.ptr{System.Int32},Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="r"/> to the value of <paramref name="x"/> - n * <paramref name="y"/>, rounded according to the direction <paramref name="rnd"/>, where n is the integer quotient of <paramref name="x"/> divided by <paramref name="y"/>, rounded toward zero. 
            </summary>
            <param name="r">The result remainder floating-point number.</param>
            <param name="q">Low significant bits of quotient.</param>
            <param name="x">The first operand floating-point number.</param>
            <param name="y">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>The return value is the <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">ternary value</a> corresponding to <paramref name="r"/>. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            Special values are handled as described in Section F.9.7.1 of the ISO C99 standard:
            If <paramref name="x"/> is infinite or <paramref name="y"/> is zero, <paramref name="r"/> is NaN.
            If <paramref name="y"/> is infinite and <paramref name="x"/> is finite, <paramref name="r"/> is <paramref name="x"/> rounded to the precision of <paramref name="r"/>.
            If <paramref name="r"/> is zero, it has the sign of <paramref name="x"/>.
            </para>
            <para>
            Additionally, <see cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_fmodquo">O:Math.Mpfr.Native.mpfr_lib.mpfr_fmodquo</see> stores the low significant bits from the quotient n in <paramref name="q"/>
            (more precisely the number of bits in a long minus one), with the sign of <paramref name="x"/> divided by <paramref name="y"/>
            (except if those low bits are all zero, in which case zero is returned).
            Note that <paramref name="x"/> may be so large in magnitude relative to <paramref name="y"/> that an exact representation of the quotient
            is not practical. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ceil(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_ceil</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_floor(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_floor</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_roundeven(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_trunc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_trunc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_ceil(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_ceil</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_floor(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_floor</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_roundeven(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_trunc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_trunc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_frac(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_frac</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_modf(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_modf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_remainder(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_remainder</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmod(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmod</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_integer_p(Math.Mpfr.Native.mpfr_t)">mpfr_integer_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Integer_and_Remainder_Related_Functions">Integer and Remainder Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Integer-Related-Functions">GNU MPFR - Integer and Remainder Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number x to 100.
            mpfr_t x = new mpfr_t();
            mpfr_lib.mpfr_init2(x, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 100, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new floating-point number y to 3.
            mpfr_t y = new mpfr_t();
            mpfr_lib.mpfr_init2(y, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(y, 3, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number r.
            mpfr_t r = new mpfr_t();
            mpfr_lib.mpfr_init2(r, 64U);
            
            // Set r = x - n * y where n = trunc(x / y).
            ptr&lt;int&gt; q = new ptr&lt;int&gt;(0);
            Assert.IsTrue(mpfr_lib.mpfr_fmodquo(r, q, x, y, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert the value of z and q.
            Assert.IsTrue(r.ToString() == "0.100000000000000000000e1" &amp;&amp; q.Value == 33);
            
            // Release unmanaged memory allocated for r, x, and y.
            mpfr_lib.mpfr_clears(r, x, y, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number x to 100.
            Dim x As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(x, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 100, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new floating-point number y to 3.
            Dim y As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(y, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(y, 3, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number r.
            Dim r As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(r, 64U)
            
            ' Set r = x - n * y where n = trunc(x / y).
            Dim q As ptr(Of int) =  New ptr(Of int)(0)
            Assert.IsTrue(mpfr_lib.mpfr_fmodquo(r, q, x, y, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert the value of z and q.
            Assert.IsTrue(r.ToString() = "0.100000000000000000000e1" AndAlso q.Value = 33)
            
            ' Release unmanaged memory allocated for r, x, and y.
            mpfr_lib.mpfr_clears(r, x, y, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_ulong_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Return non-zero if <paramref name="op"/> would fit in the C data type (32-bit) unsigned long when rounded to an integer in the direction <paramref name="rnd"/>. 
            </summary>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return non-zero if <paramref name="op"/> would fit in the C data type (32-bit) unsigned long when rounded to an integer in the direction <paramref name="rnd"/>.</returns>
            <remarks>
            <para>
            For instance, with the <see cref="F:Math.Mpfr.Native.mpfr_rnd_t.MPFR_RNDU"/> rounding mode on −0.5, the result will be non-zero for all mpfr_fits_* functions.
            For <see cref="F:Math.Mpfr.Native.mpfr_rnd_t.MPFR_RNDF"/>, those functions return non-zero when it is guaranteed that the corresponding conversion function
            (for example <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)"/> for <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_ulong_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)"/>), when called with faithful rounding, will always return a number
            that is representable in the corresponding type.
            As a consequence, for <see cref="F:Math.Mpfr.Native.mpfr_rnd_t.MPFR_RNDF"/>, <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_ulong_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)"/> will return non-zero for a non-negative number
            less or equal to ULONG_MAX.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_uj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_uj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_slong_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_slong_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_uint_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_uint_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_sint_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_sint_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_ushort_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_ushort_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_sshort_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_sshort_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_uintmax_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_uintmax_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_intmax_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_intmax_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Conversion_Functions">Conversion Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Conversion-Functions">GNU MPFR - Conversion Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op 4294967295.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_ui(op, uint.MaxValue, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that op does not fit in int.
            Assert.IsTrue(mpfr_lib.mpfr_fits_sint_p(op, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Release unmanaged memory allocated for op.
            mpfr_lib.mpfr_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op 4294967295.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_ui(op, uInteger.MaxValue, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that op does not fit in int.
            Assert.IsTrue(mpfr_lib.mpfr_fits_sint_p(op, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Release unmanaged memory allocated for op.
            mpfr_lib.mpfr_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_slong_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Return non-zero if <paramref name="op"/> would fit in the C data type (32-bit) long when rounded to an integer in the direction <paramref name="rnd"/>. 
            </summary>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return non-zero if <paramref name="op"/> would fit in the C data type (32-bit) long when rounded to an integer in the direction <paramref name="rnd"/>.</returns>
            <remarks>
            <para>
            For instance, with the <see cref="F:Math.Mpfr.Native.mpfr_rnd_t.MPFR_RNDU"/> rounding mode on −0.5, the result will be non-zero for all mpfr_fits_* functions.
            For <see cref="F:Math.Mpfr.Native.mpfr_rnd_t.MPFR_RNDF"/>, those functions return non-zero when it is guaranteed that the corresponding conversion function
            (for example <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)"/> for <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_ulong_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)"/>), when called with faithful rounding, will always return a number
            that is representable in the corresponding type.
            As a consequence, for <see cref="F:Math.Mpfr.Native.mpfr_rnd_t.MPFR_RNDF"/>, <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_ulong_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)"/> will return non-zero for a non-negative number
            less or equal to ULONG_MAX.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_sj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_sj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_ulong_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_ulong_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_uint_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_uint_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_sint_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_sint_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_ushort_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_ushort_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_sshort_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_sshort_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_uintmax_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_uintmax_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_intmax_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_intmax_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Conversion_Functions">Conversion Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Conversion-Functions">GNU MPFR - Conversion Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op 4294967295.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_ui(op, uint.MaxValue, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that op does not fit in long.
            Assert.IsTrue(mpfr_lib.mpfr_fits_slong_p(op, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Release unmanaged memory allocated for op.
            mpfr_lib.mpfr_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op 4294967295.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_ui(op, uInteger.MaxValue, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that op does not fit in long.
            Assert.IsTrue(mpfr_lib.mpfr_fits_slong_p(op, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Release unmanaged memory allocated for op.
            mpfr_lib.mpfr_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_uintmax_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Return non-zero if <paramref name="op"/> would fit in the C data type (32-bit) unsigned long when rounded to an integer in the direction <paramref name="rnd"/>. 
            </summary>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return non-zero if <paramref name="op"/> would fit in the C data type (32-bit) unsigned long when rounded to an integer in the direction <paramref name="rnd"/>.</returns>
            <remarks>
            <para>
            For instance, with the <see cref="F:Math.Mpfr.Native.mpfr_rnd_t.MPFR_RNDU"/> rounding mode on −0.5, the result will be non-zero for all mpfr_fits_* functions.
            For <see cref="F:Math.Mpfr.Native.mpfr_rnd_t.MPFR_RNDF"/>, those functions return non-zero when it is guaranteed that the corresponding conversion function
            (for example <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)"/> for <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_ulong_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)"/>), when called with faithful rounding, will always return a number
            that is representable in the corresponding type.
            As a consequence, for <see cref="F:Math.Mpfr.Native.mpfr_rnd_t.MPFR_RNDF"/>, <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_ulong_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)"/> will return non-zero for a non-negative number
            less or equal to ULONG_MAX.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_uj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_uj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_slong_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_slong_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_uint_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_uint_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_sint_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_sint_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_ushort_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_ushort_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_sshort_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_sshort_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_intmax_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_intmax_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Conversion_Functions">Conversion Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Conversion-Functions">GNU MPFR - Conversion Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op UInt64.MaxValue.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_uj(op, UInt64.MaxValue, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that op fits in uintmax_t.
            Assert.IsTrue(mpfr_lib.mpfr_fits_uintmax_p(op, mpfr_rnd_t.MPFR_RNDN) != 0);
            
            // Release unmanaged memory allocated for op.
            mpfr_lib.mpfr_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op UInt64.MaxValue.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_uj(op, UInt64.MaxValue, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that op fits in uintmax_t.
            Assert.IsTrue(mpfr_lib.mpfr_fits_uintmax_p(op,mpfr_rnd_t.MPFR_RNDN) &lt;&gt; 0)
            
            ' Release unmanaged memory allocated for op.
            mpfr_lib.mpfr_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_intmax_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Return non-zero if <paramref name="op"/> would fit in the C data type (32-bit) long when rounded to an integer in the direction <paramref name="rnd"/>. 
            </summary>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return non-zero if <paramref name="op"/> would fit in the C data type (32-bit) long when rounded to an integer in the direction <paramref name="rnd"/>.</returns>
            <remarks>
            <para>
            For instance, with the <see cref="F:Math.Mpfr.Native.mpfr_rnd_t.MPFR_RNDU"/> rounding mode on −0.5, the result will be non-zero for all mpfr_fits_* functions.
            For <see cref="F:Math.Mpfr.Native.mpfr_rnd_t.MPFR_RNDF"/>, those functions return non-zero when it is guaranteed that the corresponding conversion function
            (for example <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)"/> for <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_ulong_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)"/>), when called with faithful rounding, will always return a number
            that is representable in the corresponding type.
            As a consequence, for <see cref="F:Math.Mpfr.Native.mpfr_rnd_t.MPFR_RNDF"/>, <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_ulong_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)"/> will return non-zero for a non-negative number
            less or equal to ULONG_MAX.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_sj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_sj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_ulong_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_ulong_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_uint_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_uint_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_sint_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_sint_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_ushort_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_ushort_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_sshort_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_sshort_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_uintmax_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_uintmax_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Conversion_Functions">Conversion Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Conversion-Functions">GNU MPFR - Conversion Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op Int64.MaxValue.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_uj(op, Int64.MaxValue, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that op fits in intmax_t.
            Assert.IsTrue(mpfr_lib.mpfr_fits_intmax_p(op, mpfr_rnd_t.MPFR_RNDN) != 0);
            
            // Release unmanaged memory allocated for op.
            mpfr_lib.mpfr_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op Int64.MaxValue.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_uj(op, Int64.MaxValue, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that op fits in intmax_t.
            Assert.IsTrue(mpfr_lib.mpfr_fits_intmax_p(op,mpfr_rnd_t.MPFR_RNDN) &lt;&gt; 0)
            
            ' Release unmanaged memory allocated for op.
            mpfr_lib.mpfr_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_uint_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Return non-zero if <paramref name="op"/> would fit in the C data type (32-bit) unsigned int when rounded to an integer in the direction <paramref name="rnd"/>. 
            </summary>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return non-zero if <paramref name="op"/> would fit in the C data type (32-bit) unsigned int when rounded to an integer in the direction <paramref name="rnd"/>.</returns>
            <remarks>
            <para>
            For instance, with the <see cref="F:Math.Mpfr.Native.mpfr_rnd_t.MPFR_RNDU"/> rounding mode on −0.5, the result will be non-zero for all mpfr_fits_* functions.
            For <see cref="F:Math.Mpfr.Native.mpfr_rnd_t.MPFR_RNDF"/>, those functions return non-zero when it is guaranteed that the corresponding conversion function
            (for example <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)"/> for <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_ulong_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)"/>), when called with faithful rounding, will always return a number
            that is representable in the corresponding type.
            As a consequence, for <see cref="F:Math.Mpfr.Native.mpfr_rnd_t.MPFR_RNDF"/>, <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_ulong_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)"/> will return non-zero for a non-negative number
            less or equal to ULONG_MAX.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_ulong_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_ulong_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_slong_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_slong_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_sint_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_sint_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_ushort_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_ushort_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_sshort_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_sshort_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_uintmax_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_uintmax_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_intmax_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_intmax_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Conversion_Functions">Conversion Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Conversion-Functions">GNU MPFR - Conversion Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op 4294967295.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_ui(op, uint.MaxValue, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that op does not fit in uint.
            Assert.IsTrue(mpfr_lib.mpfr_fits_uint_p(op, mpfr_rnd_t.MPFR_RNDN) > 0);
            
            // Release unmanaged memory allocated for op.
            mpfr_lib.mpfr_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op 4294967295.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_ui(op, uInteger.MaxValue, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that op does not fit in uint.
            Assert.IsTrue(mpfr_lib.mpfr_fits_uint_p(op, mpfr_rnd_t.MPFR_RNDN) > 0)
            
            ' Release unmanaged memory allocated for op.
            mpfr_lib.mpfr_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_sint_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Return non-zero if <paramref name="op"/> would fit in the C data type (32-bit) int when rounded to an integer in the direction <paramref name="rnd"/>. 
            </summary>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return non-zero if <paramref name="op"/> would fit in the C data type (32-bit) int when rounded to an integer in the direction <paramref name="rnd"/>.</returns>
            <remarks>
            <para>
            For instance, with the <see cref="F:Math.Mpfr.Native.mpfr_rnd_t.MPFR_RNDU"/> rounding mode on −0.5, the result will be non-zero for all mpfr_fits_* functions.
            For <see cref="F:Math.Mpfr.Native.mpfr_rnd_t.MPFR_RNDF"/>, those functions return non-zero when it is guaranteed that the corresponding conversion function
            (for example <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)"/> for <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_ulong_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)"/>), when called with faithful rounding, will always return a number
            that is representable in the corresponding type.
            As a consequence, for <see cref="F:Math.Mpfr.Native.mpfr_rnd_t.MPFR_RNDF"/>, <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_ulong_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)"/> will return non-zero for a non-negative number
            less or equal to ULONG_MAX.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_ulong_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_ulong_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_slong_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_slong_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_uint_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_uint_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_ushort_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_ushort_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_sshort_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_sshort_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_uintmax_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_uintmax_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_intmax_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_intmax_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Conversion_Functions">Conversion Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Conversion-Functions">GNU MPFR - Conversion Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op 4294967295.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_ui(op, uint.MaxValue, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that op does not fit in int.
            Assert.IsTrue(mpfr_lib.mpfr_fits_sint_p(op, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Release unmanaged memory allocated for op.
            mpfr_lib.mpfr_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op 4294967295.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_ui(op, uInteger.MaxValue, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that op does not fit in int.
            Assert.IsTrue(mpfr_lib.mpfr_fits_sint_p(op, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Release unmanaged memory allocated for op.
            mpfr_lib.mpfr_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_ushort_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Return non-zero if <paramref name="op"/> would fit in the C data type (16-bit) unsigned short when rounded to an integer in the direction <paramref name="rnd"/>. 
            </summary>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return non-zero if <paramref name="op"/> would fit in the C data type (16-bit) unsigned short when rounded to an integer in the direction <paramref name="rnd"/>.</returns>
            <remarks>
            <para>
            For instance, with the <see cref="F:Math.Mpfr.Native.mpfr_rnd_t.MPFR_RNDU"/> rounding mode on −0.5, the result will be non-zero for all mpfr_fits_* functions.
            For <see cref="F:Math.Mpfr.Native.mpfr_rnd_t.MPFR_RNDF"/>, those functions return non-zero when it is guaranteed that the corresponding conversion function
            (for example <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)"/> for <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_ulong_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)"/>), when called with faithful rounding, will always return a number
            that is representable in the corresponding type.
            As a consequence, for <see cref="F:Math.Mpfr.Native.mpfr_rnd_t.MPFR_RNDF"/>, <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_ulong_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)"/> will return non-zero for a non-negative number
            less or equal to ULONG_MAX.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_ulong_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_ulong_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_slong_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_slong_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_uint_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_uint_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_sint_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_sint_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_sshort_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_sshort_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_uintmax_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_uintmax_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_intmax_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_intmax_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Conversion_Functions">Conversion Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Conversion-Functions">GNU MPFR - Conversion Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op 4294967295.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_ui(op, uint.MaxValue, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that op does not fit in ushort.
            Assert.IsTrue(mpfr_lib.mpfr_fits_ushort_p(op, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Release unmanaged memory allocated for op.
            mpfr_lib.mpfr_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op 4294967295.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_ui(op, uInteger.MaxValue, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that op does not fit in ushort.
            Assert.IsTrue(mpfr_lib.mpfr_fits_ushort_p(op, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Release unmanaged memory allocated for op.
            mpfr_lib.mpfr_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_sshort_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Return non-zero if <paramref name="op"/> would fit in the C data type (16-bit) short when rounded to an integer in the direction <paramref name="rnd"/>.
            </summary>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return non-zero if <paramref name="op"/> would fit in the C data type (16-bit) short when rounded to an integer in the direction <paramref name="rnd"/>.</returns>
            <remarks>
            <para>
            For instance, with the <see cref="F:Math.Mpfr.Native.mpfr_rnd_t.MPFR_RNDU"/> rounding mode on −0.5, the result will be non-zero for all mpfr_fits_* functions.
            For <see cref="F:Math.Mpfr.Native.mpfr_rnd_t.MPFR_RNDF"/>, those functions return non-zero when it is guaranteed that the corresponding conversion function
            (for example <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)"/> for <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_ulong_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)"/>), when called with faithful rounding, will always return a number
            that is representable in the corresponding type.
            As a consequence, for <see cref="F:Math.Mpfr.Native.mpfr_rnd_t.MPFR_RNDF"/>, <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_ulong_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)"/> will return non-zero for a non-negative number
            less or equal to ULONG_MAX.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_get_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_ulong_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_ulong_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_slong_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_slong_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_uint_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_uint_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_sint_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_sint_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_ushort_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_ushort_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_uintmax_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_uintmax_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fits_intmax_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fits_intmax_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Conversion_Functions">Conversion Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Conversion-Functions">GNU MPFR - Conversion Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op 4294967295.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_ui(op, uint.MaxValue, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that op does not fit in short.
            Assert.IsTrue(mpfr_lib.mpfr_fits_sshort_p(op, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Release unmanaged memory allocated for op.
            mpfr_lib.mpfr_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op 4294967295.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_ui(op, uInteger.MaxValue, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that op does not fit in short.
            Assert.IsTrue(mpfr_lib.mpfr_fits_sshort_p(op, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Release unmanaged memory allocated for op.
            mpfr_lib.mpfr_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_swap(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">
            <summary>
            Swap the structures pointed to by <paramref name="x"/> and <paramref name="y"/>.
            </summary>
            <param name="x">The first operand floating-point number.</param>
            <param name="y">The second operand floating-point number.</param>
            <remarks>
            <para>
            In particular, the values are exchanged without rounding (this may be different from three <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set</see> calls using a third auxiliary variable).
            </para>
            <para>
            Warning! Since the precisions are exchanged, this will affect future assignments.
            Moreover, since the significand pointers are also exchanged, you must not use this function if the allocation
            method used for <paramref name="x"/> and/or <paramref name="y"/> does not permit it.
            This is the case when <paramref name="x"/> and/or <paramref name="y"/> were declared and initialized
            with <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_init_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_kind_t,Math.Mpfr.Native.mpfr_exp_t,System.UInt32,Math.Gmp.Native.void_ptr)">mpfr_custom_init_set</see> (see <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Custom-Interface">GNU MPFR - Custom Interface</a>). 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_si(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_uj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_uj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_sj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_sj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_flt(Math.Mpfr.Native.mpfr_t,System.Single,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_flt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_d(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_f</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_ui_2exp(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_ui_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_si_2exp(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_si_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_uj_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_uj_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_sj_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_sj_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_z_2exp(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_z_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_str(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.char_ptr,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_str</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_nan(Math.Mpfr.Native.mpfr_t)">mpfr_set_nan</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_inf(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_set_inf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_zero(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_set_zero</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Assignment_Functions">Assignment Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Assignment-Functions">GNU MPFR - Assignment Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number x to 10.
            mpfr_t x = new mpfr_t();
            mpfr_lib.mpfr_init2(x, 128U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new floating-point number y to -210.
            mpfr_t y = new mpfr_t();
            mpfr_lib.mpfr_init2(y, 128U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(y, -210, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Swap the values of x and y.
            mpfr_lib.mpfr_swap(x, y);
            
            // Assert that the value of x is -210.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(x, mpfr_rnd_t.MPFR_RNDN) == -210.0);
            
            // Assert that the value of y is 10.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(y, mpfr_rnd_t.MPFR_RNDN) == 10.0);
            
            // Release unmanaged memory allocated for x and y.
            mpfr_lib.mpfr_clears(x, y, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number x to 10.
            Dim x As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(x, 128U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new floating-point number y to -210.
            Dim y As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(y, 128U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(y, -210, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Swap the values of x and y.
            mpfr_lib.mpfr_swap(x, y)
            
            ' Assert that the value of x is -210.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(x, mpfr_rnd_t.MPFR_RNDN) = -210.0)
            
            ' Assert that the value of y is 10.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(y, mpfr_rnd_t.MPFR_RNDN) = 10.0)
            
            ' Release unmanaged memory allocated for x and y.
            mpfr_lib.mpfr_clears(x, y, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_nan_p(Math.Mpfr.Native.mpfr_t)">
            <summary>
            Return non-zero if <paramref name="op"/> is NaN. Return zero otherwise.
            </summary>
            <param name="op">The operand floating-point number.</param>
            <returns>Return non-zero if <paramref name="op"/> is NaN. Return zero otherwise.</returns>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_cmp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_ui(Math.Mpfr.Native.mpfr_t,System.UInt32)">mpfr_cmp_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_si(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_cmp_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_d(Math.Mpfr.Native.mpfr_t,System.Double)">mpfr_cmp_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t)">mpfr_cmp_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t)">mpfr_cmp_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t)">mpfr_cmp_f</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_ui_2exp(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_exp_t)">mpfr_cmp_ui_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_si_2exp(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_exp_t)">mpfr_cmp_si_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmpabs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_cmpabs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inf_p(Math.Mpfr.Native.mpfr_t)">mpfr_inf_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_number_p(Math.Mpfr.Native.mpfr_t)">mpfr_number_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zero_p(Math.Mpfr.Native.mpfr_t)">mpfr_zero_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_regular_p(Math.Mpfr.Native.mpfr_t)">mpfr_regular_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sgn(Math.Mpfr.Native.mpfr_t)">mpfr_sgn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_greater_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_greater_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_greaterequal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_greaterequal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_less_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_less_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lessequal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_lessequal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_equal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_equal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lessgreater_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_lessgreater_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_unordered_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_unordered_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Comparison_Functions">Comparison Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Comparison-Functions">GNU MPFR - Comparison Functions</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize a new floating-point number op.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            
            // Assert that op is NaN.
            Assert.IsTrue(mpfr_lib.mpfr_nan_p(op) != 0);
            
            // Release unmanaged memory allocated for op.
            mpfr_lib.mpfr_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create and initialize a new floating-point number op.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            
            ' Assert that op is NaN.
            Assert.IsTrue(mpfr_lib.mpfr_nan_p(op) &lt;&gt; 0)
            
            ' Release unmanaged memory allocated for op.
            mpfr_lib.mpfr_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_inf_p(Math.Mpfr.Native.mpfr_t)">
            <summary>
            Return non-zero if <paramref name="op"/> is an infinity. Return zero otherwise.
            </summary>
            <param name="op">The operand floating-point number.</param>
            <returns>Return non-zero if <paramref name="op"/> is an infinity. Return zero otherwise.</returns>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_cmp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_ui(Math.Mpfr.Native.mpfr_t,System.UInt32)">mpfr_cmp_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_si(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_cmp_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_d(Math.Mpfr.Native.mpfr_t,System.Double)">mpfr_cmp_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t)">mpfr_cmp_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t)">mpfr_cmp_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t)">mpfr_cmp_f</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_ui_2exp(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_exp_t)">mpfr_cmp_ui_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_si_2exp(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_exp_t)">mpfr_cmp_si_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmpabs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_cmpabs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nan_p(Math.Mpfr.Native.mpfr_t)">mpfr_nan_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_number_p(Math.Mpfr.Native.mpfr_t)">mpfr_number_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zero_p(Math.Mpfr.Native.mpfr_t)">mpfr_zero_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_regular_p(Math.Mpfr.Native.mpfr_t)">mpfr_regular_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sgn(Math.Mpfr.Native.mpfr_t)">mpfr_sgn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_greater_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_greater_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_greaterequal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_greaterequal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_less_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_less_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lessequal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_lessequal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_equal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_equal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lessgreater_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_lessgreater_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_unordered_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_unordered_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Comparison_Functions">Comparison Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Comparison-Functions">GNU MPFR - Comparison Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 1.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that op is not infinity.
            Assert.IsTrue(mpfr_lib.mpfr_inf_p(op) == 0);
            
            // Release unmanaged memory allocated for op.
            mpfr_lib.mpfr_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 1.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that op is not infinity.
            Assert.IsTrue(mpfr_lib.mpfr_inf_p(op) = 0)
            
            ' Release unmanaged memory allocated for op.
            mpfr_lib.mpfr_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_number_p(Math.Mpfr.Native.mpfr_t)">
            <summary>
            Return non-zero if <paramref name="op"/> is an ordinary number (i.e., neither NaN nor an infinity). Return zero otherwise.
            </summary>
            <param name="op">The operand floating-point number.</param>
            <returns>Return non-zero if <paramref name="op"/> is an ordinary number (i.e., neither NaN nor an infinity). Return zero otherwise.</returns>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_cmp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_ui(Math.Mpfr.Native.mpfr_t,System.UInt32)">mpfr_cmp_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_si(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_cmp_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_d(Math.Mpfr.Native.mpfr_t,System.Double)">mpfr_cmp_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t)">mpfr_cmp_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t)">mpfr_cmp_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t)">mpfr_cmp_f</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_ui_2exp(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_exp_t)">mpfr_cmp_ui_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_si_2exp(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_exp_t)">mpfr_cmp_si_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmpabs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_cmpabs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nan_p(Math.Mpfr.Native.mpfr_t)">mpfr_nan_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inf_p(Math.Mpfr.Native.mpfr_t)">mpfr_inf_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zero_p(Math.Mpfr.Native.mpfr_t)">mpfr_zero_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_regular_p(Math.Mpfr.Native.mpfr_t)">mpfr_regular_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sgn(Math.Mpfr.Native.mpfr_t)">mpfr_sgn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_greater_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_greater_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_greaterequal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_greaterequal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_less_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_less_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lessequal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_lessequal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_equal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_equal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lessgreater_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_lessgreater_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_unordered_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_unordered_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Comparison_Functions">Comparison Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Comparison-Functions">GNU MPFR - Comparison Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 10.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that op is an integer.
            Assert.IsTrue(mpfr_lib.mpfr_number_p(op) != 0);
            
            // Release unmanaged memory allocated for op.
            mpfr_lib.mpfr_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 10.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that op is an integer.
            Assert.IsTrue(mpfr_lib.mpfr_number_p(op) &lt;&gt; 0)
            
            ' Release unmanaged memory allocated for op.
            mpfr_lib.mpfr_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_integer_p(Math.Mpfr.Native.mpfr_t)">
            <summary>
            Return non-zero iff <paramref name="op"/> is an integer.
            </summary>
            <param name="op">The operand floating-point number.</param>
            <returns>Return non-zero iff <paramref name="op"/> is an integer.</returns>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ceil(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_ceil</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_floor(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_floor</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_roundeven(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_trunc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_trunc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_ceil(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_ceil</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_floor(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_floor</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_roundeven(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_round</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rint_trunc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_rint_trunc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_frac(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_frac</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_modf(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_modf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmod(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmod</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_fmodquo">mpfr_fmod</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_remainder(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_remainder</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo"/>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Integer_and_Remainder_Related_Functions">Integer and Remainder Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Integer-Related-Functions">GNU MPFR - Integer and Remainder Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 10.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that op is an integer.
            Assert.IsTrue(mpfr_lib.mpfr_integer_p(op) != 0);
            
            // Release unmanaged memory allocated for op.
            mpfr_lib.mpfr_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 10.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that op is an integer.
            Assert.IsTrue(mpfr_lib.mpfr_integer_p(op) &lt;&gt;  0)
            
            ' Release unmanaged memory allocated for op.
            mpfr_lib.mpfr_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_zero_p(Math.Mpfr.Native.mpfr_t)">
            <summary>
            Return non-zero if <paramref name="op"/> is zero. Return zero otherwise.
            </summary>
            <param name="op">The operand floating-point number.</param>
            <returns>Return non-zero if <paramref name="op"/> is zero. Return zero otherwise.</returns>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_cmp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_ui(Math.Mpfr.Native.mpfr_t,System.UInt32)">mpfr_cmp_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_si(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_cmp_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_d(Math.Mpfr.Native.mpfr_t,System.Double)">mpfr_cmp_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t)">mpfr_cmp_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t)">mpfr_cmp_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t)">mpfr_cmp_f</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_ui_2exp(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_exp_t)">mpfr_cmp_ui_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_si_2exp(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_exp_t)">mpfr_cmp_si_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmpabs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_cmpabs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nan_p(Math.Mpfr.Native.mpfr_t)">mpfr_nan_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inf_p(Math.Mpfr.Native.mpfr_t)">mpfr_inf_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_number_p(Math.Mpfr.Native.mpfr_t)">mpfr_number_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_regular_p(Math.Mpfr.Native.mpfr_t)">mpfr_regular_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sgn(Math.Mpfr.Native.mpfr_t)">mpfr_sgn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_greater_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_greater_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_greaterequal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_greaterequal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_less_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_less_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lessequal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_lessequal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_equal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_equal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lessgreater_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_lessgreater_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_unordered_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_unordered_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Comparison_Functions">Comparison Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Comparison-Functions">GNU MPFR - Comparison Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 10.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that op is nopt zero.
            Assert.IsTrue(mpfr_lib.mpfr_zero_p(op) == 0);
            
            // Release unmanaged memory allocated for op.
            mpfr_lib.mpfr_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 10.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that op is nopt zero.
            Assert.IsTrue(mpfr_lib.mpfr_zero_p(op) = 0)
            
            ' Release unmanaged memory allocated for op.
            mpfr_lib.mpfr_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_regular_p(Math.Mpfr.Native.mpfr_t)">
            <summary>
            Return non-zero if <paramref name="op"/> is a regular number (i.e., neither NaN, nor an infinity nor zero). Return zero otherwise.
            </summary>
            <param name="op">The operand floating-point number.</param>
            <returns>Return non-zero if <paramref name="op"/> is a regular number (i.e., neither NaN, nor an infinity nor zero). Return zero otherwise.</returns>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_cmp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_ui(Math.Mpfr.Native.mpfr_t,System.UInt32)">mpfr_cmp_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_si(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_cmp_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_d(Math.Mpfr.Native.mpfr_t,System.Double)">mpfr_cmp_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t)">mpfr_cmp_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t)">mpfr_cmp_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t)">mpfr_cmp_f</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_ui_2exp(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_exp_t)">mpfr_cmp_ui_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_si_2exp(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_exp_t)">mpfr_cmp_si_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmpabs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_cmpabs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nan_p(Math.Mpfr.Native.mpfr_t)">mpfr_nan_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inf_p(Math.Mpfr.Native.mpfr_t)">mpfr_inf_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_number_p(Math.Mpfr.Native.mpfr_t)">mpfr_number_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zero_p(Math.Mpfr.Native.mpfr_t)">mpfr_zero_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sgn(Math.Mpfr.Native.mpfr_t)">mpfr_sgn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_greater_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_greater_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_greaterequal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_greaterequal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_less_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_less_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lessequal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_lessequal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_equal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_equal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lessgreater_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_lessgreater_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_unordered_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_unordered_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Comparison_Functions">Comparison Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Comparison-Functions">GNU MPFR - Comparison Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 10.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that op is an integer.
            Assert.IsTrue(mpfr_lib.mpfr_regular_p(op) != 0);
            
            // Release unmanaged memory allocated for op.
            mpfr_lib.mpfr_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 10.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that op is an integer.
            Assert.IsTrue(mpfr_lib.mpfr_regular_p(op) &lt;&gt; 0)
            
            ' Release unmanaged memory allocated for op.
            mpfr_lib.mpfr_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_greater_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">
            <summary>
            Return non-zero if <paramref name="op1"/> &gt; <paramref name="op2"/>, and zero otherwise.
            </summary>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <returns>Return non-zero if <paramref name="op1"/> &gt; <paramref name="op2"/>, and zero otherwise.</returns>
            <remarks>
            <para>
            Return zero whenever <paramref name="op1"/> and/or <paramref name="op2"/> is NaN. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_cmp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_ui(Math.Mpfr.Native.mpfr_t,System.UInt32)">mpfr_cmp_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_si(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_cmp_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_d(Math.Mpfr.Native.mpfr_t,System.Double)">mpfr_cmp_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t)">mpfr_cmp_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t)">mpfr_cmp_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t)">mpfr_cmp_f</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_ui_2exp(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_exp_t)">mpfr_cmp_ui_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_si_2exp(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_exp_t)">mpfr_cmp_si_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmpabs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_cmpabs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nan_p(Math.Mpfr.Native.mpfr_t)">mpfr_nan_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inf_p(Math.Mpfr.Native.mpfr_t)">mpfr_inf_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_number_p(Math.Mpfr.Native.mpfr_t)">mpfr_number_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zero_p(Math.Mpfr.Native.mpfr_t)">mpfr_zero_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_regular_p(Math.Mpfr.Native.mpfr_t)">mpfr_regular_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sgn(Math.Mpfr.Native.mpfr_t)">mpfr_sgn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_greaterequal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_greaterequal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_less_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_less_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lessequal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_lessequal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_equal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_equal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lessgreater_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_lessgreater_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_unordered_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_unordered_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Comparison_Functions">Comparison Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Comparison-Functions">GNU MPFR - Comparison Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to 1.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new floating-point number op2 to 1.
            mpfr_t op2 = new mpfr_t();
            mpfr_lib.mpfr_init2(op2, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that op1 > op2 is false.
            Assert.IsTrue(mpfr_lib.mpfr_greater_p(op1, op2) == 0);
            
            // Release unmanaged memory allocated for op1 and op2.
            mpfr_lib.mpfr_clears(op1, op2, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to 1.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new floating-point number op2 to 1.
            Dim op2 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op2, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that op1 > op2 is false.
            Assert.IsTrue(mpfr_lib.mpfr_greater_p(op1, op2) = 0)
            
            ' Release unmanaged memory allocated for op1 and op2.
            mpfr_lib.mpfr_clears(op1, op2, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_greaterequal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">
            <summary>
            Return non-zero if <paramref name="op1"/> &#8805; <paramref name="op2"/>, and zero otherwise.
            </summary>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <returns>Return non-zero if <paramref name="op1"/> &#8805; <paramref name="op2"/>, and zero otherwise.</returns>
            <remarks>
            <para>
            Return zero whenever <paramref name="op1"/> and/or <paramref name="op2"/> is NaN. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_cmp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_ui(Math.Mpfr.Native.mpfr_t,System.UInt32)">mpfr_cmp_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_si(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_cmp_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_d(Math.Mpfr.Native.mpfr_t,System.Double)">mpfr_cmp_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t)">mpfr_cmp_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t)">mpfr_cmp_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t)">mpfr_cmp_f</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_ui_2exp(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_exp_t)">mpfr_cmp_ui_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_si_2exp(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_exp_t)">mpfr_cmp_si_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmpabs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_cmpabs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nan_p(Math.Mpfr.Native.mpfr_t)">mpfr_nan_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inf_p(Math.Mpfr.Native.mpfr_t)">mpfr_inf_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_number_p(Math.Mpfr.Native.mpfr_t)">mpfr_number_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zero_p(Math.Mpfr.Native.mpfr_t)">mpfr_zero_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_regular_p(Math.Mpfr.Native.mpfr_t)">mpfr_regular_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sgn(Math.Mpfr.Native.mpfr_t)">mpfr_sgn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_greater_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_greater_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_less_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_less_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lessequal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_lessequal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_equal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_equal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lessgreater_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_lessgreater_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_unordered_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_unordered_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Comparison_Functions">Comparison Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Comparison-Functions">GNU MPFR - Comparison Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to 1.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new floating-point number op2 to 1.
            mpfr_t op2 = new mpfr_t();
            mpfr_lib.mpfr_init2(op2, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that op1 >= op2.
            Assert.IsTrue(mpfr_lib.mpfr_greaterequal_p(op1, op2) != 0);
            
            // Release unmanaged memory allocated for op1 and op2.
            mpfr_lib.mpfr_clears(op1, op2, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to 1.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new floating-point number op2 to 1.
            Dim op2 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op2, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that op1 >= op2.
            Assert.IsTrue(mpfr_lib.mpfr_greaterequal_p(op1,op2) &lt;&gt; 0)
            
            ' Release unmanaged memory allocated for op1 and op2.
            mpfr_lib.mpfr_clears(op1, op2, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_less_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">
            <summary>
            Return non-zero if <paramref name="op1"/> &lt; <paramref name="op2"/>, and zero otherwise.
            </summary>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <returns>Return non-zero if <paramref name="op1"/> &lt; <paramref name="op2"/>, and zero otherwise.</returns>
            <remarks>
            <para>
            Return zero whenever <paramref name="op1"/> and/or <paramref name="op2"/> is NaN. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_cmp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_ui(Math.Mpfr.Native.mpfr_t,System.UInt32)">mpfr_cmp_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_si(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_cmp_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_d(Math.Mpfr.Native.mpfr_t,System.Double)">mpfr_cmp_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t)">mpfr_cmp_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t)">mpfr_cmp_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t)">mpfr_cmp_f</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_ui_2exp(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_exp_t)">mpfr_cmp_ui_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_si_2exp(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_exp_t)">mpfr_cmp_si_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmpabs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_cmpabs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nan_p(Math.Mpfr.Native.mpfr_t)">mpfr_nan_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inf_p(Math.Mpfr.Native.mpfr_t)">mpfr_inf_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_number_p(Math.Mpfr.Native.mpfr_t)">mpfr_number_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zero_p(Math.Mpfr.Native.mpfr_t)">mpfr_zero_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_regular_p(Math.Mpfr.Native.mpfr_t)">mpfr_regular_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sgn(Math.Mpfr.Native.mpfr_t)">mpfr_sgn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_greater_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_greater_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_greaterequal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_greaterequal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lessequal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_lessequal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_equal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_equal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lessgreater_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_lessgreater_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_unordered_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_unordered_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Comparison_Functions">Comparison Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Comparison-Functions">GNU MPFR - Comparison Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to 1.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new floating-point number op2 to 1.
            mpfr_t op2 = new mpfr_t();
            mpfr_lib.mpfr_init2(op2, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that op1 &lt; op2 is false.
            Assert.IsTrue(mpfr_lib.mpfr_less_p(op1, op2) == 0);
            
            // Release unmanaged memory allocated for op1 and op2.
            mpfr_lib.mpfr_clears(op1, op2, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to 1.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new floating-point number op2 to 1.
            Dim op2 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op2, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that op1 &lt; op2 is false.
            Assert.IsTrue(mpfr_lib.mpfr_less_p(op1, op2) = 0)
            
            ' Release unmanaged memory allocated for op1 and op2.
            mpfr_lib.mpfr_clears(op1, op2, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_lessequal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">
            <summary>
            Return non-zero if <paramref name="op1"/> &#8804; <paramref name="op2"/>, and zero otherwise.
            </summary>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <returns>Return zero whenever <paramref name="op1"/> and/or <paramref name="op2"/> is NaN.</returns>
            <remarks>
            <para>
            Return zero whenever <paramref name="op1"/> and/or <paramref name="op2"/> is NaN. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_cmp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_ui(Math.Mpfr.Native.mpfr_t,System.UInt32)">mpfr_cmp_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_si(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_cmp_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_d(Math.Mpfr.Native.mpfr_t,System.Double)">mpfr_cmp_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t)">mpfr_cmp_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t)">mpfr_cmp_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t)">mpfr_cmp_f</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_ui_2exp(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_exp_t)">mpfr_cmp_ui_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_si_2exp(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_exp_t)">mpfr_cmp_si_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmpabs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_cmpabs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nan_p(Math.Mpfr.Native.mpfr_t)">mpfr_nan_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inf_p(Math.Mpfr.Native.mpfr_t)">mpfr_inf_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_number_p(Math.Mpfr.Native.mpfr_t)">mpfr_number_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zero_p(Math.Mpfr.Native.mpfr_t)">mpfr_zero_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_regular_p(Math.Mpfr.Native.mpfr_t)">mpfr_regular_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sgn(Math.Mpfr.Native.mpfr_t)">mpfr_sgn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_greater_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_greater_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_greaterequal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_greaterequal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_less_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_less_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_equal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_equal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lessgreater_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_lessgreater_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_unordered_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_unordered_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Comparison_Functions">Comparison Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Comparison-Functions">GNU MPFR - Comparison Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to 1.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new floating-point number op2 to 1.
            mpfr_t op2 = new mpfr_t();
            mpfr_lib.mpfr_init2(op2, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that op1 &lt;= op2.
            Assert.IsTrue(mpfr_lib.mpfr_lessequal_p(op1, op2) != 0);
            
            // Release unmanaged memory allocated for op1 and op2.
            mpfr_lib.mpfr_clears(op1, op2, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to 1.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new floating-point number op2 to 1.
            Dim op2 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op2, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that op1 &lt;= op2.
             Assert.IsTrue(mpfr_lib.mpfr_lessequal_p(op1,op2) &lt;&gt; 0)
            
            ' Release unmanaged memory allocated for op1 and op2.
            mpfr_lib.mpfr_clears(op1, op2, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_lessgreater_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">
            <summary>
            Return non-zero if <paramref name="op1"/> &lt; <paramref name="op2"/> or <paramref name="op1"/> &gt; <paramref name="op2"/> (i.e., neither <paramref name="op1"/>, nor <paramref name="op2"/> is NaN, and <paramref name="op1"/> &#8800; <paramref name="op2"/>), zero otherwise (i.e., <paramref name="op1"/> and/or <paramref name="op2"/> is NaN, or <paramref name="op1"/> = <paramref name="op2"/>).
            </summary>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <returns>Return non-zero if <paramref name="op1"/> &lt; <paramref name="op2"/> or <paramref name="op1"/> &gt; <paramref name="op2"/> (i.e., neither <paramref name="op1"/>, nor <paramref name="op2"/> is NaN, and <paramref name="op1"/> &#8800; <paramref name="op2"/>), zero otherwise (i.e., <paramref name="op1"/> and/or <paramref name="op2"/> is NaN, or <paramref name="op1"/> = <paramref name="op2"/>).</returns>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_cmp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_ui(Math.Mpfr.Native.mpfr_t,System.UInt32)">mpfr_cmp_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_si(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_cmp_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_d(Math.Mpfr.Native.mpfr_t,System.Double)">mpfr_cmp_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t)">mpfr_cmp_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t)">mpfr_cmp_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t)">mpfr_cmp_f</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_ui_2exp(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_exp_t)">mpfr_cmp_ui_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_si_2exp(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_exp_t)">mpfr_cmp_si_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmpabs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_cmpabs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nan_p(Math.Mpfr.Native.mpfr_t)">mpfr_nan_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inf_p(Math.Mpfr.Native.mpfr_t)">mpfr_inf_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_number_p(Math.Mpfr.Native.mpfr_t)">mpfr_number_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zero_p(Math.Mpfr.Native.mpfr_t)">mpfr_zero_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_regular_p(Math.Mpfr.Native.mpfr_t)">mpfr_regular_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sgn(Math.Mpfr.Native.mpfr_t)">mpfr_sgn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_greater_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_greater_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_greaterequal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_greaterequal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_less_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_less_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lessequal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_lessequal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_equal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_equal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_unordered_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_unordered_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Comparison_Functions">Comparison Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Comparison-Functions">GNU MPFR - Comparison Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to 1.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new floating-point number op2 to 1.
            mpfr_t op2 = new mpfr_t();
            mpfr_lib.mpfr_init2(op2, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that op1 &lt; op2 is false.
            Assert.IsTrue(mpfr_lib.mpfr_lessgreater_p(op1, op2) == 0);
            
            // Release unmanaged memory allocated for op1 and op2.
            mpfr_lib.mpfr_clears(op1, op2, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to 1.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new floating-point number op2 to 1.
            Dim op2 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op2, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that op1 &lt; op2 is false.
            Assert.IsTrue(mpfr_lib.mpfr_lessgreater_p(op1, op2) = 0)
            
            ' Release unmanaged memory allocated for op1 and op2.
            mpfr_lib.mpfr_clears(op1, op2, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_equal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">
            <summary>
            Return non-zero if <paramref name="op1"/> = <paramref name="op2"/>, and zero otherwise.
            </summary>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <returns>Return non-zero if <paramref name="op1"/> = <paramref name="op2"/>, and zero otherwise.</returns>
            <remarks>
            <para>
            Return zero whenever <paramref name="op1"/> and/or <paramref name="op2"/> is NaN. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_cmp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_ui(Math.Mpfr.Native.mpfr_t,System.UInt32)">mpfr_cmp_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_si(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_cmp_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_d(Math.Mpfr.Native.mpfr_t,System.Double)">mpfr_cmp_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t)">mpfr_cmp_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t)">mpfr_cmp_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t)">mpfr_cmp_f</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_ui_2exp(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_exp_t)">mpfr_cmp_ui_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_si_2exp(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_exp_t)">mpfr_cmp_si_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmpabs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_cmpabs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nan_p(Math.Mpfr.Native.mpfr_t)">mpfr_nan_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inf_p(Math.Mpfr.Native.mpfr_t)">mpfr_inf_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_number_p(Math.Mpfr.Native.mpfr_t)">mpfr_number_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zero_p(Math.Mpfr.Native.mpfr_t)">mpfr_zero_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_regular_p(Math.Mpfr.Native.mpfr_t)">mpfr_regular_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sgn(Math.Mpfr.Native.mpfr_t)">mpfr_sgn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_greater_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_greater_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_greaterequal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_greaterequal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_less_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_less_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lessequal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_lessequal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lessgreater_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_lessgreater_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_unordered_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_unordered_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Comparison_Functions">Comparison Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Comparison-Functions">GNU MPFR - Comparison Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to 1.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new floating-point number op2 to 1.
            mpfr_t op2 = new mpfr_t();
            mpfr_lib.mpfr_init2(op2, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that op1 = op2.
            Assert.IsTrue(mpfr_lib.mpfr_equal_p(op1, op2) != 0);
            
            // Release unmanaged memory allocated for op1 and op2.
            mpfr_lib.mpfr_clears(op1, op2, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to 1.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new floating-point number op2 to 1.
            Dim op2 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op2, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that op1 = op2.
            Assert.IsTrue(mpfr_lib.mpfr_equal_p(op1,op2) &lt;&gt; 0)
            
            ' Release unmanaged memory allocated for op1 and op2.
            mpfr_lib.mpfr_clears(op1, op2, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_unordered_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">
            <summary>
            Return non-zero if <paramref name="op1"/> or <paramref name="op2"/> is a NaN (i.e., they cannot be compared), zero otherwise. 
            </summary>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <returns>Return non-zero if <paramref name="op1"/> or <paramref name="op2"/> is a NaN (i.e., they cannot be compared), zero otherwise.</returns>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_cmp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_ui(Math.Mpfr.Native.mpfr_t,System.UInt32)">mpfr_cmp_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_si(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_cmp_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_d(Math.Mpfr.Native.mpfr_t,System.Double)">mpfr_cmp_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t)">mpfr_cmp_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t)">mpfr_cmp_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t)">mpfr_cmp_f</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_ui_2exp(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_exp_t)">mpfr_cmp_ui_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_si_2exp(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_exp_t)">mpfr_cmp_si_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmpabs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_cmpabs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nan_p(Math.Mpfr.Native.mpfr_t)">mpfr_nan_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inf_p(Math.Mpfr.Native.mpfr_t)">mpfr_inf_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_number_p(Math.Mpfr.Native.mpfr_t)">mpfr_number_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zero_p(Math.Mpfr.Native.mpfr_t)">mpfr_zero_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_regular_p(Math.Mpfr.Native.mpfr_t)">mpfr_regular_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sgn(Math.Mpfr.Native.mpfr_t)">mpfr_sgn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_greater_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_greater_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_greaterequal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_greaterequal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_less_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_less_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lessequal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_lessequal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_equal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_equal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lessgreater_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_lessgreater_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Comparison_Functions">Comparison Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Comparison-Functions">GNU MPFR - Comparison Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to 1.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            mpfr_lib.mpfr_set_si(op1, 1, mpfr_rnd_t.MPFR_RNDN);
            
            // Create, initialize, and set a new floating-point number op2 to 1.
            mpfr_t op2 = new mpfr_t();
            mpfr_lib.mpfr_init2(op2, 64U);
            mpfr_lib.mpfr_set_si(op2, 1, mpfr_rnd_t.MPFR_RNDN);
            
            // Assert that op1 and op2 are ordered.
            Assert.IsTrue(mpfr_lib.mpfr_unordered_p(op1, op2) == 0);
            
            // Release unmanaged memory allocated for op1 and op2.
            mpfr_lib.mpfr_clears(op1, op2, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to 1.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            mpfr_lib.mpfr_set_si(op1, 1, mpfr_rnd_t.MPFR_RNDN)
            
            ' Create, initialize, and set a new floating-point number op2 to 1.
            Dim op2 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op2, 64U)
            mpfr_lib.mpfr_set_si(op2, 1, mpfr_rnd_t.MPFR_RNDN)
            
            ' Assert that op1 and op2 are ordered.
            Assert.IsTrue(mpfr_lib.mpfr_unordered_p(op1, op2) = 0)
            
            ' Release unmanaged memory allocated for op1 and op2.
            mpfr_lib.mpfr_clears(op1, op2, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_atanh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the inverse hyperbolic tangent of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cosh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cosh</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sinh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sinh</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_tanh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_tanh</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sinh_cosh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sinh_cosh</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sech(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sech</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_csch(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_csch</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_coth(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_coth</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_acosh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_acosh</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_asinh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_asinh</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 0.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 0, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = atanh(op).
            Assert.IsTrue(mpfr_lib.mpfr_atanh(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is 0.
            Assert.IsTrue(mpfr_lib.mpfr_cmp_si(rop, 0) == 0);
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 0.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 0, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = atanh(op).
            Assert.IsTrue(mpfr_lib.mpfr_atanh(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is 0.
            Assert.IsTrue(mpfr_lib.mpfr_cmp_si(rop, 0) = 0)
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_acosh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the inverse hyperbolic cosine of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cosh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cosh</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sinh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sinh</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_tanh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_tanh</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sinh_cosh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sinh_cosh</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sech(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sech</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_csch(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_csch</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_coth(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_coth</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_asinh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_asinh</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_atanh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_atanh</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 1.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = acosh(op).
            Assert.IsTrue(mpfr_lib.mpfr_acosh(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is 0.
            Assert.IsTrue(mpfr_lib.mpfr_cmp_si(rop, 0) == 0);
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 1.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = acosh(op).
            Assert.IsTrue(mpfr_lib.mpfr_acosh(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is 0.
            Assert.IsTrue(mpfr_lib.mpfr_cmp_si(rop, 0) = 0)
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_asinh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the inverse hyperbolic sine of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cosh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cosh</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sinh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sinh</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_tanh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_tanh</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sinh_cosh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sinh_cosh</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sech(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sech</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_csch(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_csch</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_coth(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_coth</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_acosh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_acosh</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_atanh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_atanh</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 0.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 0, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = asinh(op).
            Assert.IsTrue(mpfr_lib.mpfr_asinh(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is 0.
            Assert.IsTrue(mpfr_lib.mpfr_cmp_si(rop, 0) == 0);
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 0.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 0, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = asinh(op).
            Assert.IsTrue(mpfr_lib.mpfr_asinh(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is 0.
            Assert.IsTrue(mpfr_lib.mpfr_cmp_si(rop, 0) = 0)
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_cosh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the hyperbolic cosine of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sinh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sinh</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_tanh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_tanh</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sinh_cosh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sinh_cosh</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sech(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sech</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_csch(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_csch</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_coth(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_coth</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_acosh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_acosh</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_asinh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_asinh</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_atanh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_atanh</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 0.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 0, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = cosh(op).
            Assert.IsTrue(mpfr_lib.mpfr_cosh(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is 1.
            Assert.IsTrue(mpfr_lib.mpfr_cmp_si(rop, 1) == 0);
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 0.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 0, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = cosh(op).
            Assert.IsTrue(mpfr_lib.mpfr_cosh(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is 1.
            Assert.IsTrue(mpfr_lib.mpfr_cmp_si(rop, 1) = 0)
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_sinh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the hyperbolic sine of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cosh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cosh</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_tanh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_tanh</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sinh_cosh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sinh_cosh</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sech(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sech</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_csch(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_csch</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_coth(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_coth</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_acosh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_acosh</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_asinh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_asinh</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_atanh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_atanh</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 1.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = sinh(op).
            Assert.IsTrue(mpfr_lib.mpfr_sinh(rop, op, mpfr_rnd_t.MPFR_RNDN) == -1);
            
            // Assert the value of rop.
            Assert.IsTrue(rop.ToString() == "0.117520119364380145688e1");
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 1.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = sinh(op).
            Assert.IsTrue(mpfr_lib.mpfr_sinh(rop, op, mpfr_rnd_t.MPFR_RNDN) = -1)
            
            ' Assert the value of rop.
            Assert.IsTrue(rop.ToString() = "0.117520119364380145688e1")
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_tanh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the hyperbolic tangent of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cosh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cosh</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sinh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sinh</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sinh_cosh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sinh_cosh</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sech(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sech</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_csch(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_csch</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_coth(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_coth</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_acosh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_acosh</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_asinh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_asinh</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_atanh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_atanh</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 1.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = tanh(op).
            Assert.IsTrue(mpfr_lib.mpfr_tanh(rop, op, mpfr_rnd_t.MPFR_RNDN) == -1);
            
            // Assert the value of rop.
            Assert.IsTrue(rop.ToString() == "0.761594155955764888109e0");
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 1.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = tanh(op).
            Assert.IsTrue(mpfr_lib.mpfr_tanh(rop, op, mpfr_rnd_t.MPFR_RNDN) = -1)
            
            ' Assert the value of rop.
            Assert.IsTrue(rop.ToString() = "0.761594155955764888109e0")
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_sinh_cosh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set simultaneously <paramref name="sop"/> to the hyperbolic sine of <paramref name="op"/> and <paramref name="cop"/> to the hyperbolic cosine of <paramref name="op"/>, rounded in the direction <paramref name="rnd"/> with the corresponding precision of <paramref name="sop"/> and <paramref name="cop"/>, which must be different variables.
            </summary>
            <param name="sop">The result hyperbolic sine.</param>
            <param name="cop">The result hyperbolic cosine.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return 0 iff both results are exact (see <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sin_cos(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sin_cos</see> for a more detailed description of the return value).</returns>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cosh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cosh</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sinh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sinh</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_tanh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_tanh</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sech(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sech</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_csch(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_csch</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_coth(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_coth</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_acosh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_acosh</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_asinh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_asinh</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_atanh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_atanh</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 1.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number sop.
            mpfr_t sop = new mpfr_t();
            mpfr_lib.mpfr_init2(sop, 64U);
            
            // Create and initialize a new floating-point number cop.
            mpfr_t cop = new mpfr_t();
            mpfr_lib.mpfr_init2(cop, 64U);
            
            // Set sop = sinh(op), cop = cosh(op).
            Assert.IsTrue(mpfr_lib.mpfr_sinh_cosh(sop, cop, op, mpfr_rnd_t.MPFR_RNDN) == 10);
            
            // Assert the value of sop and cop.
            Assert.IsTrue(sop.ToString() == "0.117520119364380145688e1");
            Assert.IsTrue(cop.ToString() == "0.154308063481524377844e1");
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(sop, cop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 1.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number sop.
            Dim sop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(sop, 64U)
            
            ' Create and initialize a new floating-point number cop.
            Dim cop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(cop, 64U)
            
            ' Set sop = sinh(op), cop = cosh(op).
            Assert.IsTrue(mpfr_lib.mpfr_sinh_cosh(sop, cop, op, mpfr_rnd_t.MPFR_RNDN) = 10)
            
            ' Assert the value of sop and cop.
            Assert.IsTrue(sop.ToString() = "0.117520119364380145688e1")
            Assert.IsTrue(cop.ToString() = "0.154308063481524377844e1")
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(sop, cop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_sech(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the hyperbolic secant of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cosh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cosh</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sinh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sinh</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_tanh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_tanh</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sinh_cosh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sinh_cosh</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_csch(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_csch</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_coth(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_coth</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_acosh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_acosh</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_asinh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_asinh</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_atanh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_atanh</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 1.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = sech(op).
            Assert.IsTrue(mpfr_lib.mpfr_sech(rop, op, mpfr_rnd_t.MPFR_RNDN) == 1);
            
            // Assert the value of rop.
            Assert.IsTrue(rop.ToString() == "0.648054273663885399581e0");
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 1.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = sech(op).
            Assert.IsTrue(mpfr_lib.mpfr_sech(rop, op, mpfr_rnd_t.MPFR_RNDN) = 1)
            
            ' Assert the value of rop.
            Assert.IsTrue(rop.ToString() = "0.648054273663885399581e0")
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_csch(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the hyperbolic cosecant of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cosh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cosh</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sinh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sinh</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_tanh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_tanh</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sinh_cosh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sinh_cosh</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sech(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sech</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_coth(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_coth</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_acosh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_acosh</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_asinh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_asinh</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_atanh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_atanh</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 1.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = csch(op).
            Assert.IsTrue(mpfr_lib.mpfr_csch(rop, op, mpfr_rnd_t.MPFR_RNDN) == -1);
            
            // Assert the value of rop.
            Assert.IsTrue(rop.ToString() == "0.850918128239321545122e0");
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 1.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = csch(op).
            Assert.IsTrue(mpfr_lib.mpfr_csch(rop, op, mpfr_rnd_t.MPFR_RNDN) = -1)
            
            ' Assert the value of rop.
            Assert.IsTrue(rop.ToString() = "0.850918128239321545122e0")
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_coth(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the hyperbolic cotangent of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cosh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cosh</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sinh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sinh</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_tanh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_tanh</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sinh_cosh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sinh_cosh</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sech(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sech</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_csch(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_csch</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_acosh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_acosh</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_asinh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_asinh</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_atanh(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_atanh</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 1.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = coth(op).
            Assert.IsTrue(mpfr_lib.mpfr_coth(rop, op, mpfr_rnd_t.MPFR_RNDN) == 1);
            
            // Assert the value of rop.
            Assert.IsTrue(rop.ToString() == "0.131303528549933130366e1");
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 1.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = coth(op).
            Assert.IsTrue(mpfr_lib.mpfr_coth(rop, op, mpfr_rnd_t.MPFR_RNDN) = 1)
            
            ' Assert the value of rop.
            Assert.IsTrue(rop.ToString() = "0.131303528549933130366e1")
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_acos(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the arc-cosine of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            Note that since acos(-1) returns the floating-point number closest to Pi according to the given rounding mode,
            this number might not be in the output range 0 &#8804; rop &lt; Pi of the arc-cosine function;
            still, the result lies in the image of the output range by the rounding function.
            The same holds for asin(-1), asin(1), atan(-Inf), atan(+Inf) or for atan(<paramref name="op"/>) with large
            <paramref name="op"/> and small precision of <paramref name="rop"/>.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cos(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cos</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sin(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sin</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_tan(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_tan</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sin_cos(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sin_cos</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sec(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sec</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_csc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_csc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cot(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cot</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_asin(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_asin</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_atan(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_atan</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_atan2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_atan2</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 0.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 0, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = 2 * acos(op).
            Assert.IsTrue(mpfr_lib.mpfr_acos(rop, op, mpfr_rnd_t.MPFR_RNDN) == 1);
            Assert.IsTrue(mpfr_lib.mpfr_mul_si(rop, rop, 2, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is PI.
            Assert.IsTrue(mpfr_lib.mpfr_const_pi(op, mpfr_rnd_t.MPFR_RNDN) == 1);
            Assert.IsTrue(mpfr_lib.mpfr_cmp(rop, op) == 0);
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 0.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 0, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = 2 * acos(op).
            Assert.IsTrue(mpfr_lib.mpfr_acos(rop, op, mpfr_rnd_t.MPFR_RNDN) = 1)
            Assert.IsTrue(mpfr_lib.mpfr_mul_si(rop, rop, 2, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is PI.
            Assert.IsTrue(mpfr_lib.mpfr_const_pi(op, mpfr_rnd_t.MPFR_RNDN) = 1)
            Assert.IsTrue(mpfr_lib.mpfr_cmp(rop, op) = 0)
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_asin(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the arc-sine of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            Note that since acos(-1) returns the floating-point number closest to Pi according to the given rounding mode,
            this number might not be in the output range 0 &#8804; rop &lt; Pi of the arc-cosine function;
            still, the result lies in the image of the output range by the rounding function.
            The same holds for asin(-1), asin(1), atan(-Inf), atan(+Inf) or for atan(<paramref name="op"/>) with large
            <paramref name="op"/> and small precision of <paramref name="rop"/>.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cos(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cos</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sin(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sin</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_tan(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_tan</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sin_cos(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sin_cos</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sec(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sec</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_csc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_csc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cot(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cot</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_acos(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_acos</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_atan(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_atan</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_atan2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_atan2</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 1.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = 2 * asin(op).
            Assert.IsTrue(mpfr_lib.mpfr_asin(rop, op, mpfr_rnd_t.MPFR_RNDN) == 1);
            Assert.IsTrue(mpfr_lib.mpfr_mul_si(rop, rop, 2, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is PI.
            Assert.IsTrue(mpfr_lib.mpfr_const_pi(op, mpfr_rnd_t.MPFR_RNDN) == 1);
            Assert.IsTrue(mpfr_lib.mpfr_cmp(rop, op) == 0);
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 1.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = 2 * asin(op).
            Assert.IsTrue(mpfr_lib.mpfr_asin(rop, op, mpfr_rnd_t.MPFR_RNDN) = 1)
            Assert.IsTrue(mpfr_lib.mpfr_mul_si(rop, rop, 2, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is PI.
            Assert.IsTrue(mpfr_lib.mpfr_const_pi(op, mpfr_rnd_t.MPFR_RNDN) = 1)
            Assert.IsTrue(mpfr_lib.mpfr_cmp(rop, op) = 0)
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_atan(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the arc-tangent of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            Note that since acos(-1) returns the floating-point number closest to Pi according to the given rounding mode,
            this number might not be in the output range 0 &#8804; rop &lt; Pi of the arc-cosine function;
            still, the result lies in the image of the output range by the rounding function.
            The same holds for asin(-1), asin(1), atan(-Inf), atan(+Inf) or for atan(<paramref name="op"/>) with large
            <paramref name="op"/> and small precision of <paramref name="rop"/>.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cos(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cos</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sin(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sin</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_tan(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_tan</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sin_cos(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sin_cos</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sec(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sec</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_csc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_csc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cot(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cot</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_acos(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_acos</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_asin(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_asin</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_atan2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_atan2</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 1.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = 4 * atan(op).
            Assert.IsTrue(mpfr_lib.mpfr_atan(rop, op, mpfr_rnd_t.MPFR_RNDN) == 1);
            Assert.IsTrue(mpfr_lib.mpfr_mul_si(rop, rop, 4, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is PI.
            Assert.IsTrue(mpfr_lib.mpfr_const_pi(op, mpfr_rnd_t.MPFR_RNDN) == 1);
            Assert.IsTrue(mpfr_lib.mpfr_cmp(rop, op) == 0);
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 1.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = 4 * atan(op).
            Assert.IsTrue(mpfr_lib.mpfr_atan(rop, op, mpfr_rnd_t.MPFR_RNDN) = 1)
            Assert.IsTrue(mpfr_lib.mpfr_mul_si(rop, rop, 4, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is PI.
            Assert.IsTrue(mpfr_lib.mpfr_const_pi(op, mpfr_rnd_t.MPFR_RNDN) = 1)
            Assert.IsTrue(mpfr_lib.mpfr_cmp(rop, op) = 0)
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_sin(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the sine of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cos(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cos</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_tan(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_tan</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sin_cos(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sin_cos</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sec(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sec</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_csc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_csc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cot(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cot</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_acos(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_acos</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_asin(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_asin</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_atan(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_atan</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_atan2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_atan2</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 1.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = sin(op).
            Assert.IsTrue(mpfr_lib.mpfr_sin(rop, op, mpfr_rnd_t.MPFR_RNDN) == 1);
            
            // Assert the value of rop.
            Assert.IsTrue(rop.ToString() == "0.841470984807896506665e0");
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 1.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = sin(op).
            Assert.IsTrue(mpfr_lib.mpfr_sin(rop, op, mpfr_rnd_t.MPFR_RNDN) = 1)
            
            ' Assert the value of rop.
            Assert.IsTrue(rop.ToString() = "0.841470984807896506665e0")
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_sin_cos(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set simultaneously <paramref name="sop"/> to the sine of <paramref name="op"/> and <paramref name="cop"/> to the cosine of <paramref name="op"/>, rounded in the direction <paramref name="rnd"/> with the corresponding precisions of <paramref name="sop"/> and <paramref name="cop"/>, which must be different variables.
            </summary>
            <param name="sop">The result sine.</param>
            <param name="cop">The result cosine.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return 0 iff both results are exact, more precisely it returns s + 4c where s = 0 if <paramref name="sop"/> is exact, s = 1 if <paramref name="sop"/> is larger than the sine of <paramref name="op"/>, s = 2 if <paramref name="sop"/> is smaller than the sine of <paramref name="op"/>, and similarly for c and the cosine of <paramref name="op"/>. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cos(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cos</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sin(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sin</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_tan(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_tan</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sec(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sec</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_csc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_csc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cot(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cot</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_acos(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_acos</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_asin(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_asin</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_atan(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_atan</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_atan2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_atan2</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 1.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number sop.
            mpfr_t sop = new mpfr_t();
            mpfr_lib.mpfr_init2(sop, 64U);
            
            // Create and initialize a new floating-point number cop.
            mpfr_t cop = new mpfr_t();
            mpfr_lib.mpfr_init2(cop, 64U);
            
            // Set sop = sin(op), cop = cos(op).
            Assert.IsTrue(mpfr_lib.mpfr_sin_cos(sop, cop, op, mpfr_rnd_t.MPFR_RNDN) == 5);
            
            // Assert the value of sop and cop.
            Assert.IsTrue(sop.ToString() == "0.841470984807896506665e0");
            Assert.IsTrue(cop.ToString() == "0.540302305868139717414e0");
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(sop, cop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 1.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number sop.
            Dim sop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(sop, 64U)
            
            ' Create and initialize a new floating-point number cop.
            Dim cop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(cop, 64U)
            
            ' Set sop = sin(op), cop = cos(op).
            Assert.IsTrue(mpfr_lib.mpfr_sin_cos(sop, cop, op, mpfr_rnd_t.MPFR_RNDN) = 5)
            
            ' Assert the value of sop and cop.
            Assert.IsTrue(sop.ToString() = "0.841470984807896506665e0")
            Assert.IsTrue(cop.ToString() = "0.540302305868139717414e0")
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(sop, cop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_cos(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the cosine of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sin(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sin</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_tan(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_tan</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sin_cos(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sin_cos</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sec(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sec</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_csc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_csc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cot(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cot</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_acos(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_acos</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_asin(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_asin</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_atan(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_atan</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_atan2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_atan2</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 0.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 0, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = cos(op).
            Assert.IsTrue(mpfr_lib.mpfr_cos(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is 1.
            Assert.IsTrue(mpfr_lib.mpfr_cmp_si(rop, 1) == 0);
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 0.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 0, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = cos(op).
            Assert.IsTrue(mpfr_lib.mpfr_cos(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is 1.
            Assert.IsTrue(mpfr_lib.mpfr_cmp_si(rop, 1) = 0)
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_tan(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the tangent of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cos(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cos</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sin(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sin</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sin_cos(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sin_cos</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sec(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sec</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_csc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_csc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cot(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cot</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_acos(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_acos</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_asin(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_asin</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_atan(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_atan</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_atan2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_atan2</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 1.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = tan(op).
            Assert.IsTrue(mpfr_lib.mpfr_tan(rop, op, mpfr_rnd_t.MPFR_RNDN) == -1);
            
            // Assert the value of rop.
            Assert.IsTrue(rop.ToString() == "0.155740772465490223046e1");
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 1.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = tan(op).
            Assert.IsTrue(mpfr_lib.mpfr_tan(rop, op, mpfr_rnd_t.MPFR_RNDN) = -1)
            
            ' Assert the value of rop.
            Assert.IsTrue(rop.ToString() = "0.155740772465490223046e1")
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_atan2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the arc-tangent2 of <paramref name="y"/> and <paramref name="x"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="y">The ordinate floating-point value.</param>
            <param name="x">The abscissa floating-point value.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            If <paramref name="x"/> &gt; 0, atan2(<paramref name="y"/>, <paramref name="x"/>) = atan(<paramref name="y"/>/<paramref name="x"/>);
            if <paramref name="x"/> &lt; 0, atan2(<paramref name="y"/>, <paramref name="x"/>) = sign(<paramref name="y"/>) * (Pi - atan(abs(<paramref name="y"/>/<paramref name="x"/>))),
            thus a number from -Pi to Pi.
            As for atan, in case the exact mathematical result is +Pi or -Pi, its rounded result might be outside the function output range. 
            </para>
            <para>
            atan2(<paramref name="y"/>, 0) does not raise any floating-point exception.
            Special values are handled as described in the ISO C99 and IEEE 754-2008 standards for the atan2 function:
            </para>
            <list type="bullet">
            <item>
            <description>
             atan2(+0, -0) returns +Pi. 
            </description>
            </item>
            <item>
            <description>
             atan2(-0, -0) returns -Pi. 
            </description>
            </item>
            <item>
            <description>
            atan2(+0, +0) returns +0. 
            </description>
            </item>
            <item>
            <description>
            atan2(-0, +0) returns -0. 
            </description>
            </item>
            <item>
            <description>
            atan2(+0, x) returns +Pi for x &lt; 0. 
            </description>
            </item>
            <item>
            <description>
            atan2(-0, x) returns -Pi for x &lt; 0. 
            </description>
            </item>
            <item>
            <description>
            atan2(+0, x) returns +0 for x &gt; 0. 
            </description>
            </item>
            <item>
            <description>
            atan2(-0, x) returns -0 for x &gt; 0. 
            </description>
            </item>
            <item>
            <description>
            atan2(y, 0) returns -Pi/2 for y &lt; 0. 
            </description>
            </item>
            <item>
            <description>
            atan2(y, 0) returns +Pi/2 for y &gt; 0. 
            </description>
            </item>
            <item>
            <description>
            atan2(+Inf, -Inf) returns +3 * Pi/4. 
            </description>
            </item>
            <item>
            <description>
            atan2(-Inf, -Inf) returns -3 * Pi/4. 
            </description>
            </item>
            <item>
            <description>
            atan2(+Inf, +Inf) returns +Pi/4. 
            </description>
            </item>
            <item>
            <description>
            atan2(-Inf, +Inf) returns -Pi/4. 
            </description>
            </item>
            <item>
            <description>
            atan2(+Inf, x) returns +Pi/2 for finite x. 
            </description>
            </item>
            <item>
            <description>
            atan2(-Inf, x) returns -Pi/2 for finite x. 
            </description>
            </item>
            <item>
            <description>
            atan2(y, -Inf) returns +Pi for finite y &gt; 0. 
            </description>
            </item>
            <item>
            <description>
            atan2(y, -Inf) returns -Pi for finite y &lt; 0. 
            </description>
            </item>
            <item>
            <description>
            atan2(y, +Inf) returns +0 for finite y &gt; 0. 
            </description>
            </item>
            <item>
            <description>
            atan2(y, +Inf) returns -0 for finite y &lt; 0.
            </description>
            </item>
            </list>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cos(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cos</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sin(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sin</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_tan(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_tan</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sin_cos(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sin_cos</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sec(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sec</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_csc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_csc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cot(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cot</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_acos(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_acos</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_asin(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_asin</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_atan(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_atan</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number x to -1.
            mpfr_t x = new mpfr_t();
            mpfr_lib.mpfr_init2(x, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(x, -1, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new floating-point number y to 0.
            mpfr_t y = new mpfr_t();
            mpfr_lib.mpfr_init2(y, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(y, 0, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = atan2(y, x).
            Assert.IsTrue(mpfr_lib.mpfr_atan2(rop, y, x, mpfr_rnd_t.MPFR_RNDN) == 1);
            
            // Assert that the value of rop is PI.
            Assert.IsTrue(mpfr_lib.mpfr_const_pi(x, mpfr_rnd_t.MPFR_RNDN) == 1);
            Assert.IsTrue(mpfr_lib.mpfr_cmp(rop, x) == 0);
            
            // Release unmanaged memory allocated for x, y, and rop.
            mpfr_lib.mpfr_clears(x, y, rop, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number x to -1.
            Dim x As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(x, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(x, -1, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new floating-point number y to 0.
            Dim y As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(y, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(y, 0, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = atan2(y, x).
            Assert.IsTrue(mpfr_lib.mpfr_atan2(rop, y, x, mpfr_rnd_t.MPFR_RNDN) = 1)
            
            ' Assert that the value of rop is PI.
            Assert.IsTrue(mpfr_lib.mpfr_const_pi(x, mpfr_rnd_t.MPFR_RNDN) = 1)
            Assert.IsTrue(mpfr_lib.mpfr_cmp(rop, x) = 0)
            
            ' Release unmanaged memory allocated for x, y, and rop.
            mpfr_lib.mpfr_clears(x, y, rop, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_sec(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the secant of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cos(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cos</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sin(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sin</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_tan(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_tan</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sin_cos(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sin_cos</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_csc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_csc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cot(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cot</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_acos(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_acos</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_asin(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_asin</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_atan(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_atan</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_atan2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_atan2</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to pi.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_const_pi(op, mpfr_rnd_t.MPFR_RNDN) == 1);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = csc(op).
            Assert.IsTrue(mpfr_lib.mpfr_sec(rop, op, mpfr_rnd_t.MPFR_RNDN) == 1);
            
            // Assert that the value of rop is -1.
            Assert.IsTrue(mpfr_lib.mpfr_cmp_si(rop, -1) == 0);
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to pi.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_const_pi(op, mpfr_rnd_t.MPFR_RNDN) = 1)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = csc(op).
            Assert.IsTrue(mpfr_lib.mpfr_sec(rop, op, mpfr_rnd_t.MPFR_RNDN) = 1)
            
            ' Assert that the value of rop is -1.
            Assert.IsTrue(mpfr_lib.mpfr_cmp_si(rop, -1) = 0)
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_csc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the cosecant of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cos(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cos</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sin(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sin</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_tan(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_tan</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sin_cos(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sin_cos</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sec(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sec</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cot(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cot</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_acos(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_acos</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_asin(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_asin</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_atan(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_atan</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_atan2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_atan2</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to pi / 2.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_const_pi(op, mpfr_rnd_t.MPFR_RNDN) == 1);
            Assert.IsTrue(mpfr_lib.mpfr_mul_d(op, op, 0.5, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = csc(op).
            Assert.IsTrue(mpfr_lib.mpfr_csc(rop, op, mpfr_rnd_t.MPFR_RNDN) == -1);
            
            // Assert that the value of rop is 1.
            Assert.IsTrue(mpfr_lib.mpfr_cmp_si(rop, 1) == 0);
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to pi / 2.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_const_pi(op, mpfr_rnd_t.MPFR_RNDN) = 1)
            Assert.IsTrue(mpfr_lib.mpfr_mul_d(op, op, 0.5, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = csc(op).
            Assert.IsTrue(mpfr_lib.mpfr_csc(rop, op, mpfr_rnd_t.MPFR_RNDN) = -1)
            
            ' Assert that the value of rop is 1.
            Assert.IsTrue(mpfr_lib.mpfr_cmp_si(rop, 1) = 0)
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_cot(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the cotangent of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cos(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cos</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sin(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sin</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_tan(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_tan</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sin_cos(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sin_cos</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sec(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sec</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_csc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_csc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_acos(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_acos</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_asin(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_asin</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_atan(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_atan</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_atan2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_atan2</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to pi / 4.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_const_pi(op, mpfr_rnd_t.MPFR_RNDN) == 1);
            Assert.IsTrue(mpfr_lib.mpfr_mul_d(op, op, 0.25, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = cot(op).
            Assert.IsTrue(mpfr_lib.mpfr_cot(rop, op, mpfr_rnd_t.MPFR_RNDN) == 1);
            
            // Assert that the value of rop is 1.
            Assert.IsTrue(mpfr_lib.mpfr_cmp_si(rop, 1) == 0);
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to pi / 4.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_const_pi(op, mpfr_rnd_t.MPFR_RNDN) = 1)
            Assert.IsTrue(mpfr_lib.mpfr_mul_d(op, op, 0.25, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = cot(op).
            Assert.IsTrue(mpfr_lib.mpfr_cot(rop, op, mpfr_rnd_t.MPFR_RNDN) = 1)
            
            ' Assert that the value of rop is 1.
            Assert.IsTrue(mpfr_lib.mpfr_cmp_si(rop, 1) = 0)
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_hypot(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the Euclidean norm of <paramref name="x"/> and <paramref name="y"/>, i.e., the square root of the sum of the squares of <paramref name="x"/> and <paramref name="y"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="x">The first operand floating-point number.</param>
            <param name="y">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            Special values are handled as described in the ISO C99 (Section F.9.4.3) and IEEE 754-2008 (Section 9.2.1) standards:
            If <paramref name="x"/> or <paramref name="y"/> is an infinity, then +Inf is returned in <paramref name="rop"/>, even if the other number is NaN. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fac_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fac_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_eint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_eint</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_li2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_li2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_gamma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma_inc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_gamma_inc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lngamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_lngamma</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_digamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_digamma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_beta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_beta</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_zeta</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_zeta_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erf(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erfc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erfc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_j0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_j0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_j1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_j1</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_jn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_jn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_y0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_y0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_y1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_y1</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_yn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_yn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fms</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_agm(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_agm</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ai(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ai</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number x to -3.
            mpfr_t x = new mpfr_t();
            mpfr_lib.mpfr_init2(x, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(x, -3, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new floating-point number y to 4.
            mpfr_t y = new mpfr_t();
            mpfr_lib.mpfr_init2(y, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(y, 4, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number z.
            mpfr_t z = new mpfr_t();
            mpfr_lib.mpfr_init2(z, 64U);
            
            // Set z = sqrt(x^2 + y^2).
            Assert.IsTrue(mpfr_lib.mpfr_hypot(z, x, y, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of z is 5.
            Assert.IsTrue(mpfr_lib.mpfr_cmp_si(z, 5) == 0);
            
            // Release unmanaged memory allocated for x, y, and z.
            mpfr_lib.mpfr_clears(x, y, z, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number x to -3.
            Dim x As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(x, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(x, -3, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new floating-point number y to 4.
            Dim y As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(y, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(y, 4, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number z.
            Dim z As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(z, 64U)
            
            ' Set z = sqrt(x^2 + y^2).
            Assert.IsTrue(mpfr_lib.mpfr_hypot(z, x, y, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of z is 5.
            Assert.IsTrue(mpfr_lib.mpfr_cmp_si(z, 5) = 0)
            
            ' Release unmanaged memory allocated for x, y, and z.
            mpfr_lib.mpfr_clears(x, y, z, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_erf(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the value of the error function on <paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fac_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fac_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_eint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_eint</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_li2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_li2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_gamma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma_inc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_gamma_inc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lngamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_lngamma</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_digamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_digamma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_beta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_beta</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_zeta</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_zeta_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erfc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erfc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_j0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_j0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_j1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_j1</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_jn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_jn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_y0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_y0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_y1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_y1</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_yn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_yn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fms</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmms</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_agm(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_agm</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_hypot(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_hypot</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ai(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ai</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 1.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop to error function of op.
            Assert.IsTrue(mpfr_lib.mpfr_erf(rop, op, mpfr_rnd_t.MPFR_RNDN) == 1);
            
            // Assert the value of rop.
            Assert.IsTrue(rop.ToString() == "0.842700792949714869368e0");
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 1.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop to error function of op.
            Assert.IsTrue(mpfr_lib.mpfr_erf(rop, op, mpfr_rnd_t.MPFR_RNDN) = 1)
            
            ' Assert the value of rop.
            Assert.IsTrue(rop.ToString() = "0.842700792949714869368e0")
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_erfc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the value of the complementary error function on <paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fac_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fac_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_eint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_eint</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_li2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_li2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_gamma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma_inc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_gamma_inc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lngamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_lngamma</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_digamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_digamma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_beta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_beta</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_zeta</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_zeta_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erf(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_j0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_j0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_j1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_j1</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_jn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_jn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_y0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_y0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_y1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_y1</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_yn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_yn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fms</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmms</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_agm(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_agm</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_hypot(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_hypot</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ai(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ai</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 1.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop to complementary error function of op.
            Assert.IsTrue(mpfr_lib.mpfr_erfc(rop, op, mpfr_rnd_t.MPFR_RNDN) == 1);
            
            // Assert the value of rop.
            Assert.IsTrue(rop.ToString() == "0.157299207050285130659e0");
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 1.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop to complementary error function of op.
            Assert.IsTrue(mpfr_lib.mpfr_erfc(rop, op, mpfr_rnd_t.MPFR_RNDN) = 1)
            
            ' Assert the value of rop.
            Assert.IsTrue(rop.ToString() = "0.157299207050285130659e0")
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_cbrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the cubic root of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            This functions agrees with the rootn function of the IEEE 754-2008 standard (Section 9.2).
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqr(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqr</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cbrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cbrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rootn_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_root(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_neg</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_abs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_dim(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_dim</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 8.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 8, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = cbrt(op).
            Assert.IsTrue(mpfr_lib.mpfr_cbrt(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is 2.
            Assert.IsTrue(mpfr_lib.mpfr_cmp_si(rop, 2) == 0);
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 8.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 8, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = cbrt(op).
            Assert.IsTrue(mpfr_lib.mpfr_cbrt(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is 2.
            Assert.IsTrue(mpfr_lib.mpfr_cmp_si(rop, 2) = 0)
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_rootn_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the <paramref name="k"/>th root of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="k">The degree of the root.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            For <paramref name="k"/> = 0, set <paramref name="rop"/> to NaN.
            For <paramref name="k"/> odd (resp. even) and op negative (including −Inf), set <paramref name="rop"/>
            to a negative number (resp. NaN).
            If <paramref name="op"/> is zero, set <paramref name="rop"/> to zero with the sign obtained by the usual
            limit rules, i.e., the same sign as op if <paramref name="k"/> is odd, and positive if
            <paramref name="k"/> is even.
            </para>
            <para>
            This functions agrees with the rootn function of the IEEE 754-2008 standard (Section 9.2).
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqr(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqr</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cbrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cbrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_root(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_neg</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_abs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_dim(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_dim</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 8.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 8, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop to the cubic root of op.
            Assert.IsTrue(mpfr_lib.mpfr_rootn_ui(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is 2.
            Assert.IsTrue(mpfr_lib.mpfr_cmp_si(rop, 2) == 0);
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 8.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 8, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop to the cubic root of op.
            Assert.IsTrue(mpfr_lib.mpfr_rootn_ui(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is 2.
            Assert.IsTrue(mpfr_lib.mpfr_cmp_si(rop, 2) = 0)
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_root(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the <paramref name="k"/>th root of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="k">The degree of the root.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            This function is the same as <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rootn_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)"/> except when <paramref name="op"/> is −0 and 
            <paramref name="k"/> is even: the result is −0 instead of +0 (the reason was to be consistent
            with <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)"/>).
            Said otherwise, if <paramref name="op"/> is zero, set <paramref name="rop"/> to <paramref name="op"/>.
            </para>
            <para>
            This function predates the IEEE 754-2008 standard and behaves differently from its rootn function.
            It is marked as deprecated and will be removed in a future release.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqr(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqr</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cbrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cbrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rootn_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_neg</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_abs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_dim(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_dim</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 32.0.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 32.0, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = op^(1/5).
            Assert.IsTrue(mpfr_lib.mpfr_root(rop, op, 5, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert the value of rop.
            Assert.IsTrue(rop.ToString() == "0.200000000000000000000e1");
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 32.0.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 32.0, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = op^(1/5).
            Assert.IsTrue(mpfr_lib.mpfr_root(rop, op, 5, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert the value of rop.
            Assert.IsTrue(rop.ToString() = "0.200000000000000000000e1")
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the value of the Gamma function on <paramref name="op"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            When <paramref name="op"/> is a negative integer, <paramref name="rop"/> is set to NaN. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fac_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fac_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_eint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_eint</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_li2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_li2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma_inc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_gamma_inc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lngamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_lngamma</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_digamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_digamma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_beta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_beta</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_zeta</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_zeta_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erf(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erfc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erfc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_j0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_j0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_j1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_j1</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_jn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_jn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_y0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_y0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_y1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_y1</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_yn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_yn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fms</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmms</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_agm(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_agm</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_hypot(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_hypot</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ai(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ai</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 1.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = Gamma(op).
            Assert.IsTrue(mpfr_lib.mpfr_gamma(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert the value of rop.
            Assert.IsTrue(rop.ToString() == "0.100000000000000000000e1");
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 1.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = Gamma(op).
            Assert.IsTrue(mpfr_lib.mpfr_gamma(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert the value of rop.
            Assert.IsTrue(rop.ToString() = "0.100000000000000000000e1")
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma_inc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the value of the incomplete Gamma function on <paramref name="op"/> and <paramref name="op2"/>, rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            In the literature, <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma_inc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)"/> is called upper incomplete Gamma function, or sometimes complementary incomplete Gamma function.
            </para>
            <para>
            For <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma_inc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)"/> when <paramref name="op2"/> is zero, when <paramref name="op"/> is a negative integer,
            <paramref name="rop"/> is set to NaN. 
            </para>
            <para>
            Note: the current implementation of <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma_inc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)"/> is slow for large values of
            <paramref name="rop"/> or <paramref name="op"/>, in which case some internal overflow might also occur.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fac_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fac_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_eint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_eint</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_li2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_li2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lngamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_lngamma</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_digamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_digamma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_beta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_beta</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_zeta</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_zeta_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erf(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erfc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erfc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_j0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_j0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_j1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_j1</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_jn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_jn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_y0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_y0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_y1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_y1</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_yn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_yn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fms</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmms</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_agm(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_agm</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_hypot(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_hypot</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ai(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ai</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 1.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = Gamma(op).
            Assert.IsTrue(mpfr_lib.mpfr_gamma(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert the value of rop.
            Assert.IsTrue(rop.ToString() == "0.100000000000000000000e1");
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 1.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = Gamma(op).
            Assert.IsTrue(mpfr_lib.mpfr_gamma(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert the value of rop.
            Assert.IsTrue(rop.ToString() = "0.100000000000000000000e1")
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_beta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the value of the Beta function at arguments <paramref name="op1"/> and <paramref name="op2"/>, rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op1">The operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            Note: the current code does not try to avoid internal overflow or underflow, and might use a huge internal precision in some cases.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fac_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fac_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_eint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_eint</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_li2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_li2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lngamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_lngamma</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_digamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_digamma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_zeta</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_zeta_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erf(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erfc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erfc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_j0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_j0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_j1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_j1</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_jn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_jn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_y0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_y0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_y1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_y1</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_yn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_yn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fms</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmms</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_agm(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_agm</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_hypot(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_hypot</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ai(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ai</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to 2.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 2, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new floating-point number op2 to 2.
            mpfr_t op2 = new mpfr_t();
            mpfr_lib.mpfr_init2(op2, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 2, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = Beta(op1, op2).
            Assert.IsTrue(mpfr_lib.mpfr_beta(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) == 1);
            
            // Assert the value of rop.
            Assert.IsTrue(rop.ToString() == "0.166666666666666666671e0");
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op1, op2, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to 2.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 2, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new floating-point number op2 to 2.
            Dim op2 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op2, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 2, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = Beta(op1, op2).
            Assert.IsTrue(mpfr_lib.mpfr_beta(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) = 1)
            
            ' Assert the value of rop.
            Assert.IsTrue(rop.ToString() = "0.166666666666666666671e0")
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op1, op2, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_lngamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the value of the logarithm of the Gamma function on <paramref name="op"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            When <paramref name="op"/> is 1 or 2, set <paramref name="rop"/> to +0 (in all rounding modes).
            When <paramref name="op"/> is an infinity or a nonpositive integer, set <paramref name="rop"/> to +Inf,
            following the general rules on special values.
            When -2k - 1 &lt; op &lt; -2k, k being a nonnegative integer, set <paramref name="rop"/> to NaN.
            See also <see cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma">O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma</see>. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fac_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fac_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_eint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_eint</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_li2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_li2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_gamma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma_inc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_gamma_inc</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_digamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_digamma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_beta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_beta</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_zeta</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_zeta_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erf(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erfc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erfc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_j0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_j0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_j1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_j1</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_jn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_jn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_y0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_y0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_y1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_y1</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_yn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_yn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fms</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmms</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_agm(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_agm</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_hypot(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_hypot</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ai(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ai</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 10.4.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop to log(Gamma(op)).
            Assert.IsTrue(mpfr_lib.mpfr_lngamma(rop, op, mpfr_rnd_t.MPFR_RNDN) == -1);
            
            // Assert the value of rop and sign.
            Assert.IsTrue(rop.ToString() == "0.137108263716202786516e2");
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 10.4.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop to log(Gamma(op)).
            Assert.IsTrue(mpfr_lib.mpfr_lngamma(rop, op, mpfr_rnd_t.MPFR_RNDN) = -1)
            
            ' Assert the value of rop and sign.
            Assert.IsTrue(rop.ToString() = "0.137108263716202786516e2")
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma(Math.Mpfr.Native.mpfr_t,System.Int32@,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the value of the logarithm of the absolute value of the Gamma function on <paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="signp">The returned sign.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            The sign (1 or -1) of Gamma(<paramref name="op"/>) is returned in the object pointed to by <paramref name="signp"/>.
            When <paramref name="op"/> is 1 or 2, set <paramref name="rop"/> to +0 (in all rounding modes).
            When <paramref name="op"/> is an infinity or a nonpositive integer, set <paramref name="rop"/> to +Inf.
            When <paramref name="op"/> is NaN, -Inf or a negative integer, <paramref name="signp"/> is undefined,
            and when <paramref name="op"/> is ±0, <paramref name="signp"/> is the sign of the zero.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fac_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fac_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_eint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_eint</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_li2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_li2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_gamma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma_inc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_gamma_inc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lngamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_lngamma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.ptr{System.Int32},Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_lgamma(mpfr_t, ptr{int}, mpfr_t, mpfr_rnd_t)</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_digamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_digamma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_beta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_beta</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_zeta</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_zeta_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erf(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erfc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erfc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_j0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_j0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_j1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_j1</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_jn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_jn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_y0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_y0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_y1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_y1</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_yn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_yn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fms</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmms</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_agm(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_agm</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_hypot(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_hypot</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ai(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ai</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 10.4.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop to log(|Gamma(op)|).
            int sign = 0;
            Assert.IsTrue(mpfr_lib.mpfr_lgamma(rop, ref sign, op, mpfr_rnd_t.MPFR_RNDN) == -1);
            
            // Assert the value of rop and sign.
            Assert.IsTrue(rop.ToString() == "0.137108263716202786516e2" &amp;&amp; sign == 1);
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 10.4.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop to log(|Gamma(op)|).
            Dim sign As Integer = 0
            Assert.IsTrue(mpfr_lib.mpfr_lgamma(rop,ref sign,op,mpfr_rnd_t.MPFR_RNDN)  =  -1)
            
            ' Assert the value of rop and sign.
            Assert.IsTrue(rop.ToString() = "0.137108263716202786516e2" AndAlso sign = 1)
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.ptr{System.Int32},Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the value of the logarithm of the absolute value of the Gamma function on <paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="signp">The returned sign.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            The sign (1 or -1) of Gamma(<paramref name="op"/>) is returned in the object pointed to by <paramref name="signp"/>.
            When <paramref name="op"/> is 1 or 2, set <paramref name="rop"/> to +0 (in all rounding modes).
            When <paramref name="op"/> is an infinity or a nonpositive integer, set <paramref name="rop"/> to +Inf.
            When <paramref name="op"/> is NaN, -Inf or a negative integer, <paramref name="signp"/> is undefined,
            and when <paramref name="op"/> is ±0, <paramref name="signp"/> is the sign of the zero.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fac_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fac_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_eint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_eint</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_li2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_li2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_gamma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma_inc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_gamma_inc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lngamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_lngamma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma(Math.Mpfr.Native.mpfr_t,System.Int32@,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_lgamma(mpfr_t, ref int, mpfr_t, mpfr_rnd_t)</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_digamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_digamma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_beta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_beta</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_zeta</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_zeta_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erf(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erfc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erfc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_j0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_j0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_j1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_j1</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_jn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_jn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_y0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_y0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_y1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_y1</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_yn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_yn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fms</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmms</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_agm(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_agm</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_hypot(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_hypot</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ai(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ai</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 10.4.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop to log(|Gamma(op)|).
            ptr&lt;int&gt; sign = new ptr&lt;int&gt;(0);
            Assert.IsTrue(mpfr_lib.mpfr_lgamma(rop, sign, op, mpfr_rnd_t.MPFR_RNDN) == -1);
            
            // Assert the value of rop and sign.
            Assert.IsTrue(rop.ToString() == "0.137108263716202786516e2" &amp;&amp; sign.Value == 1);
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 10.4.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop to log(|Gamma(op)|).
            Dim sign As ptr(Of int) =  New ptr(Of int)(0)
            Assert.IsTrue(mpfr_lib.mpfr_lgamma(rop, sign, op, mpfr_rnd_t.MPFR_RNDN) = -1)
            
            ' Assert the value of rop and sign.
            Assert.IsTrue(rop.ToString() = "0.137108263716202786516e2" AndAlso sign.Value = 1)
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_digamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the value of the Digamma (sometimes also called Psi) function on <paramref name="op"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            When <paramref name="op"/> is a negative integer, set <paramref name="rop"/> to NaN. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fac_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fac_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_eint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_eint</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_li2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_li2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_gamma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma_inc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_gamma_inc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lngamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_lngamma</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_zeta</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_zeta_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erf(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erfc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erfc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_j0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_j0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_j1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_j1</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_jn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_jn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_y0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_y0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_y1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_y1</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_yn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_yn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fms</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmms</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_agm(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_agm</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_hypot(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_hypot</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ai(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ai</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 1.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = digamma(op).
            Assert.IsTrue(mpfr_lib.mpfr_digamma(rop, op, mpfr_rnd_t.MPFR_RNDN) == -1);
            
            // Assert the value of rop.
            Assert.IsTrue(rop.ToString() == "-0.577215664901532860616e0");
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 1.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = digamma(op).
            Assert.IsTrue(mpfr_lib.mpfr_digamma(rop, op, mpfr_rnd_t.MPFR_RNDN) = -1)
            
            ' Assert the value of rop.
            Assert.IsTrue(rop.ToString() = "-0.577215664901532860616e0")
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the value of the Riemann Zeta function on <paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fac_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fac_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_eint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_eint</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_li2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_li2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_gamma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma_inc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_gamma_inc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lngamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_lngamma</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_digamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_digamma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_beta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_beta</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_zeta_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erf(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erfc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erfc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_j0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_j0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_j1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_j1</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_jn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_jn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_y0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_y0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_y1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_y1</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_yn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_yn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fms</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmms</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_agm(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_agm</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_hypot(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_hypot</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ai(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ai</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 2.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 2, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = Zeta(op).
            Assert.IsTrue(mpfr_lib.mpfr_zeta(rop, op, mpfr_rnd_t.MPFR_RNDN) == -1);
            
            // Assert the value of rop.
            Assert.IsTrue(rop.ToString() == "0.164493406684822643642e1");
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 2.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 2, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = Zeta(op).
            Assert.IsTrue(mpfr_lib.mpfr_zeta(rop, op, mpfr_rnd_t.MPFR_RNDN) = -1)
            
            ' Assert the value of rop.
            Assert.IsTrue(rop.ToString() = "0.164493406684822643642e1")
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the value of the Riemann Zeta function on <paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fac_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fac_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_eint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_eint</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_li2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_li2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_gamma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma_inc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_gamma_inc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lngamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_lngamma</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_digamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_digamma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_beta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_beta</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_zeta</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erf(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erfc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erfc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_j0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_j0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_j1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_j1</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_jn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_jn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_y0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_y0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_y1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_y1</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_yn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_yn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fms</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmms</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_agm(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_agm</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_hypot(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_hypot</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ai(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ai</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = Zeta(op).
            Assert.IsTrue(mpfr_lib.mpfr_zeta_ui(rop, 2U, mpfr_rnd_t.MPFR_RNDN) == -1);
            
            // Assert the value of rop.
            Assert.IsTrue(rop.ToString() == "0.164493406684822643642e1");
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clear(rop);
            </code> 
            <code language="VB.NET">
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = Zeta(op).
            Assert.IsTrue(mpfr_lib.mpfr_zeta_ui(rop, 2U, mpfr_rnd_t.MPFR_RNDN) = -1)
            
            ' Assert the value of rop.
            Assert.IsTrue(rop.ToString() = "0.164493406684822643642e1")
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clear(rop)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_fac_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the factorial of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_eint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_eint</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_li2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_li2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_gamma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma_inc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_gamma_inc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lngamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_lngamma</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_digamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_digamma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_beta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_beta</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_zeta</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_zeta_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erf(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erfc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erfc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_j0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_j0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_j1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_j1</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_jn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_jn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_y0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_y0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_y1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_y1</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_yn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_yn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fms</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmms</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_agm(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_agm</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_hypot(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_hypot</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ai(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ai</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = 5!.
            Assert.IsTrue(mpfr_lib.mpfr_fac_ui(rop, 5U, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert the value of rop.
            Assert.IsTrue(rop.ToString() == "0.120000000000000000000e3");
            
            // Release unmanaged memory allocated for rop.
            mpfr_lib.mpfr_clear(rop);
            </code> 
            <code language="VB.NET">
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = 5!.
            Assert.IsTrue(mpfr_lib.mpfr_fac_ui(rop, 5U, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert the value of rop.
            Assert.IsTrue(rop.ToString() = "0.120000000000000000000e3")
            
            ' Release unmanaged memory allocated for rop.
            mpfr_lib.mpfr_clear(rop)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_j0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the value of the first kind Bessel function of order 0 on <paramref name="op"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            When <paramref name="op"/> is NaN, <paramref name="rop"/> is always set to NaN.
            When <paramref name="op"/> is plus or minus Infinity, <paramref name="rop"/> is set to +0.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fac_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fac_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_eint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_eint</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_li2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_li2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_gamma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma_inc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_gamma_inc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lngamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_lngamma</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_digamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_digamma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_beta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_beta</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_zeta</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_zeta_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erf(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erfc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erfc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_j1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_j1</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_jn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_jn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_y0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_y0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_y1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_y1</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_yn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_yn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fms</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmms</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_agm(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_agm</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_hypot(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_hypot</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ai(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ai</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 10.4.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = J0(op).
            Assert.IsTrue(mpfr_lib.mpfr_j0(rop, op, mpfr_rnd_t.MPFR_RNDN) == 1);
            
            // Assert the value of rop.
            Assert.IsTrue(rop.ToString() == "-0.243371750714207143215e0");
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 10.4.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = J0(op).
            Assert.IsTrue(mpfr_lib.mpfr_j0(rop, op, mpfr_rnd_t.MPFR_RNDN) = 1)
            
            ' Assert the value of rop.
            Assert.IsTrue(rop.ToString() = "-0.243371750714207143215e0")
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_j1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the value of the first kind Bessel function of order 1 on <paramref name="op"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            When <paramref name="op"/> is NaN, <paramref name="rop"/> is always set to NaN.
            When <paramref name="op"/> is plus or minus Infinity, <paramref name="rop"/> is set to +0.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fac_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fac_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_eint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_eint</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_li2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_li2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_gamma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma_inc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_gamma_inc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lngamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_lngamma</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_digamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_digamma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_beta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_beta</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_zeta</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_zeta_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erf(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erfc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erfc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_j0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_j0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_jn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_jn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_y0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_y0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_y1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_y1</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_yn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_yn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fms</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmms</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_agm(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_agm</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_hypot(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_hypot</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ai(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ai</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 10.4.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = J0(op).
            Assert.IsTrue(mpfr_lib.mpfr_j1(rop, op, mpfr_rnd_t.MPFR_RNDN) == -1);
            
            // Assert the value of rop.
            Assert.IsTrue(rop.ToString() == "-0.554727618489979474337e-1");
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 10.4.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = J0(op).
            Assert.IsTrue(mpfr_lib.mpfr_j1(rop, op, mpfr_rnd_t.MPFR_RNDN) = -1)
            
            ' Assert the value of rop.
            Assert.IsTrue(rop.ToString() = "-0.554727618489979474337e-1")
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_jn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the value of the first kind Bessel function of order <paramref name="n"/> on <paramref name="op"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="n">Order of the Bessel function.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            When <paramref name="op"/> is NaN, <paramref name="rop"/> is always set to NaN.
            When <paramref name="op"/> is plus or minus Infinity, <paramref name="rop"/> is set to +0.
            When <paramref name="op"/> is zero, and <paramref name="n"/> is not zero, <paramref name="rop"/>
            is set to +0 or -0 depending on the parity and sign of <paramref name="n"/>, and the sign of <paramref name="op"/>.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fac_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fac_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_eint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_eint</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_li2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_li2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_gamma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma_inc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_gamma_inc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lngamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_lngamma</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_digamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_digamma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_beta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_beta</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_zeta</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_zeta_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erf(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erfc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erfc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_j0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_j0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_j1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_j1</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_y0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_y0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_y1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_y1</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_yn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_yn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fms</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmms</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_agm(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_agm</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_hypot(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_hypot</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ai(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ai</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 10.4.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = J0(op).
            Assert.IsTrue(mpfr_lib.mpfr_jn(rop, 3, op, mpfr_rnd_t.MPFR_RNDN) == 1);
            
            // Assert the value of rop.
            Assert.IsTrue(rop.ToString() == "0.144974266424802618878e0");
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 10.4.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = J0(op).
            Assert.IsTrue(mpfr_lib.mpfr_jn(rop, 3, op, mpfr_rnd_t.MPFR_RNDN) = 1)
            
            ' Assert the value of rop.
            Assert.IsTrue(rop.ToString() = "0.144974266424802618878e0")
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_y0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the value of the first kind Bessel function of order 0 on <paramref name="op"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            When <paramref name="op"/> is NaN, <paramref name="rop"/> is always set to NaN.
            When <paramref name="op"/> is plus or minus Infinity, <paramref name="rop"/> is set to +0.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fac_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fac_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_eint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_eint</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_li2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_li2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_gamma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma_inc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_gamma_inc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lngamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_lngamma</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_digamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_digamma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_beta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_beta</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_zeta</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_zeta_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erf(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erfc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erfc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_j0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_j0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_j1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_j1</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_jn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_jn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_y1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_y1</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_yn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_yn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fms</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmms</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_agm(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_agm</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_hypot(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_hypot</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ai(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ai</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 1.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = Y0(op).
            Assert.IsTrue(mpfr_lib.mpfr_y0(rop, op, mpfr_rnd_t.MPFR_RNDN) == -1);
            
            // Assert the value of rop.
            Assert.IsTrue(rop.ToString() == "0.882569642156769579796e-1");
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 1.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = Y0(op).
            Assert.IsTrue(mpfr_lib.mpfr_y0(rop, op, mpfr_rnd_t.MPFR_RNDN) = -1)
            
            ' Assert the value of rop.
            Assert.IsTrue(rop.ToString() = "0.882569642156769579796e-1")
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_y1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the value of the first kind Bessel function of order 1 on <paramref name="op"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            When <paramref name="op"/> is NaN, <paramref name="rop"/> is always set to NaN.
            When <paramref name="op"/> is plus or minus Infinity, <paramref name="rop"/> is set to +0.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fac_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fac_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_eint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_eint</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_li2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_li2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_gamma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma_inc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_gamma_inc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lngamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_lngamma</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_digamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_digamma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_beta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_beta</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_zeta</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_zeta_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erf(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erfc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erfc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_j0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_j0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_j1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_j1</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_jn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_jn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_y0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_y0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_yn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_yn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fms</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmms</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_agm(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_agm</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_hypot(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_hypot</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ai(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ai</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 1.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = Y1(op).
            Assert.IsTrue(mpfr_lib.mpfr_y1(rop, op, mpfr_rnd_t.MPFR_RNDN) == -1);
            
            // Assert the value of rop.
            Assert.IsTrue(rop.ToString() == "-0.781212821300288716550e0");
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 1.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = Y1(op).
            Assert.IsTrue(mpfr_lib.mpfr_y1(rop, op, mpfr_rnd_t.MPFR_RNDN) = -1)
            
            ' Assert the value of rop.
            Assert.IsTrue(rop.ToString() = "-0.781212821300288716550e0")
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_yn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the value of the first kind Bessel function of order <paramref name="n"/> on <paramref name="op"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="n">Order of the Bessel function.</param>
            <param name="op">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            When <paramref name="op"/> is NaN, <paramref name="rop"/> is always set to NaN.
            When <paramref name="op"/> is plus or minus Infinity, <paramref name="rop"/> is set to +0.
            When <paramref name="op"/> is zero, and <paramref name="n"/> is not zero, <paramref name="rop"/>
            is set to +0 or -0 depending on the parity and sign of <paramref name="n"/>, and the sign of <paramref name="op"/>. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fac_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fac_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_eint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_eint</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_li2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_li2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_gamma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma_inc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_gamma_inc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lngamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_lngamma</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_digamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_digamma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_beta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_beta</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_zeta</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_zeta_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erf(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erfc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erfc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_j0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_j0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_j1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_j1</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_jn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_jn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_y0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_y0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_y1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_y1</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fms</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmms</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_agm(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_agm</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_hypot(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_hypot</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ai(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ai</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op to 1.
            mpfr_t op = new mpfr_t();
            mpfr_lib.mpfr_init2(op, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = Yn(3, op).
            Assert.IsTrue(mpfr_lib.mpfr_yn(rop, 3, op, mpfr_rnd_t.MPFR_RNDN) == 1);
            
            // Assert the value of rop.
            Assert.IsTrue(rop.ToString() == "-0.582151760596472884774e1");
            
            // Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op to 1.
            Dim op As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = Yn(3, op).
            Assert.IsTrue(mpfr_lib.mpfr_yn(rop, 3, op, mpfr_rnd_t.MPFR_RNDN) = 1)
            
            ' Assert the value of rop.
            Assert.IsTrue(rop.ToString() = "-0.582151760596472884774e1")
            
            ' Release unmanaged memory allocated for rop and op.
            mpfr_lib.mpfr_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_ai(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the value of the Airy function Ai on <paramref name="x"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="x">The operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            When <paramref name="x"/> is NaN, <paramref name="rop"/> is always set to NaN.
            When <paramref name="x"/> is +Inf or -Inf, <paramref name="rop"/> is +0.
            The current implementation is not intended to be used with large arguments.
            It works with abs(<paramref name="x"/>) typically smaller than 500.
            For larger arguments, other methods should be used and will be implemented in a future version. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fac_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fac_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_eint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_eint</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_li2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_li2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_gamma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma_inc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_gamma_inc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lngamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_lngamma</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_digamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_digamma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_beta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_beta</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_zeta</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_zeta_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erf(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erfc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erfc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_j0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_j0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_j1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_j1</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_jn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_jn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_y0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_y0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_y1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_y1</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_yn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_yn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fms</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmms</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_agm(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_agm</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_hypot(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_hypot</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number x to 1.0.
            mpfr_t x = new mpfr_t();
            mpfr_lib.mpfr_init2(x, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_d(x, 1.0, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = Airy(x).
            Assert.IsTrue(mpfr_lib.mpfr_ai(rop, x, mpfr_rnd_t.MPFR_RNDN) == 1);
            
            // Assert the value of rop.
            Assert.IsTrue(rop.ToString() == "0.135292416312881415524e0");
            
            // Release unmanaged memory allocated for x and rop.
            mpfr_lib.mpfr_clears(x, rop, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number x to 1.0.
            Dim x As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(x, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_d(x, 1.0, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = Airy(x).
            Assert.IsTrue(mpfr_lib.mpfr_ai(rop, x, mpfr_rnd_t.MPFR_RNDN) = 1)
            
            ' Assert the value of rop.
            Assert.IsTrue(rop.ToString() = "0.135292416312881415524e0")
            
            ' Release unmanaged memory allocated for x and rop.
            mpfr_lib.mpfr_clears(x, rop, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_min(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the minimum of <paramref name="op1"/> and <paramref name="op2"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            If <paramref name="op1"/> and <paramref name="op2"/> are both NaN, then <paramref name="rop"/> is set to NaN.
            If <paramref name="op1"/> or <paramref name="op2"/> is NaN, then <paramref name="rop"/> is set to the numeric value.
            If <paramref name="op1"/> and <paramref name="op2"/> are zeros of different signs, then <paramref name="rop"/> is set to -0. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_max(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_max</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to -210.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new floating-point number op2 to 10.
            mpfr_t op2 = new mpfr_t();
            mpfr_lib.mpfr_init2(op2, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = max(op1, op2).
            Assert.IsTrue(mpfr_lib.mpfr_min(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is -210.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == -210.0);
            
            // Release unmanaged memory allocated for rop, op1, and op2.
            mpfr_lib.mpfr_clears(rop, op1, op2, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to -210.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new floating-point number op2 to 10.
            Dim op2 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op2, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = max(op1, op2).
            Assert.IsTrue(mpfr_lib.mpfr_min(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is -210.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = -210.0)
            
            ' Release unmanaged memory allocated for rop, op1, and op2.
            mpfr_lib.mpfr_clears(rop, op1, op2, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_max(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the maximum of <paramref name="op1"/> and <paramref name="op2"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            If <paramref name="op1"/> and <paramref name="op2"/> are both NaN, then <paramref name="rop"/> is set to NaN.
            If <paramref name="op1"/> or <paramref name="op2"/> is NaN, then <paramref name="rop"/> is set to the numeric value.
            If <paramref name="op1"/> and <paramref name="op2"/> are zeros of different signs, then <paramref name="rop"/> is set to +0. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_min(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_min</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to -210.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new floating-point number op2 to 10.
            mpfr_t op2 = new mpfr_t();
            mpfr_lib.mpfr_init2(op2, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = max(op1, op2).
            Assert.IsTrue(mpfr_lib.mpfr_max(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is 10.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 10.0);
            
            // Release unmanaged memory allocated for rop, op1, and op2.
            mpfr_lib.mpfr_clears(rop, op1, op2, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to -210.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new floating-point number op2 to 10.
            Dim op2 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op2, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = max(op1, op2).
            Assert.IsTrue(mpfr_lib.mpfr_max(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is 10.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 10.0)
            
            ' Release unmanaged memory allocated for rop, op1, and op2.
            mpfr_lib.mpfr_clears(rop, op1, op2, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_dim(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the positive difference of <paramref name="op1"/> and <paramref name="op2"/>, i.e., <paramref name="op1"/> - <paramref name="op2"/> rounded in the direction <paramref name="rnd"/> if <paramref name="op1"/> &gt; <paramref name="op2"/>, +0 if <paramref name="op1"/> &#8804; <paramref name="op2"/>, and NaN if <paramref name="op1"/> or <paramref name="op2"/> is NaN. 
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqr(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqr</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cbrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cbrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rootn_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_root(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_neg</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_abs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_dim(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_dim</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to -210.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new floating-point number op2 to 10.
            mpfr_t op2 = new mpfr_t();
            mpfr_lib.mpfr_init2(op2, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop to positive difference of op1 - op2.
            Assert.IsTrue(mpfr_lib.mpfr_dim(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is 0.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Release unmanaged memory allocated for rop, op1, and op2.
            mpfr_lib.mpfr_clears(rop, op1, op2, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to -210.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new floating-point number op2 to 10.
            Dim op2 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op2, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop to positive difference of op1 - op2.
            Assert.IsTrue(mpfr_lib.mpfr_dim(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is 0.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Release unmanaged memory allocated for rop, op1, and op2.
            mpfr_lib.mpfr_clears(rop, op1, op2, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_z(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> * <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            When a result is zero, its sign is the product of the signs of the operands
            (for types having no signed zeros, 0 is considered positive).
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_z(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_q(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqr(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqr</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cbrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cbrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rootn_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_root(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_neg</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_abs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_dim(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_dim</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_2ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_2ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_2si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_2si</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to 10.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new integer op2 to -210.
            mpz_t op2 = "-210";
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = op1 * op2.
            Assert.IsTrue(mpfr_lib.mpfr_mul_z(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is -2100.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == -2100.0);
            
            // Release unmanaged memory allocated for rop, op1, and op2.
            mpfr_lib.mpfr_clears(rop, op1, null);
            gmp_lib.mpz_clear(op2);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to 10.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new integer op2 to -210.
            Dim op2 As mpz_t = "-210" 
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = op1 * op2.
            Assert.IsTrue(mpfr_lib.mpfr_mul_z(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is -2100.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = -2100.0)
            
            ' Release unmanaged memory allocated for rop, op1, and op2.
            mpfr_lib.mpfr_clears(rop, op1, Nothing)
            gmp_lib.mpz_clear(op2)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_z(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> / <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            When a result is zero, its sign is the product of the signs of the operands.
            For types having no signed zeros, 0 is considered positive; but note that if 
            <paramref name="op1"/> is non-zero and <paramref name="op2"/> is zero, the result might change from
            ±Inf to NaN in future MPFR versions if there is an opposite decision on the IEEE 754 side. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqr(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqr</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ui_div(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ui_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_si_div(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_si_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_d_div(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_d_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_z(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_q(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cbrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cbrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rootn_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_root(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_neg</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_abs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_dim(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_dim</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to -210.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new integer op2 to 10.
            mpz_t op2 = new mpz_t();
            gmp_lib.mpz_init(op2);
            gmp_lib.mpz_set_si(op2, 10);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = op1 / op2.
            Assert.IsTrue(mpfr_lib.mpfr_div_z(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is -21.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == -21.0);
            
            // Release unmanaged memory allocated for rop, op1, and op2.
            mpfr_lib.mpfr_clears(rop, op1, null);
            gmp_lib.mpz_clear(op2);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to -210.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new integer op2 to 10.
            Dim op2 As mpz_t = New mpz_t()
            gmp_lib.mpz_init(op2)
            gmp_lib.mpz_set_si(op2, 10)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = op1 / op2.
            Assert.IsTrue(mpfr_lib.mpfr_div_z(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is -21.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = -21.0)
            
            ' Release unmanaged memory allocated for rop, op1, and op2.
            mpfr_lib.mpfr_clears(rop, op1, Nothing)
            gmp_lib.mpz_clear(op2)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_add_z(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> + <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            The IEEE-754 rules are used, in particular for signed zeros.
            But for types having no signed zeros, 0 is considered unsigned
            (i.e., (+0) + 0 = (+0) and (-0) + 0 = (-0)).
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add_z(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add_q(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sum(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t[],System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sum</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqr(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqr</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cbrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cbrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rootn_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_root(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_neg</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_abs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_dim(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_dim</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to -210.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new integer op2 to 5.
            mpz_t op2 = new mpz_t();
            gmp_lib.mpz_init_set_si(op2, 5);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = op1 + op2.
            Assert.IsTrue(mpfr_lib.mpfr_add_z(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is -200.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == -205.0);
            
            // Release unmanaged memory allocated for rop, op1, and op2.
            mpfr_lib.mpfr_clears(rop, op1, null);
            gmp_lib.mpz_clear(op2);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to -210.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new integer op2 to 5.
            Dim op2 As mpz_t = New mpz_t()
            gmp_lib.mpz_init_set_si(op2, 5)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = op1 + op2.
            Assert.IsTrue(mpfr_lib.mpfr_add_z(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is -200.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = -205.0)
            
            ' Release unmanaged memory allocated for rop, op1, and op2.
            mpfr_lib.mpfr_clears(rop, op1, Nothing)
            gmp_lib.mpz_clear(op2)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_z(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> - <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            The IEEE-754 rules are used, in particular for signed zeros.
            But for types having no signed zeros, 0 is considered unsigned
            (i.e., (+0) - 0 = (+0), (-0) - 0 = (-0), 0 - (+0) = (-0) and 0 - (-0) = (+0)).
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ui_sub(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ui_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_si_sub(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_si_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_d_sub(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_d_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_z_sub(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_z_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_z(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_q(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqr(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqr</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cbrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cbrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rootn_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_root(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_neg</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_abs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_dim(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_dim</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to 10.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new integer op2 to -210.
            mpz_t op2 = "-210";
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = op1 - op2.
            Assert.IsTrue(mpfr_lib.mpfr_sub_z(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is 220.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 220.0);
            
            // Release unmanaged memory allocated for rop, op1, and op2.
            mpfr_lib.mpfr_clears(rop, op1, null);
            gmp_lib.mpz_clear(op2);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to 10.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new integer op2 to -210.
            Dim op2 As mpz_t = "-210" 
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = op1 - op2.
            Assert.IsTrue(mpfr_lib.mpfr_sub_z(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is 220.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 220.0)
            
            ' Release unmanaged memory allocated for rop, op1, and op2.
            mpfr_lib.mpfr_clears(rop, op1, Nothing)
            gmp_lib.mpz_clear(op2)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_z_sub(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> - <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            The IEEE-754 rules are used, in particular for signed zeros.
            But for types having no signed zeros, 0 is considered unsigned
            (i.e., (+0) - 0 = (+0), (-0) - 0 = (-0), 0 - (+0) = (-0) and 0 - (-0) = (+0)).
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ui_sub(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ui_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_si_sub(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_si_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_d_sub(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_d_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_z_sub(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_z_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_z(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_q(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqr(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqr</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cbrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cbrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rootn_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_root(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_neg</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_abs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_dim(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_dim</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new integer op1 to -210.
            mpz_t op1 = "-210";
            
            // Create, initialize, and set a new floating-point number op2 to 10.
            mpfr_t op2 = new mpfr_t();
            mpfr_lib.mpfr_init2(op2, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = op1 - op2.
            Assert.IsTrue(mpfr_lib.mpfr_z_sub(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is -220.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == -220.0);
            
            // Release unmanaged memory allocated for rop, op1, and op2.
            mpfr_lib.mpfr_clears(rop, op2, null);
            gmp_lib.mpz_clear(op1);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new integer op1 to -210.
            Dim op1 As mpz_t = "-210" 
            
            ' Create, initialize, and set a new floating-point number op2 to 10.
            Dim op2 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op2, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = op1 - op2.
            Assert.IsTrue(mpfr_lib.mpfr_z_sub(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is -220.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = -220.0)
            
            ' Release unmanaged memory allocated for rop, op1, and op2.
            mpfr_lib.mpfr_clears(rop, op2, Nothing)
            gmp_lib.mpz_clear(op1)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t)">
            <summary>
            Compare <paramref name="op1"/> and <paramref name="op2"/>.
            </summary>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <returns>Return a positive value if <paramref name="op1"/> &gt; <paramref name="op2"/>, zero if <paramref name="op1"/> = <paramref name="op2"/>, and a negative value if <paramref name="op1"/> &lt; <paramref name="op2"/>.</returns>
            <remarks>
            <para>
            Both <paramref name="op1"/> and <paramref name="op2"/> are considered to their full own precision, which may differ.
            If one of the operands is NaN, set the erange flag and return zero. 
            </para>
            <para>
            Note: These functions may be useful to distinguish the three possible cases.
            If you need to distinguish two cases only, it is recommended to use the predicate functions
            (e.g., <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_equal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_equal_p</see> for the equality) described below; they behave like the IEEE 754 comparisons,
            in particular when one or both arguments are NaN.
            But only floating-point numbers can be compared (you may need to do a conversion first). 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_cmp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_ui(Math.Mpfr.Native.mpfr_t,System.UInt32)">mpfr_cmp_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_si(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_cmp_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_d(Math.Mpfr.Native.mpfr_t,System.Double)">mpfr_cmp_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t)">mpfr_cmp_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t)">mpfr_cmp_f</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_ui_2exp(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_exp_t)">mpfr_cmp_ui_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_si_2exp(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_exp_t)">mpfr_cmp_si_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmpabs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_cmpabs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nan_p(Math.Mpfr.Native.mpfr_t)">mpfr_nan_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inf_p(Math.Mpfr.Native.mpfr_t)">mpfr_inf_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_number_p(Math.Mpfr.Native.mpfr_t)">mpfr_number_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zero_p(Math.Mpfr.Native.mpfr_t)">mpfr_zero_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_regular_p(Math.Mpfr.Native.mpfr_t)">mpfr_regular_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sgn(Math.Mpfr.Native.mpfr_t)">mpfr_sgn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_greater_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_greater_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_greaterequal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_greaterequal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_less_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_less_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lessequal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_lessequal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_equal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_equal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lessgreater_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_lessgreater_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_unordered_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_unordered_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Comparison_Functions">Comparison Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Comparison-Functions">GNU MPFR - Comparison Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to 512.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new integer op2 to 128.
            mpz_t op2 = new mpz_t();
            gmp_lib.mpz_init_set_si(op2, 128);
            
            // Assert that op1 &gt; op2.
            Assert.IsTrue(mpfr_lib.mpfr_cmp_z(op1, op2) &gt; 0);
            
            // Release unmanaged memory allocated for op1 and op2.
            mpfr_lib.mpfr_clear(op1);
            gmp_lib.mpz_clear(op2);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to 512.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new integer op2 to 128.
            Dim op2 As mpz_t = New mpz_t()
            gmp_lib.mpz_init_set_si(op2, 128)
            
            ' Assert that op1 &gt; op2.
            Assert.IsTrue(mpfr_lib.mpfr_cmp_z(op1, op2) &gt; 0)
            
            ' Release unmanaged memory allocated for op1 and op2.
            mpfr_lib.mpfr_clear(op1)
            gmp_lib.mpz_clear(op2)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_q(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> * <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            When a result is zero, its sign is the product of the signs of the operands
            (for types having no signed zeros, 0 is considered positive).
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_z(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_q(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqr(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqr</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cbrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cbrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rootn_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_root(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_neg</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_abs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_dim(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_dim</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_2ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_2ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul_2si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul_2si</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to 10.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new rational op2 to -210.
            mpq_t op2 = "-210/1";
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = op1 * op2.
            Assert.IsTrue(mpfr_lib.mpfr_mul_q(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is -2100.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == -2100.0);
            
            // Release unmanaged memory allocated for rop, op1, and op2.
            mpfr_lib.mpfr_clears(rop, op1, null);
            gmp_lib.mpq_clear(op2);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to 10.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new rational op2 to -210.
            Dim op2 As mpq_t = "-210/1" 
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = op1 * op2.
            Assert.IsTrue(mpfr_lib.mpfr_mul_q(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is -2100.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = -2100.0)
            
            ' Release unmanaged memory allocated for rop, op1, and op2.
            mpfr_lib.mpfr_clears(rop, op1, Nothing)
            gmp_lib.mpq_clear(op2)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_q(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> / <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            When a result is zero, its sign is the product of the signs of the operands.
            For types having no signed zeros, 0 is considered positive; but note that if 
            <paramref name="op1"/> is non-zero and <paramref name="op2"/> is zero, the result might change from
            ±Inf to NaN in future MPFR versions if there is an opposite decision on the IEEE 754 side. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqr(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqr</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ui_div(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ui_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_si_div(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_si_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_d_div(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_d_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_z(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div_q(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cbrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cbrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rootn_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_root(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_neg</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_abs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_dim(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_dim</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to -210.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new rational op2 to 10.
            mpq_t op2 = new mpq_t();
            gmp_lib.mpq_init(op2);
            gmp_lib.mpq_set_si(op2, 10, 1);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = op1 / op2.
            Assert.IsTrue(mpfr_lib.mpfr_div_q(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is -21.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == -21.0);
            
            // Release unmanaged memory allocated for rop, op1, and op2.
            mpfr_lib.mpfr_clears(rop, op1, null);
            gmp_lib.mpq_clear(op2);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to -210.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new rational op2 to 10.
            Dim op2 As mpq_t = New mpq_t()
            gmp_lib.mpq_init(op2)
            gmp_lib.mpq_set_si(op2, 10, 1)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = op1 / op2.
            Assert.IsTrue(mpfr_lib.mpfr_div_q(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is -21.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = -21.0)
            
            ' Release unmanaged memory allocated for rop, op1, and op2.
            mpfr_lib.mpfr_clears(rop, op1, Nothing)
            gmp_lib.mpq_clear(op2)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_add_q(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> + <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            The IEEE-754 rules are used, in particular for signed zeros.
            But for types having no signed zeros, 0 is considered unsigned
            (i.e., (+0) + 0 = (+0) and (-0) + 0 = (-0)).
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add_z(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add_q(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sum(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t[],System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sum</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqr(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqr</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cbrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cbrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rootn_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_root(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_neg</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_abs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_dim(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_dim</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to -210.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new rational number op2 to 1/5.
            mpq_t op2 = new mpq_t();
            gmp_lib.mpq_init(op2);
            gmp_lib.mpq_set_si(op2, 1, 5);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = op1 + op2.
            Assert.IsTrue(mpfr_lib.mpfr_add_q(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) == -1);
            
            // Assert the value of rop.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == -209.8);
            
            // Release unmanaged memory allocated for rop, op1, and op2.
            mpfr_lib.mpfr_clears(rop, op1, null);
            gmp_lib.mpq_clear(op2);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to -210.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new rational number op2 to 1/5.
            Dim op2 As mpq_t = New mpq_t()
            gmp_lib.mpq_init(op2)
            gmp_lib.mpq_set_si(op2, 1, 5)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = op1 + op2.
            Assert.IsTrue(mpfr_lib.mpfr_add_q(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) = -1)
            
            ' Assert the value of rop.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = -209.8)
            
            ' Release unmanaged memory allocated for rop, op1, and op2.
            mpfr_lib.mpfr_clears(rop, op1, Nothing)
            gmp_lib.mpq_clear(op2)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_q(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> - <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            The IEEE-754 rules are used, in particular for signed zeros.
            But for types having no signed zeros, 0 is considered unsigned
            (i.e., (+0) - 0 = (+0), (-0) - 0 = (-0), 0 - (+0) = (-0) and 0 - (-0) = (+0)).
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ui_sub(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ui_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_si_sub(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_si_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_d_sub(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_d_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_z_sub(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_z_sub</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_z(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sub_q(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sub_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mul(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_mul</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqr(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqr</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_div(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_div</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sqrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_sqrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cbrt(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_cbrt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_rootn_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_root(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_root</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_pow(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_pow</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_neg(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_neg</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_abs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_abs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_dim(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_dim</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to 10.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new rational op2 to -210.
            mpq_t op2 = "-210/1";
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = op1 - op2.
            Assert.IsTrue(mpfr_lib.mpfr_sub_q(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is 220.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 220.0);
            
            // Release unmanaged memory allocated for rop, op1, and op2.
            mpfr_lib.mpfr_clears(rop, op1, null);
            gmp_lib.mpq_clear(op2);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to 10.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new rational op2 to -210.
            Dim op2 As mpq_t = "-210/1" 
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = op1 - op2.
            Assert.IsTrue(mpfr_lib.mpfr_sub_q(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is 220.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 220.0)
            
            ' Release unmanaged memory allocated for rop, op1, and op2.
            mpfr_lib.mpfr_clears(rop, op1, Nothing)
            gmp_lib.mpq_clear(op2)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t)">
            <summary>
            Compare <paramref name="op1"/> and <paramref name="op2"/>.
            </summary>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <returns>Return a positive value if <paramref name="op1"/> &gt; <paramref name="op2"/>, zero if <paramref name="op1"/> = <paramref name="op2"/>, and a negative value if <paramref name="op1"/> &lt; <paramref name="op2"/>.</returns>
            <remarks>
            <para>
            Both <paramref name="op1"/> and <paramref name="op2"/> are considered to their full own precision, which may differ.
            If one of the operands is NaN, set the erange flag and return zero. 
            </para>
            <para>
            Note: These functions may be useful to distinguish the three possible cases.
            If you need to distinguish two cases only, it is recommended to use the predicate functions
            (e.g., <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_equal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_equal_p</see> for the equality) described below; they behave like the IEEE 754 comparisons,
            in particular when one or both arguments are NaN.
            But only floating-point numbers can be compared (you may need to do a conversion first). 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_cmp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_ui(Math.Mpfr.Native.mpfr_t,System.UInt32)">mpfr_cmp_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_si(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_cmp_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_d(Math.Mpfr.Native.mpfr_t,System.Double)">mpfr_cmp_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t)">mpfr_cmp_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t)">mpfr_cmp_f</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_ui_2exp(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_exp_t)">mpfr_cmp_ui_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_si_2exp(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_exp_t)">mpfr_cmp_si_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmpabs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_cmpabs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nan_p(Math.Mpfr.Native.mpfr_t)">mpfr_nan_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inf_p(Math.Mpfr.Native.mpfr_t)">mpfr_inf_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_number_p(Math.Mpfr.Native.mpfr_t)">mpfr_number_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zero_p(Math.Mpfr.Native.mpfr_t)">mpfr_zero_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_regular_p(Math.Mpfr.Native.mpfr_t)">mpfr_regular_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sgn(Math.Mpfr.Native.mpfr_t)">mpfr_sgn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_greater_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_greater_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_greaterequal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_greaterequal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_less_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_less_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lessequal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_lessequal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_equal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_equal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lessgreater_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_lessgreater_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_unordered_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_unordered_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Comparison_Functions">Comparison Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Comparison-Functions">GNU MPFR - Comparison Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to 512.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new rational number op2.
            mpq_t op2 = new mpq_t();
            gmp_lib.mpq_init(op2);
            gmp_lib.mpq_set_si(op2, 128, 1);
            
            // Assert that op1 &gt; op2.
            Assert.IsTrue(mpfr_lib.mpfr_cmp_q(op1, op2) &gt; 0);
            
            // Release unmanaged memory allocated for op1 and op2.
            mpfr_lib.mpfr_clear(op1);
            gmp_lib.mpq_clear(op2);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to 512.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new rational number op2.
            Dim op2 As mpq_t = New mpq_t()
            gmp_lib.mpq_init(op2)
            gmp_lib.mpq_set_si(op2, 128, 1)
            
            ' Assert that op1 &gt; op2.
            Assert.IsTrue(mpfr_lib.mpfr_cmp_q(op1, op2) &gt; 0)
            
            ' Release unmanaged memory allocated for op1 and op2.
            mpfr_lib.mpfr_clear(op1)
            gmp_lib.mpq_clear(op2)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t)">
            <summary>
            Compare <paramref name="op1"/> and <paramref name="op2"/>.
            </summary>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <returns>Return a positive value if <paramref name="op1"/> &gt; <paramref name="op2"/>, zero if <paramref name="op1"/> = <paramref name="op2"/>, and a negative value if <paramref name="op1"/> &lt; <paramref name="op2"/>.</returns>
            <remarks>
            <para>
            Both <paramref name="op1"/> and <paramref name="op2"/> are considered to their full own precision, which may differ.
            If one of the operands is NaN, set the erange flag and return zero. 
            </para>
            <para>
            Note: These functions may be useful to distinguish the three possible cases.
            If you need to distinguish two cases only, it is recommended to use the predicate functions
            (e.g., <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_equal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_equal_p</see> for the equality) described below; they behave like the IEEE 754 comparisons,
            in particular when one or both arguments are NaN.
            But only floating-point numbers can be compared (you may need to do a conversion first). 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_cmp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_ui(Math.Mpfr.Native.mpfr_t,System.UInt32)">mpfr_cmp_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_si(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_cmp_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_d(Math.Mpfr.Native.mpfr_t,System.Double)">mpfr_cmp_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t)">mpfr_cmp_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t)">mpfr_cmp_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_ui_2exp(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_exp_t)">mpfr_cmp_ui_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmp_si_2exp(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_exp_t)">mpfr_cmp_si_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_cmpabs(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_cmpabs</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_nan_p(Math.Mpfr.Native.mpfr_t)">mpfr_nan_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_inf_p(Math.Mpfr.Native.mpfr_t)">mpfr_inf_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_number_p(Math.Mpfr.Native.mpfr_t)">mpfr_number_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zero_p(Math.Mpfr.Native.mpfr_t)">mpfr_zero_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_regular_p(Math.Mpfr.Native.mpfr_t)">mpfr_regular_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_sgn(Math.Mpfr.Native.mpfr_t)">mpfr_sgn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_greater_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_greater_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_greaterequal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_greaterequal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_less_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_less_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lessequal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_lessequal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_equal_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_equal_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lessgreater_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_lessgreater_p</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_unordered_p(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_unordered_p</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Comparison_Functions">Comparison Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Comparison-Functions">GNU MPFR - Comparison Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to 512.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number op2.
            mpf_t op2 = new mpf_t();
            gmp_lib.mpf_init_set_si(op2, 128);
            
            // Assert that op1 &gt; op2.
            Assert.IsTrue(mpfr_lib.mpfr_cmp_f(op1, op2) &gt; 0);
            
            // Release unmanaged memory allocated for op1 and op2.
            mpfr_lib.mpfr_clear(op1);
            gmp_lib.mpf_clear(op2);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to 512.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number op2.
            Dim op2 As mpf_t = New mpf_t()
            gmp_lib.mpf_init_set_si(op2, 128)
            
            ' Assert that op1 &gt; op2.
            Assert.IsTrue(mpfr_lib.mpfr_cmp_f(op1, op2) &gt; 0)
            
            ' Release unmanaged memory allocated for op1 and op2.
            mpfr_lib.mpfr_clear(op1)
            gmp_lib.mpf_clear(op2)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_fma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to (<paramref name="op1"/> * <paramref name="op2"/>) + <paramref name="op3"/> rounded in the direction <paramref name="rnd"/>. 
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="op3">The third operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            Concerning special values (signed zeros, infinities, NaN), these functions behave like a multiplication followed by a separate addition.
            That is, the fused operation matters only for rounding. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fac_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fac_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_eint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_eint</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_li2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_li2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_gamma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma_inc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_gamma_inc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lngamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_lngamma</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_digamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_digamma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_beta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_beta</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_zeta</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_zeta_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erf(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erfc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erfc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_j0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_j0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_j1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_j1</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_jn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_jn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_y0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_y0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_y1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_y1</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_yn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_yn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fms</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmms</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_agm(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_agm</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_hypot(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_hypot</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ai(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ai</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to -210.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new floating-point number op2 to 10.
            mpfr_t op2 = new mpfr_t();
            mpfr_lib.mpfr_init2(op2, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new floating-point number op3 to 10.
            mpfr_t op3 = new mpfr_t();
            mpfr_lib.mpfr_init2(op3, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op3, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = (op1 * op2) + op3.
            Assert.IsTrue(mpfr_lib.mpfr_fma(rop, op1, op2, op3, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is -2090.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == -2090.0);
            
            // Release unmanaged memory allocated for rop, op1, op2, and op3.
            mpfr_lib.mpfr_clears(rop, op1, op2, op3, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to -210.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new floating-point number op2 to 10.
            Dim op2 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op2, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new floating-point number op3 to 10.
            Dim op3 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op3, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op3, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = (op1 * op2) + op3.
            Assert.IsTrue(mpfr_lib.mpfr_fma(rop, op1, op2, op3, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is -2090.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = -2090.0)
            
            ' Release unmanaged memory allocated for rop, op1, op2, and op3.
            mpfr_lib.mpfr_clears(rop, op1, op2, op3, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_fms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to (<paramref name="op1"/> * <paramref name="op2"/>) - <paramref name="op3"/> rounded in the direction <paramref name="rnd"/>. 
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="op3">The third operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            Concerning special values (signed zeros, infinities, NaN), these functions behave like a multiplication followed by a separate subtraction.
            That is, the fused operation matters only for rounding. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fac_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fac_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_eint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_eint</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_li2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_li2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_gamma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma_inc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_gamma_inc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lngamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_lngamma</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_digamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_digamma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_beta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_beta</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_zeta</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_zeta_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erf(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erfc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erfc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_j0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_j0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_j1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_j1</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_jn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_jn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_y0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_y0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_y1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_y1</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_yn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_yn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmms</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_agm(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_agm</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_hypot(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_hypot</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ai(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ai</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to -210.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new floating-point number op2 to 10.
            mpfr_t op2 = new mpfr_t();
            mpfr_lib.mpfr_init2(op2, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new floating-point number op3 to 10.
            mpfr_t op3 = new mpfr_t();
            mpfr_lib.mpfr_init2(op3, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op3, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = (op1 * op2) - op3.
            Assert.IsTrue(mpfr_lib.mpfr_fms(rop, op1, op2, op3, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is -2110.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == -2110.0);
            
            // Release unmanaged memory allocated for rop, op1, op2, and op3.
            mpfr_lib.mpfr_clears(rop, op1, op2, op3, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to -210.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new floating-point number op2 to 10.
            Dim op2 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op2, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new floating-point number op3 to 10.
            Dim op3 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op3, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op3, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = (op1 * op2) - op3.
            Assert.IsTrue(mpfr_lib.mpfr_fms(rop, op1, op2, op3, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is -2110.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = -2110.0)
            
            ' Release unmanaged memory allocated for rop, op1, op2, and op3.
            mpfr_lib.mpfr_clears(rop, op1, op2, op3, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to (<paramref name="op1"/> * <paramref name="op2"/>) + (<paramref name="op3"/> * <paramref name="op4"/>) rounded in the direction <paramref name="rnd"/>. 
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="op3">The third operand floating-point number.</param>
            <param name="op4">The fourth operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            In case the computation of <paramref name="op1"/> × <paramref name="op2"/> overflows or underflows
            (or that of <paramref name="op3"/> × <paramref name="op4"/>), the result <paramref name="rop"/> is
            computed as if the two intermediate products were computed with rounding toward zero. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fac_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fac_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_eint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_eint</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_li2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_li2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_gamma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma_inc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_gamma_inc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lngamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_lngamma</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_digamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_digamma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_beta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_beta</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_zeta</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_zeta_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erf(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erfc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erfc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_j0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_j0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_j1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_j1</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_jn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_jn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_y0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_y0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_y1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_y1</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_yn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_yn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fms</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmms</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_agm(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_agm</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_hypot(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_hypot</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ai(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ai</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to -210.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new floating-point number op2 to 10.
            mpfr_t op2 = new mpfr_t();
            mpfr_lib.mpfr_init2(op2, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new floating-point number op3 to 10.
            mpfr_t op3 = new mpfr_t();
            mpfr_lib.mpfr_init2(op3, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op3, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new floating-point number op4 to 10.
            mpfr_t op4 = new mpfr_t();
            mpfr_lib.mpfr_init2(op4, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op4, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = (op1 * op2) + (op3 * op4).
            Assert.IsTrue(mpfr_lib.mpfr_fmma(rop, op1, op2, op3, op4, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is -2090.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == -2000.0);
            
            // Release unmanaged memory allocated for rop, op1, op2, and op3.
            mpfr_lib.mpfr_clears(rop, op1, op2, op3, op4, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to -210.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new floating-point number op2 to 10.
            Dim op2 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op2, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new floating-point number op3 to 10.
            Dim op3 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op3, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op3, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new floating-point number op4 to 10.
            Dim op4 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op4, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op4, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = (op1 * op2) + (op3 * op4).
            Assert.IsTrue(mpfr_lib.mpfr_fmma(rop, op1, op2, op3, op4, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is -2090.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = -2000.0)
            
            ' Release unmanaged memory allocated for rop, op1, op2, op3, and op4.
            mpfr_lib.mpfr_clears(rop, op1, op2, op3, op4, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to (<paramref name="op1"/> * <paramref name="op2"/>) - (<paramref name="op3"/> * <paramref name="op4"/>) rounded in the direction <paramref name="rnd"/>. 
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="op1">The first operand floating-point number.</param>
            <param name="op2">The second operand floating-point number.</param>
            <param name="op3">The third operand floating-point number.</param>
            <param name="op4">The fourth operand floating-point number.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            In case the computation of <paramref name="op1"/> × <paramref name="op2"/> overflows or underflows
            (or that of <paramref name="op3"/> × <paramref name="op4"/>), the result <paramref name="rop"/> is
            computed as if the two intermediate products were computed with rounding toward zero. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fac_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fac_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_eint(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_eint</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_li2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_li2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_gamma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_gamma_inc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_gamma_inc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_lngamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_lngamma</seealso>
            <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma"/>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_digamma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_digamma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_beta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_beta</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_zeta</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_zeta_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_zeta_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erf(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_erfc(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_erfc</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_j0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_j0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_j1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_j1</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_jn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_jn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_y0(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_y0</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_y1(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_y1</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_yn(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_yn</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fms(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fms</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_fmma(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_fmma</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_agm(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_agm</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_hypot(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_hypot</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_ai(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_ai</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to -210.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new floating-point number op2 to 10.
            mpfr_t op2 = new mpfr_t();
            mpfr_lib.mpfr_init2(op2, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new floating-point number op3 to 10.
            mpfr_t op3 = new mpfr_t();
            mpfr_lib.mpfr_init2(op3, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op3, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new floating-point number op4 to 10.
            mpfr_t op4 = new mpfr_t();
            mpfr_lib.mpfr_init2(op4, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op4, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = (op1 * op2) - (op3 * op4).
            Assert.IsTrue(mpfr_lib.mpfr_fmms(rop, op1, op2, op3, op4, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is -2200.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == -2200.0);
            
            // Release unmanaged memory allocated for rop, op1, op2, and op3.
            mpfr_lib.mpfr_clears(rop, op1, op2, op3, op4, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to -210.
            Dim op1 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new floating-point number op2 to 10.
            Dim op2 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op2, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new floating-point number op3 to 10.
            Dim op3 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op3, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op3, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new floating-point number op4 to 10.
            Dim op4 As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(op4, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op4, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = (op1 * op2) - (op3 * op4).
            Assert.IsTrue(mpfr_lib.mpfr_fmms(rop, op1, op2, op3, op4, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is -2200.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = -2200.0)
            
            ' Release unmanaged memory allocated for rop, op1, op2, op3, and op4.
            mpfr_lib.mpfr_clears(rop, op1, op2, op3, op4, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_sum(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t[],System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Set <paramref name="rop"/> to the sum of all elements of <paramref name="tab"/>, whose size is <paramref name="n"/>, correctly rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="tab">Array of floating-point numbers.</param>
            <param name="n">The number of floating-point numbers in <paramref name="tab"/>.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>The returned int value is zero, <paramref name="rop"/> is guaranteed to be the exact sum; otherwise <paramref name="rop"/> might be smaller than, equal to, or larger than the exact sum.</returns>
            <remarks>
            <para>
            Warning: for efficiency reasons, <paramref name="tab"/> is an array of pointers to <see cref="T:Math.Mpfr.Native.mpfr_t"/>,
            not an array of <see cref="T:Math.Mpfr.Native.mpfr_t"/>.
            If <paramref name="n"/> = 0, then the result is +0, and if <paramref name="n"/> = 1, then the function
            is equivalent to <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)"/>.
            For the special exact cases, the result is the same as the one obtained with a succession of additions
            (<see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)"/>) in infinite precision. In particular, if the result is an exact zero and
            <paramref name="n"/> &#8804; 1:
            </para>
            <list type="bullet">
            <item>
            <description>
            if all the inputs have the same sign (i.e., all +0 or all −0), then the result has the same sign as the inputs;
            </description>
            </item>
            <item>
            <description>
            otherwise, either because all inputs are zeros with at least a +0 and a −0, or because some inputs are non-zero
            (but they globally cancel), the result is +0, except for the <see cref="F:Math.Mpfr.Native.mpfr_rnd_t.MPFR_RNDD"/> rounding mode,
            where it is −0.
            </description>
            </item>
            </list>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add_ui(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add_si(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add_d(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add_z(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_add_q(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_add_q</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number op1 to 10.
            mpfr_t op1 = new mpfr_t();
            mpfr_lib.mpfr_init2(op1, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new floating-point number op2 to 20.
            mpfr_t op2 = new mpfr_t();
            mpfr_lib.mpfr_init2(op2, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 20, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create, initialize, and set a new floating-point number op3 to 30.
            mpfr_t op3 = new mpfr_t();
            mpfr_lib.mpfr_init2(op3, 64U);
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op3, 30, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Set rop = Sum({op1, op2, op3}).
            Assert.IsTrue(mpfr_lib.mpfr_sum(rop, new mpfr_t[] { op1, op2, op3 }, 3, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is 60.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 60.0);
            
            // Release unmanaged memory allocated for rop, op1, and op2.
            mpfr_lib.mpfr_clears(rop, op1, op2, op3, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number op1 to 10.
             mpfr_t op1 = New mpfr_t()
            mpfr_lib.mpfr_init2(op1, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new floating-point number op2 to 20.
            mpfr_t op2 = New mpfr_t()
            mpfr_lib.mpfr_init2(op2, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 20, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create, initialize, and set a new floating-point number op3 to 30.
            mpfr_t op3 = New mpfr_t()
            mpfr_lib.mpfr_init2(op3, 64U)
            Assert.IsTrue(mpfr_lib.mpfr_set_si(op3, 30, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Create and initialize a new floating-point number rop.
            mpfr_t rop = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Set rop = Sum({op1, op2, op3}).
            Assert.IsTrue(mpfr_lib.mpfr_sum(rop, New mpfr_t() { op1, op2, op3 }, 3, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is 60.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 60.0)
            
            ' Release unmanaged memory allocated for rop, op1, and op2.
            mpfr_lib.mpfr_clears(rop, op1, op2, op3, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_cache">
            <summary>
            Free all caches and pools used by MPFR internally.
            </summary>
            <remarks>
            <para>
            Free all caches and pools used by MPFR internally (thoses local to the current thread and those shared by all threads).
            You should call this function before terminating a thread, even if you did not call mpfr_const_* functions directly
            (they could have been called internally).
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_const_log2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_const_log2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_const_pi(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_const_pi</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_const_euler(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_const_euler</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_const_catalan(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_const_catalan</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize a new floating-point number z.
            mpfr_t z = new mpfr_t();
            mpfr_lib.mpfr_init2(z, 64U);
            
            // Assert that z is the Catalan's constant.
            Assert.IsTrue(mpfr_lib.mpfr_const_log2(z, mpfr_rnd_t.MPFR_RNDN) == 1);
            Assert.IsTrue(z.ToString() == "0.693147180559945309429e0");
            
            // Release unmanaged memory allocated for x and z.
            mpfr_lib.mpfr_clear(z);
            
            // Frere constants cache.
            mpfr_lib.mpfr_free_cache();
            </code> 
            <code language="VB.NET">
            ' Create and initialize a new floating-point number z.
            Dim z As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(z, 64U)
            
            ' Assert that z is the Catalan's constant.
            Assert.IsTrue(mpfr_lib.mpfr_const_log2(z, mpfr_rnd_t.MPFR_RNDN) = 1)
            Assert.IsTrue(z.ToString() = "0.693147180559945309429e0")
            
            ' Release unmanaged memory allocated for x and z.
            mpfr_lib.mpfr_clear(z)
            
            ' Frere constants cache.
            mpfr_lib.mpfr_free_cache()
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_cache2(Math.Mpfr.Native.mpfr_free_cache_t)">
            <summary>
            Free various caches and pools used by MPFR internally, as specified by <paramref name="way"/>, which is a set of flags
            </summary>
            <param name="way">Flags specifying what to free,.</param>
            <remarks>
            <para>
            Free those local to the current thread if flag <see cref="F:Math.Mpfr.Native.mpfr_free_cache_t.MPFR_FREE_LOCAL_CACHE"/> is set.
            Free those shared by all threads if flag <see cref="F:Math.Mpfr.Native.mpfr_free_cache_t.MPFR_FREE_GLOBAL_CACHE"/> is set.
            </para>
            <para>
            The other bits of <paramref name="way"/> are currently ignored and are reserved for future use; they should be zero.
            </para>
            <para>
            Note: <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_cache2(Math.Mpfr.Native.mpfr_free_cache_t)"/>(<see cref="F:Math.Mpfr.Native.mpfr_free_cache_t.MPFR_FREE_LOCAL_CACHE"/> | <see cref="F:Math.Mpfr.Native.mpfr_free_cache_t.MPFR_FREE_GLOBAL_CACHE"/>) is currently
            equivalent to <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_cache"/>().
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_const_log2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_const_log2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_const_pi(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_const_pi</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_const_euler(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_const_euler</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_const_catalan(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_const_catalan</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_cache">mpfr_free_cache</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_pool">mpfr_free_pool</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mp_memory_cleanup">mpfr_mp_memory_cleanup</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize a new floating-point number z.
            mpfr_t z = new mpfr_t();
            mpfr_lib.mpfr_init2(z, 64U);
            
            // Assert that z is the Catalan's constant.
            Assert.IsTrue(mpfr_lib.mpfr_const_log2(z, mpfr_rnd_t.MPFR_RNDN) == 1);
            Assert.IsTrue(z.ToString() == "0.693147180559945309429e0");
            
            // Release unmanaged memory allocated for x and z.
            mpfr_lib.mpfr_clear(z);
            
            // Free constants cache.
            mpfr_lib.mpfr_free_cache2(mpfr_free_cache_t.MPFR_FREE_GLOBAL_CACHE | mpfr_free_cache_t.MPFR_FREE_LOCAL_CACHE);
            </code> 
            <code language="VB.NET">
            ' Create and initialize a new floating-point number z.
            Dim z As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(z, 64U)
            
            ' Assert that z is the Catalan's constant.
            Assert.IsTrue(mpfr_lib.mpfr_const_log2(z, mpfr_rnd_t.MPFR_RNDN) = 1)
            Assert.IsTrue(z.ToString() = "0.693147180559945309429e0")
            
            ' Release unmanaged memory allocated for x and z.
            mpfr_lib.mpfr_clear(z)
            
            ' Free constants cache.
            mpfr_lib.mpfr_free_cache2(mpfr_free_cache_t.MPFR_FREE_GLOBAL_CACHE Or mpfr_free_cache_t.MPFR_FREE_LOCAL_CACHE)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_pool">
            <summary>
            Free the pools used by MPFR internally.
            </summary>
            <remarks>
            <para>
            Note: This function is automatically called after the thread-local caches are freed (with <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_cache"/> or <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_cache2(Math.Mpfr.Native.mpfr_free_cache_t)"/>).
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_const_log2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_const_log2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_const_pi(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_const_pi</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_const_euler(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_const_euler</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_const_catalan(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_const_catalan</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_cache">mpfr_free_cache2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_cache2(Math.Mpfr.Native.mpfr_free_cache_t)">mpfr_free_cache2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_mp_memory_cleanup">mpfr_mp_memory_cleanup</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize a new floating-point number z.
            mpfr_t z = new mpfr_t();
            mpfr_lib.mpfr_init2(z, 64U);
            
            // Assert that z is the Catalan's constant.
            Assert.IsTrue(mpfr_lib.mpfr_const_log2(z, mpfr_rnd_t.MPFR_RNDN) == 1);
            Assert.IsTrue(z.ToString() == "0.693147180559945309429e0");
            
            // Release unmanaged memory allocated for x and z.
            mpfr_lib.mpfr_clear(z);
            
            // Free internal pools.
            mpfr_lib.mpfr_free_pool();
            </code> 
            <code language="VB.NET">
            ' Create and initialize a new floating-point number z.
            Dim z As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(z, 64U)
            
            ' Assert that z is the Catalan's constant.
            Assert.IsTrue(mpfr_lib.mpfr_const_log2(z, mpfr_rnd_t.MPFR_RNDN) = 1)
            Assert.IsTrue(z.ToString() = "0.693147180559945309429e0")
            
            ' Release unmanaged memory allocated for x and z.
            mpfr_lib.mpfr_clear(z)
            
            ' Free internal pools.
            mpfr_lib.mpfr_free_pool()
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_mp_memory_cleanup">
            <summary>
            This function should be called before calling <see cref="M:Math.Gmp.Native.gmp_lib.mp_set_memory_functions(Math.Gmp.Native.allocate_function,Math.Gmp.Native.reallocate_function,Math.Gmp.Native.free_function)"/>.
            </summary>
            <returns>Zero is returned in case of success, non-zero in case of error.</returns>
            <remarks>
            <para>
            See Section 4.7 <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Memory-Handling">GNU MPFR - Memory Handling</a>, page 10, for more information.
            Zero is returned in case of success, nonzero in case of error.
            Errors are currently not possible, but checking the return value is recommended for future compatibility.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_const_log2(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_const_log2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_const_pi(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_const_pi</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_const_euler(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_const_euler</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_const_catalan(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_const_catalan</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_cache">mpfr_free_cache</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_cache2(Math.Mpfr.Native.mpfr_free_cache_t)">mpfr_free_cache2</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_free_pool">mpfr_free_pool</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize a new floating-point number z.
            mpfr_t z = new mpfr_t();
            mpfr_lib.mpfr_init2(z, 64U);
            
            // Assert that z is the Catalan's constant.
            Assert.IsTrue(mpfr_lib.mpfr_const_log2(z, mpfr_rnd_t.MPFR_RNDN) == 1);
            Assert.IsTrue(z.ToString() == "0.693147180559945309429e0");
            
            // Release unmanaged memory allocated for x and z.
            mpfr_lib.mpfr_clear(z);
            
            // Free internal pools.
            mpfr_lib.mpfr_free_pool();
            </code> 
            <code language="VB.NET">
            ' Create and initialize a new floating-point number z.
            Dim z As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(z, 64U)
            
            ' Assert that z is the Catalan's constant.
            Assert.IsTrue(mpfr_lib.mpfr_const_log2(z, mpfr_rnd_t.MPFR_RNDN) = 1)
            Assert.IsTrue(z.ToString() = "0.693147180559945309429e0")
            
            ' Release unmanaged memory allocated for x and z.
            mpfr_lib.mpfr_clear(z)
            
            ' Free internal pools.
            mpfr_lib.mpfr_free_pool()
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_subnormalize(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            This function rounds <paramref name="x"/> emulating subnormal number arithmetic.
            </summary>
            <param name="x">The operand floating-point number.</param>
            <param name="t">The input <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">ternary value</a>.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>The usual <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">ternary value</a> is returned.</returns>
            <remarks>
            <para>
            If <paramref name="x"/> is outside the subnormal exponent range of the emulated floating-point system, this function just propagates
            the ternary value <paramref name="t"/>; otherwise, it rounds <paramref name="x"/> to precision EXP(<paramref name="x"/>) - emin + 1
            according to rounding mode <paramref name="rnd"/> and previous ternary value <paramref name="t"/>, avoiding double rounding problems.
            More precisely in the subnormal domain, denoting by e the value of emin, <paramref name="x"/> is rounded in fixedpoint arithmetic to an
            integer multiple of two to the power e - 1; as a consequence, 1.5 multiplied by two to the power e - 1 when <paramref name="t"/> is zero
            is rounded to two to the power e with rounding to nearest.
            </para>
            <para>
            PREC(<paramref name="x"/>) is not modified by this function.
            <paramref name="rnd"/> and <paramref name="t"/> must be the rounding mode and the returned
            <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">ternary value</a> used when computing <paramref name="x"/>
            (as in <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_check_range(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_check_range</see>).
            The subnormal exponent range is from emin to emin + PREC(<paramref name="x"/>) - 1.
            If the result cannot be represented in the current exponent range of MPFR (due to a too small emax),
            the behavior is undefined.
            Note that unlike most functions, the result is compared to the exact one, not the input value <paramref name="x"/>,
            i.e., the <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">ternary value</a> is propagated. 
            </para>
            <para>
            As usual, if the returned <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">ternary value</a> is non zero,
            the inexact flag is set.
            Moreover, if a second rounding occurred (because the input <paramref name="x"/> was in the subnormal range), the underflow flag is set. 
            </para>
            <para>
            Warning! If you change emin (with <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_emin(Math.Mpfr.Native.mpfr_exp_t)"/>) just before calling <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_subnormalize(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)"/>, you need to make
            sure that the value is in the current exponent range of MPFR.
            But it is better to change emin before any computation, if possible.
            </para>
            <para>
            This is an example of how to emulate binary double IEEE 754 arithmetic (binary64 in IEEE 754-2008) using MPFR:
            </para>
            <code language="C#">
            mpfr_t xa, xb; int i; volatile double a, b;
            mpfr_set_default_prec(53);
            mpfr_set_emin(-1073);
            mpfr_set_emax(1024);
            
            mpfr_init(xa); mpfr_init(xb);
            
            b = 34.3; mpfr_set_d(xb, b, MPFR_RNDN);
            a = 0x1.1235P-1021;
            mpfr_set_d(xa, a, MPFR_RNDN);
            
            a /= b;
            i = mpfr_div(xa, xa, xb, MPFR_RNDN);
            i = mpfr_subnormalize(xa, i, MPFR_RNDN); /* new ternary value */
            
            mpfr_clear(xa);
            mpfr_clear(xb);
            </code> 
            <para>
            Note that <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_emin(Math.Mpfr.Native.mpfr_exp_t)"/> and <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_emax(Math.Mpfr.Native.mpfr_exp_t)"/> are called early enough in order to make sure that all
            computed values are in the current exponent range.
            Warning! This emulates a double IEEE 754 arithmetic with correct rounding in the subnormal range, which may not be the case
            for your hardware.
            </para>
            <para>
            Below is another example showing how to emulate fixed-point arithmetic in a specific case.
            Here we compute the sine of the integers 1 to 17 with a result in a fixed-point arithmetic rounded at 2−42 
            (using the fact that the result is at most 1 in absolute value):
            </para>
            <code language="C#">
            mpfr_t x; int i, inex;
            mpfr_set_emin(-41); 
            mpfr_init2(x, 42);
            for (i = 1; i &#8804; 17; i++)
            { 
                mpfr_set_ui(x, i, MPFR_RNDN);
                inex = mpfr_sin(x, x, MPFR_RNDZ);
                mpfr_subnormalize(x, inex, MPFR_RNDZ);
                mpfr_dump(x);
            }
            mpfr_clear(x);
            </code> 
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emin">mpfr_get_emin</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emax">mpfr_get_emax</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_emin(Math.Mpfr.Native.mpfr_exp_t)">mpfr_set_emin</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_emax(Math.Mpfr.Native.mpfr_exp_t)">mpfr_set_emax</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emin_min">mpfr_get_emin_min</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emin_max">mpfr_get_emin_max</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emax_min">mpfr_get_emax_min</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_get_emax_max">mpfr_get_emax_max</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_check_range(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_check_range</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
            <example>
            <code language="C#">
            // Emulate IEEE 754 double precision.
            mpfr_lib.mpfr_set_default_prec(53U);
            mpfr_lib.mpfr_set_emin(-1073);
            mpfr_lib.mpfr_set_emax(1023);
            
            // Create and initialize near-subnormal floating-point number x.
            mpfr_t x = "0x1.1235P-1021";
            
            // Create subnormal by dividing by 34.3, and round it emulating subnormal.
            int i = mpfr_lib.mpfr_div_d(x, x, 34.3, mpfr_rnd_t.MPFR_RNDN);
            i = mpfr_lib.mpfr_subnormalize(x, i, mpfr_rnd_t.MPFR_RNDN);
            
            // Release unmanaged memory allocated for x.
            mpfr_lib.mpfr_clear(x);
            </code> 
            <code language="VB.NET">
            ' Emulate IEEE 754 double precision.
            mpfr_lib.mpfr_set_default_prec(53U)
            mpfr_lib.mpfr_set_emin(-1073)
            mpfr_lib.mpfr_set_emax(1023)
            
            ' Create and initialize near-subnormal floating-point number x.
            Dim x As mpfr_t = "0x1.1235P-1021" 
            
            ' Create subnormal by dividing by 34.3, and round it emulating subnormal.
            Dim i As Integer = mpfr_lib.mpfr_div_d(x, x, 34.3, mpfr_rnd_t.MPFR_RNDN)
            i = mpfr_lib.mpfr_subnormalize(x, i, mpfr_rnd_t.MPFR_RNDN)
            
            ' Release unmanaged memory allocated for x.
            mpfr_lib.mpfr_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.char_ptr,Math.Gmp.Native.char_ptr@,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Read a floating-point number from a string <paramref name="nptr"/> in base <paramref name="base"/>, rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="nptr">String containing a floating-point number.</param>
            <param name="endptr">On return, points the first character after floating-point number in <paramref name="nptr"/>.</param>
            <param name="base">The base.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            The <paramref name="base"/> must be either 0 (to detect the base, as described below) or a number from 2 to 62 (otherwise the behavior is undefined).
            If <paramref name="nptr"/> starts with valid data, the result is stored in <paramref name="rop"/> and <paramref name="endptr"/> points to the character
            just after the valid data (if <paramref name="endptr"/> is not a null pointer); otherwise <paramref name="rop"/> is set to zero (for consistency with
            <a href="http://en.cppreference.com/w/c/string/byte/strtof">strtod</a>) and the value of <paramref name="nptr"/> is stored in the location referenced
            by <paramref name="endptr"/> (if <paramref name="endptr"/> is not a null pointer).
            The usual <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">ternary value</a> is returned. 
            </para>
            <para>
            Parsing follows the standard C <a href="http://en.cppreference.com/w/c/string/byte/strtof">strtod</a> function with some extensions.
            After optional leading whitespace, one has a subject sequence consisting of an optional sign (+ or -), and either numeric data or special data.
            The subject sequence is defined as the longest initial subsequence of the input string, starting with the first non-whitespace character, that is of the expected form. 
            </para>
            <para>
            The form of numeric data is a non-empty sequence of significand digits with an optional decimal point, and an optional exponent consisting
            of an exponent prefix followed by an optional sign and a non-empty sequence of decimal digits.
            A significand digit is either a decimal digit or a Latin letter (62 possible characters), with A = 10, B = 11, …, Z = 35; case is ignored in
            bases less or equal to 36, in bases larger than 36, a = 36, b = 37, …, z = 61.
            The value of a significand digit must be strictly less than the base.
            The decimal point can be either the one defined by the current locale or the period (the first one is accepted for consistency with the
            C standard and the practice, the second one is accepted to allow the programmer to provide MPFR numbers from strings in a way that does
            not depend on the current locale).
            The exponent prefix can be e or E for bases up to 10, or @ in any base; it indicates a multiplication by a power of the base.
            In bases 2 and 16, the exponent prefix can also be p or P, in which case the exponent, called binary exponent, indicates a multiplication
            by a power of 2 instead of the base (there is a difference only for base 16); in base 16 for example 1p2 represents 4 whereas 1@2 represents 256.
            The value of an exponent is always written in base 10. 
            </para>
            <para>
            If the argument base is 0, then the base is automatically detected as follows.
            If the significand starts with 0b or 0B, base 2 is assumed.
            If the significand starts with 0x or 0X, base 16 is assumed.
            Otherwise base 10 is assumed. 
            </para>
            <para>
            Note: The exponent (if present) must contain at least a digit.
            Otherwise the possible exponent prefix and sign are not part of the number (which ends with the significand).
            Similarly, if 0b, 0B, 0x or 0X is not followed by a binary/hexadecimal digit, then the subject sequence stops at the character 0, thus 0 is read.
            </para>
            <para>
            Special data (for infinities and NaN) can be @inf@ or @nan@(n-char-sequence-opt), and if base &#8804; 16, it can also be infinity, inf,
            nan or nan(n-char-sequence-opt), all case insensitive.
            A n-char-sequence-opt is a possibly empty string containing only digits, Latin letters and the underscore (0, 1, 2, …, 9, a, b, …, z, A, B, …, Z, _).
            Note: one has an optional sign for all data, even NaN. 
            For example, -@nAn@(This_Is_Not_17) is a valid representation for NaN in base 17. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_si(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_uj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_uj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_sj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_sj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_flt(Math.Mpfr.Native.mpfr_t,System.Single,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_flt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_d(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_f</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_ui_2exp(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_ui_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_si_2exp(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_si_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_uj_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_uj_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_sj_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_sj_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_z_2exp(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_z_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_nan(Math.Mpfr.Native.mpfr_t)">mpfr_set_nan</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_inf(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_set_inf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_zero(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_set_zero</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_swap(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_swap</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Assignment_Functions">Assignment Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Assignment-Functions">GNU MPFR - Assignment Functions</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Parse first float in string.
            char_ptr nptr = new char_ptr("10.0  20.0");
            char_ptr endptr = new char_ptr();
            Assert.IsTrue(mpfr_lib.mpfr_strtofr(rop, nptr, ref endptr, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is 10.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 10.0);
            Assert.IsTrue(endptr.ToString() == "  20.0");
            
            // Release unmanaged memory allocated for rop.
            mpfr_lib.mpfr_clear(rop);
            gmp_lib.free(nptr);
            </code> 
            <code language="VB.NET">
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Parse first float in string.
            Dim nptr As char_ptr = New char_ptr("10.0  20.0")
            Dim endptr As char_ptr = New char_ptr()
            Assert.IsTrue(mpfr_lib.mpfr_strtofr(rop,nptr,ref endptr,10,mpfr_rnd_t.MPFR_RNDN)  =  0)
            
            ' Assert that the value of rop is 10.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 10.0)
            Assert.IsTrue(endptr.ToString() = "  20.0")
            
            ' Release unmanaged memory allocated for rop.
            mpfr_lib.mpfr_clear(rop)
            gmp_lib.free(nptr)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.char_ptr,Math.Gmp.Native.ptr{Math.Gmp.Native.char_ptr},System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">
            <summary>
            Read a floating-point number from a string <paramref name="nptr"/> in base <paramref name="base"/>, rounded in the direction <paramref name="rnd"/>.
            </summary>
            <param name="rop">The result floating-point number.</param>
            <param name="nptr">String containing a floating-point number.</param>
            <param name="endptr">On return, points the first character after floating-point number in <paramref name="nptr"/>.</param>
            <param name="base">The base.</param>
            <param name="rnd">The rounding direction.</param>
            <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
            <remarks>
            <para>
            The <paramref name="base"/> must be either 0 (to detect the base, as described below) or a number from 2 to 62 (otherwise the behavior is undefined).
            If <paramref name="nptr"/> starts with valid data, the result is stored in <paramref name="rop"/> and <paramref name="endptr"/> points to the character
            just after the valid data (if <paramref name="endptr"/> is not a null pointer); otherwise <paramref name="rop"/> is set to zero (for consistency with
            <a href="http://en.cppreference.com/w/c/string/byte/strtof">strtod</a>) and the value of <paramref name="nptr"/> is stored in the location referenced
            by <paramref name="endptr"/> (if <paramref name="endptr"/> is not a null pointer).
            The usual <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">ternary value</a> is returned. 
            </para>
            <para>
            Parsing follows the standard C <a href="http://en.cppreference.com/w/c/string/byte/strtof">strtod</a> function with some extensions.
            After optional leading whitespace, one has a subject sequence consisting of an optional sign (+ or -), and either numeric data or special data.
            The subject sequence is defined as the longest initial subsequence of the input string, starting with the first non-whitespace character, that is of the expected form. 
            </para>
            <para>
            The form of numeric data is a non-empty sequence of significand digits with an optional decimal point, and an optional exponent consisting
            of an exponent prefix followed by an optional sign and a non-empty sequence of decimal digits.
            A significand digit is either a decimal digit or a Latin letter (62 possible characters), with A = 10, B = 11, …, Z = 35; case is ignored in
            bases less or equal to 36, in bases larger than 36, a = 36, b = 37, …, z = 61.
            The value of a significand digit must be strictly less than the base.
            The decimal point can be either the one defined by the current locale or the period (the first one is accepted for consistency with the
            C standard and the practice, the second one is accepted to allow the programmer to provide MPFR numbers from strings in a way that does
            not depend on the current locale).
            The exponent prefix can be e or E for bases up to 10, or @ in any base; it indicates a multiplication by a power of the base.
            In bases 2 and 16, the exponent prefix can also be p or P, in which case the exponent, called binary exponent, indicates a multiplication
            by a power of 2 instead of the base (there is a difference only for base 16); in base 16 for example 1p2 represents 4 whereas 1@2 represents 256.
            The value of an exponent is always written in base 10. 
            </para>
            <para>
            If the argument base is 0, then the base is automatically detected as follows.
            If the significand starts with 0b or 0B, base 2 is assumed.
            If the significand starts with 0x or 0X, base 16 is assumed.
            Otherwise base 10 is assumed. 
            </para>
            <para>
            Note: The exponent (if present) must contain at least a digit.
            Otherwise the possible exponent prefix and sign are not part of the number (which ends with the significand).
            Similarly, if 0b, 0B, 0x or 0X is not followed by a binary/hexadecimal digit, then the subject sequence stops at the character 0, thus 0 is read.
            </para>
            <para>
            Special data (for infinities and NaN) can be @inf@ or @nan@(n-char-sequence-opt), and if base &#8804; 16, it can also be infinity, inf,
            nan or nan(n-char-sequence-opt), all case insensitive.
            A n-char-sequence-opt is a possibly empty string containing only digits, Latin letters and the underscore (0, 1, 2, …, 9, a, b, …, z, A, B, …, Z, _).
            Note: one has an optional sign for all data, even NaN. 
            For example, -@nAn@(This_Is_Not_17) is a valid representation for NaN in base 17. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_ui(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_ui</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_si(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_si</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_uj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_uj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_sj(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_sj</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_flt(Math.Mpfr.Native.mpfr_t,System.Single,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_flt</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_d(Math.Mpfr.Native.mpfr_t,System.Double,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_d</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_z(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_z</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_q(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpq_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_q</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_f(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpf_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_f</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_ui_2exp(Math.Mpfr.Native.mpfr_t,System.UInt32,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_ui_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_si_2exp(Math.Mpfr.Native.mpfr_t,System.Int32,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_si_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_uj_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.uintmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_uj_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_sj_2exp(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.intmax_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_sj_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_z_2exp(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.mpz_t,Math.Mpfr.Native.mpfr_exp_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_set_z_2exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_nan(Math.Mpfr.Native.mpfr_t)">mpfr_set_nan</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_inf(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_set_inf</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_zero(Math.Mpfr.Native.mpfr_t,System.Int32)">mpfr_set_zero</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_swap(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_t)">mpfr_swap</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Assignment_Functions">Assignment Functions</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Assignment-Functions">GNU MPFR - Assignment Functions</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize a new floating-point number rop.
            mpfr_t rop = new mpfr_t();
            mpfr_lib.mpfr_init2(rop, 64U);
            
            // Parse first float in string.
            char_ptr nptr = new char_ptr("10.0  20.0");
            ptr&lt;char_ptr&gt; endptr = new ptr&lt;char_ptr&gt;();
            Assert.IsTrue(mpfr_lib.mpfr_strtofr(rop, nptr, endptr, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the value of rop is 10.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 10.0);
            Assert.IsTrue(endptr.Value.ToString() == "  20.0");
            
            // Release unmanaged memory allocated for rop.
            mpfr_lib.mpfr_clear(rop);
            gmp_lib.free(nptr);
            </code> 
            <code language="VB.NET">
            ' Create and initialize a new floating-point number rop.
            Dim rop As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_init2(rop, 64U)
            
            ' Parse first float in string.
            Dim nptr As char_ptr = New char_ptr("10.0  20.0")
            Dim endptr As ptr(Of char_ptr) =  New ptr(Of char_ptr)()
            Assert.IsTrue(mpfr_lib.mpfr_strtofr(rop, nptr, endptr, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the value of rop is 10.
            Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 10.0)
            Assert.IsTrue(endptr.Value.ToString() = "  20.0")
            
            ' Release unmanaged memory allocated for rop.
            mpfr_lib.mpfr_clear(rop)
            gmp_lib.free(nptr)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_clear(Math.Mpfr.Native.mpfr_t)">
            <summary>
            Free the space occupied by <paramref name="x"/>.
            </summary>
            <param name="x">The operand floating-point number.</param>
            <remarks>
            <para>
            The behavior of this function for any <see cref="T:Math.Mpfr.Native.mpfr_t">mpfr_t</see> not initialized with <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_init_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_kind_t,Math.Mpfr.Native.mpfr_exp_t,System.UInt32,Math.Gmp.Native.void_ptr)">mpfr_custom_init_set</see> is undefined. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_get_size(System.UInt32)">mpfr_custom_get_size</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_init(Math.Gmp.Native.void_ptr,System.UInt32)">mpfr_custom_init</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_init_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_kind_t,Math.Mpfr.Native.mpfr_exp_t,System.UInt32,Math.Gmp.Native.void_ptr)">mpfr_custom_init_set</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_get_kind(Math.Mpfr.Native.mpfr_t)">mpfr_custom_get_kind</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_get_significand(Math.Mpfr.Native.mpfr_t)">mpfr_custom_get_significand</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_get_exp(Math.Mpfr.Native.mpfr_t)">mpfr_custom_get_exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_move(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.void_ptr)">mpfr_custom_move</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Custom_Interface">Custom Interface</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Custom-Interface">GNU MPFR - Custom Interface</a></seealso>
            <example>
            <code language="C#">
            </code> 
            <code language="VB.NET">
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_get_size(System.UInt32)">
            <summary>
            Return the needed size in bytes to store the significand of a floating-point number of precision <paramref name="prec"/>. 
            </summary>
            <param name="prec">The precision in bits.</param>
            <returns>Return the needed size in bytes to store the significand of a floating-point number of precision <paramref name="prec"/>.</returns>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_get_size(System.UInt32)">mpfr_custom_get_size</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_init(Math.Gmp.Native.void_ptr,System.UInt32)">mpfr_custom_init</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_init_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_kind_t,Math.Mpfr.Native.mpfr_exp_t,System.UInt32,Math.Gmp.Native.void_ptr)">mpfr_custom_init_set</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_get_kind(Math.Mpfr.Native.mpfr_t)">mpfr_custom_get_kind</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_get_significand(Math.Mpfr.Native.mpfr_t)">mpfr_custom_get_significand</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_get_exp(Math.Mpfr.Native.mpfr_t)">mpfr_custom_get_exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_move(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.void_ptr)">mpfr_custom_move</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_clear(Math.Mpfr.Native.mpfr_t)">mpfr_custom_clear</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Custom_Interface">Custom Interface</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Custom-Interface">GNU MPFR - Custom Interface</a></seealso>
            <example>
            <code language="C#">
            // Initialize a custom, 64-bit significand floating-point number, and set it to 0.
            size_t size = mpfr_lib.mpfr_custom_get_size(64U);
            void_ptr significand = gmp_lib.allocate(size);
            gmp_lib.ZeroMemory(significand.ToIntPtr(), (int)size);
            mpfr_t x = new mpfr_t();
            mpfr_lib.mpfr_custom_init_set(x, mpfr_kind_t.MPFR_ZERO_KIND, 0, 64U, significand);
            
            // Set x = 16.
            Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 16, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert exponent of x.
            Assert.IsTrue(mpfr_lib.mpfr_custom_get_exp(x) == 5);
            
            // Assert significand of x.
            Byte[] result = new byte[] { 0, 0, 0, 0, 0, 0, 0, 0x80 };
            byte[] sp = new byte[8];
            Marshal.Copy(significand.ToIntPtr(), sp, 0, 8);
            Assert.IsTrue(sp.SequenceEqual(result));
            
            // Release unmanaged memory allocated for x and significand.
            mpfr_lib.mpfr_custom_clear(x);
            gmp_lib.free(significand);
            </code> 
            <code language="VB.NET">
            ' Initialize a custom, 64-bit significand floating-point number, and set it to 0.
            Dim size As size_t = mpfr_lib.mpfr_custom_get_size(64U)
            Dim significand As void_ptr = gmp_lib.allocate(size)
            gmp_lib.ZeroMemory(significand.ToIntPtr(), CType(size, Integer))
            Dim x As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_custom_init_set(x, mpfr_kind_t.MPFR_ZERO_KIND, 0, 64U, significand)
            
            ' Set x = 16.
            Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 16, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert exponent of x.
            Assert.IsTrue(mpfr_lib.mpfr_custom_get_exp(x) = 5)
            
            ' Assert significand of x.
            Dim result() As Byte = New Byte() { 0, 0, 0, 0, 0, 0, 0, 0x80}
            
            Dim sp() As Byte = New Byte(8) { }
            Marshal.Copy(significand.ToIntPtr(), sp, 0, 8)
            Assert.IsTrue(sp.SequenceEqual(result))
            
            ' Release unmanaged memory allocated for x and significand.
            mpfr_lib.mpfr_custom_clear(x)
            gmp_lib.free(significand)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_init(Math.Gmp.Native.void_ptr,System.UInt32)">
            <summary>
            Initialize a significand of precision <paramref name="prec"/>.
            </summary>
            <param name="significand">Pointer to significand.</param>
            <param name="prec">The precision in bits.</param>
            <remarks>
            <para>
            Initialize a significand of precision <paramref name="prec"/>, where significand must be an area of
            <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_get_size(System.UInt32)">mpfr_custom_get_size</see>(<paramref name="prec"/>) bytes at least and be suitably aligned
            for an array of mp_limb_t (GMP type, see <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Internals">GNU MPFR - Internals</a>). 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_get_size(System.UInt32)">mpfr_custom_get_size</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_init_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_kind_t,Math.Mpfr.Native.mpfr_exp_t,System.UInt32,Math.Gmp.Native.void_ptr)">mpfr_custom_init_set</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_get_kind(Math.Mpfr.Native.mpfr_t)">mpfr_custom_get_kind</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_get_significand(Math.Mpfr.Native.mpfr_t)">mpfr_custom_get_significand</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_get_exp(Math.Mpfr.Native.mpfr_t)">mpfr_custom_get_exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_move(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.void_ptr)">mpfr_custom_move</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_clear(Math.Mpfr.Native.mpfr_t)">mpfr_custom_clear</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Custom_Interface">Custom Interface</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Custom-Interface">GNU MPFR - Custom Interface</a></seealso>
            <example>
            <code language="C#">
            </code> 
            <code language="VB.NET">
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_get_significand(Math.Mpfr.Native.mpfr_t)">
            <summary>
            Return a pointer to the significand used by a <see cref="T:Math.Mpfr.Native.mpfr_t">mpfr_t</see> initialized with <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_init_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_kind_t,Math.Mpfr.Native.mpfr_exp_t,System.UInt32,Math.Gmp.Native.void_ptr)">mpfr_custom_init_set</see>.
            </summary>
            <param name="x">The operand floating-point number.</param>
            <returns>Return a pointer to the significand used by a <see cref="T:Math.Mpfr.Native.mpfr_t">mpfr_t</see> initialized with <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_init_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_kind_t,Math.Mpfr.Native.mpfr_exp_t,System.UInt32,Math.Gmp.Native.void_ptr)">mpfr_custom_init_set</see>.</returns>
            <remarks>
            <para>
            The behavior of this function for any <see cref="T:Math.Mpfr.Native.mpfr_t">mpfr_t</see> not initialized with <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_init_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_kind_t,Math.Mpfr.Native.mpfr_exp_t,System.UInt32,Math.Gmp.Native.void_ptr)">mpfr_custom_init_set</see> is undefined. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_get_size(System.UInt32)">mpfr_custom_get_size</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_init(Math.Gmp.Native.void_ptr,System.UInt32)">mpfr_custom_init</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_init_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_kind_t,Math.Mpfr.Native.mpfr_exp_t,System.UInt32,Math.Gmp.Native.void_ptr)">mpfr_custom_init_set</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_get_kind(Math.Mpfr.Native.mpfr_t)">mpfr_custom_get_kind</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_get_exp(Math.Mpfr.Native.mpfr_t)">mpfr_custom_get_exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_move(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.void_ptr)">mpfr_custom_move</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_clear(Math.Mpfr.Native.mpfr_t)">mpfr_custom_clear</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Custom_Interface">Custom Interface</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Custom-Interface">GNU MPFR - Custom Interface</a></seealso>
            <example>
            <code language="C#">
            // Initialize a custom, 64-bit significand floating-point number, and set it to 0.
            size_t size = mpfr_lib.mpfr_custom_get_size(64U);
            void_ptr significand = gmp_lib.allocate(size);
            gmp_lib.ZeroMemory(significand.ToIntPtr(), (int)size);
            mpfr_t x = new mpfr_t();
            mpfr_lib.mpfr_custom_init_set(x, mpfr_kind_t.MPFR_ZERO_KIND, 0, 64U, significand);
            
            // Set x = x + 1.
            Assert.IsTrue(mpfr_lib.mpfr_add_si(x, x, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert significand of x.
            Byte[] result = new byte[] { 0, 0, 0, 0, 0, 0, 0, 0x80 };
            byte[] sp = new byte[8];
            Marshal.Copy(significand.ToIntPtr(), sp, 0, 8);
            Assert.IsTrue(sp.SequenceEqual(result));
            
            // Release unmanaged memory allocated for x and significand.
            mpfr_lib.mpfr_custom_clear(x);
            gmp_lib.free(significand);
            </code> 
            <code language="VB.NET">
            ' Initialize a custom, 64-bit significand floating-point number, and set it to 0.
            Dim size As size_t = mpfr_lib.mpfr_custom_get_size(64U)
            Dim significand As void_ptr = gmp_lib.allocate(size)
            gmp_lib.ZeroMemory(significand.ToIntPtr(), CType(size, Integer))
            Dim x As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_custom_init_set(x, mpfr_kind_t.MPFR_ZERO_KIND, 0, 64U, significand)
            
            ' Set x = x + 1.
            Assert.IsTrue(mpfr_lib.mpfr_add_si(x, x, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert significand of x.
            Dim result() As Byte = New Byte() { 0, 0, 0, 0, 0, 0, 0, 0x80}
            
            Dim sp() As Byte = New Byte(8) { }
            Marshal.Copy(significand.ToIntPtr(), sp, 0, 8)
            Assert.IsTrue(sp.SequenceEqual(result))
            
            ' Release unmanaged memory allocated for x and significand.
            mpfr_lib.mpfr_custom_clear(x)
            gmp_lib.free(significand)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_get_exp(Math.Mpfr.Native.mpfr_t)">
            <summary>
            Return the exponent of <paramref name="x"/>.
            </summary>
            <param name="x">The operand floating-point number.</param>
            <returns>Return the exponent of <paramref name="x"/>.</returns>
            <remarks>
            <para>
            Return the exponent of <paramref name="x"/>, assuming that <paramref name="x"/> is a non-zero ordinary number.
            The return value for NaN, Infinity or zero is unspecified but does not produce any trap.
            The behavior of this function for any <see cref="T:Math.Mpfr.Native.mpfr_t">mpfr_t</see> not initialized with <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_init_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_kind_t,Math.Mpfr.Native.mpfr_exp_t,System.UInt32,Math.Gmp.Native.void_ptr)">mpfr_custom_init_set</see> is undefined. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_get_size(System.UInt32)">mpfr_custom_get_size</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_init(Math.Gmp.Native.void_ptr,System.UInt32)">mpfr_custom_init</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_init_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_kind_t,Math.Mpfr.Native.mpfr_exp_t,System.UInt32,Math.Gmp.Native.void_ptr)">mpfr_custom_init_set</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_get_kind(Math.Mpfr.Native.mpfr_t)">mpfr_custom_get_kind</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_get_significand(Math.Mpfr.Native.mpfr_t)">mpfr_custom_get_significand</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_move(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.void_ptr)">mpfr_custom_move</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_clear(Math.Mpfr.Native.mpfr_t)">mpfr_custom_clear</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Custom_Interface">Custom Interface</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Custom-Interface">GNU MPFR - Custom Interface</a></seealso>
            <example>
            <code language="C#">
            // Initialize a custom, 64-bit significand floating-point number, and set it to 0.
            size_t size = mpfr_lib.mpfr_custom_get_size(64U);
            void_ptr significand = gmp_lib.allocate(size);
            gmp_lib.ZeroMemory(significand.ToIntPtr(), (int)size);
            mpfr_t x = new mpfr_t();
            mpfr_lib.mpfr_custom_init_set(x, mpfr_kind_t.MPFR_ZERO_KIND, 0, 64U, significand);
            
            // Set x = x + 1.
            Assert.IsTrue(mpfr_lib.mpfr_add_si(x, x, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert that the exponent of x is 1.
            Assert.IsTrue(mpfr_lib.mpfr_custom_get_exp(x) == 1);
            
            // Release unmanaged memory allocated for x and significand.
            mpfr_lib.mpfr_custom_clear(x);
            gmp_lib.free(significand);
            </code> 
            <code language="VB.NET">
            ' Initialize a custom, 64-bit significand floating-point number, and set it to 0.
            Dim size As size_t = mpfr_lib.mpfr_custom_get_size(64U)
            Dim significand As void_ptr = gmp_lib.allocate(size)
            gmp_lib.ZeroMemory(significand.ToIntPtr(), CType(size, Integer))
            Dim x As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_custom_init_set(x, mpfr_kind_t.MPFR_ZERO_KIND, 0, 64U, significand)
            
            ' Set x = x + 1.
            Assert.IsTrue(mpfr_lib.mpfr_add_si(x, x, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert that the exponent of x is 1.
            Assert.IsTrue(mpfr_lib.mpfr_custom_get_exp(x) = 1)
            
            ' Release unmanaged memory allocated for x and significand.
            mpfr_lib.mpfr_custom_clear(x)
            gmp_lib.free(significand)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_move(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.void_ptr)">
            <summary>
            Inform MPFR that the significand of <paramref name="x"/> has moved due to a garbage collect and update its new position to <paramref name="new_position"/>.
            </summary>
            <param name="x">The operand floating-point number.</param>
            <param name="new_position">Pointer to the new address of the significand of <paramref name="x"/>.</param>
            <remarks>
            <para>
            However the application has to move the significand and the <see cref="T:Math.Mpfr.Native.mpfr_t">mpfr_t</see> itself.
            The behavior of this function for any <see cref="T:Math.Mpfr.Native.mpfr_t">mpfr_t</see> not initialized with <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_init_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_kind_t,Math.Mpfr.Native.mpfr_exp_t,System.UInt32,Math.Gmp.Native.void_ptr)">mpfr_custom_init_set</see> is undefined. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_get_size(System.UInt32)">mpfr_custom_get_size</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_init(Math.Gmp.Native.void_ptr,System.UInt32)">mpfr_custom_init</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_init_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_kind_t,Math.Mpfr.Native.mpfr_exp_t,System.UInt32,Math.Gmp.Native.void_ptr)">mpfr_custom_init_set</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_get_kind(Math.Mpfr.Native.mpfr_t)">mpfr_custom_get_kind</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_get_significand(Math.Mpfr.Native.mpfr_t)">mpfr_custom_get_significand</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_get_exp(Math.Mpfr.Native.mpfr_t)">mpfr_custom_get_exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_clear(Math.Mpfr.Native.mpfr_t)">mpfr_custom_clear</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Custom_Interface">Custom Interface</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Custom-Interface">GNU MPFR - Custom Interface</a></seealso>
            <example>
            <code language="C#">
            // Initialize a custom, 64-bit significand floating-point number, and set it to 0.
            size_t size = mpfr_lib.mpfr_custom_get_size(64U);
            void_ptr significand = gmp_lib.allocate(size);
            gmp_lib.ZeroMemory(significand.ToIntPtr(), (int)size);
            mpfr_t x = new mpfr_t();
            mpfr_lib.mpfr_custom_init_set(x, mpfr_kind_t.MPFR_ZERO_KIND, 0, 64U, significand);
            
            // Set x = 16.
            Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 16, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert the value of x.
            Assert.IsTrue(x.ToString() == "0.160000000000000000000e2");
            
            // Allocate new significand.
            void_ptr significand2 = gmp_lib.allocate(8);
            Marshal.Copy(new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0 }, 0, significand2.ToIntPtr(), 8);
            
            // Assign new significanf to x.
            mpfr_lib.mpfr_custom_move(x, significand2);
            
            // Assert the value of x.
            Assert.IsTrue(x.ToString() == "0.240000000000000000000e2");
            
            // Release unmanaged memory allocated for x and significand.
            mpfr_lib.mpfr_custom_clear(x);
            gmp_lib.free(significand);
            gmp_lib.free(significand2);
            </code> 
            <code language="VB.NET">
            ' Initialize a custom, 64-bit significand floating-point number, and set it to 0.
            Dim size As size_t = mpfr_lib.mpfr_custom_get_size(64U)
            Dim significand As void_ptr = gmp_lib.allocate(size)
            gmp_lib.ZeroMemory(significand.ToIntPtr(), CType(size, Integer))
            Dim x As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_custom_init_set(x, mpfr_kind_t.MPFR_ZERO_KIND, 0, 64U, significand)
            
            ' Set x = 16.
            Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 16, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert the value of x.
            Assert.IsTrue(x.ToString() = "0.160000000000000000000e2")
            
            ' Allocate new significand.
            Dim significand2 As void_ptr = gmp_lib.allocate(8)
            Dim Byte() As Marshal.Copy(New { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0 }, 0, significand2.ToIntPtr(), 8)
            
            ' Assign new significanf to x.
            mpfr_lib.mpfr_custom_move(x, significand2)
            
            ' Assert the value of x.
            Assert.IsTrue(x.ToString() = "0.240000000000000000000e2")
            
            ' Release unmanaged memory allocated for x and significand.
            mpfr_lib.mpfr_custom_clear(x)
            gmp_lib.free(significand)
            gmp_lib.free(significand2)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_init_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_kind_t,Math.Mpfr.Native.mpfr_exp_t,System.UInt32,Math.Gmp.Native.void_ptr)">
            <summary>
            Perform a dummy initialization of a <see cref="T:Math.Mpfr.Native.mpfr_t">mpfr_t</see>.
            </summary>
            <param name="x">The operand floating-point number.</param>
            <param name="kind">The kind of number to initialize.</param>
            <param name="exp">The exponent.</param>
            <param name="prec">The precision in bits.</param>
            <param name="significand">Pointer to the significand.</param>
            <remarks>
            <para>
            Perform a dummy initialization of a <see cref="T:Math.Mpfr.Native.mpfr_t">mpfr_t</see> and set it to:
            </para>
            <list type="bullet">
            <item>
            <description>
            if ABS(<paramref name="kind"/>) == <see cref="F:Math.Mpfr.Native.mpfr_kind_t.MPFR_NAN_KIND">mpfr_kind_t.MPFR_NAN_KIND</see>, <paramref name="x"/> is set to NaN;
            </description>
            </item>
            <item>
            <description>
            if ABS(<paramref name="kind"/>) == <see cref="F:Math.Mpfr.Native.mpfr_kind_t.MPFR_INF_KIND">mpfr_kind_t.MPFR_INF_KIND</see>, <paramref name="x"/> is set to the infinity of sign sign(<paramref name="kind"/>); 
            </description>
            </item>
            <item>
            <description>
            if ABS(<paramref name="kind"/>) == <see cref="F:Math.Mpfr.Native.mpfr_kind_t.MPFR_ZERO_KIND">mpfr_kind_t.MPFR_ZERO_KIND</see>, <paramref name="x"/> is set to the zero of sign sign(<paramref name="kind"/>); 
            </description>
            </item>
            <item>
            <description>
            if ABS(<paramref name="kind"/>) == <see cref="F:Math.Mpfr.Native.mpfr_kind_t.MPFR_REGULAR_KIND">mpfr_kind_t.MPFR_REGULAR_KIND</see>, <paramref name="x"/> is set to a regular number: 
            <paramref name="x"/> = sign(<paramref name="kind"/>) * <paramref name="significand"/> * 2^<paramref name="exp"/>. 
            </description>
            </item>
            </list>
            <para>
            In all cases, it uses significand directly for further computing involving <paramref name="x"/>.
            It will not allocate anything.
            A floating-point number initialized with this function cannot be resized using <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_set_prec(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_prec_t)">mpfr_set_prec</see>
            or <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_prec_round(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_prec_t,Math.Mpfr.Native.mpfr_rnd_t)">mpfr_prec_round</see>, or cleared using <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_clear(Math.Mpfr.Native.mpfr_t)">mpfr_clear</see>!
            The <paramref name="significand"/> must have been initialized with <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_init(Math.Gmp.Native.void_ptr,System.UInt32)">mpfr_custom_init</see> using the same precision <paramref name="prec"/>. 
            </para>
            <para>
            The <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_clear(Math.Mpfr.Native.mpfr_t)">mpfr_custom_clear</see> function must be called to free the memory occupied by <paramref name="x"/>.
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_get_size(System.UInt32)">mpfr_custom_get_size</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_init(Math.Gmp.Native.void_ptr,System.UInt32)">mpfr_custom_init</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_get_kind(Math.Mpfr.Native.mpfr_t)">mpfr_custom_get_kind</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_get_significand(Math.Mpfr.Native.mpfr_t)">mpfr_custom_get_significand</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_get_exp(Math.Mpfr.Native.mpfr_t)">mpfr_custom_get_exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_move(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.void_ptr)">mpfr_custom_move</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_clear(Math.Mpfr.Native.mpfr_t)">mpfr_custom_clear</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Custom_Interface">Custom Interface</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Custom-Interface">GNU MPFR - Custom Interface</a></seealso>
            <example>
            <code language="C#">
            // Initialize a custom, 64-bit significand floating-point number, and set it to 0.
            size_t size = mpfr_lib.mpfr_custom_get_size(64U);
            void_ptr significand = gmp_lib.allocate(size);
            gmp_lib.ZeroMemory(significand.ToIntPtr(), (int)size);
            mpfr_t x = new mpfr_t();
            mpfr_lib.mpfr_custom_init_set(x, mpfr_kind_t.MPFR_ZERO_KIND, 0, 64U, significand);
            
            // Set x = 16.
            Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 16, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert exponent of x.
            Assert.IsTrue(mpfr_lib.mpfr_custom_get_exp(x) == 5);
            
            // Assert significand of x.
            Byte[] result = new byte[] { 0, 0, 0, 0, 0, 0, 0, 0x80 };
            Byte[] sp = new byte[8];
            Marshal.Copy(significand.ToIntPtr(), sp, 0, 8);
            Assert.IsTrue(sp.SequenceEqual(result));
            
            // Release unmanaged memory allocated for x and significand.
            mpfr_lib.mpfr_custom_clear(x);
            gmp_lib.free(significand);
            </code> 
            <code language="VB.NET">
            ' Initialize a custom, 64-bit significand floating-point number, and set it to 0.
            Dim size As size_t = mpfr_lib.mpfr_custom_get_size(64U)
            Dim significand As void_ptr = gmp_lib.allocate(size)
            gmp_lib.ZeroMemory(significand.ToIntPtr(), CType(size, Integer))
            Dim x As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_custom_init_set(x, mpfr_kind_t.MPFR_ZERO_KIND, 0, 64U, significand)
            
            ' Set x = 16.
            Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 16, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert exponent of x.
            Assert.IsTrue(mpfr_lib.mpfr_custom_get_exp(x) = 5)
            
            ' Assert significand of x.
            Dim result() As Byte = New Byte() { 0, 0, 0, 0, 0, 0, 0, 0x80}
            
            Dim sp() As Byte = New Byte(8) { }
            Marshal.Copy(significand.ToIntPtr(), sp, 0, 8)
            Assert.IsTrue(sp.SequenceEqual(result))
            
            ' Release unmanaged memory allocated for x and significand.
            mpfr_lib.mpfr_custom_clear(x)
            gmp_lib.free(significand)
            </code> 
            </example>
        </member>
        <member name="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_get_kind(Math.Mpfr.Native.mpfr_t)">
            <summary>
            Return the current kind of a <see cref="T:Math.Mpfr.Native.mpfr_t">mpfr_t</see> as created by <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_init_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_kind_t,Math.Mpfr.Native.mpfr_exp_t,System.UInt32,Math.Gmp.Native.void_ptr)">mpfr_custom_init_set</see>.
            </summary>
            <param name="x">The operand floating-point number.</param>
            <returns>Return the current kind of a <see cref="T:Math.Mpfr.Native.mpfr_t">mpfr_t</see> as created by <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_init_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_kind_t,Math.Mpfr.Native.mpfr_exp_t,System.UInt32,Math.Gmp.Native.void_ptr)">mpfr_custom_init_set</see>.</returns>
            <remarks>
            <para>
            The behavior of this function for any <see cref="T:Math.Mpfr.Native.mpfr_t">mpfr_t</see> not initialized with <see cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_init_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_kind_t,Math.Mpfr.Native.mpfr_exp_t,System.UInt32,Math.Gmp.Native.void_ptr)">mpfr_custom_init_set</see> is undefined. 
            </para>
            </remarks>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_get_size(System.UInt32)">mpfr_custom_get_size</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_init(Math.Gmp.Native.void_ptr,System.UInt32)">mpfr_custom_init</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_init_set(Math.Mpfr.Native.mpfr_t,Math.Mpfr.Native.mpfr_kind_t,Math.Mpfr.Native.mpfr_exp_t,System.UInt32,Math.Gmp.Native.void_ptr)">mpfr_custom_init_set</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_get_significand(Math.Mpfr.Native.mpfr_t)">mpfr_custom_get_significand</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_get_exp(Math.Mpfr.Native.mpfr_t)">mpfr_custom_get_exp</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_move(Math.Mpfr.Native.mpfr_t,Math.Gmp.Native.void_ptr)">mpfr_custom_move</seealso>
            <seealso cref="M:Math.Mpfr.Native.mpfr_lib.mpfr_custom_clear(Math.Mpfr.Native.mpfr_t)">mpfr_custom_clear</seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Custom_Interface">Custom Interface</a></seealso>
            <seealso cref="T:Math.Mpfr.Native.mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Custom-Interface">GNU MPFR - Custom Interface</a></seealso>
            <example>
            <code language="C#">
            // Initialize a custom, 64-bit significand floating-point number, and set it to 0.
            size_t size = mpfr_lib.mpfr_custom_get_size(64U);
            void_ptr significand = gmp_lib.allocate(size);
            gmp_lib.ZeroMemory(significand.ToIntPtr(), (int)size);
            mpfr_t x = new mpfr_t();
            mpfr_lib.mpfr_custom_init_set(x, mpfr_kind_t.MPFR_ZERO_KIND, 0, 64U, significand);
            
            // Set x = x + 1.
            Assert.IsTrue(mpfr_lib.mpfr_add_si(x, x, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
            
            // Assert x is a regular floating-point number.
            Assert.IsTrue(mpfr_lib.mpfr_custom_get_kind(x) == mpfr_kind_t.MPFR_REGULAR_KIND);
            
            // Release unmanaged memory allocated for x and significand.
            mpfr_lib.mpfr_custom_clear(x);
            gmp_lib.free(significand);
            </code> 
            <code language="VB.NET">
            ' Initialize a custom, 64-bit significand floating-point number, and set it to 0.
            Dim size As size_t = mpfr_lib.mpfr_custom_get_size(64U)
            Dim significand As void_ptr = gmp_lib.allocate(size)
            gmp_lib.ZeroMemory(significand.ToIntPtr(), CType(size, Integer))
            Dim x As mpfr_t = New mpfr_t()
            mpfr_lib.mpfr_custom_init_set(x, mpfr_kind_t.MPFR_ZERO_KIND, 0, 64U, significand)
            
            ' Set x = x + 1.
            Assert.IsTrue(mpfr_lib.mpfr_add_si(x, x, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
            
            ' Assert x is a regular floating-point number.
            Assert.IsTrue(mpfr_lib.mpfr_custom_get_kind(x) = mpfr_kind_t.MPFR_REGULAR_KIND)
            
            ' Release unmanaged memory allocated for x and significand.
            mpfr_lib.mpfr_custom_clear(x)
            gmp_lib.free(significand)
            </code> 
            </example>
        </member>
    </members>
</doc>
