<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Math.Gmp.Native</name>
    </assembly>
    <members>
        <member name="T:Math.Gmp.Native.va_list">
            <summary>
            Represent a variable argument list.
            </summary>
        </member>
        <member name="M:Math.Gmp.Native.va_list.#ctor(System.Object[])">
            <summary>
            Creates a variable list of arguments in unmanaged memory.
            </summary>
            <param name="args">The list of arguments.</param>
        </member>
        <member name="M:Math.Gmp.Native.va_list.ToIntPtr">
            <summary>
            Return the pointer to the list of arguments in unmanaged memory.
            </summary>
            <returns>The pointer to the list of arguments in unmanaged memory.</returns>
        </member>
        <member name="M:Math.Gmp.Native.va_list.RetrieveArgumentValues">
            <summary>
            Retrieves argument values from unmanaged memory.
            </summary>
        </member>
        <member name="T:Math.Gmp.Native.mp_base">
            <summary>
            Provides common functionality to <see cref="T:Math.Gmp.Native.mpz_t">mpz_t</see>, <see cref="T:Math.Gmp.Native.mpf_t">mpf_t</see>, and <see cref="T:Math.Gmp.Native.gmp_randstate_t">gmp_randstate_t</see>.
            </summary>
        </member>
        <member name="F:Math.Gmp.Native.mp_base.Pointer">
            <summary>
            Pointer to limbs in unmanaged memory.
            </summary>
        </member>
        <member name="P:Math.Gmp.Native.mp_base._mp_size">
            <summary>
            The number of limbs.
            </summary>
            <remarks></remarks>
        </member>
        <member name="P:Math.Gmp.Native.mp_base._mp_d_intptr">
            <summary>
            Gets or sets the pointer to limbs in unmanaged memory.
            </summary>
        </member>
        <member name="P:Math.Gmp.Native.mp_base._mp_d">
            <summary>
            A pointer to an array of limbs which is the magnitude.
            </summary>
            <remarks>
            <para>
            In <see cref="T:Math.Gmp.Native.mpz_t">mpz_t</see>:
            </para>
            <para>
            A pointer to an array of limbs which is the magnitude.
            These are stored “little endian” as per the mpn functions, so <c><see cref="P:Math.Gmp.Native.mp_base._mp_d">_mp_d</see>[0]</c>
            is the least significant limb and <c><see cref="P:Math.Gmp.Native.mp_base._mp_d">_mp_d</see>[ABS(<see cref="P:Math.Gmp.Native.mp_base._mp_size">_mp_size</see>) - 1]</c>
            is the most significant.
            Whenever <see cref="P:Math.Gmp.Native.mp_base._mp_size">_mp_size</see> is non-zero, the most significant limb is non-zero.
            </para>
            <para>
            Currently there’s always at least one limb allocated, so for instance <see cref="M:Math.Gmp.Native.gmp_lib.mpz_set_ui(Math.Gmp.Native.mpz_t,System.UInt32)">gmp_lib.mpz_set_ui</see>
            never needs to reallocate, and <see cref="M:Math.Gmp.Native.gmp_lib.mpz_get_ui(Math.Gmp.Native.mpz_t)">gmp_lib.mpz_get_ui</see> can fetch <c><see cref="P:Math.Gmp.Native.mp_base._mp_d">_mp_d</see>[0]</c>
            unconditionally (though its value is then only wanted if <see cref="P:Math.Gmp.Native.mp_base._mp_size">_mp_size</see> is non-zero).
            </para>
            <para>
            In <see cref="T:Math.Gmp.Native.mpz_t">mpz_t</see>:
            </para>
            <para>
            A pointer to the array of limbs which is the absolute value of the mantissa.
            These are stored "little endian" as per the <c>mpn</c> functions, so <c>_mp_d[0]</c> is the least
            significant limb and <c>_mp_d[ABS(_mp_size)-1]</c> the most significant. 
            </para>
            <para>
            The most significant limb is always non-zero, but there are no other restrictions on its value,
            in particular the highest <c>1</c> bit can be anywhere within the limb. 
            </para>
            <para>
            <c>_mp_prec + 1</c> limbs are allocated to <see cref="P:Math.Gmp.Native.mp_base._mp_d">mp_base._mp_d</see>, the extra limb being for
            convenience (see below).
            There are no reallocations during a calculation, only in a change of precision with <see cref="M:Math.Gmp.Native.gmp_lib.mpf_set_prec(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_bitcnt_t)">gmp_lib.mpf_set_prec</see>. 
            </para>
            </remarks>
        </member>
        <member name="T:Math.Gmp.Native.FILE">
            <summary>
            Represents a file stream.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Math.Gmp.Native.FILE.Value">
            <summary>
            File pointer in unmanaged memory.
            </summary>
        </member>
        <member name="M:Math.Gmp.Native.FILE.Equals(System.Object)">
            <summary>
            Returns a value indicating whether this instance is equal to a specified object.
            </summary>
            <param name="obj">An object to compare with this instance.</param>
            <returns><c>True</c> if <paramref name="obj"/> is an instance of <see cref="T:Math.Gmp.Native.FILE">FILE</see> and equals the value of this instance; otherwise, <c>False</c>.</returns>
        </member>
        <member name="M:Math.Gmp.Native.FILE.Equals(Math.Gmp.Native.FILE)">
            <summary>
            Returns a value indicating whether this instance is equal to a specified <see cref="T:Math.Gmp.Native.FILE">FILE</see> value.
            </summary>
            <param name="other">A <see cref="T:Math.Gmp.Native.FILE">FILE</see> value to compare to this instance.</param>
            <returns><c>True</c> if <paramref name="other"/> has the same value as this instance; otherwise, <c>False</c>.</returns>
        </member>
        <member name="M:Math.Gmp.Native.FILE.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:Math.Gmp.Native.FILE.op_Equality(Math.Gmp.Native.FILE,Math.Gmp.Native.FILE)">
            <summary>
            Gets a value that indicates whether the two argument values are equal.
            </summary>
            <param name="value1">A <see cref="T:Math.Gmp.Native.FILE">FILE</see> value.</param>
            <param name="value2">A <see cref="T:Math.Gmp.Native.FILE">FILE</see> value.</param>
            <returns><c>True</c> if the two values are equal, and <c>False</c> otherwise.</returns>
        </member>
        <member name="M:Math.Gmp.Native.FILE.op_Inequality(Math.Gmp.Native.FILE,Math.Gmp.Native.FILE)">
            <summary>
            Gets a value that indicates whether the two argument values are different.
            </summary>
            <param name="value1">A <see cref="T:Math.Gmp.Native.FILE">FILE</see> value.</param>
            <param name="value2">A <see cref="T:Math.Gmp.Native.FILE">FILE</see> value.</param>
            <returns><c>True</c> if the two FILE are different, and <c>False</c> otherwise.</returns>
        </member>
        <member name="T:Math.Gmp.Native.mp_ptr">
            <summary>
            Represents a pointer to an array of <see cref="T:Math.Gmp.Native.mp_limb_t">mp_limb_t</see> values in unmanaged memory,
            </summary>
            <remarks>
            <para>
            </para>
            </remarks>
        </member>
        <member name="M:Math.Gmp.Native.mp_ptr.#ctor(Math.Gmp.Native.mp_size_t)">
            <summary>
            Creates a new array of <paramref name="size"/> limbs in unmanaged memory.
            </summary>
            <param name="size">The number of limbs.</param>
            <remarks>
            <para>
            When done with the array, you must release the unmanaged memory by calling <see cref="M:Math.Gmp.Native.gmp_lib.free(Math.Gmp.Native.mp_ptr[])">free</see>. 
            </para>
            </remarks>
        </member>
        <member name="M:Math.Gmp.Native.mp_ptr.#ctor(System.Byte[])">
            <summary>
            Creates a new array of limbs initialized with <paramref name="values"/> in unmanaged memory.
            </summary>
            <param name="values">The values of the limbs.</param>
            <remarks>
            <para>
            If there is not enough bytes to fill out the most significant limb, it is padded with zeroes.
            </para>
            <para>
            When done with the array, you must release the unmanaged memory by calling <see cref="M:Math.Gmp.Native.gmp_lib.free(Math.Gmp.Native.mp_ptr[])">free</see>. 
            </para>
            </remarks>
        </member>
        <member name="M:Math.Gmp.Native.mp_ptr.#ctor(System.UInt16[])">
            <summary>
            Creates a new array of limbs initialized with <paramref name="values"/> in unmanaged memory.
            </summary>
            <param name="values">The values of the limbs.</param>
            <remarks>
            <para>
            If there is not enough 16-bit words to fill out the most significant limb, it is padded with zeroes.
            </para>
            <para>
            When done with the array, you must release the unmanaged memory by calling <see cref="M:Math.Gmp.Native.gmp_lib.free(Math.Gmp.Native.mp_ptr[])">free</see>. 
            </para>
            </remarks>
        </member>
        <member name="M:Math.Gmp.Native.mp_ptr.#ctor(System.UInt32[])">
            <summary>
            Creates a new array of limbs initialized with <paramref name="values"/> in unmanaged memory.
            </summary>
            <param name="values">The values of the limbs.</param>
            <remarks>
            <para>
            If there is not enough 32-bit words to fill out the most significant limb, it is padded with zeroes.
            </para>
            <para>
            When done with the array, you must release the unmanaged memory by calling <see cref="M:Math.Gmp.Native.gmp_lib.free(Math.Gmp.Native.mp_ptr[])">free</see>. 
            </para>
            </remarks>
        </member>
        <member name="M:Math.Gmp.Native.mp_ptr.#ctor(System.UInt64[])">
            <summary>
            Creates a new array of limbs initialized with <paramref name="values"/> in unmanaged memory.
            </summary>
            <param name="values">The values of the limbs.</param>
            <remarks>
            <para>
            If limbs size is 32 bits, the 64-bit values are split into 32-bit limbs.
            </para>
            <para>
            When done with the array, you must release the unmanaged memory by calling <see cref="M:Math.Gmp.Native.gmp_lib.free(Math.Gmp.Native.mp_ptr[])">free</see>. 
            </para>
            </remarks>
        </member>
        <member name="M:Math.Gmp.Native.mp_ptr.#ctor(Math.Gmp.Native.mp_base)">
            <summary>
            Creates new pointer to array of limbs at <paramref name="mp"/>.
            </summary>
            <param name="mp">Represents an array of limbs.</param>
        </member>
        <member name="P:Math.Gmp.Native.mp_ptr.Size">
            <summary>
            The number of limbs.
            </summary>
            <remarks></remarks>
        </member>
        <member name="P:Math.Gmp.Native.mp_ptr.Item(System.Int32)">
            <summary>
            Gets or sets the value of the limb at <paramref name="index"/>.
            </summary>
            <param name="index">The zero-based index of the limb to get or set.</param>
            <returns></returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_ptr.ToIntPtr">
            <summary>
            Returns pointer to limbs in unmanaged memory.
            </summary>
            <returns>Returns pointer to limbs in unmanaged memory.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_ptr.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the array of limbs.
            </summary>
            <returns>An enumerator that iterates through the array of limbs.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_ptr.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the array of limbs.
            </summary>
            <returns>An enumerator that iterates through the array of limbs.</returns>
        </member>
        <member name="T:Math.Gmp.Native.mp_exp_t">
            <summary>
            Represents the exponent of a floating-point number.
            </summary>
            <remarks>
            <para>
            The floating point functions accept and return exponents in the C type <see cref="T:Math.Gmp.Native.mp_exp_t">mp_exp_t</see>.
            Currently this is usually a long, but on some systems it’s an int for efficiency.
            </para>
            <para>
            In .Net, this is a 32-bit integer. 
            </para>
            </remarks>
        </member>
        <member name="F:Math.Gmp.Native.mp_exp_t.Value">
            <summary>
             The <see cref="T:Math.Gmp.Native.mp_exp_t">mp_exp_t</see> value.
            </summary>
        </member>
        <member name="M:Math.Gmp.Native.mp_exp_t.#ctor(System.Int32)">
            <summary>
            Creates a new <see cref="T:Math.Gmp.Native.mp_exp_t">mp_exp_t</see>, and sets its <paramref name="value"/>.
            </summary>
            <param name="value">The value of the new <see cref="T:Math.Gmp.Native.mp_exp_t">mp_exp_t</see>.</param>
        </member>
        <member name="M:Math.Gmp.Native.mp_exp_t.op_Implicit(System.Byte)~Math.Gmp.Native.mp_exp_t">
            <summary>
            Converts a <see cref="T:System.Byte">Byte</see> value to an <see cref="T:Math.Gmp.Native.mp_exp_t">mp_exp_t</see> value.
            </summary>
            <param name="value">A <see cref="T:System.Byte">Byte</see> value.</param>
            <returns>An <see cref="T:Math.Gmp.Native.mp_exp_t">mp_exp_t</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_exp_t.op_Implicit(System.SByte)~Math.Gmp.Native.mp_exp_t">
            <summary>
            Converts a <see cref="T:System.Byte">Byte</see> value to an <see cref="T:Math.Gmp.Native.mp_exp_t">mp_exp_t</see> value.
            </summary>
            <param name="value">A <see cref="T:System.Byte">Byte</see> value.</param>
            <returns>An <see cref="T:Math.Gmp.Native.mp_exp_t">mp_exp_t</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_exp_t.op_Implicit(System.UInt16)~Math.Gmp.Native.mp_exp_t">
            <summary>
            Converts a <see cref="T:System.UInt16">UInt16</see> value to an <see cref="T:Math.Gmp.Native.mp_exp_t">mp_exp_t</see> value.
            </summary>
            <param name="value">A <see cref="T:System.UInt16">UInt16</see> value.</param>
            <returns>An <see cref="T:Math.Gmp.Native.mp_exp_t">mp_exp_t</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_exp_t.op_Implicit(System.Int16)~Math.Gmp.Native.mp_exp_t">
            <summary>
            Converts an <see cref="T:System.Int16">Int16</see> value to an <see cref="T:Math.Gmp.Native.mp_exp_t">mp_exp_t</see> value.
            </summary>
            <param name="value">An <see cref="T:System.Int16">Int16</see> value.</param>
            <returns>An <see cref="T:Math.Gmp.Native.mp_exp_t">mp_exp_t</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_exp_t.op_Explicit(System.UInt32)~Math.Gmp.Native.mp_exp_t">
            <summary>
            Converts a <see cref="T:System.UInt32">UInt32</see> value to an <see cref="T:Math.Gmp.Native.mp_exp_t">mp_exp_t</see> value.
            </summary>
            <param name="value">A <see cref="T:System.UInt32">UInt32</see> value.</param>
            <returns>An <see cref="T:Math.Gmp.Native.mp_exp_t">mp_exp_t</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_exp_t.op_Implicit(System.Int32)~Math.Gmp.Native.mp_exp_t">
            <summary>
            Converts an <see cref="T:System.Int32">Int32</see> value to an <see cref="T:Math.Gmp.Native.mp_exp_t">mp_exp_t</see> value.
            </summary>
            <param name="value">An <see cref="T:System.Int32">Int32</see> value.</param>
            <returns>An <see cref="T:Math.Gmp.Native.mp_exp_t">mp_exp_t</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_exp_t.op_Explicit(System.UInt64)~Math.Gmp.Native.mp_exp_t">
            <summary>
            Converts a <see cref="T:System.UInt64">UInt64</see> value to an <see cref="T:Math.Gmp.Native.mp_exp_t">mp_exp_t</see> value.
            </summary>
            <param name="value">A <see cref="T:System.UInt64">UInt64</see> value.</param>
            <returns>An <see cref="T:Math.Gmp.Native.mp_exp_t">mp_exp_t</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_exp_t.op_Explicit(System.Int64)~Math.Gmp.Native.mp_exp_t">
            <summary>
            Converts an <see cref="T:System.Int64">Int64</see> value to a <see cref="T:Math.Gmp.Native.mp_exp_t">mp_exp_t</see> value.
            </summary>
            <param name="value">An <see cref="T:System.Int64">Int64</see> value.</param>
            <returns>An <see cref="T:Math.Gmp.Native.mp_exp_t">mp_exp_t</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_exp_t.op_Explicit(Math.Gmp.Native.mp_exp_t)~System.Byte">
            <summary>
            Converts an <see cref="T:Math.Gmp.Native.mp_exp_t">mp_exp_t</see> value to a <see cref="T:System.Byte">Byte</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Gmp.Native.mp_exp_t">mp_exp_t</see> value.</param>
            <returns>A <see cref="T:System.Byte">Byte</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_exp_t.op_Explicit(Math.Gmp.Native.mp_exp_t)~System.SByte">
            <summary>
            Converts an <see cref="T:Math.Gmp.Native.mp_exp_t">mp_exp_t</see> value to an <see cref="T:System.SByte">SByte</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Gmp.Native.mp_exp_t">mp_exp_t</see> value.</param>
            <returns>An <see cref="T:System.SByte">SByte</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_exp_t.op_Explicit(Math.Gmp.Native.mp_exp_t)~System.UInt16">
            <summary>
            Converts an <see cref="T:Math.Gmp.Native.mp_exp_t">mp_exp_t</see> value to a <see cref="T:System.UInt16">UInt16</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Gmp.Native.mp_exp_t">mp_exp_t</see> value.</param>
            <returns>A <see cref="T:System.UInt16">UInt16</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_exp_t.op_Explicit(Math.Gmp.Native.mp_exp_t)~System.Int16">
            <summary>
            Converts an <see cref="T:Math.Gmp.Native.mp_exp_t">mp_exp_t</see> value to an <see cref="T:System.Int16">Int16</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Gmp.Native.mp_exp_t">mp_exp_t</see> value.</param>
            <returns>An <see cref="T:System.Int16">Int16</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_exp_t.op_Explicit(Math.Gmp.Native.mp_exp_t)~System.UInt32">
            <summary>
            Converts an <see cref="T:Math.Gmp.Native.mp_exp_t">mp_exp_t</see> value to a <see cref="T:System.UInt32">UInt32</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Gmp.Native.mp_exp_t">mp_exp_t</see> value.</param>
            <returns>A <see cref="T:System.UInt32">UInt32</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_exp_t.op_Implicit(Math.Gmp.Native.mp_exp_t)~System.Int32">
            <summary>
            Converts an <see cref="T:Math.Gmp.Native.mp_exp_t">mp_exp_t</see> value to an <see cref="T:System.Int32">Int32</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Gmp.Native.mp_exp_t">mp_exp_t</see> value.</param>
            <returns>An <see cref="T:System.Int32">Int32</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_exp_t.op_Explicit(Math.Gmp.Native.mp_exp_t)~System.UInt64">
            <summary>
            Converts an <see cref="T:Math.Gmp.Native.mp_exp_t">mp_exp_t</see> value to a <see cref="T:System.UInt64">UInt64</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Gmp.Native.mp_exp_t">mp_exp_t</see> value.</param>
            <returns>A <see cref="T:System.UInt64">UInt64</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_exp_t.op_Implicit(Math.Gmp.Native.mp_exp_t)~System.Int64">
            <summary>
            Converts an <see cref="T:Math.Gmp.Native.mp_exp_t">mp_exp_t</see> value to an <see cref="T:System.Int64">Int64</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Gmp.Native.mp_exp_t">mp_exp_t</see> value.</param>
            <returns>An <see cref="T:System.Int64">Int64</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_exp_t.ToString">
            <summary>
            Gets the string representation of the <see cref="T:Math.Gmp.Native.mp_exp_t">mp_exp_t</see>.
            </summary>
            <returns>The string representation of the <see cref="T:Math.Gmp.Native.mp_exp_t">mp_exp_t</see>.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_exp_t.Equals(System.Object)">
            <summary>
            Returns a value indicating whether this instance is equal to a specified object.
            </summary>
            <param name="obj">An object to compare with this instance.</param>
            <returns><c>True</c> if <paramref name="obj"/> is an instance of <see cref="T:Math.Gmp.Native.mp_exp_t">mp_exp_t</see> and equals the value of this instance; otherwise, <c>False</c>.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_exp_t.Equals(Math.Gmp.Native.mp_exp_t)">
            <summary>
            Returns a value indicating whether this instance is equal to a specified <see cref="T:Math.Gmp.Native.mp_exp_t">mp_exp_t</see> value.
            </summary>
            <param name="other">A <see cref="T:Math.Gmp.Native.mp_exp_t">mp_exp_t</see> value to compare to this instance.</param>
            <returns><c>True</c> if <paramref name="other"/> has the same value as this instance; otherwise, <c>False</c>.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_exp_t.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_exp_t.op_Equality(Math.Gmp.Native.mp_exp_t,Math.Gmp.Native.mp_exp_t)">
            <summary>
            Gets a value that indicates whether the two argument values are equal.
            </summary>
            <param name="value1">A <see cref="T:Math.Gmp.Native.mp_exp_t">mp_exp_t</see> value.</param>
            <param name="value2">A <see cref="T:Math.Gmp.Native.mp_exp_t">mp_exp_t</see> value.</param>
            <returns><c>True</c> if the two values are equal, and <c>False</c> otherwise.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_exp_t.op_Inequality(Math.Gmp.Native.mp_exp_t,Math.Gmp.Native.mp_exp_t)">
            <summary>
            Gets a value that indicates whether the two argument values are different.
            </summary>
            <param name="value1">A <see cref="T:Math.Gmp.Native.mp_exp_t">mp_exp_t</see> value.</param>
            <param name="value2">A <see cref="T:Math.Gmp.Native.mp_exp_t">mp_exp_t</see> value.</param>
            <returns><c>True</c> if the two values are different, and <c>False</c> otherwise.</returns>
        </member>
        <member name="T:Math.Gmp.Native.mp_size_t">
            <summary>
            Represents a count of limbs.
            </summary>
            <remarks>
            <para>
            Counts of limbs of a multi-precision number represented in the C type <see cref="T:Math.Gmp.Native.mp_size_t">mp_size_t</see>.
            Currently this is normally a long, but on some systems it’s an int for efficiency,
            and on some systems it will be long long in the future.
            </para>
            <para>
            In .Net, this is a 32-bit integer. 
            </para>
            </remarks>
            <seealso cref="T:Math.Gmp.Native.mp_limb_t">mp_limb_t</seealso>
            <seealso cref="T:Math.Gmp.Native.mpf_t">mpf_t</seealso>
            <seealso cref="T:Math.Gmp.Native.mpq_t">mpq_t</seealso>
            <seealso cref="T:Math.Gmp.Native.mpz_t">mpz_t</seealso>
        </member>
        <member name="F:Math.Gmp.Native.mp_size_t.Value">
            <summary>
             The <see cref="T:Math.Gmp.Native.mp_size_t">mp_size_t</see> value.
            </summary>
        </member>
        <member name="M:Math.Gmp.Native.mp_size_t.#ctor(System.Int32)">
            <summary>
            Creates a new <see cref="T:Math.Gmp.Native.mp_size_t">mp_size_t</see>, and sets its <paramref name="value"/>.
            </summary>
            <param name="value">The value of the new <see cref="T:Math.Gmp.Native.mp_size_t">mp_size_t</see>.</param>
        </member>
        <member name="M:Math.Gmp.Native.mp_size_t.op_Implicit(System.Byte)~Math.Gmp.Native.mp_size_t">
            <summary>
            Converts a <see cref="T:System.Byte">Byte</see> value to an <see cref="T:Math.Gmp.Native.mp_size_t">mp_size_t</see> value.
            </summary>
            <param name="value">A <see cref="T:System.Byte">Byte</see> value.</param>
            <returns>An <see cref="T:Math.Gmp.Native.mp_size_t">mp_size_t</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_size_t.op_Implicit(System.SByte)~Math.Gmp.Native.mp_size_t">
            <summary>
            Converts a <see cref="T:System.Byte">Byte</see> value to an <see cref="T:Math.Gmp.Native.mp_size_t">mp_size_t</see> value.
            </summary>
            <param name="value">A <see cref="T:System.Byte">Byte</see> value.</param>
            <returns>An <see cref="T:Math.Gmp.Native.mp_size_t">mp_size_t</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_size_t.op_Implicit(System.UInt16)~Math.Gmp.Native.mp_size_t">
            <summary>
            Converts a <see cref="T:System.UInt16">UInt16</see> value to an <see cref="T:Math.Gmp.Native.mp_size_t">mp_size_t</see> value.
            </summary>
            <param name="value">A <see cref="T:System.UInt16">UInt16</see> value.</param>
            <returns>An <see cref="T:Math.Gmp.Native.mp_size_t">mp_size_t</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_size_t.op_Implicit(System.Int16)~Math.Gmp.Native.mp_size_t">
            <summary>
            Converts an <see cref="T:System.Int16">Int16</see> value to an <see cref="T:Math.Gmp.Native.mp_size_t">mp_size_t</see> value.
            </summary>
            <param name="value">An <see cref="T:System.Int16">Int16</see> value.</param>
            <returns>An <see cref="T:Math.Gmp.Native.mp_size_t">mp_size_t</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_size_t.op_Explicit(System.UInt32)~Math.Gmp.Native.mp_size_t">
            <summary>
            Converts a <see cref="T:System.UInt32">UInt32</see> value to an <see cref="T:Math.Gmp.Native.mp_size_t">mp_size_t</see> value.
            </summary>
            <param name="value">A <see cref="T:System.UInt32">UInt32</see> value.</param>
            <returns>An <see cref="T:Math.Gmp.Native.mp_size_t">mp_size_t</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_size_t.op_Implicit(System.Int32)~Math.Gmp.Native.mp_size_t">
            <summary>
            Converts an <see cref="T:System.Int32">Int32</see> value to an <see cref="T:Math.Gmp.Native.mp_size_t">mp_size_t</see> value.
            </summary>
            <param name="value">An <see cref="T:System.Int32">Int32</see> value.</param>
            <returns>An <see cref="T:Math.Gmp.Native.mp_size_t">mp_size_t</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_size_t.op_Explicit(System.UInt64)~Math.Gmp.Native.mp_size_t">
            <summary>
            Converts a <see cref="T:System.UInt64">UInt64</see> value to an <see cref="T:Math.Gmp.Native.mp_size_t">mp_size_t</see> value.
            </summary>
            <param name="value">A <see cref="T:System.UInt64">UInt64</see> value.</param>
            <returns>An <see cref="T:Math.Gmp.Native.mp_size_t">mp_size_t</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_size_t.op_Explicit(System.Int64)~Math.Gmp.Native.mp_size_t">
            <summary>
            Converts an <see cref="T:System.Int64">Int64</see> value to a <see cref="T:Math.Gmp.Native.mp_size_t">mp_size_t</see> value.
            </summary>
            <param name="value">An <see cref="T:System.Int64">Int64</see> value.</param>
            <returns>An <see cref="T:Math.Gmp.Native.mp_size_t">mp_size_t</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_size_t.op_Explicit(Math.Gmp.Native.mp_size_t)~System.Byte">
            <summary>
            Converts an <see cref="T:Math.Gmp.Native.mp_size_t">mp_size_t</see> value to a <see cref="T:System.Byte">Byte</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Gmp.Native.mp_size_t">mp_size_t</see> value.</param>
            <returns>A <see cref="T:System.Byte">Byte</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_size_t.op_Explicit(Math.Gmp.Native.mp_size_t)~System.SByte">
            <summary>
            Converts an <see cref="T:Math.Gmp.Native.mp_size_t">mp_size_t</see> value to an <see cref="T:System.SByte">SByte</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Gmp.Native.mp_size_t">mp_size_t</see> value.</param>
            <returns>An <see cref="T:System.SByte">SByte</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_size_t.op_Explicit(Math.Gmp.Native.mp_size_t)~System.UInt16">
            <summary>
            Converts an <see cref="T:Math.Gmp.Native.mp_size_t">mp_size_t</see> value to a <see cref="T:System.UInt16">UInt16</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Gmp.Native.mp_size_t">mp_size_t</see> value.</param>
            <returns>A <see cref="T:System.UInt16">UInt16</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_size_t.op_Explicit(Math.Gmp.Native.mp_size_t)~System.Int16">
            <summary>
            Converts an <see cref="T:Math.Gmp.Native.mp_size_t">mp_size_t</see> value to an <see cref="T:System.Int16">Int16</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Gmp.Native.mp_size_t">mp_size_t</see> value.</param>
            <returns>An <see cref="T:System.Int16">Int16</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_size_t.op_Explicit(Math.Gmp.Native.mp_size_t)~System.UInt32">
            <summary>
            Converts an <see cref="T:Math.Gmp.Native.mp_size_t">mp_size_t</see> value to a <see cref="T:System.UInt32">UInt32</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Gmp.Native.mp_size_t">mp_size_t</see> value.</param>
            <returns>A <see cref="T:System.UInt32">UInt32</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_size_t.op_Implicit(Math.Gmp.Native.mp_size_t)~System.Int32">
            <summary>
            Converts an <see cref="T:Math.Gmp.Native.mp_size_t">mp_size_t</see> value to an <see cref="T:System.Int32">Int32</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Gmp.Native.mp_size_t">mp_size_t</see> value.</param>
            <returns>An <see cref="T:System.Int32">Int32</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_size_t.op_Explicit(Math.Gmp.Native.mp_size_t)~System.UInt64">
            <summary>
            Converts an <see cref="T:Math.Gmp.Native.mp_size_t">mp_size_t</see> value to a <see cref="T:System.UInt64">UInt64</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Gmp.Native.mp_size_t">mp_size_t</see> value.</param>
            <returns>A <see cref="T:System.UInt64">UInt64</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_size_t.op_Implicit(Math.Gmp.Native.mp_size_t)~System.Int64">
            <summary>
            Converts an <see cref="T:Math.Gmp.Native.mp_size_t">mp_size_t</see> value to an <see cref="T:System.Int64">Int64</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Gmp.Native.mp_size_t">mp_size_t</see> value.</param>
            <returns>An <see cref="T:System.Int64">Int64</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_size_t.ToString">
            <summary>
            Gets the string representation of the <see cref="T:Math.Gmp.Native.mp_size_t">mp_size_t</see>.
            </summary>
            <returns>The string representation of the <see cref="T:Math.Gmp.Native.mp_size_t">mp_size_t</see>.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_size_t.Equals(System.Object)">
            <summary>
            Returns a value indicating whether this instance is equal to a specified object.
            </summary>
            <param name="obj">An object to compare with this instance.</param>
            <returns><c>True</c> if <paramref name="obj"/> is an instance of <see cref="T:Math.Gmp.Native.mp_size_t">mp_size_t</see> and equals the value of this instance; otherwise, <c>False</c>.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_size_t.Equals(Math.Gmp.Native.mp_size_t)">
            <summary>
            Returns a value indicating whether this instance is equal to a specified <see cref="T:Math.Gmp.Native.mp_size_t">mp_size_t</see> value.
            </summary>
            <param name="other">A <see cref="T:Math.Gmp.Native.mp_size_t">mp_size_t</see> value to compare to this instance.</param>
            <returns><c>True</c> if <paramref name="other"/> has the same value as this instance; otherwise, <c>False</c>.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_size_t.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_size_t.op_Equality(Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_size_t)">
            <summary>
            Gets a value that indicates whether the two argument values are equal.
            </summary>
            <param name="value1">A <see cref="T:Math.Gmp.Native.mp_size_t">mp_size_t</see> value.</param>
            <param name="value2">A <see cref="T:Math.Gmp.Native.mp_size_t">mp_size_t</see> value.</param>
            <returns><c>True</c> if the two values are equal, and <c>False</c> otherwise.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_size_t.op_Inequality(Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_size_t)">
            <summary>
            Gets a value that indicates whether the two argument values are different.
            </summary>
            <param name="value1">A <see cref="T:Math.Gmp.Native.mp_size_t">mp_size_t</see> value.</param>
            <param name="value2">A <see cref="T:Math.Gmp.Native.mp_size_t">mp_size_t</see> value.</param>
            <returns><c>True</c> if the two values are different, and <c>False</c> otherwise.</returns>
        </member>
        <member name="T:Math.Gmp.Native.mp_limb_t">
            <summary>
            Represents a part of a multiple precision number.
            </summary>
            <remarks>
            <para>
            A limb means the part of a multi-precision number that fits in a single machine word.
            (We chose this word because a limb of the human body is analogous to a digit, only larger,
            and containing several digits.) Normally a limb is 32 or 64 bits.
            </para>
            </remarks>
            <seealso cref="T:Math.Gmp.Native.mpf_t">mpf_t</seealso>
            <seealso cref="T:Math.Gmp.Native.mpq_t">mpq_t</seealso>
            <seealso cref="T:Math.Gmp.Native.mpz_t">mpz_t</seealso>
        </member>
        <member name="F:Math.Gmp.Native.mp_limb_t.Value">
            <summary>
             The <see cref="T:Math.Gmp.Native.mp_limb_t">mp_limb_t</see> value.
            </summary>
        </member>
        <member name="M:Math.Gmp.Native.mp_limb_t.#ctor(System.UInt64)">
            <summary>
            Creates a new <see cref="T:Math.Gmp.Native.mp_limb_t">mp_limb_t</see>, and sets its <paramref name="value"/>.
            </summary>
            <param name="value">The value of the new <see cref="T:Math.Gmp.Native.mp_limb_t">mp_limb_t</see>.</param>
        </member>
        <member name="M:Math.Gmp.Native.mp_limb_t.op_Implicit(System.Byte)~Math.Gmp.Native.mp_limb_t">
            <summary>
            Converts a <see cref="T:System.Byte">Byte</see> value to an <see cref="T:Math.Gmp.Native.mp_limb_t">mp_limb_t</see> value.
            </summary>
            <param name="value">A <see cref="T:System.Byte">Byte</see> value.</param>
            <returns>An <see cref="T:Math.Gmp.Native.mp_limb_t">mp_limb_t</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_limb_t.op_Explicit(System.SByte)~Math.Gmp.Native.mp_limb_t">
            <summary>
            Converts a <see cref="T:System.SByte">SByte</see> value to an <see cref="T:Math.Gmp.Native.mp_limb_t">mp_limb_t</see> value.
            </summary>
            <param name="value">A <see cref="T:System.SByte">SByte</see> value.</param>
            <returns>An <see cref="T:Math.Gmp.Native.mp_limb_t">mp_limb_t</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_limb_t.op_Implicit(System.UInt16)~Math.Gmp.Native.mp_limb_t">
            <summary>
            Converts a <see cref="T:System.UInt16">UInt16</see> value to an <see cref="T:Math.Gmp.Native.mp_limb_t">mp_limb_t</see> value.
            </summary>
            <param name="value">A <see cref="T:System.UInt16">UInt16</see> value.</param>
            <returns>An <see cref="T:Math.Gmp.Native.mp_limb_t">mp_limb_t</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_limb_t.op_Explicit(System.Int16)~Math.Gmp.Native.mp_limb_t">
            <summary>
            Converts an <see cref="T:System.Int16">Int16</see> value to an <see cref="T:Math.Gmp.Native.mp_limb_t">mp_limb_t</see> value.
            </summary>
            <param name="value">An <see cref="T:System.Int16">Int16</see> value.</param>
            <returns>An <see cref="T:Math.Gmp.Native.mp_limb_t">mp_limb_t</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_limb_t.op_Implicit(System.UInt32)~Math.Gmp.Native.mp_limb_t">
            <summary>
            Converts a <see cref="T:System.UInt32">UInt32</see> value to an <see cref="T:Math.Gmp.Native.mp_limb_t">mp_limb_t</see> value.
            </summary>
            <param name="value">A <see cref="T:System.UInt32">UInt32</see> value.</param>
            <returns>An <see cref="T:Math.Gmp.Native.mp_limb_t">mp_limb_t</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_limb_t.op_Explicit(System.Int32)~Math.Gmp.Native.mp_limb_t">
            <summary>
            Converts an <see cref="T:System.Int32">Int32</see> value to an <see cref="T:Math.Gmp.Native.mp_limb_t">mp_limb_t</see> value.
            </summary>
            <param name="value">An <see cref="T:System.Int32">Int32</see> value.</param>
            <returns>An <see cref="T:Math.Gmp.Native.mp_limb_t">mp_limb_t</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_limb_t.op_Implicit(System.UInt64)~Math.Gmp.Native.mp_limb_t">
            <summary>
            Converts a <see cref="T:System.UInt64">UInt64</see> value to an <see cref="T:Math.Gmp.Native.mp_limb_t">mp_limb_t</see> value.
            </summary>
            <param name="value">A <see cref="T:System.UInt64">UInt64</see> value.</param>
            <returns>An <see cref="T:Math.Gmp.Native.mp_limb_t">mp_limb_t</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_limb_t.op_Explicit(System.Int64)~Math.Gmp.Native.mp_limb_t">
            <summary>
            Converts an <see cref="T:System.Int64">Int64</see> value to an <see cref="T:Math.Gmp.Native.mp_limb_t">mp_limb_t</see> value.
            </summary>
            <param name="value">An <see cref="T:System.Int64">Int64</see> value.</param>
            <returns>An <see cref="T:Math.Gmp.Native.mp_limb_t">mp_limb_t</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_limb_t.op_Explicit(Math.Gmp.Native.mp_limb_t)~System.Byte">
            <summary>
            Converts a <see cref="T:Math.Gmp.Native.mp_limb_t">mp_limb_t</see> value to a <see cref="T:System.Byte">Byte</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Gmp.Native.mp_limb_t">mp_limb_t</see> value.</param>
            <returns>A <see cref="T:System.Byte">Byte</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_limb_t.op_Explicit(Math.Gmp.Native.mp_limb_t)~System.SByte">
            <summary>
            Converts a <see cref="T:Math.Gmp.Native.mp_limb_t">mp_limb_t</see> value to an <see cref="T:System.SByte">SByte</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Gmp.Native.mp_limb_t">mp_limb_t</see> value.</param>
            <returns>An <see cref="T:System.SByte">SByte</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_limb_t.op_Explicit(Math.Gmp.Native.mp_limb_t)~System.UInt16">
            <summary>
            Converts a <see cref="T:Math.Gmp.Native.mp_limb_t">mp_limb_t</see> value to a <see cref="T:System.UInt16">UInt16</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Gmp.Native.mp_limb_t">mp_limb_t</see> value.</param>
            <returns>A <see cref="T:System.UInt16">UInt16</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_limb_t.op_Explicit(Math.Gmp.Native.mp_limb_t)~System.Int16">
            <summary>
            Converts a <see cref="T:Math.Gmp.Native.mp_limb_t">mp_limb_t</see> value to an <see cref="T:System.Int16">Int16</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Gmp.Native.mp_limb_t">mp_limb_t</see> value.</param>
            <returns>An <see cref="T:System.Int16">Int16</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_limb_t.op_Explicit(Math.Gmp.Native.mp_limb_t)~System.UInt32">
            <summary>
            Converts a <see cref="T:Math.Gmp.Native.mp_limb_t">mp_limb_t</see> value to a <see cref="T:System.UInt32">UInt32</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Gmp.Native.mp_limb_t">mp_limb_t</see> value.</param>
            <returns>A <see cref="T:System.UInt32">UInt32</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_limb_t.op_Explicit(Math.Gmp.Native.mp_limb_t)~System.Int32">
            <summary>
            Converts a <see cref="T:Math.Gmp.Native.mp_limb_t">mp_limb_t</see> value to an <see cref="T:System.Int32">Int32</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Gmp.Native.mp_limb_t">mp_limb_t</see> value.</param>
            <returns>An <see cref="T:System.Int32">Int32</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_limb_t.op_Implicit(Math.Gmp.Native.mp_limb_t)~System.UInt64">
            <summary>
            Converts a <see cref="T:Math.Gmp.Native.mp_limb_t">mp_limb_t</see> value to a <see cref="T:System.UInt64">UInt64</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Gmp.Native.mp_limb_t">mp_limb_t</see> value.</param>
            <returns>A <see cref="T:System.UInt64">UInt64</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_limb_t.op_Explicit(Math.Gmp.Native.mp_limb_t)~System.Int64">
            <summary>
            Converts a <see cref="T:Math.Gmp.Native.mp_limb_t">mp_limb_t</see> value to an <see cref="T:System.Int64">Int64</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Gmp.Native.mp_limb_t">mp_limb_t</see> value.</param>
            <returns>An <see cref="T:System.Int64">Int64</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_limb_t.ToString">
            <summary>
            Gets the string representation of the <see cref="T:Math.Gmp.Native.mp_limb_t">mp_limb_t</see>.
            </summary>
            <returns>The string representation of the <see cref="T:Math.Gmp.Native.mp_limb_t">mp_limb_t</see>.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_limb_t.Equals(System.Object)">
            <summary>
            Returns a value indicating whether this instance is equal to a specified object.
            </summary>
            <param name="obj">An object to compare with this instance.</param>
            <returns><c>True</c> if <paramref name="obj"/> is an instance of <see cref="T:Math.Gmp.Native.mp_limb_t">mp_limb_t</see> and equals the value of this instance; otherwise, <c>False</c>.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_limb_t.Equals(Math.Gmp.Native.mp_limb_t)">
            <summary>
            Returns a value indicating whether this instance is equal to a specified <see cref="T:Math.Gmp.Native.mp_limb_t">mp_limb_t</see> value.
            </summary>
            <param name="other">A <see cref="T:Math.Gmp.Native.mp_limb_t">mp_limb_t</see> value to compare to this instance.</param>
            <returns><c>True</c> if <paramref name="other"/> has the same value as this instance; otherwise, <c>False</c>.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_limb_t.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_limb_t.op_Equality(Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_limb_t)">
            <summary>
            Gets a value that indicates whether the two argument values are equal.
            </summary>
            <param name="value1">A <see cref="T:Math.Gmp.Native.mp_limb_t">mp_limb_t</see> value.</param>
            <param name="value2">A <see cref="T:Math.Gmp.Native.mp_limb_t">mp_limb_t</see> value.</param>
            <returns><c>True</c> if the two values are equal, and <c>False</c> otherwise.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_limb_t.op_Inequality(Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_limb_t)">
            <summary>
            Gets a value that indicates whether the two argument values are different.
            </summary>
            <param name="value1">A <see cref="T:Math.Gmp.Native.mp_limb_t">mp_limb_t</see> value.</param>
            <param name="value2">A <see cref="T:Math.Gmp.Native.mp_limb_t">mp_limb_t</see> value.</param>
            <returns><c>True</c> if the two values are different, and <c>False</c> otherwise.</returns>
        </member>
        <member name="T:Math.Gmp.Native.mp_bitcnt_t">
            <summary>
            Represents a count of bits.
            </summary>
            <remarks>
            <para>
            Counts of bits of a multi-precision number are represented in the C type <see cref="T:Math.Gmp.Native.mp_bitcnt_t">mp_bitcnt_t</see>.
            Currently this is always an unsigned long, but on some systems it will be an unsigned long long in the future.
            </para>
            <para>
            In .NET, this is an unsigned 32-bit integer.
            </para>
            </remarks>
            <seealso cref="T:Math.Gmp.Native.mpf_t">mpf_t</seealso>
            <seealso cref="T:Math.Gmp.Native.mpq_t">mpq_t</seealso>
            <seealso cref="T:Math.Gmp.Native.mpz_t">mpz_t</seealso>
        </member>
        <member name="F:Math.Gmp.Native.mp_bitcnt_t.Value">
            <summary>
             The <see cref="T:Math.Gmp.Native.mp_bitcnt_t">mp_bitcnt_t</see> value.
            </summary>
        </member>
        <member name="M:Math.Gmp.Native.mp_bitcnt_t.#ctor(System.UInt32)">
            <summary>
            Creates a new <see cref="T:Math.Gmp.Native.mp_bitcnt_t">mp_bitcnt_t</see>, and sets its <paramref name="value"/>.
            </summary>
            <param name="value">The value of the new <see cref="T:Math.Gmp.Native.mp_bitcnt_t">mp_bitcnt_t</see>.</param>
        </member>
        <member name="M:Math.Gmp.Native.mp_bitcnt_t.op_Implicit(System.Byte)~Math.Gmp.Native.mp_bitcnt_t">
            <summary>
            Converts a <see cref="T:System.Byte">Byte</see> value to an <see cref="T:Math.Gmp.Native.mp_bitcnt_t">mp_bitcnt_t</see> value.
            </summary>
            <param name="value">A <see cref="T:System.Byte">Byte</see> value.</param>
            <returns>An <see cref="T:Math.Gmp.Native.mp_bitcnt_t">mp_bitcnt_t</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_bitcnt_t.op_Explicit(System.SByte)~Math.Gmp.Native.mp_bitcnt_t">
            <summary>
            Converts a <see cref="T:System.Byte">Byte</see> value to an <see cref="T:Math.Gmp.Native.mp_bitcnt_t">mp_bitcnt_t</see> value.
            </summary>
            <param name="value">A <see cref="T:System.Byte">Byte</see> value.</param>
            <returns>An <see cref="T:Math.Gmp.Native.mp_bitcnt_t">mp_bitcnt_t</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_bitcnt_t.op_Implicit(System.UInt16)~Math.Gmp.Native.mp_bitcnt_t">
            <summary>
            Converts a <see cref="T:System.UInt16">UInt16</see> value to an <see cref="T:Math.Gmp.Native.mp_bitcnt_t">mp_bitcnt_t</see> value.
            </summary>
            <param name="value">A <see cref="T:System.UInt16">UInt16</see> value.</param>
            <returns>An <see cref="T:Math.Gmp.Native.mp_bitcnt_t">mp_bitcnt_t</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_bitcnt_t.op_Explicit(System.Int16)~Math.Gmp.Native.mp_bitcnt_t">
            <summary>
            Converts an <see cref="T:System.Int16">Int16</see> value to an <see cref="T:Math.Gmp.Native.mp_bitcnt_t">mp_bitcnt_t</see> value.
            </summary>
            <param name="value">An <see cref="T:System.Int16">Int16</see> value.</param>
            <returns>An <see cref="T:Math.Gmp.Native.mp_bitcnt_t">mp_bitcnt_t</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_bitcnt_t.op_Implicit(System.UInt32)~Math.Gmp.Native.mp_bitcnt_t">
            <summary>
            Converts a <see cref="T:System.UInt32">UInt32</see> value to an <see cref="T:Math.Gmp.Native.mp_bitcnt_t">mp_bitcnt_t</see> value.
            </summary>
            <param name="value">A <see cref="T:System.UInt32">UInt32</see> value.</param>
            <returns>An <see cref="T:Math.Gmp.Native.mp_bitcnt_t">mp_bitcnt_t</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_bitcnt_t.op_Explicit(System.Int32)~Math.Gmp.Native.mp_bitcnt_t">
            <summary>
            Converts an <see cref="T:System.Int32">Int32</see> value to an <see cref="T:Math.Gmp.Native.mp_bitcnt_t">mp_bitcnt_t</see> value.
            </summary>
            <param name="value">An <see cref="T:System.Int32">Int32</see> value.</param>
            <returns>An <see cref="T:Math.Gmp.Native.mp_bitcnt_t">mp_bitcnt_t</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_bitcnt_t.op_Explicit(System.UInt64)~Math.Gmp.Native.mp_bitcnt_t">
            <summary>
            Converts a <see cref="T:System.UInt64">UInt64</see> value to an <see cref="T:Math.Gmp.Native.mp_bitcnt_t">mp_bitcnt_t</see> value.
            </summary>
            <param name="value">A <see cref="T:System.UInt64">UInt64</see> value.</param>
            <returns>An <see cref="T:Math.Gmp.Native.mp_bitcnt_t">mp_bitcnt_t</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_bitcnt_t.op_Explicit(System.Int64)~Math.Gmp.Native.mp_bitcnt_t">
            <summary>
            Converts an <see cref="T:System.Int64">Int64</see> value to a <see cref="T:Math.Gmp.Native.mp_bitcnt_t">mp_bitcnt_t</see> value.
            </summary>
            <param name="value">An <see cref="T:System.Int64">Int64</see> value.</param>
            <returns>An <see cref="T:Math.Gmp.Native.mp_bitcnt_t">mp_bitcnt_t</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_bitcnt_t.op_Explicit(Math.Gmp.Native.mp_bitcnt_t)~System.Byte">
            <summary>
            Converts an <see cref="T:Math.Gmp.Native.mp_bitcnt_t">mp_bitcnt_t</see> value to a <see cref="T:System.Byte">Byte</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Gmp.Native.mp_bitcnt_t">mp_bitcnt_t</see> value.</param>
            <returns>A <see cref="T:System.Byte">Byte</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_bitcnt_t.op_Explicit(Math.Gmp.Native.mp_bitcnt_t)~System.SByte">
            <summary>
            Converts an <see cref="T:Math.Gmp.Native.mp_bitcnt_t">mp_bitcnt_t</see> value to an <see cref="T:System.SByte">SByte</see> value.
            </summary>
            <param name="value">An <see cref="T:System.SByte">SByte</see> value.</param>
            <returns>An <see cref="T:System.Byte">Byte</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_bitcnt_t.op_Explicit(Math.Gmp.Native.mp_bitcnt_t)~System.UInt16">
            <summary>
            Converts an <see cref="T:Math.Gmp.Native.mp_bitcnt_t">mp_bitcnt_t</see> value to a <see cref="T:System.UInt16">UInt16</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Gmp.Native.mp_bitcnt_t">mp_bitcnt_t</see> value.</param>
            <returns>A <see cref="T:System.UInt16">UInt16</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_bitcnt_t.op_Explicit(Math.Gmp.Native.mp_bitcnt_t)~System.Int16">
            <summary>
            Converts an <see cref="T:Math.Gmp.Native.mp_bitcnt_t">mp_bitcnt_t</see> value to an <see cref="T:System.Int16">Int16</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Gmp.Native.mp_bitcnt_t">mp_bitcnt_t</see> value.</param>
            <returns>An <see cref="T:System.Int16">Int16</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_bitcnt_t.op_Implicit(Math.Gmp.Native.mp_bitcnt_t)~System.UInt32">
            <summary>
            Converts an <see cref="T:Math.Gmp.Native.mp_bitcnt_t">mp_bitcnt_t</see> value to a <see cref="T:System.UInt32">UInt32</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Gmp.Native.mp_bitcnt_t">mp_bitcnt_t</see> value.</param>
            <returns>A <see cref="T:System.UInt32">UInt32</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_bitcnt_t.op_Explicit(Math.Gmp.Native.mp_bitcnt_t)~System.Int32">
            <summary>
            Converts an <see cref="T:Math.Gmp.Native.mp_bitcnt_t">mp_bitcnt_t</see> value to an <see cref="T:System.Int32">Int32</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Gmp.Native.mp_bitcnt_t">mp_bitcnt_t</see> value.</param>
            <returns>An <see cref="T:System.Int32">Int32</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_bitcnt_t.op_Implicit(Math.Gmp.Native.mp_bitcnt_t)~System.UInt64">
            <summary>
            Converts an <see cref="T:Math.Gmp.Native.mp_bitcnt_t">mp_bitcnt_t</see> value to a <see cref="T:System.UInt64">UInt64</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Gmp.Native.mp_bitcnt_t">mp_bitcnt_t</see> value.</param>
            <returns>A <see cref="T:System.UInt64">UInt64</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_bitcnt_t.op_Implicit(Math.Gmp.Native.mp_bitcnt_t)~System.Int64">
            <summary>
            Converts an <see cref="T:Math.Gmp.Native.mp_bitcnt_t">mp_bitcnt_t</see> value to an <see cref="T:System.Int64">Int64</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Gmp.Native.mp_bitcnt_t">mp_bitcnt_t</see> value.</param>
            <returns>An <see cref="T:System.Int64">Int64</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_bitcnt_t.ToString">
            <summary>
            Gets the string representation of the <see cref="T:Math.Gmp.Native.mp_bitcnt_t">mp_bitcnt_t</see>.
            </summary>
            <returns>The string representation of the <see cref="T:Math.Gmp.Native.mp_bitcnt_t">mp_bitcnt_t</see>.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_bitcnt_t.Equals(System.Object)">
            <summary>
            Returns a value indicating whether this instance is equal to a specified object.
            </summary>
            <param name="obj">An object to compare with this instance.</param>
            <returns><c>True</c> if <paramref name="obj"/> is an instance of <see cref="T:Math.Gmp.Native.mp_bitcnt_t">mp_bitcnt_t</see> and equals the value of this instance; otherwise, <c>False</c>.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_bitcnt_t.Equals(Math.Gmp.Native.mp_bitcnt_t)">
            <summary>
            Returns a value indicating whether this instance is equal to a specified <see cref="T:Math.Gmp.Native.mp_bitcnt_t">mp_bitcnt_t</see> value.
            </summary>
            <param name="other">A <see cref="T:Math.Gmp.Native.mp_bitcnt_t">mp_bitcnt_t</see> value to compare to this instance.</param>
            <returns><c>True</c> if <paramref name="other"/> has the same value as this instance; otherwise, <c>False</c>.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_bitcnt_t.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_bitcnt_t.op_Equality(Math.Gmp.Native.mp_bitcnt_t,Math.Gmp.Native.mp_bitcnt_t)">
            <summary>
            Gets a value that indicates whether the two argument values are equal.
            </summary>
            <param name="value1">A <see cref="T:Math.Gmp.Native.mp_bitcnt_t">mp_bitcnt_t</see> value.</param>
            <param name="value2">A <see cref="T:Math.Gmp.Native.mp_bitcnt_t">mp_bitcnt_t</see> value.</param>
            <returns><c>True</c> if the two values are equal, and <c>False</c> otherwise.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mp_bitcnt_t.op_Inequality(Math.Gmp.Native.mp_bitcnt_t,Math.Gmp.Native.mp_bitcnt_t)">
            <summary>
            Gets a value that indicates whether the two argument values are different.
            </summary>
            <param name="value1">A <see cref="T:Math.Gmp.Native.mp_bitcnt_t">mp_bitcnt_t</see> value.</param>
            <param name="value2">A <see cref="T:Math.Gmp.Native.mp_bitcnt_t">mp_bitcnt_t</see> value.</param>
            <returns><c>True</c> if the two values are different, and <c>False</c> otherwise.</returns>
        </member>
        <member name="T:Math.Gmp.Native.ptr`1">
            <summary>
            Represents a pointer to a value of type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">A value type.</typeparam>
            <remarks>
            <para>
            Mimics the C address-of (&amp;) construct to pass the address of a value type variable
            to a function of the GMP library.
            </para>
            <para>
            Note that this is only for value types. Strings and arrays have their own "pointer"
            types defined with names ending in <c>_ptr</c>.
            </para>
            </remarks>
        </member>
        <member name="F:Math.Gmp.Native.ptr`1.Value">
            <summary>
            The value that is "pointed to".
            </summary>
        </member>
        <member name="M:Math.Gmp.Native.ptr`1.#ctor">
            <summary>
            Creates a new pointer with default value.
            </summary>
        </member>
        <member name="M:Math.Gmp.Native.ptr`1.#ctor(`0)">
            <summary>
            Creates a new pointer with <see cref="F:Math.Gmp.Native.ptr`1.Value">Value</see> set to <paramref name="value"/>.
            </summary>
            <param name="value">The initial value.</param>
        </member>
        <member name="T:Math.Gmp.Native.size_t">
            <summary>
            Represents a count of characters or bytes.
            </summary>
            <remarks>
            <para>
            In .NET, this is an unsigned 64-bit integer.
            </para>
            </remarks>
        </member>
        <member name="F:Math.Gmp.Native.size_t.Value">
            <summary>
             The <see cref="T:Math.Gmp.Native.size_t">size_t</see> value.
            </summary>
        </member>
        <member name="M:Math.Gmp.Native.size_t.#ctor(System.UInt64)">
            <summary>
            Creates a new <see cref="T:Math.Gmp.Native.size_t">size_t</see>, and sets its <paramref name="value"/>.
            </summary>
            <param name="value">The value of the new <see cref="T:Math.Gmp.Native.size_t">size_t</see>.</param>
        </member>
        <member name="M:Math.Gmp.Native.size_t.op_Implicit(System.Byte)~Math.Gmp.Native.size_t">
            <summary>
            Converts a <see cref="T:System.Byte">Byte</see> value to a <see cref="T:Math.Gmp.Native.size_t">size_t</see> value.
            </summary>
            <param name="value">A <see cref="T:System.Byte">Byte</see> value.</param>
            <returns>A <see cref="T:Math.Gmp.Native.size_t">size_t</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.size_t.op_Explicit(System.SByte)~Math.Gmp.Native.size_t">
            <summary>
            Converts a <see cref="T:System.SByte">SByte</see> value to a <see cref="T:Math.Gmp.Native.size_t">size_t</see> value.
            </summary>
            <param name="value">A <see cref="T:System.SByte">SByte</see> value.</param>
            <returns>A <see cref="T:Math.Gmp.Native.size_t">size_t</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.size_t.op_Implicit(System.UInt16)~Math.Gmp.Native.size_t">
            <summary>
            Converts a <see cref="T:System.UInt16">UInt16</see> value to a <see cref="T:Math.Gmp.Native.size_t">size_t</see> value.
            </summary>
            <param name="value">A <see cref="T:System.UInt16">UInt16</see> value.</param>
            <returns>A <see cref="T:Math.Gmp.Native.size_t">size_t</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.size_t.op_Explicit(System.Int16)~Math.Gmp.Native.size_t">
            <summary>
            Converts an <see cref="T:System.Int16">Int16</see> value to a <see cref="T:Math.Gmp.Native.size_t">size_t</see> value.
            </summary>
            <param name="value">An <see cref="T:System.Int16">Int16</see> value.</param>
            <returns>A <see cref="T:Math.Gmp.Native.size_t">size_t</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.size_t.op_Implicit(System.UInt32)~Math.Gmp.Native.size_t">
            <summary>
            Converts a <see cref="T:System.UInt32">UInt32</see> value to a <see cref="T:Math.Gmp.Native.size_t">size_t</see> value.
            </summary>
            <param name="value">A <see cref="T:System.UInt32">UInt32</see> value.</param>
            <returns>A <see cref="T:Math.Gmp.Native.size_t">size_t</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.size_t.op_Explicit(System.Int32)~Math.Gmp.Native.size_t">
            <summary>
            Converts an <see cref="T:System.Int32">Int32</see> value to a <see cref="T:Math.Gmp.Native.size_t">size_t</see> value.
            </summary>
            <param name="value">An <see cref="T:System.Int32">Int32</see> value.</param>
            <returns>A <see cref="T:Math.Gmp.Native.size_t">size_t</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.size_t.op_Implicit(System.UInt64)~Math.Gmp.Native.size_t">
            <summary>
            Converts a <see cref="T:System.UInt64">UInt64</see> value to a <see cref="T:Math.Gmp.Native.size_t">size_t</see> value.
            </summary>
            <param name="value">A <see cref="T:System.UInt64">UInt64</see> value.</param>
            <returns>A <see cref="T:Math.Gmp.Native.size_t">size_t</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.size_t.op_Explicit(System.Int64)~Math.Gmp.Native.size_t">
            <summary>
            Converts an <see cref="T:System.Int64">Int64</see> value to a <see cref="T:Math.Gmp.Native.size_t">size_t</see> value.
            </summary>
            <param name="value">An <see cref="T:System.Int64">Int64</see> value.</param>
            <returns>A <see cref="T:Math.Gmp.Native.size_t">size_t</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.size_t.op_Explicit(Math.Gmp.Native.size_t)~System.Byte">
            <summary>
            Converts a <see cref="T:Math.Gmp.Native.size_t">size_t</see> value to a <see cref="T:System.Byte">Byte</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Gmp.Native.size_t">size_t</see> value.</param>
            <returns>A <see cref="T:System.Byte">Byte</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.size_t.op_Explicit(Math.Gmp.Native.size_t)~System.SByte">
            <summary>
            Converts a <see cref="T:Math.Gmp.Native.size_t">size_t</see> value to an <see cref="T:System.SByte">SByte</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Gmp.Native.size_t">size_t</see> value.</param>
            <returns>An <see cref="T:System.SByte">SByte</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.size_t.op_Explicit(Math.Gmp.Native.size_t)~System.UInt16">
            <summary>
            Converts a <see cref="T:Math.Gmp.Native.size_t">size_t</see> value to a <see cref="T:System.UInt16">UInt16</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Gmp.Native.size_t">size_t</see> value.</param>
            <returns>A <see cref="T:System.UInt16">UInt16</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.size_t.op_Explicit(Math.Gmp.Native.size_t)~System.Int16">
            <summary>
            Converts a <see cref="T:Math.Gmp.Native.size_t">size_t</see> value to an <see cref="T:System.Int16">Int16</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Gmp.Native.size_t">size_t</see> value.</param>
            <returns>An <see cref="T:System.Int16">Int16</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.size_t.op_Explicit(Math.Gmp.Native.size_t)~System.UInt32">
            <summary>
            Converts a <see cref="T:Math.Gmp.Native.size_t">size_t</see> value to a <see cref="T:System.UInt32">UInt32</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Gmp.Native.size_t">size_t</see> value.</param>
            <returns>A <see cref="T:System.UInt32">UInt32</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.size_t.op_Explicit(Math.Gmp.Native.size_t)~System.Int32">
            <summary>
            Converts a <see cref="T:Math.Gmp.Native.size_t">size_t</see> value to an <see cref="T:System.Int32">Int32</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Gmp.Native.size_t">size_t</see> value.</param>
            <returns>An <see cref="T:System.Int32">Int32</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.size_t.op_Implicit(Math.Gmp.Native.size_t)~System.UInt64">
            <summary>
            Converts a <see cref="T:Math.Gmp.Native.size_t">size_t</see> value to a <see cref="T:System.UInt64">UInt64</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Gmp.Native.size_t">size_t</see> value.</param>
            <returns>A <see cref="T:System.UInt64">UInt64</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.size_t.op_Explicit(Math.Gmp.Native.size_t)~System.Int64">
            <summary>
            Converts a <see cref="T:Math.Gmp.Native.size_t">size_t</see> value to an <see cref="T:System.Int64">Int64</see> value.
            </summary>
            <param name="value">An <see cref="T:Math.Gmp.Native.size_t">size_t</see> value.</param>
            <returns>An <see cref="T:System.Int64">Int64</see> value.</returns>
        </member>
        <member name="M:Math.Gmp.Native.size_t.ToString">
            <summary>
            Gets the string representation of the <see cref="T:Math.Gmp.Native.size_t">size_t</see>.
            </summary>
            <returns>The string representation of the <see cref="T:Math.Gmp.Native.size_t">size_t</see>.</returns>
        </member>
        <member name="M:Math.Gmp.Native.size_t.Equals(System.Object)">
            <summary>
            Returns a value indicating whether this instance is equal to a specified object.
            </summary>
            <param name="obj">An object to compare with this instance.</param>
            <returns><c>True</c> if <paramref name="obj"/> is an instance of <see cref="T:Math.Gmp.Native.size_t">size_t</see> and equals the value of this instance; otherwise, <c>False</c>.</returns>
        </member>
        <member name="M:Math.Gmp.Native.size_t.Equals(Math.Gmp.Native.size_t)">
            <summary>
            Returns a value indicating whether this instance is equal to a specified <see cref="T:Math.Gmp.Native.size_t">size_t</see> value.
            </summary>
            <param name="other">A <see cref="T:Math.Gmp.Native.size_t">size_t</see> value to compare to this instance.</param>
            <returns><c>True</c> if <paramref name="other"/> has the same value as this instance; otherwise, <c>False</c>.</returns>
        </member>
        <member name="M:Math.Gmp.Native.size_t.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:Math.Gmp.Native.size_t.op_Equality(Math.Gmp.Native.size_t,Math.Gmp.Native.size_t)">
            <summary>
            Gets a value that indicates whether the two argument values are equal.
            </summary>
            <param name="value1">A <see cref="T:Math.Gmp.Native.size_t">size_t</see> value.</param>
            <param name="value2">A <see cref="T:Math.Gmp.Native.size_t">size_t</see> value.</param>
            <returns><c>True</c> if the two values are equal, and <c>False</c> otherwise.</returns>
        </member>
        <member name="M:Math.Gmp.Native.size_t.op_Inequality(Math.Gmp.Native.size_t,Math.Gmp.Native.size_t)">
            <summary>
            Gets a value that indicates whether the two argument values are different.
            </summary>
            <param name="value1">A <see cref="T:Math.Gmp.Native.size_t">size_t</see> value.</param>
            <param name="value2">A <see cref="T:Math.Gmp.Native.size_t">size_t</see> value.</param>
            <returns><c>True</c> if the two values are different, and <c>False</c> otherwise.</returns>
        </member>
        <member name="T:Math.Gmp.Native.void_ptr">
            <summary>
            Represents a pointer to a block of unmanaged memory.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Math.Gmp.Native.void_ptr.#ctor(System.IntPtr)">
            <summary>
            Creates new <see cref="T:Math.Gmp.Native.void_ptr">void_ptr</see> from an exidting pointer to unmanaged memory.
            </summary>
            <param name="pointer">Pointer to unmanaged memory.</param>
        </member>
        <member name="M:Math.Gmp.Native.void_ptr.FromIntPtr(System.IntPtr)">
            <summary>
            Gets a <see cref="T:Math.Gmp.Native.void_ptr">void_ptr</see> from a pointer to a block of unmanaged memory.
            </summary>
            <param name="value">A pointer to a block of unmanaged memory.</param>
            <returns>A <see cref="T:Math.Gmp.Native.void_ptr">void_ptr</see> from a pointer to a block of unmanaged memory.</returns>
        </member>
        <member name="M:Math.Gmp.Native.void_ptr.ToIntPtr">
            <summary>
            Gets pointer to block of unmanaged memory.
            </summary>
            <returns>Pointer to block of unmanaged memory.</returns>
        </member>
        <member name="F:Math.Gmp.Native.void_ptr.Zero">
            <summary>
            Gets a null <see cref="T:Math.Gmp.Native.void_ptr">void_ptr</see>.
            </summary>
        </member>
        <member name="M:Math.Gmp.Native.void_ptr.Equals(System.Object)">
            <summary>
            Returns a value indicating whether this instance is equal to a specified object.
            </summary>
            <param name="obj">An object to compare with this instance.</param>
            <returns><c>True</c> if <paramref name="obj"/> is an instance of <see cref="T:Math.Gmp.Native.void_ptr">void_ptr</see> and equals the value of this instance; otherwise, <c>False</c>.</returns>
        </member>
        <member name="M:Math.Gmp.Native.void_ptr.Equals(Math.Gmp.Native.void_ptr)">
            <summary>
            Returns a value indicating whether this instance is equal to a specified <see cref="T:Math.Gmp.Native.void_ptr">void_ptr</see> value.
            </summary>
            <param name="other">A <see cref="T:Math.Gmp.Native.void_ptr">void_ptr</see> value to compare to this instance.</param>
            <returns><c>True</c> if <paramref name="other"/> has the same value as this instance; otherwise, <c>False</c>.</returns>
        </member>
        <member name="M:Math.Gmp.Native.void_ptr.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:Math.Gmp.Native.void_ptr.op_Equality(Math.Gmp.Native.void_ptr,Math.Gmp.Native.void_ptr)">
            <summary>
            Gets a value that indicates whether the two argument values are equal.
            </summary>
            <param name="value1">A <see cref="T:Math.Gmp.Native.void_ptr">void_ptr</see> value.</param>
            <param name="value2">A <see cref="T:Math.Gmp.Native.void_ptr">void_ptr</see> value.</param>
            <returns><c>True</c> if the two values are equal, and <c>False</c> otherwise.</returns>
        </member>
        <member name="M:Math.Gmp.Native.void_ptr.op_Inequality(Math.Gmp.Native.void_ptr,Math.Gmp.Native.void_ptr)">
            <summary>
            Gets a value that indicates whether the two argument values are different.
            </summary>
            <param name="value1">A <see cref="T:Math.Gmp.Native.void_ptr">void_ptr</see> value.</param>
            <param name="value2">A <see cref="T:Math.Gmp.Native.void_ptr">void_ptr</see> value.</param>
            <returns><c>True</c> if the two values are different, and <c>False</c> otherwise.</returns>
        </member>
        <member name="T:Math.Gmp.Native.free_function">
            <summary>
            De-allocate the space pointed to by <paramref name="ptr"/>.
            </summary>
            <param name="ptr">Pointer to previously allocated block.</param>
            <param name="size">Number of bytes of previously allocated block.</param>
        </member>
        <member name="T:Math.Gmp.Native.char_ptr">
            <summary>
            Represents a pointer to a string in unmanaged memory.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Math.Gmp.Native.char_ptr.Pointer">
            <summary>
            Pointer to string in unmanaged memory.
            </summary>
        </member>
        <member name="M:Math.Gmp.Native.char_ptr.#ctor(System.String)">
            <summary>
            Creates new string in unmanaged memory and initializes it with <paramref name="str"/>.
            </summary>
            <param name="str">The value of the new string.</param>
            <remarks>
            <para>
            When done with the string, unmanaged memory must be released with <see cref="M:Math.Gmp.Native.gmp_lib.free(Math.Gmp.Native.char_ptr)">free</see>.
            </para>
            </remarks>
        </member>
        <member name="M:Math.Gmp.Native.char_ptr.#ctor(System.IntPtr)">
            <summary>
            Creates new string using an already allocated string in unmanaged memory.
            </summary>
            <param name="pointer">Pointer to existing string in unmanaged memory.</param>
        </member>
        <member name="M:Math.Gmp.Native.char_ptr.ToIntPtr">
            <summary>
            Gets pointer to string in unmanaged memory.
            </summary>
            <returns>Pointer to string in unmanaged memory.</returns>
        </member>
        <member name="F:Math.Gmp.Native.char_ptr.Zero">
            <summary>
            Gets a null <see cref="T:Math.Gmp.Native.char_ptr">char_ptr</see>.
            </summary>
        </member>
        <member name="M:Math.Gmp.Native.char_ptr.ToString">
            <summary>
            Gets the .NET <see cref="T:System.String">string</see> equivalent of the unmanaged string.
            </summary>
            <returns>The .NET <see cref="T:System.String">string</see> equivalent of the unmanaged string.</returns>
        </member>
        <member name="M:Math.Gmp.Native.char_ptr.Equals(System.Object)">
            <summary>
            Returns a value indicating whether this instance is equal to a specified object.
            </summary>
            <param name="obj">An object to compare with this instance.</param>
            <returns><c>True</c> if <paramref name="obj"/> is an instance of <see cref="T:Math.Gmp.Native.char_ptr">char_ptr</see> and equals the value of this instance; otherwise, <c>False</c>.</returns>
        </member>
        <member name="M:Math.Gmp.Native.char_ptr.Equals(Math.Gmp.Native.char_ptr)">
            <summary>
            Returns a value indicating whether this instance is equal to a specified <see cref="T:Math.Gmp.Native.char_ptr">char_ptr</see> value.
            </summary>
            <param name="other">A <see cref="T:Math.Gmp.Native.char_ptr">char_ptr</see> value to compare to this instance.</param>
            <returns><c>True</c> if <paramref name="other"/> has the same value as this instance; otherwise, <c>False</c>.</returns>
        </member>
        <member name="M:Math.Gmp.Native.char_ptr.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:Math.Gmp.Native.char_ptr.op_Equality(Math.Gmp.Native.char_ptr,Math.Gmp.Native.char_ptr)">
            <summary>
            Gets a value that indicates whether the two argument values are equal.
            </summary>
            <param name="value1">A <see cref="T:Math.Gmp.Native.char_ptr">char_ptr</see> value.</param>
            <param name="value2">A <see cref="T:Math.Gmp.Native.char_ptr">char_ptr</see> value.</param>
            <returns><c>True</c> if the two values are equal, and <c>False</c> otherwise.</returns>
        </member>
        <member name="M:Math.Gmp.Native.char_ptr.op_Inequality(Math.Gmp.Native.char_ptr,Math.Gmp.Native.char_ptr)">
            <summary>
            Gets a value that indicates whether the two argument values are different.
            </summary>
            <param name="value1">A <see cref="T:Math.Gmp.Native.char_ptr">char_ptr</see> value.</param>
            <param name="value2">A <see cref="T:Math.Gmp.Native.char_ptr">char_ptr</see> value.</param>
            <returns><c>True</c> if the two values are different, and <c>False</c> otherwise.</returns>
        </member>
        <member name="T:Math.Gmp.Native.reallocate_function">
            <summary>
            Resize a previously allocated block ptr of <paramref name="old_size"/> bytes to be <paramref name="new_size"/> bytes.
            </summary>
            <param name="ptr">Pointer to previously allocated block.</param>
            <param name="old_size">Number of bytes of previously allocated block.</param>
            <param name="new_size">New number of bytes of previously allocated block.</param>
            <returns>A previously allocated block ptr of <paramref name="old_size"/> bytes to be <paramref name="new_size"/> bytes.</returns>
        </member>
        <member name="T:Math.Gmp.Native.allocate_function">
            <summary>
            Return a pointer to newly allocated space with at least <paramref name="alloc_size"/> bytes.
            </summary>
            <param name="alloc_size">The minimum number of bytes to allocate.</param>
            <returns>A pointer to newly allocated space with at least <paramref name="alloc_size"/> bytes.</returns>
        </member>
        <member name="T:Math.Gmp.Native.gmp_lib">
            <summary>
            Represents all of the functions of the GNU MP library.
            </summary>
            <remarks>
            <para>
            <h2>Functions Categories</h2>
            </para>
            <para><a name="Global_Variable_and_Constants"/><h3>Global Variable and Constants:</h3></para>
            <list type="bullet">
            <item><description><see cref="P:Math.Gmp.Native.gmp_lib.gmp_errno">gmp_errno</see> - Gets or sets the global GMP error number.</description></item>
            <item><description><see cref="F:Math.Gmp.Native.gmp_lib.gmp_version">gmp_version</see> - The GMP version number in the form “i.j.k”. This release is "6.1.2".</description></item>
            <item><description><see cref="F:Math.Gmp.Native.gmp_lib.mp_bits_per_limb">mp_bits_per_limb</see> - The number of bits per limb.</description></item>
            <item><description><see cref="F:Math.Gmp.Native.gmp_lib.mp_bytes_per_limb">mp_bytes_per_limb</see> - The number of bytes per limb.</description></item>
            <item><description><see cref="F:Math.Gmp.Native.gmp_lib.mp_uint_per_limb">mp_uint_per_limb</see> - The number of 32-bit, unsigned integers per limb.</description></item>
            </list>
            <para><a name="Integer_Functions"/><h3>Integer Functions:</h3></para>
            <para><a name="Initializing_Integers"/><h4>Initializing Integers:</h4></para>
            <list type="bullet">
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_init(Math.Gmp.Native.mpz_t)">mpz_init</see> - Initialize <i>x</i>, and set its value to 0.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_inits(Math.Gmp.Native.mpz_t[])">mpz_inits</see> - Initialize a NULL-terminated list of <see cref="T:Math.Gmp.Native.mpz_t">mpz_t</see> variables, and set their values to 0.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_init2(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_init2</see> - Initialize <i>x</i>, with space for <i>n</i>-bit numbers, and set its value to 0.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_clear(Math.Gmp.Native.mpz_t)">mpz_clear</see> - Free the space occupied by <i>x</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_clears(Math.Gmp.Native.mpz_t[])">mpz_clears</see> - Free the space occupied by a NULL-terminated list of <see cref="T:Math.Gmp.Native.mpz_t">mpz_t</see> variables.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_realloc2(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_realloc2</see> - Change the space allocated for <i>x</i> to <i>n</i> bits.</description></item>
            </list>
            <para><a name="Assigning_Integers"/><h4>Assigning Integers:</h4></para>
            <list type="bullet">
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_set(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_set</see> - Set the value of <i>rop</i> from <i>op</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_set_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_set_ui</see> - Set the value of <i>rop</i> from <i>op</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_set_si(Math.Gmp.Native.mpz_t,System.Int32)">mpz_set_si</see> - Set the value of <i>rop</i> from <i>op</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_set_d(Math.Gmp.Native.mpz_t,System.Double)">mpz_set_d</see> - Set the value of <i>rop</i> from <i>op</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_set_q(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpq_t)">mpz_set_q</see> - Set the value of <i>rop</i> from <i>op</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_set_f(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpf_t)">mpz_set_f</see> - Set the value of <i>rop</i> from <i>op</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_set_str(Math.Gmp.Native.mpz_t,Math.Gmp.Native.char_ptr,System.Int32)">mpz_set_str</see> - Set the value of <i>rop</i> from <i>str</i>, a null-terminated C string in base <i>base</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_swap(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_swap</see> - Swap the values <i>rop1</i> and <i>rop2</i> efficiently.</description></item>
            </list>
            <para><a name="Simultaneous_Integer_Init_Assign"/><h4>Simultaneous Integer Init &amp; Assign:</h4></para>
            <list type="bullet">
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_init_set(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_init_set</see> - Initialize <i>rop</i> with limb space and set the initial numeric value from <i>op</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_init_set_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_init_set_ui</see> - Initialize <i>rop</i> with limb space and set the initial numeric value from <i>op</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_init_set_si(Math.Gmp.Native.mpz_t,System.Int32)">mpz_init_set_si</see> - Initialize <i>rop</i> with limb space and set the initial numeric value from <i>op</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_init_set_d(Math.Gmp.Native.mpz_t,System.Double)">mpz_init_set_d</see> - Initialize <i>rop</i> with limb space and set the initial numeric value from <i>op</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_set_str(Math.Gmp.Native.mpz_t,Math.Gmp.Native.char_ptr,System.Int32)">mpz_set_str</see> - Set the value of <i>rop</i> from <i>str</i>, a null-terminated C string in base <i>base</i>.</description></item>
            </list>
            <para><a name="Converting_Integers"/><h4>Converting Integers:</h4></para>
            <list type="bullet">
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_get_ui(Math.Gmp.Native.mpz_t)">mpz_get_ui</see> - Return the value of <i>op</i> as an unsigned long.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_get_si(Math.Gmp.Native.mpz_t)">mpz_get_si</see> - Return the value of <i>op</i> as an signed long.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_get_d(Math.Gmp.Native.mpz_t)">mpz_get_d</see> - Convert <i>op</i> to a double, truncating if necessary (i.e. rounding towards zero).</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_get_d_2exp(System.Int32@,Math.Gmp.Native.mpz_t)">mpz_get_d_2exp</see> - Convert <i>op</i> to a double, truncating if necessary (i.e. rounding towards zero), and returning the exponent separately.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_get_str(Math.Gmp.Native.char_ptr,System.Int32,Math.Gmp.Native.mpz_t)">mpz_get_str</see> - Convert <i>op</i> to a string of digits in base <i>base</i>.</description></item>
            </list>
            <para><a name="Integer_Arithmetic"/><h4>Integer Arithmetic:</h4></para>
            <list type="bullet">
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_add(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_add</see> - Set <i>rop</i> to <i>op1</i> + <i>op2</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_add_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_add_ui</see> - Set <i>rop</i> to <i>op1</i> + <i>op2</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_sub(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_sub</see> - Set <i>rop</i> to <i>op1</i> - <i>op2</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_sub_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_sub_ui</see> - Set <i>rop</i> to <i>op1</i> - <i>op2</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_ui_sub(Math.Gmp.Native.mpz_t,System.UInt32,Math.Gmp.Native.mpz_t)">mpz_ui_sub</see> - Set <i>rop</i> to <i>op1</i> - <i>op2</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_mul(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_mul</see> - Set <i>rop</i> to <i>op1</i> * <i>op2</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_mul_si(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.Int32)">mpz_mul_si</see> - Set <i>rop</i> to <i>op1</i> * <i>op2</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_mul_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_mul_ui</see> - Set <i>rop</i> to <i>op1</i> * <i>op2</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_addmul(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_addmul</see> - Set <i>rop</i> to <i>rop</i> + <i>op1</i> * <i>op2</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_addmul_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_addmul_ui</see> - Set <i>rop</i> to <i>rop</i> + <i>op1</i> * <i>op2</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_submul(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_submul</see> - Set <i>rop</i> to <i>rop</i> - <i>op1</i> * <i>op2</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_submul_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_submul_ui</see> - Set <i>rop</i> to <i>rop</i> - <i>op1</i> * <i>op2</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_mul_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_mul_2exp</see> - Set <i>rop</i> to <i>op1</i> * 2^<i>op2</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_neg(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_neg</see> - Set <i>rop</i> to -<i>op</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_abs(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_abs</see> - Set <i>rop</i> to the absolute value of <i>op</i>.</description></item>
            </list>
            <para><a name="Integer_Division"/><h4>Integer Division:</h4></para>
            <list type="bullet">
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_q(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_q</see> - Set the quotient <i>q</i> to ceiling(<i>n</i> / <i>d</i>).</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_r(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_r</see> - Set the remainder <i>r</i> to <i>n</i> - q * <i>d</i> where q = ceiling(<i>n</i> / <i>d</i>).</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_qr</see> - Set the quotient <i>q</i> to ceiling(<i>n</i> / <i>d</i>), and set the remainder <i>r</i> to <i>n</i> - <i>q</i> * <i>d</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_q_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_cdiv_q_ui</see> - Set the quotient <i>q</i> to ceiling(<i>n</i> / <i>d</i>), and return the remainder r = | <i>n</i> - <i>q</i> * <i>d</i> |.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_r_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_cdiv_r_ui</see> - Set the remainder <i>r</i> to <i>n</i> - q * <i>d</i> where q = ceiling(<i>n</i> / <i>d</i>), and return | <i>r</i> |.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_qr_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_cdiv_qr_ui</see> - Set quotient <i>q</i> to ceiling(<i>n</i> / <i>d</i>), set the remainder <i>r</i> to <i>n</i> - <i>q</i> * <i>d</i>, and return | <i>r</i> |.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_cdiv_ui</see> - Return the remainder | r | where r = <i>n</i> - q * <i>d</i>, and where q = ceiling(<i>n</i> / <i>d</i>).</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_q_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_cdiv_q_2exp</see> - Set the quotient <i>q</i> to ceiling(<i>n</i> / 2^<i>b</i>).</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_r_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_cdiv_r_2exp</see> - Set the remainder <i>r</i> to <i>n</i> - q * 2^<i>b</i> where q = ceiling(<i>n</i> / 2^<i>b</i>).</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_q(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_fdiv_q</see> - Set the quotient <i>q</i> to floor(<i>n</i> / <i>d</i>).</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_r(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_fdiv_r</see> - Set the remainder <i>r</i> to <i>n</i> - q * <i>d</i> where q = floor(<i>n</i> / <i>d</i>).</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_fdiv_qr</see> - Set the quotient <i>q</i> to floor(<i>n</i> / <i>d</i>), and set the remainder <i>r</i> to <i>n</i> - <i>q</i> * <i>d</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_q_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_fdiv_q_ui</see> - Set the quotient <i>q</i> to floor(<i>n</i> / <i>d</i>), and return the remainder r = | <i>n</i> - <i>q</i> * <i>d</i> |.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_r_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_fdiv_r_ui</see> - Set the remainder <i>r</i> to <i>n</i> - q * <i>d</i> where q = floor(<i>n</i> / <i>d</i>), and return | <i>r</i> |.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_qr_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_fdiv_qr_ui</see> - Set quotient <i>q</i> to floor(<i>n</i> / <i>d</i>), set the remainder <i>r</i> to <i>n</i> - <i>q</i> * <i>d</i>, and return | <i>r</i> |.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_fdiv_ui</see> - Return the remainder | r | where r = <i>n</i> - q * <i>d</i>, and where q = floor(<i>n</i> / <i>d</i>).</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_q_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_fdiv_q_2exp</see> - Set the quotient <i>q</i> to floor(<i>n</i> / 2^<i>b</i>).</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_r_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_fdiv_r_2exp</see> - Set the remainder <i>r</i> to <i>n</i> - q * 2^<i>b</i> where q = floor(<i>n</i> / 2^<i>b</i>).</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_q(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_q</see> - Set the quotient <i>q</i> to trunc(<i>n</i> / <i>d</i>).</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_r(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_r</see> - Set the remainder <i>r</i> to <i>n</i> - q * <i>d</i> where q = trunc(<i>n</i> / <i>d</i>).</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_qr</see> - Set the quotient <i>q</i> to trunc(<i>n</i> / <i>d</i>), and set the remainder <i>r</i> to <i>n</i> - <i>q</i> * <i>d</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_q_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_tdiv_q_ui</see> - Set the quotient <i>q</i> to trunc(<i>n</i> / <i>d</i>), and return the remainder r = | <i>n</i> - <i>q</i> * <i>d</i> |.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_r_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_tdiv_r_ui</see> - Set the remainder <i>r</i> to <i>n</i> - q * <i>d</i> where q = trunc(<i>n</i> / <i>d</i>), and return | <i>r</i> |.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_qr_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_tdiv_qr_ui</see> - Set quotient <i>q</i> to trunc(<i>n</i> / <i>d</i>), set the remainder <i>r</i> to <i>n</i> - <i>q</i> * <i>d</i>, and return | <i>r</i> |.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_tdiv_ui</see> - Return the remainder | r | where r = <i>n</i> - q * <i>d</i>, and where q = trunc(<i>n</i> / <i>d</i>).</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_q_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_tdiv_q_2exp</see> - Set the quotient <i>q</i> to trunc(<i>n</i> / 2^<i>b</i>).</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_r_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_tdiv_r_2exp</see> - Set the remainder <i>r</i> to <i>n</i> - q * 2^<i>b</i> where q = trunc(<i>n</i> / 2^<i>b</i>).</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_mod(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_mod</see> - Set <i>r</i> to <i>n</i> mod <i>d</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_mod_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_mod_ui</see> - Set <i>r</i> to <i>n</i> mod <i>d</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_divexact(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divexact</see> - Set <i>q</i> to <i>n</i> / <i>d</i> when it is known in advance that <i>d</i> divides <i>n</i>. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_divexact_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_divexact_ui</see> - Set <i>q</i> to <i>n</i> / <i>d</i> when it is known in advance that <i>d</i> divides <i>n</i>. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_divisible_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divisible_p</see> - Return non-zero if <i>n</i> is exactly divisible by <i>d</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_divisible_ui_p(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_divisible_ui_p</see> - Return non-zero if <i>n</i> is exactly divisible by <i>d</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_divisible_2exp_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_divisible_2exp_p</see> - Return non-zero if <i>n</i> is exactly divisible by 2^<i>b</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_congruent_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_congruent_p</see> - Return non-zero if <i>n</i> is congruent to <i>c</i> modulo <i>d</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_congruent_ui_p(Math.Gmp.Native.mpz_t,System.UInt32,System.UInt32)">mpz_congruent_ui_p</see> - Return non-zero if <i>n</i> is congruent to <i>c</i> modulo <i>d</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_congruent_2exp_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_congruent_2exp_p</see> - Return non-zero if <i>n</i> is congruent to <i>c</i> modulo 2^<i>b</i>.</description></item>
            </list>
            <para><a name="Integer_Exponentiation"/><h4>Integer Exponentiation:</h4></para>
            <list type="bullet">
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_powm(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_powm</see> - Set <i>rop</i> to (<i>base</i>^<i>exp</i>) modulo <i>mod</i>. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_powm_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32,Math.Gmp.Native.mpz_t)">mpz_powm_ui</see> - Set <i>rop</i> to (<i>base</i>^<i>exp</i>) modulo <i>mod</i>. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_powm_sec(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_powm_sec</see> - Set <i>rop</i> to (<i>base</i>^<i>exp</i>) modulo <i>mod</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_pow_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_pow_ui</see> - Set <i>rop</i> to <i>base</i>^<i>exp</i>. The case 0^0 yields 1. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_ui_pow_ui(Math.Gmp.Native.mpz_t,System.UInt32,System.UInt32)">mpz_ui_pow_ui</see> - Set <i>rop</i> to <i>base</i>^<i>exp</i>. The case 0^0 yields 1.</description></item>
            </list>
            <para><a name="Integer_Roots"/><h4>Integer Roots:</h4></para>
            <list type="bullet">
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_root(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_root</see> - Set <i>rop</i> to the truncated integer part of the <i>n</i>th root of <i>op</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_rootrem(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_rootrem</see> - Set <i>root</i> to the truncated integer part of the <i>n</i>th root of <i>u</i>. Set <i>rem</i> to the remainder, <i>u</i> - <i>root</i>^<i>n</i>. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_sqrt(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_sqrt</see> - Set <i>rop</i> to the truncated integer part of the square root of <i>op</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_sqrtrem(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_sqrtrem</see> - Set <i>rop1</i> to the truncated integer part of the square root of <i>op</i>, like <see cre="mpz_sqrt">mpz_sqrt</see>. Set <i>rop2</i> to the remainder <i>op</i> - <i>rop1</i> * <i>rop1</i>, which will be zero if <i>op</i> is a perfect square.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_perfect_power_p(Math.Gmp.Native.mpz_t)">mpz_perfect_power_p</see> - Return non-zero if <i>op</i> is a perfect power, i.e., if there exist integers a and b, with b &gt; 1, such that <i>op</i> = a^b. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_perfect_square_p(Math.Gmp.Native.mpz_t)">mpz_perfect_square_p</see> - Return non-zero if <i>op</i> is a perfect square, i.e., if the square root of <i>op</i> is an integer.</description></item>
            </list>
            <para><a name="Number_Theoretic_Functions"/><h4>Number Theoretic Functions:</h4></para>
            <list type="bullet">
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_probab_prime_p(Math.Gmp.Native.mpz_t,System.Int32)">mpz_probab_prime_p</see> - Determine whether <i>n</i> is prime.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_nextprime(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_nextprime</see> - Set <i>rop</i> to the next prime greater than <i>op</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_gcd(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_gcd</see> - Set <i>rop</i> to the greatest common divisor of <i>op1</i> and <i>op2</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_gcd_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_gcd_ui</see> - Compute the greatest common divisor of <i>op1</i> and <i>op2</i>. If <i>rop</i> is not null, store the result there. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_gcdext(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_gcdext</see> - Set <i>g</i> to the greatest common divisor of <i>a</i> and <i>b</i>, and in addition set <i>s</i> and <i>t</i> to coefficients satisfying <i>a</i> * <i>s</i> + <i>b</i> * <i>t</i> = <i>g</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_lcm(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_lcm</see> - Set <i>rop</i> to the least common multiple of <i>op1</i> and <i>op2</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_lcm_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_lcm_ui</see> - Set <i>rop</i> to the least common multiple of <i>op1</i> and <i>op2</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_invert(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_invert</see> - Compute the inverse of <i>op1</i> modulo <i>op2</i> and put the result in <i>rop</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_jacobi(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_jacobi</see> - Calculate the Jacobi symbol (<i>a</i>/<i>b</i>).</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_legendre(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_legendre</see> - Calculate the Legendre symbol (<i>a</i>/<i>p</i>).</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_kronecker(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_kronecker</see> - Calculate the Jacobi symbol (<i>a</i>/<i>b</i>) with the Kronecker extension (<i>a</i>/2) = (2/<i>a</i>) when <i>a</i> odd, or (<i>a</i>/2) = 0 when <i>a</i> even. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_kronecker_si(Math.Gmp.Native.mpz_t,System.Int32)">mpz_kronecker_si</see> - Calculate the Jacobi symbol (<i>a</i>/<i>b</i>) with the Kronecker extension (<i>a</i>/2) = (2/<i>a</i>) when <i>a</i> odd, or (<i>a</i>/2) = 0 when <i>a</i> even. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_kronecker_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_kronecker_ui</see> - Calculate the Jacobi symbol (<i>a</i>/<i>b</i>) with the Kronecker extension (<i>a</i>/2) = (2/<i>a</i>) when <i>a</i> odd, or (<i>a</i>/2) = 0 when <i>a</i> even. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_si_kronecker(System.Int32,Math.Gmp.Native.mpz_t)">mpz_si_kronecker</see> - Calculate the Jacobi symbol (<i>a</i>/<i>b</i>) with the Kronecker extension (<i>a</i>/2) = (2/<i>a</i>) when <i>a</i> odd, or (<i>a</i>/2) = 0 when <i>a</i> even. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_ui_kronecker(System.UInt32,Math.Gmp.Native.mpz_t)">mpz_ui_kronecker</see> - Calculate the Jacobi symbol (<i>a</i>/<i>b</i>) with the Kronecker extension (<i>a</i>/2) = (2/<i>a</i>) when <i>a</i> odd, or (<i>a</i>/2) = 0 when <i>a</i> even. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_remove(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_remove</see> - Remove all occurrences of the factor <i>f</i> from <i>op</i> and store the result in <i>rop</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_fac_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_fac_ui</see> - Set <i>rop</i> to the factorial <i>n</i>!.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_2fac_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_2fac_ui</see> - Set <i>rop</i> to the double-factorial <i>n</i>!!.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_mfac_uiui(Math.Gmp.Native.mpz_t,System.UInt32,System.UInt32)">mpz_mfac_uiui</see> - Set <i>rop</i> to the m-multi-factorial <i>n</i>!^(<i>m</i>)n.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_primorial_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_primorial_ui</see> - Set <i>rop</i> to the primorial of <i>n</i>, i.e. the product of all positive prime numbers &#8804; <i>n</i>. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_bin_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_bin_ui</see> - Compute the binomial coefficient <i>n</i> over <i>k</i> and store the result in <i>rop</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_bin_uiui(Math.Gmp.Native.mpz_t,System.UInt32,System.UInt32)">mpz_bin_uiui</see> - Compute the binomial coefficient <i>n</i> over <i>k</i> and store the result in <i>rop</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_fib_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_fib_ui</see> - Sets <i>fn</i> to to F[<i>n</i>], the <i>n</i>’th Fibonacci number. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_fib2_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_fib2_ui</see> - Sets <i>fn</i> to F[<i>n</i>], and <i>fnsub1</i> to F[<i>n</i> - 1]. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_lucnum_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_lucnum_ui</see> - Sets <i>ln</i> to to L[<i>n</i>], the <i>n</i>’th Lucas number. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_lucnum2_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_lucnum2_ui</see> - Sets <i>ln</i> to L[<i>n</i>], and <i>lnsub1</i> to L[<i>n</i> - 1]. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_millerrabin(Math.Gmp.Native.mpz_t,System.Int32)">mpz_millerrabin</see> - An implementation of the probabilistic primality test found in Knuth's Seminumerical Algorithms book.</description></item>
            </list>
            <para><a name="Integer_Comparisons"/><h4>Integer Comparisons:</h4></para>
            <list type="bullet">
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_cmp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cmp</see> - Compare <i>op1</i> and <i>op2</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_cmp_d(Math.Gmp.Native.mpz_t,System.Double)">mpz_cmp_d</see> - Compare <i>op1</i> and <i>op2</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_cmp_si(Math.Gmp.Native.mpz_t,System.Int32)">mpz_cmp_si</see> - Compare <i>op1</i> and <i>op2</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_cmp_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_cmp_ui</see> - Compare <i>op1</i> and <i>op2</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_cmpabs(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cmpabs</see> - Compare the absolute values of <i>op1</i> and <i>op2</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_cmpabs_d(Math.Gmp.Native.mpz_t,System.Double)">mpz_cmpabs_d</see> - Compare the absolute values of <i>op1</i> and <i>op2</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_cmpabs_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_cmpabs_ui</see> - Compare the absolute values of <i>op1</i> and <i>op2</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_sgn(Math.Gmp.Native.mpz_t)">mpz_sgn</see> - Return +1 if <i>op</i> &gt; 0, 0 if <i>op</i> = 0, and -1 if <i>op</i> &lt; 0.</description></item>
            </list>
            <para><a name="Integer_Logic_and_Bit_Fiddling"/><h4>Integer Logic and Bit Fiddling:</h4></para>
            <list type="bullet">
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_and(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_and</see> - Set <i>rop</i> to <i>op1</i> bitwise-and <i>op2</i>. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_ior(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_ior</see> - Set <i>rop</i> to <i>op1</i> bitwise inclusive-or <i>op2</i>. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_xor(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_xor</see> - Set <i>rop</i> to <i>op1</i> bitwise exclusive-or <i>op2</i>. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_com(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_com</see> - Set <i>rop</i> to the one’s complement of <i>op</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_popcount(Math.Gmp.Native.mpz_t)">mpz_popcount</see> - Return the population count of <i>op</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_hamdist(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_hamdist</see> - Return the hamming distance between the two operands.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_scan0(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_scan0</see> - Scan <i>op</i> for 0 bit.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_scan1(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_scan1</see> - Scan <i>op</i> for 1 bit.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_setbit(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_setbit</see> - Set bit <i>bit_index</i> in <i>rop</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_clrbit(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_clrbit</see> - Clear bit <i>bit_index</i> in <i>rop</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_combit(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_combit</see> - Complement bit <i>bit_index</i> in <i>rop</i>. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_tstbit(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_tstbit</see> - Test bit <i>bit_index</i> in <i>op</i> and return 0 or 1 accordingly. </description></item>
            </list>
            <para><a name="IO_of_Integers"/><h4>I/O of Integers:</h4></para>
            <list type="bullet">
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_out_str(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.Int32,Math.Gmp.Native.mpz_t)">mpz_out_str</see> - Output <i>op</i> on stdio stream <i>stream</i>, as a string of digits in base <i>base</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_inp_str(Math.Gmp.Native.mpz_t,Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.Int32)">mpz_inp_str</see> - Input a possibly white-space preceded string in base <i>base</i> from stdio stream <i>stream</i>, and put the read integer in <i>rop</i>. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_out_raw(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},Math.Gmp.Native.mpz_t)">mpz_out_raw</see> - Output <i>op</i> on stdio stream <i>stream</i>, in raw binary format.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_out_raw(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},Math.Gmp.Native.mpz_t)">mpz_out_raw</see>, and put the result in <i>rop</i>.</description></item>
            </list>
            <para><a name="Integer_Random_Numbers"/><h4>Integer Random Numbers:</h4></para>
            <list type="bullet">
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_urandomb(Math.Gmp.Native.mpz_t,Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_urandomb</see> - Generate a uniformly distributed random integer in the range 0 to 2^<i>n</i> - 1, inclusive.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_urandomm(Math.Gmp.Native.mpz_t,Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.mpz_t)">mpz_urandomm</see> - Generate a uniform random integer in the range 0 to <i>n</i> - 1, inclusive.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_rrandomb(Math.Gmp.Native.mpz_t,Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_rrandomb</see> - Generate a random integer with long strings of zeros and ones in the binary representation.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_random(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">mpz_random</see> - Generate a random integer of at most <i>max_size</i> limbs.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_random2(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">mpz_random2</see> - Generate a random integer of at most <i>max_size</i> limbs, with long strings of zeros and ones in the binary representation.</description></item>
            </list>
            <para><a name="Integer_Import_and_Export"/><h4>Integer Import and Export:</h4></para>
            <list type="bullet">
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_import(Math.Gmp.Native.mpz_t,Math.Gmp.Native.size_t,System.Int32,Math.Gmp.Native.size_t,System.Int32,Math.Gmp.Native.size_t,Math.Gmp.Native.void_ptr)">mpz_import</see> - Set <i>rop</i> from an array of word data at <i>op</i>.</description></item>
            <item><description><see cref="O:Math.Gmp.Native.gmp_lib.mpz_export">mpz_export</see> - Fill <i>rop</i> with word data from <i>op</i>.</description></item>
            </list>
            <para><a name="Miscellaneous_Integer_Functions"/><h4>Miscellaneous Integer Functions:</h4></para>
            <list type="bullet">
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_sint_p(Math.Gmp.Native.mpz_t)">mpz_fits_sint_p</see> - Return non-zero iff the value of <i>op</i> fits in a signed 32-bit integer. Otherwise, return zero.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_slong_p(Math.Gmp.Native.mpz_t)">mpz_fits_slong_p</see> - Return non-zero iff the value of <i>op</i> fits in a signed 32-bit integer. Otherwise, return zero.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_sshort_p(Math.Gmp.Native.mpz_t)">mpz_fits_sshort_p</see> - Return non-zero iff the value of <i>op</i> fits in a signed 16-bit integer. Otherwise, return zero.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_uint_p(Math.Gmp.Native.mpz_t)">mpz_fits_uint_p</see> - Return non-zero iff the value of <i>op</i> fits in an unsigned 32-bit integer. Otherwise, return zero.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_ulong_p(Math.Gmp.Native.mpz_t)">mpz_fits_ulong_p</see> - Return non-zero iff the value of <i>op</i> fits in an unsigned 32-bit integer. Otherwise, return zero.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_ushort_p(Math.Gmp.Native.mpz_t)">mpz_fits_ushort_p</see> - Return non-zero iff the value of <i>op</i> fits in an unsigned 16-bit integer. Otherwise, return zero.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_sizeinbase(Math.Gmp.Native.mpz_t,System.Int32)">mpz_sizeinbase</see> - Return the size of <i>op</i> measured in number of digits in the given <i>base</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_even_p(Math.Gmp.Native.mpz_t)">mpz_even_p</see> - Determine whether <i>op</i> is even.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_odd_p(Math.Gmp.Native.mpz_t)">mpz_odd_p</see> - Determine whether <i>op</i> is odd.</description></item>
            </list>
            <para><a name="Integer_Special_Functions"/><h4>Integer Special Functions:</h4></para>
            <list type="bullet">
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib._mpz_realloc(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">_mpz_realloc</see> - Change the space for <i>integer</i> to <i>new_alloc</i> limbs.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_getlimbn(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">mpz_getlimbn</see> - Return limb number <i>n</i> from <i>op</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_size(Math.Gmp.Native.mpz_t)">mpz_size</see> - Return the size of <i>op</i> measured in number of limbs.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_limbs_read(Math.Gmp.Native.mpz_t)">mpz_limbs_read</see> - Return a pointer to the limb array representing the absolute value of <i>x</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_limbs_write(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">mpz_limbs_write</see> - Return a pointer to the limb array of <i>x</i>, intended for write access.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_limbs_modify(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">mpz_limbs_modify</see> - Return a pointer to the limb array of <i>x</i>, intended for write access.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_limbs_finish(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">mpz_limbs_finish</see> - Updates the internal size field of <i>x</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpz_roinit_n(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpz_roinit_n</see> - Special initialization of <i>x</i>, using the given limb array and size.</description></item>
            </list>
            <para><a name="Rational_Number_Functions"/><h3>Rational Number Functions:</h3></para>
            <para><a name="Initializing_Rationals"/><h4>Initializing Rationals:</h4></para>
            <list type="bullet">
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpq_canonicalize(Math.Gmp.Native.mpq_t)">mpq_canonicalize</see> - Remove any factors that are common to the numerator and denominator of <i>op</i>, and make the denominator positive.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpq_init(Math.Gmp.Native.mpq_t)">mpq_init</see> - Initialize <i>x</i> and set it to 0/1.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpq_inits(Math.Gmp.Native.mpq_t[])">mpq_inits</see> - Initialize a NULL-terminated list of <see cref="T:Math.Gmp.Native.mpq_t">mpq_t</see> variables, and set their values to 0/1. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpq_clear(Math.Gmp.Native.mpq_t)">mpq_clear</see> - Free the space occupied by <i>x</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpq_clears(Math.Gmp.Native.mpq_t[])">mpq_clears</see> - Free the space occupied by a NULL-terminated list of <see cref="T:Math.Gmp.Native.mpq_t">mpq_t</see> variables. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpq_set(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_set</see> - Assign <i>rop</i> from <i>op</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpq_set_z(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpz_t)">mpq_set_z</see> - Assign <i>rop</i> from <i>op</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpq_set_ui(Math.Gmp.Native.mpq_t,System.UInt32,System.UInt32)">mpq_set_ui</see> - Set the value of <i>rop</i> to <i>op1</i> / <i>op2</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpq_set_si(Math.Gmp.Native.mpq_t,System.Int32,System.UInt32)">mpq_set_si</see> - Set the value of <i>rop</i> to <i>op1</i> / <i>op2</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpq_set_str(Math.Gmp.Native.mpq_t,Math.Gmp.Native.char_ptr,System.Int32)">mpq_set_str</see> - Set <i>rop</i> from a null-terminated string <i>str</i> in the given <i>base</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpq_swap(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_swap</see> - Swap the values <i>rop1</i> and <i>rop2</i> efficiently. </description></item>
            </list>
            <para><a name="Rational_Conversions"/><h4>Rational Conversions:</h4></para>
            <list type="bullet">
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpq_get_d(Math.Gmp.Native.mpq_t)">mpq_get_d</see> - Convert <i>op</i> to a <see cref="T:System.Double">System.Double</see>, truncating if necessary (i.e. rounding towards zero). </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpq_set_d(Math.Gmp.Native.mpq_t,System.Double)">mpq_set_d</see> - Set <i>rop</i> to the value of <i>op</i>. There is no rounding, this conversion is exact. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpq_set_f(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpf_t)">mpq_set_f</see> - Set <i>rop</i> to the value of <i>op</i>. There is no rounding, this conversion is exact. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpq_get_str(Math.Gmp.Native.char_ptr,System.Int32,Math.Gmp.Native.mpq_t)">mpq_get_str</see> - Convert <i>op</i> to a string of digits in base <i>base</i>.</description></item>
            </list>
            <para><a name="Rational_Arithmetic"/><h4>Rational Arithmetic:</h4></para>
            <list type="bullet">
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpq_add(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_add</see> - Set <i>sum</i> to <i>addend1</i> + <i>addend2</i>. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpq_sub(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_sub</see> - Set <i>difference</i> to <i>minuend</i> - <i>subtrahend</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpq_mul(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_mul</see> - Set <i>product</i> to <i>multiplier</i> * <i>multiplicand</i>. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpq_mul_2exp(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,System.UInt32)">mpq_mul_2exp</see> - Set <i>rop</i> to <i>op1</i> * 2^<i>op2</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpq_div(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_div</see> - Set <i>quotient</i> to <i>dividend</i> / <i>divisor</i>. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpq_div_2exp(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,System.UInt32)">mpq_div_2exp</see> - Set <i>rop</i> to <i>op1</i> / 2^<i>op2</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpq_neg(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_neg</see> - Set <i>negated_operand</i> to -<i>operand</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpq_abs(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_abs</see> - Set <i>rop</i> to the absolute value of <i>op</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpq_inv(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_inv</see> - Set <i>inverted_number</i> to 1 / <i>number</i>.</description></item>
            </list>
            <para><a name="Comparing_Rationals"/><h4>Comparing Rationals:</h4></para>
            <list type="bullet">
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpq_cmp(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_cmp</see> - Compare <i>op1</i> and <i>op2</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpq_cmp_z(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpz_t)">mpq_cmp_z</see> - Compare <i>op1</i> and <i>op2</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpq_cmp_ui(Math.Gmp.Native.mpq_t,System.UInt32,System.UInt32)">mpq_cmp_ui</see> - Compare <i>op1</i> and <i>num2</i> / <i>den2</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpq_cmp_si(Math.Gmp.Native.mpq_t,System.Int32,System.UInt32)">mpq_cmp_si</see> - Compare <i>op1</i> and <i>num2</i> / <i>den2</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpq_sgn(Math.Gmp.Native.mpq_t)">mpq_sgn</see> - Return +1 if <i>op</i> &gt; 0, 0 if <i>op</i> = 0, and -1 if <i>op</i> &lt; 0. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpq_equal(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_equal</see> - Return non-zero if <i>op1</i> and <i>op2</i> are equal, zero if they are non-equal. </description></item>
            </list>
            <para><a name="Applying_Integer_Functions"/><h4>Applying Integer Functions:</h4></para>
            <list type="bullet">
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpq_numref(Math.Gmp.Native.mpq_t)">mpq_numref</see> - Return a reference to the numerator <i>op</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpq_denref(Math.Gmp.Native.mpq_t)">mpq_denref</see> - Return a reference to the denominator <i>op</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpq_get_num(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpq_t)">mpq_get_num</see> - Set <i>numerator</i> to the numerator of <i>rational</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpq_get_den(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpq_t)">mpq_get_den</see> - Set <i>denominator</i> to the denominator of <i>rational</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpq_set_num(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpz_t)">mpq_set_num</see> - Set the numerator of <i>rational</i> to <i>numerator</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpq_set_den(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpz_t)">mpq_set_den</see> - Set the denominator of <i>rational</i> to <i>denominator</i>.</description></item>
            </list>
            <para><a name="IO_of_Rationals"/><h4>I/O of Rationals:</h4></para>
            <list type="bullet">
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpq_out_str(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.Int32,Math.Gmp.Native.mpq_t)">mpq_out_str</see> - Output <i>op</i> on stdio stream <i>stream</i>, as a string of digits in base <i>base</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpq_inp_str(Math.Gmp.Native.mpq_t,Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.Int32)">mpq_inp_str</see> - Read a string of digits from <i>stream</i> and convert them to a rational in <i>rop</i>.</description></item>
            </list>
            <para><a name="Floating_point_Functions"/><h3>Floating-point Functions:</h3></para>
            <para><a name="Initializing_Floats"/><h4>Initializing Floats:</h4></para>
            <list type="bullet">
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_set_default_prec(Math.Gmp.Native.mp_bitcnt_t)">mpf_set_default_prec</see> - Set the default precision to be at least <i>prec</i> bits.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_get_default_prec">mpf_get_default_prec</see> - Return the default precision actually used. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_init(Math.Gmp.Native.mpf_t)">mpf_init</see> - Initialize <i>x</i> to 0.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_init2(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_bitcnt_t)">mpf_init2</see> - Initialize <i>x</i> to 0 and set its precision to be at least <i>prec</i> bits.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_inits(Math.Gmp.Native.mpf_t[])">mpf_inits</see> - Initialize a NULL-terminated list of <see cref="T:Math.Gmp.Native.mpf_t">mpf_t</see> variables, and set their values to 0.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_clear(Math.Gmp.Native.mpf_t)">mpf_clear</see> - Free the space occupied by <i>x</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_clears(Math.Gmp.Native.mpf_t[])">mpf_clears</see> - Free the space occupied by a NULL-terminated list of <see cref="T:Math.Gmp.Native.mpf_t">mpf_t</see> variables. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_get_prec(Math.Gmp.Native.mpf_t)">mpf_get_prec</see> - Return the current precision of <i>op</i>, in bits. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_set_prec(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_bitcnt_t)">mpf_set_prec</see> - Set the precision of <i>rop</i> to be at least <i>prec</i> bits.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_set_prec_raw(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_bitcnt_t)">mpf_set_prec_raw</see> - Set the precision of <i>rop</i> to be at least <i>prec</i> bits, without changing the memory allocated. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_size(Math.Gmp.Native.mpf_t)">mpf_size</see> - Return the number of limbs currently in use.</description></item>
            </list>
            <para><a name="Assigning_Floats"/><h4>Assigning Floats:</h4></para>
            <list type="bullet">
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_set(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_set</see> - Set the value of <i>rop</i> from <i>op</i>. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_set_ui(Math.Gmp.Native.mpf_t,System.UInt32)">mpf_set_ui</see> - Set the value of <i>rop</i> from <i>op</i>. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_set_si(Math.Gmp.Native.mpf_t,System.Int32)">mpf_set_si</see> - Set the value of <i>rop</i> from <i>op</i>. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_set_d(Math.Gmp.Native.mpf_t,System.Double)">mpf_set_d</see> - Set the value of <i>rop</i> from <i>op</i>. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_set_z(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpz_t)">mpf_set_z</see> - Set the value of <i>rop</i> from <i>op</i>. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_set_q(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpq_t)">mpf_set_q</see> - Set the value of <i>rop</i> from <i>op</i>. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_set_str(Math.Gmp.Native.mpf_t,Math.Gmp.Native.char_ptr,System.Int32)">mpf_set_str</see> - Set the value of <i>rop</i> from the string in <i>str</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_swap(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_swap</see> - Swap <i>rop1</i> and <i>rop2</i> efficiently. </description></item>
            </list>
            <para><a name="Simultaneous_Float_Init_Assign"/><h4>Simultaneous Float Init &amp; Assign:</h4></para>
            <list type="bullet">
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_init_set(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_init_set</see> - Initialize <i>rop</i> and set its value from <i>op</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_init_set_ui(Math.Gmp.Native.mpf_t,System.UInt32)">mpf_init_set_ui</see> - Initialize <i>rop</i> and set its value from <i>op</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_init_set_si(Math.Gmp.Native.mpf_t,System.Int32)">mpf_init_set_si</see> - Initialize <i>rop</i> and set its value from <i>op</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_init_set_d(Math.Gmp.Native.mpf_t,System.Double)">mpf_init_set_d</see> - Initialize <i>rop</i> and set its value from <i>op</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_init_set_str(Math.Gmp.Native.mpf_t,Math.Gmp.Native.char_ptr,System.Int32)">mpf_init_set_str</see> - Initialize <i>rop</i> and set its value from the string in <i>str</i>.</description></item>
            </list>
            <para><a name="Converting_Floats"/><h4>Converting Floats:</h4></para>
            <list type="bullet">
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_get_d(Math.Gmp.Native.mpf_t)">mpf_get_d</see> - Convert <i>op</i> to a <see cref="T:System.Double">System.Double</see>, truncating if necessary (i.e. rounding towards zero). </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_get_d_2exp(Math.Gmp.Native.ptr{System.Int32},Math.Gmp.Native.mpf_t)">mpf_get_d_2exp</see> - Convert op to a double, truncating if necessary (i.e. rounding towards zero), and with an exponent returned separately. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_get_si(Math.Gmp.Native.mpf_t)">mpf_get_si</see> - Convert <i>op</i> to a 32-bit integer, truncating any fraction part.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_get_ui(Math.Gmp.Native.mpf_t)">mpf_get_ui</see> - Convert <i>op</i> to an unsigned 32-bit integer, truncating any fraction part.</description></item>
            <item><description><see cref="O:Math.Gmp.Native.gmp_lib.mpf_get_str">mpf_get_str</see> - Convert <i>op</i> to a string of digits in base <i>base</i>.</description></item>
            </list>
            <para><a name="Float_Arithmetic"/><h4>Float Arithmetic:</h4></para>
            <list type="bullet">
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_add(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_add</see> - Set <i>rop</i> to <i>op1</i> + <i>op2</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_add_ui(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,System.UInt32)">mpf_add_ui</see> - Set <i>rop</i> to <i>op1</i> + <i>op2</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_sub(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_sub</see> - Set <i>rop</i> to <i>op1</i> - <i>op2</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_ui_sub(Math.Gmp.Native.mpf_t,System.UInt32,Math.Gmp.Native.mpf_t)">mpf_ui_sub</see> - Set <i>rop</i> to <i>op1</i> - <i>op2</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_sub_ui(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,System.UInt32)">mpf_sub_ui</see> - Set <i>rop</i> to <i>op1</i> - <i>op2</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_mul(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_mul</see> - Set <i>rop</i> to <i>op1</i> * <i>op2</i>. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_mul_ui(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,System.UInt32)">mpf_mul_ui</see> - Set <i>rop</i> to <i>op1</i> * <i>op2</i>. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_div(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_div</see> - Set <i>rop</i> to <i>op1</i> / <i>op2</i>. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_ui_div(Math.Gmp.Native.mpf_t,System.UInt32,Math.Gmp.Native.mpf_t)">mpf_ui_div</see> - Set <i>rop</i> to <i>op1</i> / <i>op2</i>. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_div_ui(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,System.UInt32)">mpf_div_ui</see> - Set <i>rop</i> to <i>op1</i> / <i>op2</i>. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_sqrt(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_sqrt</see> - Set <i>rop</i> to the square root of <i>op</i>. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_sqrt_ui(Math.Gmp.Native.mpf_t,System.UInt32)">mpf_sqrt_ui</see> - Set <i>rop</i> to the square root of <i>op</i>. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_pow_ui(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,System.UInt32)">mpf_pow_ui</see> - Set <i>rop</i> to <i>op1</i>^<i>op2</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_neg(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_neg</see> - Set <i>rop</i> to -<i>op</i>. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_abs(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_abs</see> - Set <i>rop</i> to | <i>op</i> |. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_mul_2exp(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_bitcnt_t)">mpf_mul_2exp</see> - Set <i>rop</i> to <i>op1</i> * 2^<i>op2</i>. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_div_2exp(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,System.UInt32)">mpf_div_2exp</see> - Set <i>rop</i> to <i>op1</i> / 2^<i>op2</i>. </description></item>
            </list>
            <para><a name="Float_Comparison"/><h4>Float Comparison:</h4></para>
            <list type="bullet">
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_cmp(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_cmp</see> - Compare <i>op1</i> and <i>op2</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_cmp_z(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpz_t)">mpf_cmp_z</see> - Compare <i>op1</i> and <i>op2</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_cmp_d(Math.Gmp.Native.mpf_t,System.Double)">mpf_cmp_d</see> - Compare <i>op1</i> and <i>op2</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_cmp_ui(Math.Gmp.Native.mpf_t,System.UInt32)">mpf_cmp_ui</see> - Compare <i>op1</i> and <i>op2</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_cmp_si(Math.Gmp.Native.mpf_t,System.Int32)">mpf_cmp_si</see> - Compare <i>op1</i> and <i>op2</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_reldiff(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_reldiff</see> - Compute the relative difference between <i>op1</i> and <i>op2</i> and store the result in <i>rop</i>. This is | <i>op1</i> - <i>op2</i> | / <i>op1</i>. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_sgn(Math.Gmp.Native.mpf_t)">mpf_sgn</see> - Return +1 if op &gt; 0, 0 if op = 0, and -1 if op &lt; 0. </description></item>
            </list>
            <para><a name="IO_of_Floats"/><h4>I/O of Floats:</h4></para>
            <list type="bullet">
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_out_str(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.Int32,Math.Gmp.Native.size_t,Math.Gmp.Native.mpf_t)">mpf_out_str</see> - Print <i>op</i> to <i>stream</i>, as a string of digits.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_inp_str(Math.Gmp.Native.mpf_t,Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.Int32)">mpf_inp_str</see> - Read a string in base <i>base</i> from <i>stream</i>, and put the read float in <i>rop</i>.</description></item>
            </list>
            <para><a name="Miscellaneous_Float_Functions"/><h4>Miscellaneous Float Functions:</h4></para>
            <list type="bullet">
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_ceil(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_ceil</see> - Set <i>rop</i> to <i>op</i> rounded to the next higher integer. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_floor(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_floor</see> - Set <i>rop</i> to <i>op</i> rounded to the next lower integer.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_trunc(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_trunc</see> - Set <i>rop</i> to <i>op</i> rounded to the integer towards zero. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_integer_p(Math.Gmp.Native.mpf_t)">mpf_integer_p</see> - Return non-zero if <i>op</i> is an integer.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_ulong_p(Math.Gmp.Native.mpf_t)">mpf_fits_ulong_p</see> - Return non-zero if <i>op</i> fits in an unsigned 32-bit integer, when truncated to an integer. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_slong_p(Math.Gmp.Native.mpf_t)">mpf_fits_slong_p</see> - Return non-zero if <i>op</i> fits in a 32-bit integer, when truncated to an integer. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_uint_p(Math.Gmp.Native.mpf_t)">mpf_fits_uint_p</see> - Return non-zero if <i>op</i> fits in an unsigned 32-bit integer, when truncated to an integer. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_sint_p(Math.Gmp.Native.mpf_t)">mpf_fits_sint_p</see> - Return non-zero if <i>op</i> fits in a 32-bit integer, when truncated to an integer. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_sshort_p(Math.Gmp.Native.mpf_t)">mpf_fits_sshort_p</see> - Return non-zero if <i>op</i> fits in a 16-bit integer, when truncated to an integer. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_ushort_p(Math.Gmp.Native.mpf_t)">mpf_fits_ushort_p</see> - Return non-zero if <i>op</i> fits in an unsigned 16-bit integer, when truncated to an integer. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_urandomb(Math.Gmp.Native.mpf_t,Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.mp_bitcnt_t)">mpf_urandomb</see> - Generate a uniformly distributed random float in <i>rop</i>, such that 0 &#8804; rop &lt; 1, with <i>nbits</i> significant bits in the mantissa or less if the precision of <i>rop</i> is smaller.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpf_random2(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_exp_t)">mpf_random2</see> - Generate a random float of at most <i>max_size</i> limbs, with long strings of zeros and ones in the binary representation.</description></item>
            </list>
            <para><a name="Low_level_Functions"/><h3>Low-level Functions:</h3></para>
            <list type="bullet">
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_add_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_add_n</see> - Add {<i>s1p</i>, <i>n</i>} and {<i>s2p</i>, <i>n</i>}, and write the <i>n</i> least significant limbs of the result to <i>rp</i>. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_add_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_add_1</see> - Add {<i>s1p</i>, <i>n</i>} and <i>s2limb</i>, and write the <i>n</i> least significant limbs of the result to <i>rp</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_add(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_add</see> - Add {<i>s1p</i>, <i>s1n</i>} and {<i>s2p</i>, <i>s2n</i>}, and write the <i>s1n</i> least significant limbs of the result to <i>rp</i>. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_sub_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sub_n</see> - Subtract {<i>s2p</i>, <i>n</i>} from {<i>s1p</i>, <i>n</i>}, and write the <i>n</i> least significant limbs of the result to <i>rp</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_sub_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_sub_1</see> - Subtract <i>s2limb</i> from {<i>s1p</i>, <i>n</i>}, and write the <i>n</i> least significant limbs of the result to <i>rp</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_sub(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sub</see> - Subtract {<i>s2p</i>, <i>s2n</i>} from {<i>s1p</i>, <i>s1n</i>}, and write the <i>s1n</i> least significant limbs of the result to <i>rp</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_neg(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_neg</see> - Perform the negation of {<i>sp</i>, <i>n</i>}, and write the result to {<i>rp</i>, <i>n</i>}.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_mul_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_mul_n</see> - Multiply {<i>s1p</i>, <i>n</i>} and {<i>s2p</i>, <i>n</i>}, and write the (2 * <i>n</i>)-limb result to <i>rp</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_mul(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_mul</see> - Multiply {<i>s1p</i>, <i>s1n</i>} and {<i>s2p</i>, <i>s2n</i>}, and write the (<i>s1n</i> + <i>s2n</i>)-limb result to <i>rp</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_sqr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sqr</see> - Compute the square of {<i>s1p</i>, <i>n</i>} and write the (2 * <i>n</i>)-limb result to <i>rp</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_mul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_mul_1</see> - Multiply {<i>s1p</i>, <i>n</i>} by <i>s2limb</i>, and write the <i>n</i> least significant limbs of the product to <i>rp</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_addmul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_addmul_1</see> - Multiply {<i>s1p</i>, <i>n</i>} and <i>s2limb</i>, and add the <i>n</i> least significant limbs of the product to {<i>rp</i>, <i>n</i>} and write the result to <i>rp</i>. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_submul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_submul_1</see> - Multiply {<i>s1p</i>, <i>n</i>} and <i>s2limb</i>, and subtract the <i>n</i> least significant limbs of the product from {<i>rp</i>, <i>n</i>} and write the result to <i>rp</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_tdiv_qr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_tdiv_qr</see> - Divide {<i>np</i>, <i>nn</i>} by {<i>dp</i>, <i>dn</i>} and put the quotient at {<i>qp</i>, <i>nn</i> - <i>dn</i> + 1} and the remainder at {<i>rp</i>, <i>dn</i>}.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_divrem_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divrem_1</see> - Divide {<i>s2p</i>, <i>s2n</i>} by <i>s3limb</i>, and write the quotient at <i>r1p</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_divmod_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divmod_1</see> - Divide {<i>s2p</i>, <i>s2n</i>} by <i>s3limb</i>, and write the quotient at <i>r1p</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divexact_1</see> - Divide {<i>sp</i>, <i>n</i>} by <i>d</i>, expecting it to divide exactly, and writing the result to {r<i>rp</i>, <i>n</i>}.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_by3(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_divexact_by3</see> - Divide {<i>sp</i>, <i>n</i>} by 3, expecting it to divide exactly, and writing the result to {<i>rp</i>, <i>n</i>}. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_by3c(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divexact_by3c</see> - Divide {<i>sp</i>, <i>n</i>} by 3, expecting it to divide exactly, and writing the result to {<i>rp</i>, <i>n</i>}. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_mod_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_mod_1</see> - Divide {<i>s1p</i>, <i>s1n</i>} by <i>s2limb</i>, and return the remainder. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_lshift(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,System.UInt32)">mpn_lshift</see> - Shift {<i>sp</i>, <i>n</i>} left by <i>count</i> bits, and write the result to {<i>rp</i>, <i>n</i>}. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_rshift(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,System.UInt32)">mpn_rshift</see> - Shift {<i>sp</i>, <i>n</i>} right by <i>count</i> bits, and write the result to {<i>rp</i>, <i>n</i>}. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_cmp(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_cmp</see> - Compare {<i>s1p</i>, <i>n</i>} and {<i>s2p</i>, <i>n</i>}.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_zero_p(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_zero_p</see> - Test {<i>sp</i>, <i>n</i>} and return 1 if the operand is zero, 0 otherwise.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_gcd(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_gcd</see> - Set {<i>rp</i>, retval} to the greatest common divisor of {<i>xp</i>, <i>xn</i>} and {<i>yp</i>, <i>yn</i>}.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_gcd_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_gcd_1</see> - Return the greatest common divisor of {<i>xp</i>, <i>xn</i>} and <i>ylimb</i>.</description></item>
            <item><description><see cref="O:Math.Gmp.Native.gmp_lib.mpn_gcdext">mpn_gcdext</see> - Compute the greatest common divisor G of U and V. Compute a cofactor S such that G = US + VT.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_sqrtrem(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sqrtrem</see> - Compute the square root of {<i>sp</i>, <i>n</i>} and put the result at {<i>r1p</i>, ceil(<i>n</i> / 2)} and the remainder at {<i>r2p</i>, retval}.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_sizeinbase(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,System.Int32)">mpn_sizeinbase</see> - Return the size of {<i>xp</i>, <i>n</i>} measured in number of digits in the given <i>base</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_get_str(Math.Gmp.Native.char_ptr,System.Int32,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_get_str</see> - Convert {<i>s1p</i>, <i>s1n</i>} to a raw unsigned char array at <i>str</i> in base <i>base</i>, and return the number of characters produced.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_set_str(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.char_ptr,Math.Gmp.Native.size_t,System.Int32)">mpn_set_str</see> - Convert bytes {<i>str</i>, <i>strsize</i>} in the given <i>base</i> to limbs at <i>rp</i>. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_scan0(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_bitcnt_t)">mpn_scan0</see> - Scan <i>s1p</i> from bit position <i>bit</i> for the next clear bit.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_scan1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_bitcnt_t)">mpn_scan1</see> - Scan <i>s1p</i> from bit position <i>bit</i> for the next set bit.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_random(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_random</see> - Generate a random number of length <i>r1n</i> and store it at <i>r1p</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_random2(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_random2</see> - Generate a random number of length <i>r1n</i> and store it at <i>r1p</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_popcount(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_popcount</see> - Count the number of set bits in {<i>s1p</i>, <i>n</i>}. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_hamdist(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_hamdist</see> - Compute the hamming distance between {<i>s1p</i>, <i>n</i>} and {<i>s2p</i>, <i>n</i>}, which is the number of bit positions where the two operands have different bit values. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_perfect_square_p(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_perfect_square_p</see> - Return non-zero iff {<i>s1p</i>, <i>n</i>} is a perfect square.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_perfect_power_p(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_perfect_power_p</see> - Return non-zero iff {<i>sp</i>, <i>n</i>} is a perfect power.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_and_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_and_n</see> - Perform the bitwise logical and of {<i>s1p</i>, <i>n</i>} and {<i>s2p</i>, <i>n</i>}, and write the result to {<i>rp</i>, <i>n</i>}. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_ior_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_ior_n</see> - Perform the bitwise logical inclusive or of {<i>s1p</i>, <i>n</i>} and {<i>s2p</i>, <i>n</i>}, and write the result to {<i>rp</i>, <i>n</i>}. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_xor_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_xor_n</see> - Perform the bitwise logical exclusive or of {<i>s1p</i>, <i>n</i>} and {<i>s2p</i>, <i>n</i>}, and write the result to {<i>rp</i>, <i>n</i>}. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_andn_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_andn_n</see> - Perform the bitwise logical and of {<i>s1p</i>, <i>n</i>} and the bitwise complement of {<i>s2p</i>, <i>n</i>}, and write the result to {<i>rp</i>, <i>n</i>}.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_iorn_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_iorn_n</see> - Perform the bitwise logical inclusive or of {<i>s1p</i>, <i>n</i>} and the bitwise complement of {<i>s2p</i>, <i>n</i>}, and write the result to {<i>rp</i>, <i>n</i>}. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_nand_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_nand_n</see> - Perform the bitwise logical and of {<i>s1p</i>, <i>n</i>} and {<i>s2p</i>, <i>n</i>}, and write the bitwise complement of the result to {<i>rp</i>, <i>n</i>}. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_nior_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_nior_n</see> - Perform the bitwise logical inclusive or of {<i>s1p</i>, <i>n</i>} and {<i>s2p</i>, <i>n</i>}, and write the bitwise complement of the result to {<i>rp</i>, <i>n</i>}.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_xnor_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_xnor_n</see> - Perform the bitwise logical exclusive or of {<i>s1p</i>, <i>n</i>} and {<i>s2p</i>, <i>n</i>}, and write the bitwise complement of the result to {<i>rp</i>, <i>n</i>}. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_com(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_com</see> - Perform the bitwise complement of {<i>sp</i>, <i>n</i>}, and write the result to {<i>rp</i>, <i>n</i>}.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_copyi(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_copyi</see> - Copy from {<i>s1p</i>, <i>n</i>} to {<i>rp</i>, <i>n</i>}, increasingly. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_copyd(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_copyd</see> - Copy from {<i>s1p</i>, <i>n</i>} to {<i>rp</i>, <i>n</i>}, decreasingly. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_zero(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_zero</see> - Zero {<i>rp</i>, <i>n</i>}.</description></item>
            </list>
            <para><a name="Low_level_functions_for_cryptography"/><h4>Low-level functions for cryptography:</h4></para>
            <list type="bullet">
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_cnd_add_n(Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_cnd_add_n</see> - If <i>cnd</i> is non-zero, it produces the same result as a regular <see cref="M:Math.Gmp.Native.gmp_lib.mpn_add_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_add_n</see>, and if <i>cnd</i> is zero, it copies {<i>s1p</i>, <i>n</i>} to the result area and returns zero.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_cnd_sub_n(Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_cnd_sub_n</see> - If <i>cnd</i> is non-zero, it produces the same result as a regular <see cref="M:Math.Gmp.Native.gmp_lib.mpn_sub_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sub_n</see>, and if <i>cnd</i> is zero, it copies {<i>s1p</i>, <i>n</i>} to the result area and returns zero.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_add_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr)">mpn_sec_add_1</see> - Set R to A + b, where R = {<i>rp</i>, <i>n</i>}, A = {<i>ap</i>, <i>n</i>}, and <i>b</i> is a single limb.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_add_1_itch(Math.Gmp.Native.mp_size_t)">mpn_sec_add_1_itch</see> - Return the scratch space in number of limbs required by the function <see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_add_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr)">mpn_sec_add_1</see>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_sub_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr)">mpn_sec_sub_1</see> - Set R to A - b, where R = {<i>rp</i>, <i>n</i>}, A = {<i>ap</i>, <i>n</i>}, and <i>b</i> is a single limb.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_sub_1_itch(Math.Gmp.Native.mp_size_t)">mpn_sec_sub_1_itch</see> - Return the scratch space in number of limbs required by the function <see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_sub_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr)">mpn_sec_sub_1</see>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_cnd_swap(Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_cnd_swap</see> - If <i>cnd</i> is non-zero, swaps the contents of the areas {<i>ap</i>, <i>n</i>} and {<i>bp</i>, <i>n</i>}. Otherwise, the areas are left unmodified.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_mul(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_mul</see> - Set R to A * B, where A = {<i>ap</i>, <i>an</i>}, B = {<i>bp</i>, <i>bn</i>}, and R = {<i>rp</i>, <i>an</i> + <i>bn</i>}. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_mul_itch(Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_size_t)">mpn_sec_mul_itch</see> - Return the scratch space in number of limbs required by the function <see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_mul(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_mul</see>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_sqr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_sqr</see> - Set R to A^2, where A = {<i>ap</i>, <i>an</i>}, and R = {<i>rp</i>, 2 * <i>an</i>}. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_sqr_itch(Math.Gmp.Native.mp_size_t)">mpn_sec_sqr_itch</see> - Return the scratch space in number of limbs required by the function <see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_sqr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_sqr</see>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_powm(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_bitcnt_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_powm</see> - Set R to (B^E) modulo M, where R = {<i>rp</i>, <i>n</i>}, M = {<i>mp</i>, <i>n</i>}, and E = {<i>ep</i>, ceil(<i>enb</i> / <see cref="F:Math.Gmp.Native.gmp_lib.mp_bits_per_limb">mp_bits_per_limb</see>)}.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_powm_itch(Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_bitcnt_t,Math.Gmp.Native.mp_size_t)">mpn_sec_powm_itch</see> - Return the scratch space in number of limbs required by the function <see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_powm(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_bitcnt_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_powm</see>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_tabselect(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_size_t)">mpn_sec_tabselect</see> - Select entry <i>which</i> from table <i>tab</i>, which has <i>nents</i> entries, each <i>n</i> limbs. Store the selected entry at <i>rp</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_div_qr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_div_qr</see> - Set Q to the truncated quotient N / D and R to N modulo D, where N = {<i>np</i>, <i>nn</i>}, D = {<i>dp</i>, <i>dn</i>}, Q’s most significant limb is the function return value and the remaining limbs are {<i>qp</i>, <i>nn</i> - <i>dn</i>}, and R = {<i>np</i>, <i>dn</i>}. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_div_qr_itch(Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_size_t)">mpn_sec_div_qr_itch</see> - Return the scratch space in number of limbs required by the function <see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_div_qr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_div_qr</see>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_div_r(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_div_r</see> - Set R to N modulo D, where N = {<i>np</i>, <i>nn</i>}, D = {<i>dp</i>, <i>dn</i>}, and R = {<i>np</i>, <i>dn</i>}. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_div_r_itch(Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_size_t)">mpn_sec_div_r_itch</see> - Return the scratch space in number of limbs required by the function <see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_div_r(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_div_r</see>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_invert(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_bitcnt_t,Math.Gmp.Native.mp_ptr)">mpn_sec_invert</see> - Set R to the inverse of A modulo M, where R = {<i>rp</i>, <i>n</i>}, A = {<i>ap</i>, <i>n</i>}, and M = {<i>mp</i>, <i>n</i>}. This function’s interface is preliminary. </description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_invert_itch(Math.Gmp.Native.mp_size_t)">mpn_sec_invert_itch</see> - Return the scratch space in number of limbs required by the function <see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_invert(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_bitcnt_t,Math.Gmp.Native.mp_ptr)">mpn_sec_invert</see>.</description></item>
            </list>
            <para><a name="Random_Number_Functions"/><h3>Random Number Functions:</h3></para>
            <para><a name="Random_State_Initialization"/><h4>Random State Initialization:</h4></para>
            <list type="bullet">
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.gmp_randinit_default(Math.Gmp.Native.gmp_randstate_t)">gmp_randinit_default</see> - Initialize <i>state</i> with a default algorithm.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.gmp_randinit_mt(Math.Gmp.Native.gmp_randstate_t)">gmp_randinit_mt</see> - Initialize <i>state</i> for a Mersenne Twister algorithm.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.gmp_randinit_lc_2exp(Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.mpz_t,System.UInt32,Math.Gmp.Native.mp_bitcnt_t)">gmp_randinit_lc_2exp</see> - Initialize <i>state</i> with a linear congruential algorithm X = (<i>a</i>X + <i>c</i>) mod 2^<i>m2exp</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.gmp_randinit_lc_2exp_size(Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.mp_bitcnt_t)">gmp_randinit_lc_2exp_size</see> - Initialize <i>state</i> for a linear congruential algorithm as per <see cref="M:Math.Gmp.Native.gmp_lib.gmp_randinit_lc_2exp(Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.mpz_t,System.UInt32,Math.Gmp.Native.mp_bitcnt_t)">gmp_randinit_lc_2exp</see>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.gmp_randinit_set(Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.gmp_randstate_t)">gmp_randinit_set</see> - Initialize <i>rop</i> with a copy of the algorithm and state from <i>op</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.gmp_randclear(Math.Gmp.Native.gmp_randstate_t)">gmp_randclear</see> - Free all memory occupied by <i>state</i>.</description></item>
            </list>
            <para><a name="Random_State_Seeding"/><h4>Random State Seeding:</h4></para>
            <list type="bullet">
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.gmp_randseed(Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.mpz_t)">gmp_randseed</see> - Set an initial <i>seed</i> value into <i>state</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.gmp_randseed_ui(Math.Gmp.Native.gmp_randstate_t,System.UInt32)">gmp_randseed_ui</see> - Set an initial <i>seed</i> value into <i>state</i>.</description></item>
            </list>
            <para><a name="Random_State_Miscellaneous"/><h4>Random State Miscellaneous:</h4></para>
            <list type="bullet">
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.gmp_urandomb_ui(Math.Gmp.Native.gmp_randstate_t,System.UInt32)">gmp_urandomb_ui</see> - Generate a uniformly distributed random number of <i>n</i> bits, i.e. in the range 0 to 2^<i>n</i> - 1 inclusive.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.gmp_urandomm_ui(Math.Gmp.Native.gmp_randstate_t,System.UInt32)">gmp_urandomm_ui</see> - Generate a uniformly distributed random number in the range 0 to <i>n</i> - 1, inclusive.</description></item>
            </list>
            <para><a name="Formatted_Output"/><h3>Formatted Output:</h3></para>
            <para><a name="Formatted_Output_Functions"/><h4>Formatted Output Functions:</h4></para>
            <list type="bullet">
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.gmp_printf(System.String,System.Object[])">gmp_printf</see> - Print to the standard output stdout.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.gmp_vprintf(System.String,System.Object[])">gmp_vprintf</see> - Print to the standard output stdout.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.gmp_fprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.String,System.Object[])">gmp_fprintf</see> - Print to the stream <i>fp</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.gmp_vfprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.String,System.Object[])">gmp_vfprintf</see> - Print to the stream <i>fp</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.gmp_sprintf(Math.Gmp.Native.char_ptr,System.String,System.Object[])">gmp_sprintf</see> - Form a null-terminated string in <i>buf</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.gmp_vsprintf(Math.Gmp.Native.char_ptr,System.String,System.Object[])">gmp_vsprintf</see> - Form a null-terminated string in <i>buf</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.gmp_snprintf(Math.Gmp.Native.char_ptr,Math.Gmp.Native.size_t,System.String,System.Object[])">gmp_snprintf</see> - Form a null-terminated string in <i>buf</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.gmp_vsnprintf(Math.Gmp.Native.char_ptr,Math.Gmp.Native.size_t,System.String,System.Object[])">gmp_vsnprintf</see> - Form a null-terminated string in <i>buf</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.gmp_asprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.char_ptr},System.String,System.Object[])">gmp_asprintf</see> - Form a null-terminated string in a block of memory obtained from the current memory allocation function.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.gmp_vasprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.char_ptr},System.String,System.Object[])">gmp_vasprintf</see> - Form a null-terminated string in a block of memory obtained from the current memory allocation function.</description></item>
            </list>
            <para><a name="Formatted_Input"/><h3>Formatted Input:</h3></para>
            <para><a name="Formatted_Input_Functions"/><h4>Formatted Input Functions:</h4></para>
            <list type="bullet">
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.gmp_scanf(System.String,System.Object[])">gmp_scanf</see> - Read from the standard input stdin.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.gmp_vscanf(System.String,System.Object[])">gmp_vscanf</see> - Read from the standard input stdin.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.gmp_fscanf(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.String,System.Object[])">gmp_fscanf</see> - Read from the stream fp.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.gmp_vfscanf(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.String,System.Object[])">gmp_vfscanf</see> - Read from the stream fp.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.gmp_sscanf(System.String,System.String,System.Object[])">gmp_sscanf</see> - Read from a null-terminated string <i>s</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.gmp_vsscanf(System.String,System.String,System.Object[])">gmp_vsscanf</see> - Read from a null-terminated string <i>s</i>.</description></item>
            </list>
            <para><a name="Custom_Allocation"/><h3>Custom Allocation:</h3></para>
            <list type="bullet">
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mp_set_memory_functions(Math.Gmp.Native.allocate_function,Math.Gmp.Native.reallocate_function,Math.Gmp.Native.free_function)">mp_set_memory_functions</see> - Replace the current allocation functions from the arguments.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.mp_get_memory_functions(Math.Gmp.Native.allocate_function@,Math.Gmp.Native.reallocate_function@,Math.Gmp.Native.free_function@)">mp_get_memory_functions</see> - Get the current allocation functions, storing function pointers to the locations given by the arguments.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.allocate(Math.Gmp.Native.size_t)">allocate</see> - Return a pointer to newly allocated space with at least <i>alloc_size</i> bytes.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.reallocate(Math.Gmp.Native.void_ptr,Math.Gmp.Native.size_t,Math.Gmp.Native.size_t)">reallocate</see> - Resize a previously allocated block <i>ptr</i> of <i>old_size</i> bytes to be <i>new_size</i> bytes.</description></item>
            <item><description><see cref="O:Math.Gmp.Native.gmp_lib.free">free</see> - De-allocate the space pointed to by <i>ptrs</i>.</description></item>
            <item><description><see cref="M:Math.Gmp.Native.gmp_lib.ZeroMemory(System.IntPtr,System.Int32)">ZeroMemory</see> - The <see cref="M:Math.Gmp.Native.gmp_lib.ZeroMemory(System.IntPtr,System.Int32)">ZeroMemory</see> routine fills a block of memory with zeros, given a pointer to the block and the length, in bytes, to be filled.</description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Math.Gmp.Native.gmp_lib.gmp_errno">
            <summary>
            Gets or sets the global GMP error number.
            </summary>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Global_Variable_and_Constants">Global Variable and Constants</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Useful-Macros-and-Constants.html#Useful-Macros-and-Constants">GNU MP - Useful Macros and Constants</a></seealso>
        </member>
        <member name="F:Math.Gmp.Native.gmp_lib.gmp_version">
            <summary>
            The GMP version number in the form “i.j.k”. This release is "6.1.2".
            </summary>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Global_Variable_and_Constants">Global Variable and Constants</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Useful-Macros-and-Constants.html#Useful-Macros-and-Constants">GNU MP - Useful Macros and Constants</a></seealso>
            <example>
            <code language="C#">
            string version = gmp_lib.gmp_version;
            Assert.AreEqual(version, "6.1.2");
            </code> 
            <code language="VB.NET">
            Dim version As String = gmp_lib.gmp_version
            Assert.AreEqual(version, "6.1.2")
            </code> 
            </example>
        </member>
        <member name="F:Math.Gmp.Native.gmp_lib.mp_bits_per_limb">
            <summary>
            The number of bits per limb.
            </summary>
            <seealso cref="F:Math.Gmp.Native.gmp_lib.mp_bytes_per_limb">mp_bytes_per_limb</seealso>
            <seealso cref="F:Math.Gmp.Native.gmp_lib.mp_uint_per_limb">mp_uint_per_limb</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Global_Variable_and_Constants">Global Variable and Constants</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Useful-Macros-and-Constants.html#Useful-Macros-and-Constants">GNU MP - Useful Macros and Constants</a></seealso>
            <example>
            <code language="C#">
            int bitsPerLimb = gmp_lib.mp_bits_per_limb;
            Assert.AreEqual(bitsPerLimb, IntPtr.Size * 8);
            </code> 
            <code language="VB.NET">
            Dim bitsPerLimb As Integer = gmp_lib.mp_bits_per_limb
            Assert.AreEqual(bitsPerLimb, IntPtr.Size * 8)
            </code> 
            </example>
        </member>
        <member name="F:Math.Gmp.Native.gmp_lib.mp_bytes_per_limb">
            <summary>
            The number of bytes per limb.
            </summary>
            <seealso cref="F:Math.Gmp.Native.gmp_lib.mp_bits_per_limb">mp_bits_per_limb</seealso>
            <seealso cref="F:Math.Gmp.Native.gmp_lib.mp_uint_per_limb">mp_uint_per_limb</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Global_Variable_and_Constants">Global Variable and Constants</a></seealso>
            <example>
            <code language="C#">
            mp_size_t bytesPerLimb = gmp_lib.mp_bytes_per_limb;
            Assert.AreEqual(bytesPerLimb, (mp_size_t)IntPtr.Size);
            </code> 
            <code language="VB.NET">
            Dim bytesPerLimb As mp_size_t = gmp_lib.mp_bytes_per_limb
            Assert.AreEqual(bytesPerLimb, DirectCast(IntPtr.Size, mp_size_t)) 
            </code> 
            </example>
        </member>
        <member name="F:Math.Gmp.Native.gmp_lib.mp_uint_per_limb">
            <summary>
            The number of 32-bit, unsigned integers per limb.
            </summary>
            <seealso cref="F:Math.Gmp.Native.gmp_lib.mp_bits_per_limb">mp_bits_per_limb</seealso>
            <seealso cref="F:Math.Gmp.Native.gmp_lib.mp_bytes_per_limb">mp_bytes_per_limb</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Global_Variable_and_Constants">Global Variable and Constants</a></seealso>
            <example>
            <code language="C#">
            mp_size_t uintsPerLimb = gmp_lib.mp_uint_per_limb;
            Assert.AreEqual(uintsPerLimb, (mp_size_t)(IntPtr.Size / 4));
            </code> 
            <code language="VB.NET">
            Dim uintsPerLimb As mp_size_t = gmp_lib.mp_uint_per_limb
            Assert.AreEqual(uintsPerLimb, DirectCast(IntPtr.Size / 4, mp_size_t))
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.allocate(Math.Gmp.Native.size_t)">
            <summary>
            Return a pointer to newly allocated space with at least <paramref name="alloc_size"/> bytes.
            </summary>
            <param name="alloc_size">The minimum number of bytes to allocate.</param>
            <returns>A pointer to newly allocated space with at least <paramref name="alloc_size"/> bytes.</returns>
            <remarks></remarks>
            <seealso cref="O:Math.Gmp.Native.gmp_lib.free">free</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.reallocate(Math.Gmp.Native.void_ptr,Math.Gmp.Native.size_t,Math.Gmp.Native.size_t)">reallocate</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Custom_Allocation">Custom Allocation</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Custom-Allocation.html#Custom-Allocation">GNU MP - Custom Allocation</a></seealso>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.reallocate(Math.Gmp.Native.void_ptr,Math.Gmp.Native.size_t,Math.Gmp.Native.size_t)">
            <summary>
            Resize a previously allocated block <paramref name="ptr"/> of <paramref name="old_size"/> bytes to be <paramref name="new_size"/> bytes.
            </summary>
            <param name="ptr">Pointer to previously allocated block.</param>
            <param name="old_size">Number of bytes of previously allocated block.</param>
            <param name="new_size">New number of bytes of previously allocated block.</param>
            <returns>A previously allocated block ptr of <paramref name="old_size"/> bytes to be <paramref name="new_size"/> bytes.</returns>
            <remarks>
            <para>
            The block may be moved if necessary or if desired, and in that case the smaller of <paramref name="old_size"/> and
            <paramref name="new_size"/> bytes must be copied to the new location.
            The return value is a pointer to the resized block, that being the new location if moved or just <paramref name="ptr"/> if not.
            </para>
            <para>
            <paramref name="ptr"/> is never NULL, it’s always a previously allocated block. 
            <paramref name="new_size"/> may be bigger or smaller than <paramref name="old_size"/>.
            </para>
            <para>
            The reallocate function parameter <paramref name="old_size"/> is passed for convenience, but of course it can be ignored
            if not needed by an implementation. The default functions using malloc and friends for instance don’t use it.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.allocate(Math.Gmp.Native.size_t)">allocate</seealso>
            <seealso cref="O:Math.Gmp.Native.gmp_lib.free">free</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Custom_Allocation">Custom Allocation</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Custom-Allocation.html#Custom-Allocation">GNU MP - Custom Allocation</a></seealso>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.free(Math.Gmp.Native.mp_ptr[])">
            <summary>
            De-allocate the space pointed to by <paramref name="ptrs"/>.
            </summary>
            <param name="ptrs">Pointers to previously allocated memory.</param>
            <remarks></remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.free(Math.Gmp.Native.void_ptr,Math.Gmp.Native.size_t)"/>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.free(Math.Gmp.Native.gmp_randstate_t)">
            <summary>
            De-allocate the space pointed to by <paramref name="ptr"/>.
            </summary>
            <param name="ptr">Pointer to previously allocated memory.</param>
            <remarks></remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.free(Math.Gmp.Native.void_ptr,Math.Gmp.Native.size_t)"/>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.free(Math.Gmp.Native.char_ptr)">
            <summary>
            De-allocate the space pointed to by <paramref name="ptr"/>.
            </summary>
            <param name="ptr">Pointer to previously allocated memory.</param>
            <remarks></remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.free(Math.Gmp.Native.void_ptr,Math.Gmp.Native.size_t)"/>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.free(Math.Gmp.Native.void_ptr)">
            <summary>
            De-allocate the space pointed to by <paramref name="ptr"/>.
            </summary>
            <param name="ptr">Pointer to previously allocated memory.</param>
            <remarks></remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.free(Math.Gmp.Native.void_ptr,Math.Gmp.Native.size_t)"/>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.free(System.IntPtr)">
            <summary>
            Free the unmanaged memory at <paramref name="ptr"/>.
            </summary>
            <param name="ptr">Pointer to unmanaged memory.</param>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.free(Math.Gmp.Native.void_ptr,Math.Gmp.Native.size_t)">
            <summary>
            De-allocate the space pointed to by <paramref name="ptr"/>.
            </summary>
            <param name="ptr">Pointer to previously allocated block.</param>
            <param name="size">Number of bytes of previously allocated block.</param>
            <remarks>
            <para>
            The free function parameter <paramref name="size"/> is passed for convenience, but of course it can be ignored
            if not needed by an implementation. The default functions using malloc and friends for instance don’t use it.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.allocate(Math.Gmp.Native.size_t)">allocate</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.reallocate(Math.Gmp.Native.void_ptr,Math.Gmp.Native.size_t,Math.Gmp.Native.size_t)">reallocate</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Custom_Allocation">Custom Allocation</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Custom-Allocation.html#Custom-Allocation">GNU MP - Custom Allocation</a></seealso>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mp_get_memory_functions(Math.Gmp.Native.allocate_function@,Math.Gmp.Native.reallocate_function@,Math.Gmp.Native.free_function@)">
            <summary>
            Get the current allocation functions, storing function pointers to the locations given by the arguments.
            </summary>
            <param name="alloc_func_ptr">The memory allocation function.</param>
            <param name="realloc_func_ptr">The memory reallocation function.</param>
            <param name="free_func_ptr">The memory de-allocation function.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mp_set_memory_functions(Math.Gmp.Native.allocate_function,Math.Gmp.Native.reallocate_function,Math.Gmp.Native.free_function)">mp_set_memory_functions</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Custom_Allocation">Custom Allocation</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Custom-Allocation.html#Custom-Allocation">GNU MP - Custom Allocation</a></seealso>
            <example>
            <code language="C#">
            allocate_function allocate;
            reallocate_function reallocate;
            free_function free;
            
            // Retrieve the GMP memory allocation functions.
            allocate = null;
            reallocate = null;
            free = null;
            gmp_lib.mp_get_memory_functions(ref allocate, ref reallocate, ref free);
            Assert.IsTrue(allocate != null &amp;&amp; reallocate != null &amp;&amp; free != null);
            
            // Allocate and free memory.
            void_ptr p = allocate(100);
            free(p, 100);
            </code> 
            <code language="VB.NET">
            Dim allocate As allocate_function
            Dim reallocate As reallocate_function
            Dim free As free_function
            
            ' Retrieve the GMP memory allocation functions.
            allocate = Nothing
            reallocate = Nothing
            free = Nothing
            gmp_lib.mp_get_memory_functions(allocate, reallocate, free)
            Assert.IsTrue(allocate IsNot Nothing AndAlso reallocate IsNot Nothing AndAlso free IsNot Nothing)
            
            ' Allocate and free memory.
            Dim p As void_ptr = allocate(100)
            free(p, 100)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mp_set_memory_functions(Math.Gmp.Native.allocate_function,Math.Gmp.Native.reallocate_function,Math.Gmp.Native.free_function)">
            <summary>
            Replace the current allocation functions from the arguments.
            </summary>
            <param name="alloc_func_ptr">The new memory allocation function.</param>
            <param name="realloc_func_ptr">The new memory reallocation function.</param>
            <param name="free_func_ptr">The new memory de-allocation function.</param>
            <remarks>
            <para>
            If an argument is <c>null</c> (<c>Nothing</c> in VB.NET), the corresponding
            default function is used.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mp_get_memory_functions(Math.Gmp.Native.allocate_function@,Math.Gmp.Native.reallocate_function@,Math.Gmp.Native.free_function@)">mp_get_memory_functions</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Custom_Allocation">Custom Allocation</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Custom-Allocation.html#Custom-Allocation">GNU MP - Custom Allocation</a></seealso>
            <example>
            <code language="C#">
            // Retrieve GMP default memory allocation functions.
            allocate_function default_allocate = null;
            reallocate_function default_reallocate = null;
            free_function default_free = null;
            gmp_lib.mp_get_memory_functions(ref default_allocate, ref default_reallocate, ref default_free);
            
            // Create and set new memory allocation functions that count the number of times they are called.
            int counter = 0;
            allocate_function new_allocate = (size_t alloc_size) => { counter++; return default_allocate(alloc_size); };
            reallocate_function new_reallocate = (void_ptr ptr, size_t old_size, size_t new_size) => { counter++; return default_reallocate(ptr, old_size, new_size); };
            free_function new_free = (void_ptr ptr, size_t size) => { counter++; default_free(ptr, size); };
            gmp_lib.mp_set_memory_functions(new_allocate, new_reallocate, new_free);
            
            // Retrieve GMP memory allocation functions.
            allocate_function allocate = null;
            reallocate_function reallocate = null;
            free_function free = null;
            gmp_lib.mp_get_memory_functions(ref allocate, ref reallocate, ref free);
            
            // Call memory function and assert calls count.
            void_ptr p = allocate(10);
            Assert.IsTrue(counter == 1);
            
            reallocate(p, 10, 20);
            Assert.IsTrue(counter == 2);
            
            free(p, 20);
            Assert.IsTrue(counter == 3);
            
            // Restore default memory allocation functions.
            gmp_lib.mp_set_memory_functions(null, null, null);
            </code> 
            <code language="VB.NET">
            ' Retrieve GMP default memory allocation functions.
            Dim default_allocate As allocate_function = Nothing
            Dim default_reallocate As reallocate_function = Nothing
            Dim default_free As free_function = Nothing
            gmp_lib.gmp_get_memory_functions(default_allocate, default_reallocate, default_free)
            
            ' Create and set new memory allocation functions that count the number of times they are called.
            Dim counter As Integer = 0
            Dim new_allocate As allocate_function =
                Function(alloc_size As size_t) 
                    counter += 1
                    Return default_allocate(alloc_size)
                End Function
            Dim new_reallocate As reallocate_function =
                Function(ptr As void_ptr, old_size As size_t, new_size As size_t) 
            	    counter += 1
            	    Return default_reallocate(ptr, old_size, new_size)
                End Function
            Dim new_free As free_function =
                Function(ptr As void_ptr, size As size_t) 
            	    counter += 1
            	    default_free(ptr, size)
                End Function
            gmp_lib.gmp_set_memory_functions(new_allocate, new_reallocate, new_free)
            
            ' Retrieve GMP memory allocation functions.
            Dim allocate As allocate_function = Nothing
            Dim reallocate As reallocate_function = Nothing
            Dim free As free_function = Nothing
            gmp_lib.gmp_get_memory_functions(allocate, reallocate, free)
            
            ' Call memory function and assert calls count.
            Dim p As void_ptr = allocate(10)
            Assert.IsTrue(counter = 1)
            
            reallocate(p, 10, 20)
            Assert.IsTrue(counter = 2)
            
            free(p, 20)
            Assert.IsTrue(counter = 3)
            
            ' Restore default memory allocation functions.
            gmp_lib.gmp_set_memory_functions(Nothing, Nothing, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.ZeroMemory(System.IntPtr,System.Int32)">
            <summary>
            The <see cref="M:Math.Gmp.Native.gmp_lib.ZeroMemory(System.IntPtr,System.Int32)">ZeroMemory</see> routine fills a block of memory with zeros, given a pointer to the block and the length, in bytes, to be filled.
            </summary>
            <param name="dst">A pointer to the memory block to be filled with zeros.</param>
            <param name="length">The number of bytes to fill with zeros.</param>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.gmp_randinit_default(Math.Gmp.Native.gmp_randstate_t)">
            <summary>
            Initialize <paramref name="state"/> with a default algorithm.
            </summary>
            <param name="state">The state to initialize.</param>
            <remarks>
            <para>
            This will be a compromise between speed and randomness, 
            and is recommended for applications with no special requirements.
            Currently this is <see cref="M:Math.Gmp.Native.gmp_lib.gmp_randinit_mt(Math.Gmp.Native.gmp_randstate_t)">gmp_randinit_mt</see>.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_randclear(Math.Gmp.Native.gmp_randstate_t)">gmp_randclear</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_randinit_lc_2exp(Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.mpz_t,System.UInt32,Math.Gmp.Native.mp_bitcnt_t)">gmp_randinit_lc_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_randinit_lc_2exp_size(Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.mp_bitcnt_t)">gmp_randinit_lc_2exp_size</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_randinit_mt(Math.Gmp.Native.gmp_randstate_t)">gmp_randinit_mt</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_randinit_set(Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.gmp_randstate_t)">gmp_randinit_set</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Random_State_Initialization">Random State Initialization</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Random-State-Initialization.html#Random-State-Initialization">GNU MP - Random State Initialization</a></seealso>
            <example>
            <code language="C#">
            // Create new random number generator state.
            gmp_randstate_t state = new gmp_randstate_t();
            
            // Initialize state with default random number generator algorithm.
            gmp_lib.gmp_randinit_default(state);
            
            // Free all memory occupied by state.
            gmp_lib.gmp_randclear(state);
            </code> 
            <code language="VB.NET">
            ' Create new random number generator state.
            Dim state As New gmp_randstate_t()
            
            ' Initialize state with default random number generator algorithm.
            gmp_lib.gmp_randinit_default(state)
            
            ' Free all memory occupied by state.
            gmp_lib.gmp_randclear(state)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.gmp_randinit_lc_2exp(Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.mpz_t,System.UInt32,Math.Gmp.Native.mp_bitcnt_t)">
            <summary>
            Initialize <paramref name="state"/> with a linear congruential algorithm X = (<paramref name="a"/>X + <paramref name="c"/>) mod 2^<paramref name="m2exp"/>.
            </summary>
            <param name="state">The state to initialize.</param>
            <param name="a">Parameter of the algorithm.</param>
            <param name="c">Parameter of the algorithm.</param>
            <param name="m2exp">Parameter of the algorithm.</param>
            <remarks>
            <para>
            The low bits of X in this algorithm are not very random.
            The least significant bit will have a period no more than 2, and the second bit
            no more than 4, etc. For this reason only the high half of each X is actually used.
            </para>
            <para>
            When a random number of more than <paramref name="m2exp"/> / 2 bits is to be generated,
            multiple iterations of the recurrence are used and the results concatenated.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_randclear(Math.Gmp.Native.gmp_randstate_t)">gmp_randclear</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_randinit_default(Math.Gmp.Native.gmp_randstate_t)">gmp_randinit_default</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_randinit_lc_2exp_size(Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.mp_bitcnt_t)">gmp_randinit_lc_2exp_size</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_randinit_mt(Math.Gmp.Native.gmp_randstate_t)">gmp_randinit_mt</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_randinit_set(Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.gmp_randstate_t)">gmp_randinit_set</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Random_State_Initialization">Random State Initialization</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Random-State-Initialization.html#Random-State-Initialization">GNU MP - Random State Initialization</a></seealso>
            <example>
            <code language="C#">
            // Create new random number generator state.
            gmp_randstate_t state = new gmp_randstate_t();
            
            // Initialize state with a linear congruential random number generator algorithm.
            mpz_t a = new mpz_t();
            gmp_lib.mpz_init_set_ui(a, 100000U);
            gmp_lib.gmp_randinit_lc_2exp(state, a, 13, 300);
            
            // Free all memory occupied by state and a.
            gmp_lib.gmp_randclear(state);
            gmp_lib.mpz_clear(a);
            </code> 
            <code language="VB.NET">
            ' Create new random number generator state.
            Dim state As New gmp_randstate_t()
            
            ' Initialize state with a linear congruential random number generator algorithm.
            Dim a As New mpz_t()
            
            gmp_lib.mpz_init_set_ui(a, 100000UI)
            gmp_lib.gmp_randinit_lc_2exp(state, a, 13, 300)
            
            ' Free all memory occupied by state and a.
            gmp_lib.gmp_randclear(state)
            gmp_lib.mpz_clear(a)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.gmp_randinit_lc_2exp_size(Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.mp_bitcnt_t)">
            <summary>
            Initialize <paramref name="state"/> for a linear congruential algorithm as per <see cref="M:Math.Gmp.Native.gmp_lib.gmp_randinit_lc_2exp(Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.mpz_t,System.UInt32,Math.Gmp.Native.mp_bitcnt_t)">gmp_randinit_lc_2exp</see>.
            </summary>
            <param name="state">The state to initialize.</param>
            <param name="size"></param>
            <returns>If successful the return value is non-zero. If <paramref name="size"/> is bigger than the table data provides then the return value is zero.</returns>
            <remarks>
            <para>
            a, c and m2exp are selected from a table, chosen so that <paramref name="size"/>
            bits (or more) of each X will be used, i.e. m2exp / 2 &#8805; <paramref name="size"/>.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_randclear(Math.Gmp.Native.gmp_randstate_t)">gmp_randclear</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_randinit_default(Math.Gmp.Native.gmp_randstate_t)">gmp_randinit_default</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_randinit_lc_2exp(Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.mpz_t,System.UInt32,Math.Gmp.Native.mp_bitcnt_t)">gmp_randinit_lc_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_randinit_mt(Math.Gmp.Native.gmp_randstate_t)">gmp_randinit_mt</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_randinit_set(Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.gmp_randstate_t)">gmp_randinit_set</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Random_State_Initialization">Random State Initialization</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Random-State-Initialization.html#Random-State-Initialization">GNU MP - Random State Initialization</a></seealso>
            <example>
            <code language="C#">
            // Create new random number generator state.
            gmp_randstate_t state = new gmp_randstate_t();
            
            // Initialize state with a linear congruential random number generator algorithm.
            gmp_lib.gmp_randinit_lc_2exp_size(state, 30);
            
            // Free all memory occupied by state.
            gmp_lib.gmp_randclear(state);
            </code> 
            <code language="VB.NET">
            ' Create new random number generator state.
            Dim state As New gmp_randstate_t()
            
            ' Initialize state with a linear congruential random number generator algorithm.
            gmp_lib.gmp_randinit_lc_2exp_size(state, 30)
            
            ' Free all memory occupied by state.
            gmp_lib.gmp_randclear(state)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.gmp_randinit_mt(Math.Gmp.Native.gmp_randstate_t)">
            <summary>
            Initialize <paramref name="state"/> for a Mersenne Twister algorithm.
            </summary>
            <param name="state">The state to initialize.</param>
            <remarks>
            <para>
            This algorithm is fast and has good randomness properties.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_randclear(Math.Gmp.Native.gmp_randstate_t)">gmp_randclear</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_randinit_default(Math.Gmp.Native.gmp_randstate_t)">gmp_randinit_default</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_randinit_lc_2exp(Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.mpz_t,System.UInt32,Math.Gmp.Native.mp_bitcnt_t)">gmp_randinit_lc_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_randinit_lc_2exp_size(Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.mp_bitcnt_t)">gmp_randinit_lc_2exp_size</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_randinit_set(Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.gmp_randstate_t)">gmp_randinit_set</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Random_State_Initialization">Random State Initialization</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Random-State-Initialization.html#Random-State-Initialization">GNU MP - Random State Initialization</a></seealso>
            <example>
            <code language="C#">
            // Create new random number generator state.
            gmp_randstate_t state = new gmp_randstate_t();
            
            // Initialize state with Mersenne Twister random number generator algorithm.
            gmp_lib.gmp_randinit_mt(state);
            
            // Free all memory occupied by state.
            gmp_lib.gmp_randclear(state);
            </code> 
            <code language="VB.NET">
            ' Create new random number generator state.
            Dim state As New gmp_randstate_t()
            
            ' Initialize state with Mersenne Twister random number generator algorithm.
            gmp_lib.gmp_randinit_mt(state)
            
            ' Free all memory occupied by state.
            gmp_lib.gmp_randclear(state)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.gmp_randinit_set(Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.gmp_randstate_t)">
            <summary>
            Initialize <paramref name="rop"/> with a copy of the algorithm and state from <paramref name="op"/>.
            </summary>
            <param name="rop">The state to initialize.</param>
            <param name="op">The source state.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_randclear(Math.Gmp.Native.gmp_randstate_t)">gmp_randclear</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_randinit_default(Math.Gmp.Native.gmp_randstate_t)">gmp_randinit_default</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_randinit_lc_2exp(Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.mpz_t,System.UInt32,Math.Gmp.Native.mp_bitcnt_t)">gmp_randinit_lc_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_randinit_lc_2exp_size(Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.mp_bitcnt_t)">gmp_randinit_lc_2exp_size</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_randinit_mt(Math.Gmp.Native.gmp_randstate_t)">gmp_randinit_mt</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Random_State_Initialization">Random State Initialization</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Random-State-Initialization.html#Random-State-Initialization">GNU MP - Random State Initialization</a></seealso>
            <example>
            <code language="C#">
            // Create new random number generator state, and initialize state with the Mersenne Twister algorithm.
            gmp_randstate_t op = new gmp_randstate_t();
            gmp_lib.gmp_randinit_mt(op);
            
            // Create new random number generator state, and initialize it with the state op.
            gmp_randstate_t rop = new gmp_randstate_t();
            gmp_lib.gmp_randinit_set(rop, op);
            
            // Free all memory occupied by op and rop.
            gmp_lib.gmp_randclear(op);
            gmp_lib.gmp_randclear(rop);
            </code> 
            <code language="VB.NET">
            ' Create new random number generator state, and initialize state with the Mersenne Twister algorithm.
            Dim op As New gmp_randstate_t()
            
            gmp_lib.gmp_randinit_mt(op)
            
            ' Create new random number generator state, and initialize it with the state op.
            Dim rop As New gmp_randstate_t()
            
            gmp_lib.gmp_randinit_set(rop, op)
            
            ' Free all memory occupied by op and rop.
            gmp_lib.gmp_randclear(op)
            gmp_lib.gmp_randclear(rop)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.gmp_randseed(Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.mpz_t)">
            <summary>
            Set an initial <paramref name="seed"/> value into <paramref name="state"/>.
            </summary>
            <param name="state">The state to seed.</param>
            <param name="seed">The seed.</param>
            <remarks>
            <para>
            The size of a seed determines how many different sequences of random numbers that it’s possible to
            generate. The “quality” of the seed is the randomness of a given seed compared to the previous seed
            used, and this affects the randomness of separate number sequences. The method for choosing a seed
            is critical if the generated numbers are to be used for important applications, such as generating
            cryptographic keys.
            </para>
            <para>
            Traditionally the system time has been used to seed, but care needs to be taken with this. If an
            application seeds often and the resolution of the system clock is low, then the same sequence of
            numbers might be repeated. Also, the system time is quite easy to guess, so if unpredictability is
            required then it should definitely not be the only source for the seed value. On some systems
            there’s a special device /dev/random which provides random data better suited for use as a seed.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_randseed_ui(Math.Gmp.Native.gmp_randstate_t,System.UInt32)">gmp_randseed_ui</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Random_State_Seeding">Random State Seeding</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Random-State-Seeding.html#Random-State-Seeding">GNU MP - Random State Seeding</a></seealso>
            <example>
            <code language="C#">
            // Create new random number generator state, and initialize state with the Mersenne Twister algorithm.
            gmp_randstate_t state = new gmp_randstate_t();
            gmp_lib.gmp_randinit_mt(state);
            
            // Seed random number generator.
            mpz_t seed = new mpz_t();
            gmp_lib.mpz_init_set_ui(seed, 100000U);
            gmp_lib.gmp_randseed(state, seed);
            
            // Free all memory occupied by state and seed.
            gmp_lib.gmp_randclear(state);
            gmp_lib.mpz_clear(seed);
            </code> 
            <code language="VB.NET">
            ' Create new random number generator state, and initialize state with the Mersenne Twister algorithm.
            Dim state As New gmp_randstate_t()
            
            gmp_lib.gmp_randinit_mt(state)
            
            ' Seed random number generator.
            Dim seed As New mpz_t()
            
            gmp_lib.mpz_init_set_ui(seed, 100000UI)
            gmp_lib.gmp_randseed(state, seed)
            
            ' Free all memory occupied by state and seed.
            gmp_lib.gmp_randclear(state)
            gmp_lib.mpz_clear(seed)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.gmp_randseed_ui(Math.Gmp.Native.gmp_randstate_t,System.UInt32)">
            <summary>
            Set an initial <paramref name="seed"/> value into <paramref name="state"/>.
            </summary>
            <param name="state">The state to seed.</param>
            <param name="seed">The seed.</param>
            <remarks>
            <para>
            The size of a seed determines how many different sequences of random numbers that it’s possible to
            generate. The “quality” of the seed is the randomness of a given seed compared to the previous seed
            used, and this affects the randomness of separate number sequences. The method for choosing a seed
            is critical if the generated numbers are to be used for important applications, such as generating
            cryptographic keys.
            </para>
            <para>
            Traditionally the system time has been used to seed, but care needs to be taken with this. If an
            application seeds often and the resolution of the system clock is low, then the same sequence of
            numbers might be repeated. Also, the system time is quite easy to guess, so if unpredictability is
            required then it should definitely not be the only source for the seed value. On some systems
            there’s a special device /dev/random which provides random data better suited for use as a seed.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_randseed(Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.mpz_t)">gmp_randseed</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Random_State_Seeding">Random State Seeding</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Random-State-Seeding.html#Random-State-Seeding">GNU MP - Random State Seeding</a></seealso>
            <example>
            <code language="C#">
            // Create new random number generator state, and initialize state with the Mersenne Twister algorithm.
            gmp_randstate_t state = new gmp_randstate_t();
            gmp_lib.gmp_randinit_mt(state);
            
            // Seed random number generator.
            gmp_lib.gmp_randseed_ui(state, 100000U);
            
            // Free all memory occupied by state.
            gmp_lib.gmp_randclear(state);
            </code> 
            <code language="VB.NET">
            ' Create new random number generator state, and initialize state with the Mersenne Twister algorithm.
            Dim state As New gmp_randstate_t()
            
            gmp_lib.gmp_randinit_mt(state)
            
            ' Seed random number generator.
            gmp_lib.gmp_randseed_ui(state, 100000UI)
            
            ' Free all memory occupied by state.
            gmp_lib.gmp_randclear(state)        /// </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.gmp_randclear(Math.Gmp.Native.gmp_randstate_t)">
            <summary>
            Free all memory occupied by <paramref name="state"/>.
            </summary>
            <param name="state">A state.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_randinit_default(Math.Gmp.Native.gmp_randstate_t)">gmp_randinit_default</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_randinit_lc_2exp(Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.mpz_t,System.UInt32,Math.Gmp.Native.mp_bitcnt_t)">gmp_randinit_lc_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_randinit_lc_2exp_size(Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.mp_bitcnt_t)">gmp_randinit_lc_2exp_size</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_randinit_mt(Math.Gmp.Native.gmp_randstate_t)">gmp_randinit_mt</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_randinit_set(Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.gmp_randstate_t)">gmp_randinit_set</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Random_State_Initialization">Random State Initialization</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Random-State-Initialization.html#Random-State-Initialization">GNU MP - Random State Initialization</a></seealso>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.gmp_urandomb_ui(Math.Gmp.Native.gmp_randstate_t,System.UInt32)">
            <summary>
            Generate a uniformly distributed random number of <paramref name="n"/> bits, i.e. in the range 0 to 2^<paramref name="n"/> - 1 inclusive.
            </summary>
            <param name="state">The state of the random number generator to use.</param>
            <param name="n">The numbe rof bits.</param>
            <returns>The generated random number.</returns>
            <remarks>
            <para>
            <paramref name="n"/> must be less than or equal to the number of bits in an unsigned long.
            </para>
            <para>
            In .NET, <paramref name="n"/> must be less than or equal to the number of bits in an unsigned 32-bit integer.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_urandomm_ui(Math.Gmp.Native.gmp_randstate_t,System.UInt32)">gmp_urandomm_ui</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Random_State_Miscellaneous">Random State Miscellaneous</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Random-State-Miscellaneous.html#Random-State-Miscellaneous">GNU MP - Random State Miscellaneous</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and seed a new random number generator.
            gmp_randstate_t state = new gmp_randstate_t();
            gmp_lib.gmp_randinit_mt(state);
            gmp_lib.gmp_randseed_ui(state, 100000U);
            
            // Generate a random integer in the range [0, 2^8-1].
            uint rand = gmp_lib.gmp_urandomb_ui(state, 8);
            
            // Free all memory occupied by state.
            gmp_lib.gmp_randclear(state);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and seed a new random number generator.
            Dim state As New gmp_randstate_t()
            gmp_lib.gmp_randinit_mt(state)
            gmp_lib.gmp_randseed_ui(state, 100000UI)
            
            ' Generate a random integer in the range [0, 2^8-1].
            Dim rand As UInteger = gmp_lib.gmp_urandomb_ui(state, 8)
            
            ' Free all memory occupied by state.
            gmp_lib.gmp_randclear(state)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.gmp_urandomm_ui(Math.Gmp.Native.gmp_randstate_t,System.UInt32)">
            <summary>
            Generate a uniformly distributed random number in the range 0 to <paramref name="n"/> - 1, inclusive.
            </summary>
            <param name="state">The state of the random number generator to use.</param>
            <param name="n">The upper bound of the range.</param>
            <returns>The generated random number.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_urandomb_ui(Math.Gmp.Native.gmp_randstate_t,System.UInt32)">gmp_urandomb_ui</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Random_State_Miscellaneous">Random State Miscellaneous</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Random-State-Miscellaneous.html#Random-State-Miscellaneous">GNU MP - Random State Miscellaneous</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and seed a new random number generator.
            gmp_randstate_t state = new gmp_randstate_t();
            gmp_lib.gmp_randinit_mt(state);
            gmp_lib.gmp_randseed_ui(state, 1000U);
            
            // Generate a random integer in the range [0, 8-1].
            uint rand = gmp_lib.gmp_urandomm_ui(state, 8);
            
            // Free all memory occupied by state.
            gmp_lib.gmp_randclear(state);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and seed a new random number generator.
            Dim state As New gmp_randstate_t()
            
            gmp_lib.gmp_randinit_mt(state)
            gmp_lib.gmp_randseed_ui(state, 1000UI)
            
            ' Generate a random integer in the range [0, 8-1].
            Dim rand As UInteger = gmp_lib.gmp_urandomm_ui(state, 8)
            
            ' Free all memory occupied by state.
            gmp_lib.gmp_randclear(state)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.gmp_asprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.char_ptr},System.String,System.Object[])">
            <summary>
            Form a null-terminated string in a block of memory obtained from the current memory allocation function.
            </summary>
            <param name="pp">Pointer to returned, allocated string.</param>
            <param name="fmt">Format string. See <a href="https://gmplib.org/manual/Formatted-Output-Strings.html#Formatted-Output-Strings">Formatted Output Strings</a>.</param>
            <param name="args">Arguments.</param>
            <returns>The return value is the number of characters produced, excluding the null-terminator.</returns>
            <remarks>
            <para>
            The block will be the size of the string and null-terminator. The address of the block in stored to <paramref name="pp"/>.
            </para>
            <para>
            Unlike the C library asprintf, <see cref="M:Math.Gmp.Native.gmp_lib.gmp_asprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.char_ptr},System.String,System.Object[])">gmp_asprintf</see> doesn’t return -1 if there’s no more memory available,
            it lets the current allocation function handle that. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_snprintf(Math.Gmp.Native.char_ptr,Math.Gmp.Native.size_t,System.String,System.Object[])">gmp_snprintf</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_sprintf(Math.Gmp.Native.char_ptr,System.String,System.Object[])">gmp_sprintf</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_vasprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.char_ptr},System.String,System.Object[])">gmp_vasprintf</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Formatted_Output_Functions">Formatted Output Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Formatted-Output-Functions.html#Formatted-Output-Functions">GNU MP - Formatted Output Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Formatted-Output-Strings.html#Formatted-Output-Strings">GNU MP - Formatted Output Strings</a></seealso>
            <example>
            <code language="C#">
            // Create pointer to unmanaged character string pointer.
            ptr&lt;char_ptr&gt; str = new ptr&lt;char_ptr&gt;();
            
            mpz_t z = "123456";
            mpq_t q = "123/456";
            mpf_t f = "12345e6";
            mp_limb_t m = 123456;
            
            // Print to newly allocated unmanaged memory string.
            Assert.IsTrue(gmp_lib.gmp_asprintf(str, "%Zd - %QX - %Fa - %Mo", z, q, f, m) == 42);
            Assert.IsTrue(str.Value.ToString() == "123456 - 7B/1C8 - 0x2.dfd1c04p+32 - 361100");
            
            // Release unmanaged memory.
            gmp_lib.free(str.Value);
            gmp_lib.mpz_clear(z);
            gmp_lib.mpq_clear(q);
            gmp_lib.mpf_clear(f);
            </code> 
            <code language="VB.NET">
            ' Create pointer to unmanaged character string pointer.
            Dim str As New ptr(Of char_ptr)()
            
            Dim z As mpz_t = "123456"
            Dim q As mpq_t = "123/456"
            Dim f As mpf_t = "12345e6"
            Dim m As mp_limb_t = 123456
            
            ' Print to newly allocated unmanaged memory string.
            Assert.IsTrue(gmp_lib.gmp_asprintf(str, "%Zd - %QX - %Fa - %Mo", z, q, f, m) = 42)
            Assert.IsTrue(str.Value.ToString() = "123456 - 7B/1C8 - 0x2.dfd1c04p+32 - 361100")
            
            ' Release unmanaged memory.
            gmp_lib.free(str.Value)
            gmp_lib.mpz_clear(z)
            gmp_lib.mpq_clear(q)
            gmp_lib.mpf_clear(f)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.gmp_fprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.String,System.Object[])">
            <summary>
            Print to the stream <paramref name="fp"/>.
            </summary>
            <param name="fp">File stream.</param>
            <param name="fmt">Format string. See <a href="https://gmplib.org/manual/Formatted-Output-Strings.html#Formatted-Output-Strings">Formatted Output Strings</a>.</param>
            <param name="args">Arguments.</param>
            <returns>Return the number of characters written, or -1 if an error occurred.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_printf(System.String,System.Object[])">gmp_printf</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_sprintf(Math.Gmp.Native.char_ptr,System.String,System.Object[])">gmp_sprintf</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_vfprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.String,System.Object[])">gmp_vfprintf</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Formatted_Output_Functions">Formatted Output Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Formatted-Output-Functions.html#Formatted-Output-Functions">GNU MP - Formatted Output Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Formatted-Output-Strings.html#Formatted-Output-Strings">GNU MP - Formatted Output Strings</a></seealso>
            <example>
            <code language="C#">
            // Create unique file pathname and a file pointer.
            string pathname = System.IO.Path.GetTempFileName();
            ptr&lt;FILE&gt; stream = new ptr&lt;FILE&gt;();
            
            mpz_t z = "123456";
            mpq_t q = "123/456";
            mpf_t f = "12345e6";
            mp_limb_t m = 123456;
            
            // Open file stream and print to it.
            _wfopen_s(out stream.Value.Value, pathname, "w");
            Assert.IsTrue(gmp_lib.gmp_fprintf(stream, "%Zd - %QX - %Fa - %Mo", z, q, f, m) == 42);
            fclose(stream.Value.Value);
            Assert.IsTrue(System.IO.File.ReadAllText(pathname) == "123456 - 7B/1C8 - 0x2.dfd1c04p+32 - 361100");
            
            // Release unmanaged memory.
            gmp_lib.mpz_clear(z)
            gmp_lib.mpq_clear(q)
            gmp_lib.mpf_clear(f)
            </code> 
            <code language="VB.NET">
            ' Create unique file pathname and a file pointer.
            Dim pathname As String = System.IO.Path.GetTempFileName()
            Dim stream As New ptr(Of FILE)()
            
            Dim z As mpz_t = "123456"
            Dim q As mpq_t = "123/456"
            Dim f As mpf_t = "12345e6"
            Dim m As mp_limb_t = 123456
            
            ' Open file stream and print to it.
            _wfopen_s(stream.Value.Value, pathname, "w")
            Assert.IsTrue(gmp_lib.gmp_fprintf(stream, "%Zd - %QX - %Fa - %Mo", z, q, f, m) = 42)
            fclose(stream.Value.Value)
            Assert.IsTrue(System.IO.File.ReadAllText(pathname) = "123456 - 7B/1C8 - 0x2.dfd1c04p+32 - 361100")
            
            ' Release unmanaged memory.
            gmp_lib.mpz_clear(z)
            gmp_lib.mpq_clear(q)
            gmp_lib.mpf_clear(f)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.gmp_printf(System.String,System.Object[])">
             <summary>
             Print to the standard output stdout.
             </summary>
             <param name="fmt">Format string. See <a href="https://gmplib.org/manual/Formatted-Output-Strings.html#Formatted-Output-Strings">Formatted Output Strings</a>.</param>
             <param name="args">Arguments.</param>
             <returns>Return the number of characters written, or -1 if an error occurred.</returns>
             <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_fprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.String,System.Object[])">gmp_fprintf</seealso>
             <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_sprintf(Math.Gmp.Native.char_ptr,System.String,System.Object[])">gmp_sprintf</seealso>
             <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_vprintf(System.String,System.Object[])">gmp_vprintf</seealso>
             <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Formatted_Output_Functions">Formatted Output Functions</a></seealso>
             <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Formatted-Output-Functions.html#Formatted-Output-Functions">GNU MP - Formatted Output Functions</a></seealso>
             <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Formatted-Output-Strings.html#Formatted-Output-Strings">GNU MP - Formatted Output Strings</a></seealso>
             <example>
             <code language="C#">
             mpz_t z = "123456";
             mpq_t q = "123/456";
             mpf_t f = "12345e6";
             mp_limb_t m = 123456;
             
             // Print to standard output.
             Assert.IsTrue(gmp_lib.gmp_printf("%Zd - %QX - %Fa - %Mo", z, q, f, m) == 42);
             
             // Release unmanaged memory.
             gmp_lib.mpz_clear(z)
             gmp_lib.mpq_clear(q)
             gmp_lib.mpf_clear(f)
             </code> 
             <code language="VB.NET">
             Dim z As mpz_t = "123456"
             Dim q As mpq_t = "123/456"
             Dim f As mpf_t = "12345e6"
             Dim m As mp_limb_t = 123456
             
             ' Print to standard output.
             Assert.IsTrue(gmp_lib.gmp_printf("%Zd - %QX - %Fa - %Mo", z, q, f, m) = 42)
            
             ' Release unmanaged memory.
             gmp_lib.mpz_clear(z)
             gmp_lib.mpq_clear(q)
             gmp_lib.mpf_clear(f)
             </code> 
             </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.gmp_snprintf(Math.Gmp.Native.char_ptr,Math.Gmp.Native.size_t,System.String,System.Object[])">
            <summary>
            Form a null-terminated string in <paramref name="buf"/>.
            </summary>
            <param name="buf">The string to print to.</param>
            <param name="size">The maximum number of bytes to write.</param>
            <param name="fmt">Format string. See <a href="https://gmplib.org/manual/Formatted-Output-Strings.html#Formatted-Output-Strings">Formatted Output Strings</a>.</param>
            <param name="args">Arguments.</param>
            <returns>The return value is the total number of characters which ought to have been produced, excluding the terminating null. If retval &#8805; <paramref name="size"/> then the actual output has been truncated to the first <paramref name="size"/> - 1 characters, and a null appended.</returns>
            <remarks>
            <para>
            No more than <paramref name="size"/> bytes will be written. To get the full output, <paramref name="size"/> must be enough for the string and null-terminator. 
            </para>
            <para>
            No overlap is permitted between the regiom {<paramref name="buf"/>,<paramref name="size"/>} and the <paramref name="fmt"/> string.
            </para>
            <para>
            Notice the return value is in ISO C99 snprintf style. This is so even if the C library vsnprintf is the older GLIBC 2.0.x style.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_asprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.char_ptr},System.String,System.Object[])">gmp_asprintf</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_sprintf(Math.Gmp.Native.char_ptr,System.String,System.Object[])">gmp_sprintf</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_vsnprintf(Math.Gmp.Native.char_ptr,Math.Gmp.Native.size_t,System.String,System.Object[])">gmp_vsnprintf</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Formatted_Output_Functions">Formatted Output Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Formatted-Output-Functions.html#Formatted-Output-Functions">GNU MP - Formatted Output Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Formatted-Output-Strings.html#Formatted-Output-Strings">GNU MP - Formatted Output Strings</a></seealso>
            <example>
            <code language="C#">
            // Allocate unmanaged string with 50 characters.
            char_ptr str = new char_ptr(".................................................");
            
            mpz_t z = "123456";
            mpq_t q = "123/456";
            mpf_t f = "12345e6";
            mp_limb_t m = 123456;
            
            // Print to string.
            Assert.IsTrue(gmp_lib.gmp_snprintf(str, 50, "%Zd - %QX - %Fa - %Mo", z, q, f, m) == 42);
            Assert.IsTrue(str.ToString() == "123456 - 7B/1C8 - 0x2.dfd1c04p+32 - 361100");
            
            // Release unmanaged memory.
            gmp_lib.free(str);
            gmp_lib.mpz_clear(z);
            gmp_lib.mpq_clear(q);
            gmp_lib.mpf_clear(f);
            </code> 
            <code language="VB.NET">
            ' Allocate unmanaged string with 50 characters.
            Dim str As New char_ptr(".................................................")
            
            Dim z As mpz_t = "123456"
            Dim q As mpq_t = "123/456"
            Dim f As mpf_t = "12345e6"
            Dim m As mp_limb_t = 123456
            
            ' Print to string.
            Assert.IsTrue(gmp_lib.gmp_snprintf(str, 50, "%Zd - %QX - %Fa - %Mo", z, q, f, m) = 42)
            Assert.IsTrue(str.ToString() = "123456 - 7B/1C8 - 0x2.dfd1c04p+32 - 361100")
            
            ' Release unmanaged memory.
            gmp_lib.free(str)
            gmp_lib.mpz_clear(z)
            gmp_lib.mpq_clear(q)
            gmp_lib.mpf_clear(f)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.gmp_sprintf(Math.Gmp.Native.char_ptr,System.String,System.Object[])">
            <summary>
            Form a null-terminated string in <paramref name="buf"/>.
            </summary>
            <param name="buf">The string to print to.</param>
            <param name="fmt">Format string. See <a href="https://gmplib.org/manual/Formatted-Output-Strings.html#Formatted-Output-Strings">Formatted Output Strings</a>.</param>
            <param name="args">Arguments.</param>
            <returns>Return the number of characters written, excluding the terminating null.</returns>
            <remarks>
            <para>
            No overlap is permitted between the space at <paramref name="buf"/> and the string <paramref name="fmt"/>.
            </para>
            <para>
            These functions are not recommended, since there’s no protection against exceeding the space available at <paramref name="buf"/>.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_asprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.char_ptr},System.String,System.Object[])">gmp_asprintf</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_printf(System.String,System.Object[])">gmp_printf</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_fprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.String,System.Object[])">gmp_fprintf</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_snprintf(Math.Gmp.Native.char_ptr,Math.Gmp.Native.size_t,System.String,System.Object[])">gmp_snprintf</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_vsprintf(Math.Gmp.Native.char_ptr,System.String,System.Object[])">gmp_vsprintf</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Formatted_Output_Functions">Formatted Output Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Formatted-Output-Functions.html#Formatted-Output-Functions">GNU MP - Formatted Output Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Formatted-Output-Strings.html#Formatted-Output-Strings">GNU MP - Formatted Output Strings</a></seealso>
            <example>
            <code language="C#">
            // Allocate unmanaged string with 50 characters.
            char_ptr str = new char_ptr(".................................................");
            
            mpz_t z = "123456";
            mpq_t q = "123/456";
            mpf_t f = "12345e6";
            mp_limb_t m = 123456;
            
            // Print to string.
            Assert.IsTrue(gmp_lib.gmp_sprintf(str, "%Zd - %QX - %Fa - %Mo", z, q, f, m) == 42);
            Assert.IsTrue(str.ToString() == "123456 - 7B/1C8 - 0x2.dfd1c04p+32 - 361100");
            
            // Release unmanaged memory.
            gmp_lib.free(str);
            gmp_lib.mpz_clear(z);
            gmp_lib.mpq_clear(q);
            gmp_lib.mpf_clear(f);
            </code> 
            <code language="VB.NET">
            ' Allocate unmanaged string with 50 characters.
            Dim str As New char_ptr(".................................................")
            
            Dim z As mpz_t = "123456"
            Dim q As mpq_t = "123/456"
            Dim f As mpf_t = "12345e6"
            Dim m As mp_limb_t = 123456
            
            ' Print to string.
            Assert.IsTrue(gmp_lib.gmp_sprintf(str, "%Zd - %QX - %Fa - %Mo", z, q, f, m) = 42)
            Assert.IsTrue(str.ToString() = "123456 - 7B/1C8 - 0x2.dfd1c04p+32 - 361100")
            
            ' Release unmanaged memory.
            gmp_lib.free(str)
            gmp_lib.mpz_clear(z)
            gmp_lib.mpq_clear(q)
            gmp_lib.mpf_clear(f)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.gmp_vasprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.char_ptr},System.String,System.Object[])">
            <summary>
            Form a null-terminated string in a block of memory obtained from the current memory allocation function.
            </summary>
            <param name="ptr"></param>
            <param name="fmt">Format string. See <a href="https://gmplib.org/manual/Formatted-Output-Strings.html#Formatted-Output-Strings">Formatted Output Strings</a>.</param>
            <param name="ap">Arguments.</param>
            <returns>The return value is the number of characters produced, excluding the null-terminator.</returns>
            <remarks>
            <para>
            The block will be the size of the string and null-terminator. The address of the block in stored to <paramref name="ptr"/>.
            </para>
            <para>
            Unlike the C library vasprintf, <see cref="M:Math.Gmp.Native.gmp_lib.gmp_vasprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.char_ptr},System.String,System.Object[])">gmp_vasprintf</see> doesn’t return -1 if there’s no more memory available,
            it lets the current allocation function handle that. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_asprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.char_ptr},System.String,System.Object[])">gmp_asprintf</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Formatted_Output_Functions">Formatted Output Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Formatted-Output-Functions.html#Formatted-Output-Functions">GNU MP - Formatted Output Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Formatted-Output-Strings.html#Formatted-Output-Strings">GNU MP - Formatted Output Strings</a></seealso>
            <example>
            <code language="C#">
            // Create pointer to unmanaged character string pointer.
            ptr&lt;char_ptr&gt; str = new ptr&lt;char_ptr&gt;();
            
            mpz_t z = "123456";
            mpq_t q = "123/456";
            mpf_t f = "12345e6";
            mp_limb_t m = 123456;
            
            // Print to newly allocated unmanaged memory string.
            Assert.IsTrue(gmp_lib.gmp_vasprintf(str, "%Zd - %QX - %Fa - %Mo", z, q, f, m) == 42);
            Assert.IsTrue(str.Value.ToString() == "123456 - 7B/1C8 - 0x2.dfd1c04p+32 - 361100");
            
            // Release unmanaged memory.
            gmp_lib.free(str.Value);
            gmp_lib.mpz_clear(z);
            gmp_lib.mpq_clear(q);
            gmp_lib.mpf_clear(f);
            </code> 
            <code language="VB.NET">
            ' Create pointer to unmanaged character string pointer.
            Dim str As New ptr(Of char_ptr)()
            
            Dim z As mpz_t = "123456"
            Dim q As mpq_t = "123/456"
            Dim f As mpf_t = "12345e6"
            Dim m As mp_limb_t = 123456
            
            ' Print to newly allocated unmanaged memory string.
            Assert.IsTrue(gmp_lib.gmp_vasprintf(str, "%Zd - %QX - %Fa - %Mo", z, q, f, m) = 42)
            Assert.IsTrue(str.Value.ToString() = "123456 - 7B/1C8 - 0x2.dfd1c04p+32 - 361100")
            
            ' Release unmanaged memory.
            gmp_lib.free(str.Value)
            gmp_lib.mpz_clear(z)
            gmp_lib.mpq_clear(q)
            gmp_lib.mpf_clear(f)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.gmp_vfprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.String,System.Object[])">
            <summary>
            Print to the stream <paramref name="fp"/>.
            </summary>
            <param name="fp">File stream.</param>
            <param name="fmt">Format string. See <a href="https://gmplib.org/manual/Formatted-Output-Strings.html#Formatted-Output-Strings">Formatted Output Strings</a>.</param>
            <param name="ap">Arguments.</param>
            <returns>Return the number of characters written, or -1 if an error occurred.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_fprintf(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.String,System.Object[])">gmp_fprintf</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Formatted_Output_Functions">Formatted Output Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Formatted-Output-Functions.html#Formatted-Output-Functions">GNU MP - Formatted Output Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Formatted-Output-Strings.html#Formatted-Output-Strings">GNU MP - Formatted Output Strings</a></seealso>
            <example>
            <code language="C#">
            // Create unique file pathname and a file pointer.
            string pathname = System.IO.Path.GetTempFileName();
            ptr&lt;FILE&gt; stream = new ptr&lt;FILE&gt;();
            
            mpz_t z = "123456";
            mpq_t q = "123/456";
            mpf_t f = "12345e6";
            mp_limb_t m = 123456;
            
            // Open file stream and print to it.
            _wfopen_s(out stream.Value.Value, pathname, "w");
            Assert.IsTrue(gmp_lib.gmp_vfprintf(stream, "%Zd - %QX - %Fa - %Mo", z, q, f, m) == 42);
            fclose(stream.Value.Value);
            Assert.IsTrue(System.IO.File.ReadAllText(pathname) == "123456 - 7B/1C8 - 0x2.dfd1c04p+32 - 361100");
            
            // Release unmanaged memory.
            gmp_lib.mpz_clear(z)
            gmp_lib.mpq_clear(q)
            gmp_lib.mpf_clear(f)
            </code> 
            <code language="VB.NET">
            ' Create unique file pathname and a file pointer.
            Dim pathname As String = System.IO.Path.GetTempFileName()
            Dim stream As New ptr(Of FILE)()
            
            Dim z As mpz_t = "123456"
            Dim q As mpq_t = "123/456"
            Dim f As mpf_t = "12345e6"
            Dim m As mp_limb_t = 123456
            
            ' Open file stream and print to it.
            _wfopen_s(stream.Value.Value, pathname, "w")
            Assert.IsTrue(gmp_lib.gmp_vfprintf(stream, "%Zd - %QX - %Fa - %Mo", z, q, f, m) = 42)
            fclose(stream.Value.Value)
            Assert.IsTrue(System.IO.File.ReadAllText(pathname) = "123456 - 7B/1C8 - 0x2.dfd1c04p+32 - 361100")
            ' Release unmanaged memory.
            gmp_lib.mpz_clear(z)
            gmp_lib.mpq_clear(q)
            gmp_lib.mpf_clear(f)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.gmp_vprintf(System.String,System.Object[])">
             <summary>
             Print to the standard output stdout.
             </summary>
             <param name="fmt">Format string. See <a href="https://gmplib.org/manual/Formatted-Output-Strings.html#Formatted-Output-Strings">Formatted Output Strings</a>.</param>
             <param name="ap">Arguments.</param>
             <returns>Return the number of characters written, or -1 if an error occurred.</returns>
             <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_printf(System.String,System.Object[])">gmp_printf</seealso>
             <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Formatted_Output_Functions">Formatted Output Functions</a></seealso>
             <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Formatted-Output-Functions.html#Formatted-Output-Functions">GNU MP - Formatted Output Functions</a></seealso>
             <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Formatted-Output-Strings.html#Formatted-Output-Strings">GNU MP - Formatted Output Strings</a></seealso>
             <example>
             <code language="C#">
             mpz_t z = "123456";
             mpq_t q = "123/456";
             mpf_t f = "12345e6";
             mp_limb_t m = 123456;
             
             // Print to standard output.
             Assert.IsTrue(gmp_lib.gmp_vprintf("%Zd - %QX - %Fa - %Mo", z, q, f, m) == 42);
             
             // Release unmanaged memory.
             gmp_lib.mpz_clear(z)
             gmp_lib.mpq_clear(q)
             gmp_lib.mpf_clear(f)
             </code> 
             <code language="VB.NET">
             Dim z As mpz_t = "123456"
             Dim q As mpq_t = "123/456"
             Dim f As mpf_t = "12345e6"
             Dim m As mp_limb_t = 123456
             
             ' Print to standard output.
             Assert.IsTrue(gmp_lib.gmp_vprintf("%Zd - %QX - %Fa - %Mo", z, q, f, m) = 42)
            
             ' Release unmanaged memory.
             gmp_lib.mpz_clear(z)
             gmp_lib.mpq_clear(q)
             gmp_lib.mpf_clear(f)
             </code> 
             </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.gmp_vsnprintf(Math.Gmp.Native.char_ptr,Math.Gmp.Native.size_t,System.String,System.Object[])">
            <summary>
            Form a null-terminated string in <paramref name="buf"/>.
            </summary>
            <param name="buf">The string to print to.</param>
            <param name="size">The maximum number of bytes to write.</param>
            <param name="fmt">Format string. See <a href="https://gmplib.org/manual/Formatted-Output-Strings.html#Formatted-Output-Strings">Formatted Output Strings</a>.</param>
            <param name="ap">Arguments.</param>
            <returns>The return value is the total number of characters which ought to have been produced, excluding the terminating null. If retval &#8805; <paramref name="size"/> then the actual output has been truncated to the first <paramref name="size"/> - 1 characters, and a null appended.</returns>
            <remarks>
            <para>
            No more than <paramref name="size"/> bytes will be written. To get the full output, <paramref name="size"/> must be enough for the string and null-terminator. 
            </para>
            <para>
            No overlap is permitted between the regiom {<paramref name="buf"/>,<paramref name="size"/>} and the <paramref name="fmt"/> string.
            </para>
            <para>
            Notice the return value is in ISO C99 snprintf style. This is so even if the C library vsnprintf is the older GLIBC 2.0.x style. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_snprintf(Math.Gmp.Native.char_ptr,Math.Gmp.Native.size_t,System.String,System.Object[])">gmp_snprintf</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Formatted_Output_Functions">Formatted Output Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Formatted-Output-Functions.html#Formatted-Output-Functions">GNU MP - Formatted Output Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Formatted-Output-Strings.html#Formatted-Output-Strings">GNU MP - Formatted Output Strings</a></seealso>
            <example>
            <code language="C#">
            // Allocate unmanaged string with 50 characters.
            char_ptr str = new char_ptr(".................................................");
            
            mpz_t z = "123456";
            mpq_t q = "123/456";
            mpf_t f = "12345e6";
            mp_limb_t m = 123456;
            
            // Print to string.
            Assert.IsTrue(gmp_lib.gmp_vsnprintf(str, 50, "%Zd - %QX - %Fa - %Mo", z, q, f, m) == 42);
            Assert.IsTrue(str.ToString() == "123456 - 7B/1C8 - 0x2.dfd1c04p+32 - 361100");
            
            // Release unmanaged memory.
            gmp_lib.free(str);
            gmp_lib.mpz_clear(z);
            gmp_lib.mpq_clear(q);
            gmp_lib.mpf_clear(f);
            </code> 
            <code language="VB.NET">
            ' Allocate unmanaged string with 50 characters.
            Dim str As New char_ptr(".................................................")
            
            Dim z As mpz_t = "123456"
            Dim q As mpq_t = "123/456"
            Dim f As mpf_t = "12345e6"
            Dim m As mp_limb_t = 123456
            
            ' Print to string.
            Assert.IsTrue(gmp_lib.gmp_vsnprintf(str, 50, "%Zd - %QX - %Fa - %Mo", z, q, f, m) = 42)
            Assert.IsTrue(str.ToString() = "123456 - 7B/1C8 - 0x2.dfd1c04p+32 - 361100")
            
            ' Release unmanaged memory.
            gmp_lib.free(str)
            gmp_lib.mpz_clear(z)
            gmp_lib.mpq_clear(q)
            gmp_lib.mpf_clear(f)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.gmp_vsprintf(Math.Gmp.Native.char_ptr,System.String,System.Object[])">
            <summary>
            Form a null-terminated string in <paramref name="buf"/>.
            </summary>
            <param name="buf">The string to print to.</param>
            <param name="fmt">Format string. See <a href="https://gmplib.org/manual/Formatted-Output-Strings.html#Formatted-Output-Strings">Formatted Output Strings</a>.</param>
            <param name="ap">Arguments.</param>
            <returns>Return the number of characters written, excluding the terminating null.</returns>
            <remarks>
            <para>
            No overlap is permitted between the space at <paramref name="buf"/> and the string <paramref name="fmt"/>.
            </para>
            <para>
            These functions are not recommended, since there’s no protection against exceeding the space available at <paramref name="buf"/>.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_sprintf(Math.Gmp.Native.char_ptr,System.String,System.Object[])">gmp_sprintf</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Formatted_Output_Functions">Formatted Output Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Formatted-Output-Functions.html#Formatted-Output-Functions">GNU MP - Formatted Output Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Formatted-Output-Strings.html#Formatted-Output-Strings">GNU MP - Formatted Output Strings</a></seealso>
            <example>
            <code language="C#">
            // Allocate unmanaged string with 50 characters.
            char_ptr str = new char_ptr(".................................................");
            
            mpz_t z = "123456";
            mpq_t q = "123/456";
            mpf_t f = "12345e6";
            mp_limb_t m = 123456;
            
            // Print to string.
            Assert.IsTrue(gmp_lib.gmp_vsprintf(str, "%Zd - %QX - %Fa - %Mo", z, q, f, m) == 42);
            Assert.IsTrue(str.ToString() == "123456 - 7B/1C8 - 0x2.dfd1c04p+32 - 361100");
            
            // Release unmanaged memory.
            gmp_lib.free(str);
            gmp_lib.mpz_clear(z);
            gmp_lib.mpq_clear(q);
            gmp_lib.mpf_clear(f);
            </code> 
            <code language="VB.NET">
            ' Allocate unmanaged string with 50 characters.
            Dim str As New char_ptr(".................................................")
            
            Dim z As mpz_t = "123456"
            Dim q As mpq_t = "123/456"
            Dim f As mpf_t = "12345e6"
            Dim m As mp_limb_t = 123456
            
            ' Print to string.
            Assert.IsTrue(gmp_lib.gmp_vsprintf(str, "%Zd - %QX - %Fa - %Mo", z, q, f, m) = 42)
            Assert.IsTrue(str.ToString() = "123456 - 7B/1C8 - 0x2.dfd1c04p+32 - 361100")
            
            ' Release unmanaged memory.
            gmp_lib.free(str)
            gmp_lib.mpz_clear(z)
            gmp_lib.mpq_clear(q)
            gmp_lib.mpf_clear(f)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.gmp_fscanf(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.String,System.Object[])">
            <summary>
            Read from the stream <paramref name="fp"/>.
            </summary>
            <param name="fp">File stream.</param>
            <param name="fmt">Format string. See <a href="https://gmplib.org/manual/Formatted-Input-Strings.html#Formatted-Input-Strings">Formatted Input Strings</a>.</param>
            <param name="ap">Arguments.</param>
            <returns>The return value the number of fields successfully parsed and stored. ‘%n’ fields and fields read but suppressed by ‘*’ don’t count towards the return value.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_scanf(System.String,System.Object[])">gmp_scanf</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_sscanf(System.String,System.String,System.Object[])">gmp_sscanf</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_vfscanf(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.String,System.Object[])">gmp_vfscanf</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Formatted_Input_Functions">Formatted Input Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Formatted-Input-Functions.html#Formatted-Input-Functions">GNU MP - Formatted Input Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Formatted-Input-Strings.html#Formatted-Input-Strings">GNU MP - Formatted Input Strings</a></seealso>
            <example>
            <code language="C#">
            // Create unique filename and stream pointer.
            string pathname = System.IO.Path.GetTempFileName();
            ptr&lt;FILE&gt; stream = new ptr&lt;FILE&gt;();
            
            mpz_t z = "0";
            mpq_t q = "0";
            mpf_t f = "0";
            ptr&lt;Char&gt; c = new ptr&lt;Char&gt;('0');
            ptr&lt;mp_size_t&gt; zt = new ptr&lt;mp_size_t&gt;(0);
            ptr&lt;Double&gt; dbl = new ptr&lt;Double&gt;(0);
            
            // Write string to file, and then read values from it.
            System.IO.File.WriteAllText(pathname, "123456 7B/1C8 1.234500e+10 A 10 1.000000");
            _wfopen_s(out stream.Value.Value, pathname, "r");
            Assert.IsTrue(gmp_lib.gmp_fscanf(stream, "%Zd %QX %Fe %hhc %d %lf", z, q, f, c, zt, dbl) == 6);
            fclose(stream.Value.Value);
            
            // Assert values read.
            Assert.IsTrue(z.ToString() == "123456");
            Assert.IsTrue(q.ToString() == "123/456");
            Assert.IsTrue(f.ToString() == "0.12345e11");
            Assert.IsTrue(c.Value == 'A');
            Assert.IsTrue(zt.Value == 10);
            Assert.IsTrue(dbl.Value == 1.0);
            
            // Release unmanaged memory.
            gmp_lib.mpz_clear(z);
            gmp_lib.mpq_clear(q);
            gmp_lib.mpf_clear(f);
            </code> 
            <code language="VB.NET">
            ' Create unique filename and stream pointer.
            Dim pathname As String = System.IO.Path.GetTempFileName()
            Dim stream As New ptr(Of FILE)()
            
            Dim z As mpz_t = "0"
            Dim q As mpq_t = "0"
            Dim f As mpf_t = "0"
            Dim c As New ptr(Of[Char])("0"C)
            Dim zt As New ptr(Of mp_size_t)(0)
            Dim dbl As New ptr(Of[Double])(0)
            
            ' Write string to file, and then read values from it.
            System.IO.File.WriteAllText(pathname, "123456 7B/1C8 1.234500e+10 A 10 1.000000")
            _wfopen_s(stream.Value.Value, pathname, "r")
            Assert.IsTrue(gmp_lib.gmp_fscanf(stream, "%Zd %QX %Fe %hhc %d %lf", z, q, f, c, zt, dbl) = 6)
            fclose(stream.Value.Value)
            
            ' Assert values read.
            Assert.IsTrue(z.ToString() = "123456")
            Assert.IsTrue(q.ToString() = "123/456")
            Assert.IsTrue(f.ToString() = "0.12345e11")
            Assert.IsTrue(c.Value = "A"C)
            Assert.IsTrue(zt.Value = 10)
            Assert.IsTrue(dbl.Value = 1.0)
            
            ' Release unmanaged memory.
            gmp_lib.mpz_clear(z)
            gmp_lib.mpq_clear(q)
            gmp_lib.mpf_clear(f)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.gmp_scanf(System.String,System.Object[])">
            <summary>
            Read from the standard input <c>stdin</c>.
            </summary>
            <param name="fmt">Format string. See <a href="https://gmplib.org/manual/Formatted-Input-Strings.html#Formatted-Input-Strings">Formatted Input Strings</a>.</param>
            <param name="ap">Arguments.</param>
            <returns>The return value the number of fields successfully parsed and stored. ‘%n’ fields and fields read but suppressed by ‘*’ don’t count towards the return value.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_fscanf(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.String,System.Object[])">gmp_fscanf</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_sscanf(System.String,System.String,System.Object[])">gmp_sscanf</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_vscanf(System.String,System.Object[])">gmp_vscanf</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Formatted_Input_Functions">Formatted Input Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Formatted-Input-Functions.html#Formatted-Input-Functions">GNU MP - Formatted Input Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Formatted-Input-Strings.html#Formatted-Input-Strings">GNU MP - Formatted Input Strings</a></seealso>
            <example>
            <code language="C#">
            mpz_t z = "0";
            mpq_t q = "0";
            mpf_t f = "0";
            ptr&lt;Char&gt; c = new ptr&lt;Char&gt;('0');
            ptr&lt;mp_size_t&gt; zt = new ptr&lt;mp_size_t&gt;(0);
            ptr&lt;Double&gt; dbl = new ptr&lt;Double&gt;(0);
            
            // Read values from standard input.
            Assert.IsTrue(gmp_lib.gmp_scanf(stream, "%Zd %QX %Fe %hhc %d %lf", z, q, f, c, zt, dbl) == 6);
            
            // Assert values read.
            Assert.IsTrue(z.ToString() == "123456");
            Assert.IsTrue(q.ToString() == "123/456");
            Assert.IsTrue(f.ToString() == "0.12345e11");
            Assert.IsTrue(c.Value == 'A');
            Assert.IsTrue(zt.Value == 10);
            Assert.IsTrue(dbl.Value == 1.0);
            
            // Release unmanaged memory.
            gmp_lib.mpz_clear(z);
            gmp_lib.mpq_clear(q);
            gmp_lib.mpf_clear(f);
            </code> 
            <code language="VB.NET">
            Dim z As mpz_t = "0"
            Dim q As mpq_t = "0"
            Dim f As mpf_t = "0"
            Dim c As New ptr(Of[Char])("0"C)
            Dim zt As New ptr(Of mp_size_t)(0)
            Dim dbl As New ptr(Of[Double])(0)
            
            ' Read values from standard input.
            Assert.IsTrue(gmp_lib.gmp_scanf(stream, "%Zd %QX %Fe %hhc %d %lf", z, q, f, c, zt, dbl) = 6)
            
            ' Assert values read.
            Assert.IsTrue(z.ToString() = "123456")
            Assert.IsTrue(q.ToString() = "123/456")
            Assert.IsTrue(f.ToString() = "0.12345e11")
            Assert.IsTrue(c.Value = "A"C)
            Assert.IsTrue(zt.Value = 10)
            Assert.IsTrue(dbl.Value = 1.0)
            
            ' Release unmanaged memory.
            gmp_lib.mpz_clear(z)
            gmp_lib.mpq_clear(q)
            gmp_lib.mpf_clear(f)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.gmp_sscanf(System.String,System.String,System.Object[])">
            <summary>
            Read from a null-terminated string <paramref name="s"/>.
            </summary>
            <param name="s">A string.</param>
            <param name="fmt">Format string. See <a href="https://gmplib.org/manual/Formatted-Input-Strings.html#Formatted-Input-Strings">Formatted Input Strings</a>.</param>
            <param name="ap">Arguments.</param>
            <returns>The return value the number of fields successfully parsed and stored. ‘%n’ fields and fields read but suppressed by ‘*’ don’t count towards the return value.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_fscanf(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.String,System.Object[])">gmp_fscanf</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_scanf(System.String,System.Object[])">gmp_scanf</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_vsscanf(System.String,System.String,System.Object[])">gmp_vsscanf</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Formatted_Input_Functions">Formatted Input Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Formatted-Input-Functions.html#Formatted-Input-Functions">GNU MP - Formatted Input Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Formatted-Input-Strings.html#Formatted-Input-Strings">GNU MP - Formatted Input Strings</a></seealso>
            <example>
            <code language="C#">
            mpz_t z = "0";
            mpq_t q = "0";
            mpf_t f = "0";
            ptr&lt;Char&gt; c = new ptr&lt;Char&gt;('0');
            ptr&lt;mp_size_t&gt; zt = new ptr&lt;mp_size_t&gt;(0);
            ptr&lt;Double&gt; dbl = new ptr&lt;Double&gt;(0);
            
            Assert.IsTrue(gmp_lib.gmp_sscanf("123456 7B/1C8 1.234500e+10 A 10 1.000000", "%Zd %QX %Fe %hhc %d %lf", z, q, f, c, zt, dbl) == 6);
            
            Assert.IsTrue(z.ToString() == "123456");
            Assert.IsTrue(q.ToString() == "123/456");
            Assert.IsTrue(f.ToString() == "0.12345e11");
            Assert.IsTrue(c.Value == 'A');
            Assert.IsTrue(zt.Value == 10);
            Assert.IsTrue(dbl.Value == 1.0);
            
            // Release unmanaged memory.
            gmp_lib.mpz_clear(z);
            gmp_lib.mpq_clear(q);
            gmp_lib.mpf_clear(f);
            </code> 
            <code language="VB.NET">
            Dim z As mpz_t = "0"
            Dim q As mpq_t = "0"
            Dim f As mpf_t = "0"
            Dim c As New ptr(Of[Char])("0"C)
            Dim zt As New ptr(Of mp_size_t)(0)
            Dim dbl As New ptr(Of[Double])(0)
            
            Assert.IsTrue(gmp_lib.gmp_sscanf("123456 7B/1C8 1.234500e+10 A 10 1.000000", "%Zd %QX %Fe %hhc %d %lf", z, q, f, c, zt, dbl) = 6)
            
            Assert.IsTrue(z.ToString() = "123456")
            Assert.IsTrue(q.ToString() = "123/456")
            Assert.IsTrue(f.ToString() = "0.12345e11")
            Assert.IsTrue(c.Value = "A"C)
            Assert.IsTrue(zt.Value = 10)
            Assert.IsTrue(dbl.Value = 1.0)
            
            ' Release unmanaged memory.
            gmp_lib.mpz_clear(z)
            gmp_lib.mpq_clear(q)
            gmp_lib.mpf_clear(f)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.gmp_vfscanf(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.String,System.Object[])">
            <summary>
            Read from the stream <paramref name="fp"/>.
            </summary>
            <param name="fp">File stream.</param>
            <param name="fmt">Format string. See <a href="https://gmplib.org/manual/Formatted-Input-Strings.html#Formatted-Input-Strings">Formatted Input Strings</a>.</param>
            <param name="ap">Arguments.</param>
            <returns>The return value the number of fields successfully parsed and stored. ‘%n’ fields and fields read but suppressed by ‘*’ don’t count towards the return value.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_fscanf(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.String,System.Object[])">gmp_fscanf</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_vscanf(System.String,System.Object[])">gmp_vscanf</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_vsscanf(System.String,System.String,System.Object[])">gmp_vsscanf</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Formatted_Input_Functions">Formatted Input Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Formatted-Input-Functions.html#Formatted-Input-Functions">GNU MP - Formatted Input Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Formatted-Input-Strings.html#Formatted-Input-Strings">GNU MP - Formatted Input Strings</a></seealso>
            <example>
            <code language="C#">
            // Create unique filename and stream pointer.
            string pathname = System.IO.Path.GetTempFileName();
            ptr&lt;FILE&gt; stream = new ptr&lt;FILE&gt;();
            
            mpz_t z = "0";
            mpq_t q = "0";
            mpf_t f = "0";
            ptr&lt;Char&gt; c = new ptr&lt;Char&gt;('0');
            ptr&lt;mp_size_t&gt; zt = new ptr&lt;mp_size_t&gt;(0);
            ptr&lt;Double&gt; dbl = new ptr&lt;Double&gt;(0);
            
            // Write string to file, and then read values from it.
            System.IO.File.WriteAllText(pathname, "123456 7B/1C8 1.234500e+10 A 10 1.000000");
            _wfopen_s(out stream.Value.Value, pathname, "r");
            Assert.IsTrue(gmp_lib.gmp_vfscanf(stream, "%Zd %QX %Fe %hhc %d %lf", z, q, f, c, zt, dbl) == 6);
            fclose(stream.Value.Value);
            
            // Assert values read.
            Assert.IsTrue(z.ToString() == "123456");
            Assert.IsTrue(q.ToString() == "123/456");
            Assert.IsTrue(f.ToString() == "0.12345e11");
            Assert.IsTrue(c.Value == 'A');
            Assert.IsTrue(zt.Value == 10);
            Assert.IsTrue(dbl.Value == 1.0);
            
            // Release unmanaged memory.
            gmp_lib.mpz_clear(z);
            gmp_lib.mpq_clear(q);
            gmp_lib.mpf_clear(f);
            </code> 
            <code language="VB.NET">
            ' Create unique filename and stream pointer.
            Dim pathname As String = System.IO.Path.GetTempFileName()
            Dim stream As New ptr(Of FILE)()
            
            Dim z As mpz_t = "0"
            Dim q As mpq_t = "0"
            Dim f As mpf_t = "0"
            Dim c As New ptr(Of[Char])("0"C)
            Dim zt As New ptr(Of mp_size_t)(0)
            Dim dbl As New ptr(Of[Double])(0)
            
            ' Write string to file, and then read values from it.
            System.IO.File.WriteAllText(pathname, "123456 7B/1C8 1.234500e+10 A 10 1.000000")
            _wfopen_s(stream.Value.Value, pathname, "r")
            Assert.IsTrue(gmp_lib.gmp_vfscanf(stream, "%Zd %QX %Fe %hhc %d %lf", z, q, f, c, zt, dbl) = 6)
            fclose(stream.Value.Value)
            
            ' Assert values read.
            Assert.IsTrue(z.ToString() = "123456")
            Assert.IsTrue(q.ToString() = "123/456")
            Assert.IsTrue(f.ToString() = "0.12345e11")
            Assert.IsTrue(c.Value = "A"C)
            Assert.IsTrue(zt.Value = 10)
            Assert.IsTrue(dbl.Value = 1.0)
            
            ' Release unmanaged memory.
            gmp_lib.mpz_clear(z)
            gmp_lib.mpq_clear(q)
            gmp_lib.mpf_clear(f)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.gmp_vscanf(System.String,System.Object[])">
            <summary>
            Read from the standard input <c>stdin</c>.
            </summary>
            <param name="fmt">Format string. See <a href="https://gmplib.org/manual/Formatted-Input-Strings.html#Formatted-Input-Strings">Formatted Input Strings</a>.</param>
            <param name="ap">Arguments.</param>
            <returns>The return value the number of fields successfully parsed and stored. ‘%n’ fields and fields read but suppressed by ‘*’ don’t count towards the return value.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_scanf(System.String,System.Object[])">gmp_scanf</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_vfscanf(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.String,System.Object[])">gmp_vfscanf</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_vsscanf(System.String,System.String,System.Object[])">gmp_vsscanf</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Formatted_Input_Functions">Formatted Input Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Formatted-Input-Functions.html#Formatted-Input-Functions">GNU MP - Formatted Input Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Formatted-Input-Strings.html#Formatted-Input-Strings">GNU MP - Formatted Input Strings</a></seealso>
            <example>
            <code language="C#">
            mpz_t z = "0";
            mpq_t q = "0";
            mpf_t f = "0";
            ptr&lt;Char&gt; c = new ptr&lt;Char&gt;('0');
            ptr&lt;mp_size_t&gt; zt = new ptr&lt;mp_size_t&gt;(0);
            ptr&lt;Double&gt; dbl = new ptr&lt;Double&gt;(0);
            
            // Read values from standard input.
            Assert.IsTrue(gmp_lib.gmp_vscanf(stream, "%Zd %QX %Fe %hhc %d %lf", z, q, f, c, zt, dbl) == 6);
            
            // Assert values read.
            Assert.IsTrue(z.ToString() == "123456");
            Assert.IsTrue(q.ToString() == "123/456");
            Assert.IsTrue(f.ToString() == "0.12345e11");
            Assert.IsTrue(c.Value == 'A');
            Assert.IsTrue(zt.Value == 10);
            Assert.IsTrue(dbl.Value == 1.0);
            
            // Release unmanaged memory.
            gmp_lib.mpz_clear(z);
            gmp_lib.mpq_clear(q);
            gmp_lib.mpf_clear(f);
            </code> 
            <code language="VB.NET">
            Dim z As mpz_t = "0"
            Dim q As mpq_t = "0"
            Dim f As mpf_t = "0"
            Dim c As New ptr(Of[Char])("0"C)
            Dim zt As New ptr(Of mp_size_t)(0)
            Dim dbl As New ptr(Of[Double])(0)
            
            ' Read values from standard input.
            Assert.IsTrue(gmp_lib.gmp_vscanf(stream, "%Zd %QX %Fe %hhc %d %lf", z, q, f, c, zt, dbl) = 6)
            
            ' Assert values read.
            Assert.IsTrue(z.ToString() = "123456")
            Assert.IsTrue(q.ToString() = "123/456")
            Assert.IsTrue(f.ToString() = "0.12345e11")
            Assert.IsTrue(c.Value = "A"C)
            Assert.IsTrue(zt.Value = 10)
            Assert.IsTrue(dbl.Value = 1.0)
            
            ' Release unmanaged memory.
            gmp_lib.mpz_clear(z)
            gmp_lib.mpq_clear(q)
            gmp_lib.mpf_clear(f)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.gmp_vsscanf(System.String,System.String,System.Object[])">
            <summary>
            Read from a null-terminated string <paramref name="s"/>.
            </summary>
            <param name="s">A string.</param>
            <param name="fmt">Format string. See <a href="https://gmplib.org/manual/Formatted-Input-Strings.html#Formatted-Input-Strings">Formatted Input Strings</a>.</param>
            <param name="ap">Arguments.</param>
            <returns>The return value the number of fields successfully parsed and stored. ‘%n’ fields and fields read but suppressed by ‘*’ don’t count towards the return value.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_sscanf(System.String,System.String,System.Object[])">gmp_sscanf</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_vfscanf(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.String,System.Object[])">gmp_vfscanf</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.gmp_vscanf(System.String,System.Object[])">gmp_vscanf</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Formatted_Input_Functions">Formatted Input Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Formatted-Input-Functions.html#Formatted-Input-Functions">GNU MP - Formatted Input Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Formatted-Input-Strings.html#Formatted-Input-Strings">GNU MP - Formatted Input Strings</a></seealso>
            <example>
            <code language="C#">
            mpz_t z = "0";
            mpq_t q = "0";
            mpf_t f = "0";
            ptr&lt;Char&gt; c = new ptr&lt;Char&gt;('0');
            ptr&lt;mp_size_t&gt; zt = new ptr&lt;mp_size_t&gt;(0);
            ptr&lt;Double&gt; dbl = new ptr&lt;Double&gt;(0);
            
            Assert.IsTrue(gmp_lib.gmp_vsscanf("123456 7B/1C8 1.234500e+10 A 10 1.000000", "%Zd %QX %Fe %hhc %d %lf", z, q, f, c, zt, dbl) == 6);
            
            Assert.IsTrue(z.ToString() == "123456");
            Assert.IsTrue(q.ToString() == "123/456");
            Assert.IsTrue(f.ToString() == "0.12345e11");
            Assert.IsTrue(c.Value == 'A');
            Assert.IsTrue(zt.Value == 10);
            Assert.IsTrue(dbl.Value == 1.0);
            
            // Release unmanaged memory.
            gmp_lib.mpz_clear(z);
            gmp_lib.mpq_clear(q);
            gmp_lib.mpf_clear(f);
            </code> 
            <code language="VB.NET">
            Dim z As mpz_t = "0"
            Dim q As mpq_t = "0"
            Dim f As mpf_t = "0"
            Dim c As New ptr(Of[Char])("0"C)
            Dim zt As New ptr(Of mp_size_t)(0)
            Dim dbl As New ptr(Of[Double])(0)
            
            Assert.IsTrue(gmp_lib.gmp_vsscanf("123456 7B/1C8 1.234500e+10 A 10 1.000000", "%Zd %QX %Fe %hhc %d %lf", z, q, f, c, zt, dbl) = 6)
            
            Assert.IsTrue(z.ToString() = "123456")
            Assert.IsTrue(q.ToString() = "123/456")
            Assert.IsTrue(f.ToString() = "0.12345e11")
            Assert.IsTrue(c.Value = "A"C)
            Assert.IsTrue(zt.Value = 10)
            Assert.IsTrue(dbl.Value = 1.0)
            
            ' Release unmanaged memory.
            gmp_lib.mpz_clear(z)
            gmp_lib.mpq_clear(q)
            gmp_lib.mpf_clear(f)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib._mpz_realloc(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">
            <summary>
            Change the space for <paramref name="integer"/> to <paramref name="new_alloc"/> limbs.
            </summary>
            <param name="integer">The integer to resize.</param>
            <param name="new_alloc">The new number of limbs.</param>
            <remarks>
            <para>
            The value in <paramref name="integer"/> is preserved if it fits, or is set to 0 if not.
            </para>
            <para>
            <see cref="M:Math.Gmp.Native.gmp_lib.mpz_realloc2(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_realloc2</see> is the preferred way to accomplish allocation changes like this.
            <see cref="M:Math.Gmp.Native.gmp_lib.mpz_realloc2(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_realloc2</see> and <see cref="M:Math.Gmp.Native.gmp_lib._mpz_realloc(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">_mpz_realloc</see> are the same except that
            <see cref="M:Math.Gmp.Native.gmp_lib._mpz_realloc(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">_mpz_realloc</see> takes its size in limbs.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_realloc2(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_realloc2</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_getlimbn(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">mpz_getlimbn</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_size(Math.Gmp.Native.mpz_t)">mpz_size</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_limbs_read(Math.Gmp.Native.mpz_t)">mpz_limbs_read</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_limbs_write(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">mpz_limbs_write</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_limbs_modify(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">mpz_limbs_modify</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_limbs_finish(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">mpz_limbs_finish</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_roinit_n(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpz_roinit_n</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Special_Functions">Integer Special Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Special-Functions.html#Integer-Special-Functions">GNU MP - Integer Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize new integer x.
            mpz_t x = new mpz_t();
            gmp_lib.mpz_init(x);
            
            // Set the value of x to a 77-bit integer.
            char_ptr value = new char_ptr("1000 0000 0000 0000 0000");
            gmp_lib.mpz_set_str(x, value, 16);
            
            // Resize x to 50 limbs, and assert that its value has not changed.
            gmp_lib._mpz_realloc(x, 50);
            char_ptr s = gmp_lib.mpz_get_str(char_ptr.Zero, 16, x);
            Assert.IsTrue(s.ToString() == "1000 0000 0000 0000 0000".Replace(" ", ""));
            
            // Resize x to 1 limb, and assert that its value has changed to 0.
            gmp_lib._mpz_realloc(x, 1);
            Assert.IsTrue(gmp_lib.mpz_get_si(x) == 0);
            
            // Release unmanaged memory allocated for x and string values.
            gmp_lib.mpz_clear(x);
            gmp_lib.free(value);
            gmp_lib.free(s);
            </code> 
            <code language="VB.NET">
            ' Create and initialize new integer x.
            Dim x As New mpz_t()
            gmp_lib.mpz_init(x)
            
            ' Set the value of x to a 77-bit integer.
            Dim value As New char_ptr("1000 0000 0000 0000 0000")
            gmp_lib.mpz_set_str(x, value, 16)
            
            ' Resize x to 50 limbs, and assert that its value has not changed.
            gmp_lib._mpz_realloc(x, 50)
            Dim s As char_ptr = gmp_lib.mpz_get_str(char_ptr.Zero, 16, x)
            Assert.IsTrue(s.ToString() = "1000 0000 0000 0000 0000".Replace(" ", ""))
            
            ' Resize x to 1 limb, and assert that its value has changed to 0.
            gmp_lib._mpz_realloc(x, 1)
            Assert.IsTrue(gmp_lib.mpz_get_si(x) = 0)
            
            ' Release unmanaged memory allocated for x and string values.
            gmp_lib.mpz_clear(x)
            gmp_lib.free(value)
            gmp_lib.free(s)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_abs(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">
            <summary>
            Set <paramref name="rop"/> to the absolute value of <paramref name="op"/>.
            </summary>
            <param name="rop">The result integer.</param>
            <param name="op">The operand integer.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_add(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_addmul(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_addmul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mul(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_neg(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_sub(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_submul(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_submul</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Arithmetic">Integer Arithmetic</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Arithmetic.html#Integer-Arithmetic">GNU MP - Integer Arithmetic</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of x to -10000.
            mpz_t x = new mpz_t();
            gmp_lib.mpz_init_set_si(x, -10000);
            
            // Create, initialize, and set the value of z to 0.
            mpz_t z = new mpz_t();
            gmp_lib.mpz_init(z);
            
            // Set z = |x|.
            gmp_lib.mpz_abs(z, x);
            
            // Assert that z is |x|.
            Assert.IsTrue(gmp_lib.mpz_get_si(z) == 10000);
            
            // Release unmanaged memory allocated for x and z.
            gmp_lib.mpz_clears(x, z, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of x to -10000.
            Dim x As New mpz_t()
            gmp_lib.mpz_init_set_si(x, -10000)
            
            ' Create, initialize, and set the value of z to 0.
            Dim z As New mpz_t()
            gmp_lib.mpz_init(z)
            
            ' Set z = |x|.
            gmp_lib.mpz_abs(z, x)
            
            ' Assert that z is |x|.
            Assert.IsTrue(gmp_lib.mpz_get_si(z) = 10000)
            
            ' Release unmanaged memory allocated for x and z.
            gmp_lib.mpz_clears(x, z, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_add(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> + <paramref name="op2"/>.
            </summary>
            <param name="rop">The result integer.</param>
            <param name="op1">The first operand integer.</param>
            <param name="op2">The second operand integer.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_abs(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_abs</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_add_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_add_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_addmul(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_addmul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mul(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_neg(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_sub(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_submul(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_submul</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Arithmetic">Integer Arithmetic</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Arithmetic.html#Integer-Arithmetic">GNU MP - Integer Arithmetic</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of x to 10000.
            mpz_t x = new mpz_t();
            gmp_lib.mpz_init_set_ui(x, 10000U);
            
            // Create, initialize, and set the value of y to 12222.
            mpz_t y = new mpz_t();
            gmp_lib.mpz_init_set_ui(y, 12222U);
            
            // Create, initialize, and set the value of z to 0.
            mpz_t z = new mpz_t();
            gmp_lib.mpz_init(z);
            
            // Set z = x + y.
            gmp_lib.mpz_add(z, x, y);
            
            // Assert that z is the sum of x and y.
            Assert.IsTrue(gmp_lib.mpz_get_ui(z) == 22222U);
            
            // Release unmanaged memory allocated for x, y, and z.
            gmp_lib.mpz_clears(x, y, z, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of x to 10000.
            Dim x As New mpz_t()
            gmp_lib.mpz_init_set_ui(x, 10000UI)
            
            ' Create, initialize, and set the value of y to 12222.
            Dim y As New mpz_t()
            gmp_lib.mpz_init_set_ui(y, 12222UI)
            
            ' Create, initialize, and set the value of z to 0.
            Dim z As New mpz_t()
            gmp_lib.mpz_init(z)
            
            ' Set z = x + y.
            gmp_lib.mpz_add(z, x, y)
            
            ' Assert that z is the sum of x and y.
            Assert.IsTrue(gmp_lib.mpz_get_ui(z) = 22222UI)
            
            ' Release unmanaged memory allocated for x, y, and z.
            gmp_lib.mpz_clears(x, y, z, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_add_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> + <paramref name="op2"/>.
            </summary>
            <param name="rop">The result integer.</param>
            <param name="op1">The first operand integer.</param>
            <param name="op2">The second operand integer.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_abs(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_abs</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_add(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_addmul(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_addmul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mul(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_neg(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_sub(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_submul(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_submul</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Arithmetic">Integer Arithmetic</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Arithmetic.html#Integer-Arithmetic">GNU MP - Integer Arithmetic</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of x to 0.
            mpz_t x = new mpz_t();
            gmp_lib.mpz_init(x);
            
            // Increment x twice by 101999.
            gmp_lib.mpz_add_ui(x, x, 101999U);
            gmp_lib.mpz_add_ui(x, x, 101999U);
            
            // Assert that x is 203998.
            Assert.IsTrue(gmp_lib.mpz_get_ui(x) == 203998U);
            
            // Release unmanaged memory allocated for x.
            gmp_lib.mpz_clear(x);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of x to 0.
            Dim x As New mpz_t()
            gmp_lib.mpz_init(x)
            
            ' Increment x twice by 101999.
            gmp_lib.mpz_add_ui(x, x, 101999UI)
            gmp_lib.mpz_add_ui(x, x, 101999UI)
            
            ' Assert that x is 203998.
            Assert.IsTrue(gmp_lib.mpz_get_ui(x) = 203998UI)
            
            ' Release unmanaged memory allocated for x.
            gmp_lib.mpz_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_addmul(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="rop"/> + <paramref name="op1"/> * <paramref name="op2"/>.
            </summary>
            <param name="rop">The result integer.</param>
            <param name="op1">The first operand integer.</param>
            <param name="op2">The second operand integer.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_abs(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_abs</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_add(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_addmul_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_addmul_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mul(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_neg(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_sub(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_submul(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_submul</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Arithmetic">Integer Arithmetic</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Arithmetic.html#Integer-Arithmetic">GNU MP - Integer Arithmetic</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of x to 10000.
            mpz_t x = new mpz_t();
            gmp_lib.mpz_init_set_ui(x, 10000U);
            
            // Create, initialize, and set the value of y to 12222.
            mpz_t y = new mpz_t();
            gmp_lib.mpz_init_set_ui(y, 12222U);
            
            // Create, initialize, and set the value of z to 20000.
            mpz_t z = new mpz_t();
            gmp_lib.mpz_init_set_ui(z, 20000U);
            
            // Set z += x * y.
            gmp_lib.mpz_addmul(z, x, y);
            
            // Assert that z has been incremented by 10000 * 12222.
            Assert.IsTrue(gmp_lib.mpz_get_si(z) == 20000U + 10000 * 12222);
            
            // Release unmanaged memory allocated for x and z.
            gmp_lib.mpz_clears(x, y, z, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of x to 10000.
            Dim x As New mpz_t()
            gmp_lib.mpz_init_set_ui(x, 10000UI)
            
            ' Create, initialize, and set the value of y to 12222.
            Dim y As New mpz_t()
            gmp_lib.mpz_init_set_ui(y, 12222UI)
            
            ' Create, initialize, and set the value of z to 20000.
            Dim z As New mpz_t()
            gmp_lib.mpz_init_set_ui(z, 20000UI)
            
            ' Set z += x * y.
            gmp_lib.mpz_addmul(z, x, y)
            
            ' Assert that z has been incremented by 10000 * 12222.
            Assert.IsTrue(gmp_lib.mpz_get_si(z) = 20000UI + 10000 * 12222)
            
            ' Release unmanaged memory allocated for x and z.
            gmp_lib.mpz_clears(x, y, z, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_addmul_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="rop"/> + <paramref name="op1"/> * <paramref name="op2"/>.
            </summary>
            <param name="rop">The result integer.</param>
            <param name="op1">The first operand integer.</param>
            <param name="op2">The second operand integer.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_abs(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_abs</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_add(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_addmul(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_addmul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mul(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_neg(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_sub(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_submul(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_submul</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Arithmetic">Integer Arithmetic</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Arithmetic.html#Integer-Arithmetic">GNU MP - Integer Arithmetic</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of x to -10000.
            mpz_t x = new mpz_t();
            gmp_lib.mpz_init_set_si(x, -10000);
            
            // Create, initialize, and set the value of z to 20000.
            mpz_t z = new mpz_t();
            gmp_lib.mpz_init_set_si(z, 20000);
            
            // Set z += x * 12222.
            gmp_lib.mpz_addmul_ui(z, x, 12222U);
            
            // Assert that z has been incremented by -10000 * 12222.
            Assert.IsTrue(gmp_lib.mpz_get_si(z) == 20000 + -10000 * 12222);
            
            // Release unmanaged memory allocated for x and z.
            gmp_lib.mpz_clears(x, z, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of x to -10000.
            Dim x As New mpz_t()
            gmp_lib.mpz_init_set_si(x, -10000)
            
            ' Create, initialize, and set the value of z to 20000.
            Dim z As New mpz_t()
            gmp_lib.mpz_init_set_si(z, 20000)
            
            ' Set z += x * 12222.
            gmp_lib.mpz_addmul_ui(z, x, 12222UI)
            
            ' Assert that z has been incremented by -10000 * 12222.
            Assert.IsTrue(gmp_lib.mpz_get_si(z) = 20000 + -10000 * 12222)
            
            ' Release unmanaged memory allocated for x and z.
            gmp_lib.mpz_clears(x, z, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_and(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> bitwise-and <paramref name="op2"/>. 
            </summary>
            <param name="rop">The result integer.</param>
            <param name="op1">The first operand integer.</param>
            <param name="op2">The second operand integer.</param>
            <remarks>
            <para>
            The function behaves as if twos complement arithmetic were used (although sign-magnitude is the actual implementation).
            The least significant bit is number 0. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_ior(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_ior</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_xor(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_xor</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_com(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_com</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_popcount(Math.Gmp.Native.mpz_t)">mpz_popcount</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_hamdist(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_hamdist</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_scan0(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_scan0</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_scan1(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_scan1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_setbit(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_setbit</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_clrbit(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_clrbit</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_combit(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_combit</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tstbit(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_tstbit</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Logic_and_Bit_Fiddling">Integer Logic and Bit Fiddling</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Logic-and-Bit-Fiddling.html#Integer-Logic-and-Bit-Fiddling">GNU MP - Integer Logic and Bit Fiddling</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op1 to 63.
            mpz_t op1 = new mpz_t();
            gmp_lib.mpz_init_set_ui(op1, 63U);
            
            // Create, initialize, and set the value of op2 to 70.
            mpz_t op2 = new mpz_t();
            gmp_lib.mpz_init_set_ui(op2, 70U);
            
            // Create, initialize, and set the value of rop to 0.
            mpz_t rop = new mpz_t();
            gmp_lib.mpz_init(rop);
            
            // Set rop to the bitwise and of op1 and op2.
            gmp_lib.mpz_and(rop, op1, op2);
            
            // Assert that rop is 6.
            Assert.IsTrue(gmp_lib.mpz_get_si(rop) == 6);
            
            // Release unmanaged memory allocated for rop, op1, and op2.
            gmp_lib.mpz_clears(rop, op1, op2, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op1 to 63.
            Dim op1 As New mpz_t()
            gmp_lib.mpz_init_set_ui(op1, 63UI)
            
            ' Create, initialize, and set the value of op2 to 70.
            Dim op2 As New mpz_t()
            gmp_lib.mpz_init_set_ui(op2, 70UI)
            
            ' Create, initialize, and set the value of rop to 0.
            Dim rop As New mpz_t()
            gmp_lib.mpz_init(rop)
            
            ' Set rop to the bitwise and of op1 and op2.
            gmp_lib.mpz_and(rop, op1, op2)
            
            ' Assert that rop is 6.
            Assert.IsTrue(gmp_lib.mpz_get_si(rop) = 6)
            
            ' Release unmanaged memory allocated for rop, op1, and op2.
            gmp_lib.mpz_clears(rop, op1, op2, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_bin_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">
            <summary>
            Compute the binomial coefficient <paramref name="n"/> over <paramref name="k"/> and store the result in <paramref name="rop"/>.
            </summary>
            <param name="rop">The result integer.</param>
            <param name="n">The first operand integer.</param>
            <param name="k">The second operand integer.</param>
            <remarks>
            <para>
            Negative values of n are supported by <see cref="M:Math.Gmp.Native.gmp_lib.mpz_bin_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_bin_ui</see>, using the identity
            bin(-<paramref name="n"/>, <paramref name="k"/>) = (-1)^<paramref name="k"/> * bin(<paramref name="n"/> + <paramref name="k"/> - 1, <paramref name="k"/>),
            see Knuth volume 1 section 1.2.6 part G.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_bin_uiui(Math.Gmp.Native.mpz_t,System.UInt32,System.UInt32)">mpz_bin_uiui</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Number_Theoretic_Functions">Number Theoretic Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions">GNU MP - Number Theoretic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of n to 4.
            mpz_t n = new mpz_t();
            gmp_lib.mpz_init_set_si(n, 4);
            
            // Create, initialize, and set the value of rop to 0.
            mpz_t rop = new mpz_t();
            gmp_lib.mpz_init(rop);
            
            // Set rop to the binomial coefficient (n:2).
            gmp_lib.mpz_bin_ui(rop, n, 2U);
            
            // Assert that rop is 6.
            Assert.IsTrue(gmp_lib.mpz_get_si(rop) == 6);
            
            // Release unmanaged memory allocated for n and rop.
            gmp_lib.mpz_clears(n, rop, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of n to 4.
            Dim n As New mpz_t()
            gmp_lib.mpz_init_set_si(n, 4)
            
            ' Create, initialize, and set the value of rop to 0.
            Dim rop As New mpz_t()
            gmp_lib.mpz_init(rop)
            
            ' Set rop to the binomial coefficient (n:2).
            gmp_lib.mpz_bin_ui(rop, n, 2UI)
            
            ' Assert that rop is 6.
            Assert.IsTrue(gmp_lib.mpz_get_si(rop) = 6)
            
            ' Release unmanaged memory allocated for n and rop.
            gmp_lib.mpz_clears(n, rop, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_bin_uiui(Math.Gmp.Native.mpz_t,System.UInt32,System.UInt32)">
            <summary>
            Compute the binomial coefficient <paramref name="n"/> over <paramref name="k"/> and store the result in <paramref name="rop"/>.
            </summary>
            <param name="rop">The result integer.</param>
            <param name="n">The first operand integer.</param>
            <param name="k">The second operand integer.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_bin_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_bin_ui</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Number_Theoretic_Functions">Number Theoretic Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions">GNU MP - Number Theoretic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of rop to 0.
            mpz_t rop = new mpz_t();
            gmp_lib.mpz_init(rop);
            
            // Set rop to the binomial coefficient (4:2).
            gmp_lib.mpz_bin_uiui(rop, 4U, 2U);
            
            // Assert that rop is 6.
            Assert.IsTrue(gmp_lib.mpz_get_si(rop) == 6);
            
            // Release unmanaged memory allocated for rop.
            gmp_lib.mpz_clear(rop);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of rop to 0.
            Dim rop As New mpz_t()
            gmp_lib.mpz_init(rop)
            
            ' Set rop to the binomial coefficient (4:2).
            gmp_lib.mpz_bin_uiui(rop, 4UI, 2UI)
            
            ' Assert that rop is 6.
            Assert.IsTrue(gmp_lib.mpz_get_si(rop) = 6)
            
            ' Release unmanaged memory allocated for rop.
            gmp_lib.mpz_clear(rop)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_q(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">
            <summary>
            Set the quotient <paramref name="q"/> to ceiling(<paramref name="n"/> / <paramref name="d"/>).
            </summary>
            <param name="q">The result quotient integer.</param>
            <param name="n">The numerator integer.</param>
            <param name="d">The denominator integer.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_r(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_r</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_q_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_cdiv_q_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_r_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_cdiv_r_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_qr_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_cdiv_qr_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_cdiv_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_q_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_cdiv_q_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_r_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_cdiv_r_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_congruent_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_congruent_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divexact(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divexact</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divisible_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divisible_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_fdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mod(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_mod</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_qr</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Division">Integer Division</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Division.html#Integer-Division">GNU MP - Integer Division</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of n to 10000.
            mpz_t n = new mpz_t();
            gmp_lib.mpz_init_set_si(n, 10000);
            
            // Create, initialize, and set the value of d to 3.
            mpz_t d = new mpz_t();
            gmp_lib.mpz_init_set_si(d, 3);
            
            // Create, initialize, and set the value of q to 0.
            mpz_t q = new mpz_t();
            gmp_lib.mpz_init(q);
            
            // Set q = ceiling(n / d).
            gmp_lib.mpz_cdiv_q(q, n, d);
            
            // Assert that q is ceiling(10000 / 3).
            Assert.IsTrue(gmp_lib.mpz_get_si(q) == 3334);
            
            // Release unmanaged memory allocated for n, d, and q.
            gmp_lib.mpz_clears(n, d, q, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of n to 10000.
            Dim n As New mpz_t()
            gmp_lib.mpz_init_set_si(n, 10000)
            
            ' Create, initialize, and set the value of d to 3.
            Dim d As New mpz_t()
            gmp_lib.mpz_init_set_si(d, 3)
            
            ' Create, initialize, and set the value of q to 0.
            Dim q As New mpz_t()
            gmp_lib.mpz_init(q)
            
            ' Set q = ceiling(n / d).
            gmp_lib.mpz_cdiv_q(q, n, d)
            
            ' Assert that q is ceiling(10000 / 3).
            Assert.IsTrue(gmp_lib.mpz_get_si(q) = 3334)
            
            ' Release unmanaged memory allocated for n, d, and q.
            gmp_lib.mpz_clears(n, d, q, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_q_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">
            <summary>
            Set the quotient <paramref name="q"/> to ceiling(<paramref name="n"/> / 2^<paramref name="b"/>).
            </summary>
            <param name="q">The result quotient integer.</param>
            <param name="n">The numerator integer.</param>
            <param name="b">The exponent of the power of two denominator.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_q(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_q</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_r(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_r</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_q_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_cdiv_q_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_r_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_cdiv_r_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_qr_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_cdiv_qr_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_cdiv_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_r_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_cdiv_r_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_congruent_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_congruent_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divexact(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divexact</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divisible_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divisible_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_fdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mod(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_mod</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_qr</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Division">Integer Division</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Division.html#Integer-Division">GNU MP - Integer Division</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of n to 10001.
            mpz_t n = new mpz_t();
            gmp_lib.mpz_init_set_si(n, 10001);
            
            // Create, initialize, and set the value of q to 0.
            mpz_t q = new mpz_t();
            gmp_lib.mpz_init(q);
            
            // Set q = ceiling(n / 2^2).
            gmp_lib.mpz_cdiv_q_2exp(q, n, 2U);
            
            // Assert that q is ceiling(10001 / 4).
            Assert.IsTrue(gmp_lib.mpz_get_si(q) == 2501);
            
            // Release unmanaged memory allocated for n and q.
            gmp_lib.mpz_clears(n, q, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of n to 10001.
            Dim n As New mpz_t()
            gmp_lib.mpz_init_set_si(n, 10001)
            
            ' Create, initialize, and set the value of q to 0.
            Dim q As New mpz_t()
            gmp_lib.mpz_init(q)
            
            ' Set q = ceiling(n / 2^2).
            gmp_lib.mpz_cdiv_q_2exp(q, n, 2UI)
            
            ' Assert that q is ceiling(10001 / 4).
            Assert.IsTrue(gmp_lib.mpz_get_si(q) = 2501)
            
            ' Release unmanaged memory allocated for n and q.
            gmp_lib.mpz_clears(n, q, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_q_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">
            <summary>
            Set the quotient <paramref name="q"/> to ceiling(<paramref name="n"/> / <paramref name="d"/>), and return the remainder r = | <paramref name="n"/> - <paramref name="q"/> * <paramref name="d"/> |.
            </summary>
            <param name="q">The result quotient integer.</param>
            <param name="n">The numerator integer.</param>
            <param name="d">The denominator integer.</param>
            <returns>Return the remainder r = | <paramref name="n"/> - <paramref name="q"/> * <paramref name="d"/> |.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_q(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_q</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_r(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_r</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_r_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_cdiv_r_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_qr_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_cdiv_qr_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_cdiv_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_q_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_cdiv_q_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_r_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_cdiv_r_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_congruent_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_congruent_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divexact(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divexact</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divisible_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divisible_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_fdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mod(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_mod</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_qr</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Division">Integer Division</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Division.html#Integer-Division">GNU MP - Integer Division</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of n to 10000.
            mpz_t n = new mpz_t();
            gmp_lib.mpz_init_set_si(n, 10000);
            
            // Create, initialize, and set the value of q to 0.
            mpz_t q = new mpz_t();
            gmp_lib.mpz_init(q);
            
            // Set q = ceiling(n / 3) and return r = n - 3 * q.
            // Assert q and r values.
            Assert.IsTrue(gmp_lib.mpz_cdiv_q_ui(q, n, 3U) == 2U);
            Assert.IsTrue(gmp_lib.mpz_get_si(q) == 3334);
            
            // Release unmanaged memory allocated for n and q.
            gmp_lib.mpz_clears(n, q, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of n to 10000.
            Dim n As New mpz_t()
            gmp_lib.mpz_init_set_si(n, 10000)
            
            ' Create, initialize, and set the value of q to 0.
            Dim q As New mpz_t()
            gmp_lib.mpz_init(q)
            
            ' Set q = ceiling(n / 3) and return r = n - 3 * q.
            ' Assert q and r values.
            Assert.IsTrue(gmp_lib.mpz_cdiv_q_ui(q, n, 3UI) = 2UI)
            Assert.IsTrue(gmp_lib.mpz_get_si(q) = 3334)
            
            ' Release unmanaged memory allocated for n and q.
            gmp_lib.mpz_clears(n, q, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">
            <summary>
            Set the quotient <paramref name="q"/> to ceiling(<paramref name="n"/> / <paramref name="d"/>), and set the remainder <paramref name="r"/> to <paramref name="n"/> - <paramref name="q"/> * <paramref name="d"/>.
            </summary>
            <param name="q">The result quotient integer.</param>
            <param name="r">The result remainder integer.</param>
            <param name="n">The numerator integer.</param>
            <param name="d">The denominator integer.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_q(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_q</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_r(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_r</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_q_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_cdiv_q_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_r_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_cdiv_r_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_qr_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_cdiv_qr_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_cdiv_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_q_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_cdiv_q_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_r_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_cdiv_r_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_congruent_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_congruent_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divexact(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divexact</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divisible_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divisible_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_fdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mod(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_mod</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_qr</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Division">Integer Division</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Division.html#Integer-Division">GNU MP - Integer Division</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of n to 10000.
            mpz_t n = new mpz_t();
            gmp_lib.mpz_init_set_si(n, 10000);
            
            // Create, initialize, and set the value of d to 3.
            mpz_t d = new mpz_t();
            gmp_lib.mpz_init_set_si(d, 3);
            
            // Create, initialize, and set the values of q and r to 0.
            mpz_t q = new mpz_t();
            mpz_t r = new mpz_t();
            gmp_lib.mpz_inits(q, r, null);
            
            // Set q = ceiling(n / 3) and r = n - d * q.
            gmp_lib.mpz_cdiv_qr(q, r, n, d);
            
            // Assert that q is 3334, and that r is -2.
            Assert.IsTrue(gmp_lib.mpz_get_si(q) == 3334);
            Assert.IsTrue(gmp_lib.mpz_get_si(r) == -2);
            
            // Release unmanaged memory allocated for n, d, q, and r.
            gmp_lib.mpz_clears(n, d, q, r, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of n to 10000.
            Dim n As New mpz_t()
            gmp_lib.mpz_init_set_si(n, 10000)
            
            ' Create, initialize, and set the value of d to 3.
            Dim d As New mpz_t()
            gmp_lib.mpz_init_set_si(d, 3)
            
            ' Create, initialize, and set the values of q and r to 0.
            Dim q As New mpz_t()
            Dim r As New mpz_t()
            gmp_lib.mpz_inits(q, r, Nothing)
            
             Set q = ceiling(n / 3) and r = n - d * q.
            gmp_lib.mpz_cdiv_qr(q, r, n, d)
            
            ' Assert that q is 3334, and that r is -2.
            Assert.IsTrue(gmp_lib.mpz_get_si(q) = 3334)
            Assert.IsTrue(gmp_lib.mpz_get_si(r) = -2)
            
            ' Release unmanaged memory allocated for n, d, q, and r.
            gmp_lib.mpz_clears(n, d, q, r, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_qr_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">
            <summary>
            Set quotient <paramref name="q"/> to ceiling(<paramref name="n"/> / <paramref name="d"/>), set the remainder <paramref name="r"/> to <paramref name="n"/> - <paramref name="q"/> * <paramref name="d"/>, and return | <paramref name="r"/> |.
            </summary>
            <param name="q">The result quotient integer.</param>
            <param name="r">The result remainder integer.</param>
            <param name="n">The numerator integer.</param>
            <param name="d">The denominator integer.</param>
            <returns>Return | <paramref name="r"/> |.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_q(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_q</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_r(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_r</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_q_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_cdiv_q_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_r_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_cdiv_r_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_cdiv_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_q_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_cdiv_q_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_r_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_cdiv_r_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_congruent_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_congruent_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divexact(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divexact</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divisible_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divisible_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_fdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mod(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_mod</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_qr</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Division">Integer Division</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Division.html#Integer-Division">GNU MP - Integer Division</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of n to 10000.
            mpz_t n = new mpz_t();
            gmp_lib.mpz_init_set_si(n, 10000);
            
            // Create, initialize, and set the values of q and r to 0.
            mpz_t q = new mpz_t();
            mpz_t r = new mpz_t();
            gmp_lib.mpz_inits(q, r, null);
            
            // Set q = ceiling(n / 3), r = n - d * q, and return r.
            Assert.IsTrue(gmp_lib.mpz_cdiv_qr_ui(q, r, n, 3U) == 2U);
            
            // Assert that q is 3334, and that r is -2.
            Assert.IsTrue(gmp_lib.mpz_get_si(q) == 3334);
            Assert.IsTrue(gmp_lib.mpz_get_si(r) == -2);
            
            // Release unmanaged memory allocated for n, q, and r.
            gmp_lib.mpz_clears(n, q, r, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of n to 10000.
            Dim n As New mpz_t()
            gmp_lib.mpz_init_set_si(n, 10000)
            
            ' Create, initialize, and set the values of q and r to 0.
            Dim q As New mpz_t()
            Dim r As New mpz_t()
            gmp_lib.mpz_inits(q, r, Nothing)
            
            ' Set q = ceiling(n / 3), r = n - d * q, and return r.
            Assert.IsTrue(gmp_lib.mpz_cdiv_qr_ui(q, r, n, 3UI) = 2UI)
            
            ' Assert that q is 3334, and that r is -2.
            Assert.IsTrue(gmp_lib.mpz_get_si(q) = 3334)
            Assert.IsTrue(gmp_lib.mpz_get_si(r) = -2)
            
            ' Release unmanaged memory allocated for n, q, and r.
            gmp_lib.mpz_clears(n, q, r, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_r(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">
            <summary>
            Set the remainder <paramref name="r"/> to <paramref name="n"/> - q * <paramref name="d"/> where q = ceiling(<paramref name="n"/> / <paramref name="d"/>).
            </summary>
            <param name="r">The result remainder integer.</param>
            <param name="n">The numerator integer.</param>
            <param name="d">The denominator integer.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_q(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_q</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_q_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_cdiv_q_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_r_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_cdiv_r_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_qr_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_cdiv_qr_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_cdiv_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_q_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_cdiv_q_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_r_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_cdiv_r_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_congruent_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_congruent_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divexact(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divexact</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divisible_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divisible_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_fdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mod(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_mod</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_qr</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Division">Integer Division</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Division.html#Integer-Division">GNU MP - Integer Division</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of n to 10000.
            mpz_t n = new mpz_t();
            gmp_lib.mpz_init_set_si(n, 10000);
            
            // Create, initialize, and set the value of d to 3.
            mpz_t d = new mpz_t();
            gmp_lib.mpz_init_set_si(d, 3);
            
            // Create, initialize, and set the value of r to 0.
            mpz_t r = new mpz_t();
            gmp_lib.mpz_init(r);
            
            // Set r = n - d * ceiling(n / d).
            gmp_lib.mpz_cdiv_r(r, n, d);
            
            // Assert that r is -2.
            Assert.IsTrue(gmp_lib.mpz_get_si(r) == -2);
            
            // Release unmanaged memory allocated for n, d, and r.
            gmp_lib.mpz_clears(n, d, r, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of n to 10000.
            Dim n As New mpz_t()
            gmp_lib.mpz_init_set_si(n, 10000)
            
            ' Create, initialize, and set the value of d to 3.
            Dim d As New mpz_t()
            gmp_lib.mpz_init_set_si(d, 3)
            
            ' Create, initialize, and set the value of r to 0.
            Dim r As New mpz_t()
            gmp_lib.mpz_init(r)
            
            ' Set r = n - d * ceiling(n / d).
            gmp_lib.mpz_cdiv_r(r, n, d)
            
            ' Assert that r is -2.
            Assert.IsTrue(gmp_lib.mpz_get_si(r) = -2)
            
            ' Release unmanaged memory allocated for n, d, and r.
            gmp_lib.mpz_clears(n, d, r, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_r_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">
            <summary>
            Set the remainder <paramref name="r"/> to <paramref name="n"/> - q * 2^<paramref name="b"/> where q = ceiling(<paramref name="n"/> / 2^<paramref name="b"/>).
            </summary>
            <param name="r">The result remainder integer.</param>
            <param name="n">The numerator integer.</param>
            <param name="b">The exponent of the power of two denominator.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_q(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_q</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_r(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_r</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_q_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_cdiv_q_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_r_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_cdiv_r_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_qr_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_cdiv_qr_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_cdiv_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_q_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_cdiv_q_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_congruent_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_congruent_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divexact(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divexact</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divisible_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divisible_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_fdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mod(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_mod</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_qr</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Division">Integer Division</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Division.html#Integer-Division">GNU MP - Integer Division</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of n to 10001.
            mpz_t n = new mpz_t();
            gmp_lib.mpz_init_set_si(n, 10001);
            
            // Create, initialize, and set the value of r to 0.
            mpz_t r = new mpz_t();
            gmp_lib.mpz_init(r);
            
            // Set r = n - 2^2 * ceiling(n / 2^2)
            gmp_lib.mpz_cdiv_r_2exp(r, n, 2U);
            
            // Assert that r is -3.
            Assert.IsTrue(gmp_lib.mpz_get_si(r) == -3);
            
            // Release unmanaged memory allocated for n and r.
            gmp_lib.mpz_clears(n, r, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of n to 10001.
            Dim n As New mpz_t()
            gmp_lib.mpz_init_set_si(n, 10001)
            
            ' Create, initialize, and set the value of r to 0.
            Dim r As New mpz_t()
            gmp_lib.mpz_init(r)
            ' Set r = n - 2^2 * ceiling(n / 2^2)
            gmp_lib.mpz_cdiv_r_2exp(r, n, 2UI)
            
            ' Assert that r is -3.
            Assert.IsTrue(gmp_lib.mpz_get_si(r) = -3)
            
            ' Release unmanaged memory allocated for n and r.
            gmp_lib.mpz_clears(n, r, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_r_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">
            <summary>
            Set the remainder <paramref name="r"/> to <paramref name="n"/> - q * <paramref name="d"/> where q = ceiling(<paramref name="n"/> / <paramref name="d"/>), and return | <paramref name="r"/> |.
            </summary>
            <param name="r">The result remainder integer.</param>
            <param name="n">The numerator integer.</param>
            <param name="d">The denominator integer.</param>
            <returns>Return | <paramref name="r"/> |.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_q(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_q</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_r(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_r</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_q_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_cdiv_q_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_qr_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_cdiv_qr_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_cdiv_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_q_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_cdiv_q_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_r_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_cdiv_r_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_congruent_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_congruent_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divexact(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divexact</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divisible_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divisible_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_fdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mod(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_mod</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_qr</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Division">Integer Division</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Division.html#Integer-Division">GNU MP - Integer Division</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of n to 10000.
            mpz_t n = new mpz_t();
            gmp_lib.mpz_init_set_si(n, 10000);
            
            // Create, initialize, and set the value of r to 0.
            mpz_t r = new mpz_t();
            gmp_lib.mpz_init(r);
            
            // Set r = n - 3 * ceiling(n / 3), and return |r|.
            Assert.IsTrue(gmp_lib.mpz_cdiv_r_ui(r, n, 3U) == 2U);
            
            // Assert that r is -2.
            Assert.IsTrue(gmp_lib.mpz_get_si(r) == -2);
            
            // Release unmanaged memory allocated for n and r.
            gmp_lib.mpz_clears(n, r, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of n to 10000.
            Dim n As New mpz_t()
            gmp_lib.mpz_init_set_si(n, 10000)
            
            ' Create, initialize, and set the value of r to 0.
            Dim r As New mpz_t()
            gmp_lib.mpz_init(r)
            
            ' Set r = n - 3 * ceiling(n / 3), and return |r|.
            Assert.IsTrue(gmp_lib.mpz_cdiv_r_ui(r, n, 3UI) = 2UI)
            
            ' Assert that r is -2.
            Assert.IsTrue(gmp_lib.mpz_get_si(r) = -2)
            
            ' Release unmanaged memory allocated for n and r.
            gmp_lib.mpz_clears(n, r, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_ui(Math.Gmp.Native.mpz_t,System.UInt32)">
            <summary>
            Return the remainder | r | where r = <paramref name="n"/> - q * <paramref name="d"/>, and where q = ceiling(<paramref name="n"/> / <paramref name="d"/>).
            </summary>
            <param name="n">The numerator integer.</param>
            <param name="d">The denominator integer.</param>
            <returns>The remainder | r | where r = <paramref name="n"/> - q * <paramref name="d"/>, and where q = ceiling(<paramref name="n"/> / <paramref name="d"/>).</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_q(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_q</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_r(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_r</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_q_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_cdiv_q_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_r_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_cdiv_r_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_qr_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_cdiv_qr_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_q_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_cdiv_q_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_r_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_cdiv_r_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_congruent_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_congruent_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divexact(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divexact</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divisible_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divisible_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_fdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mod(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_mod</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_qr</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Division">Integer Division</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Division.html#Integer-Division">GNU MP - Integer Division</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of n to 10000.
            mpz_t n = new mpz_t();
            gmp_lib.mpz_init_set_si(n, 10000);
            
            // Assert that returned value is |n - 3 * ceiling(n / 3)|.
            Assert.IsTrue(gmp_lib.mpz_cdiv_ui(n, 3U) == 2U);
            
            // Release unmanaged memory allocated for n.
            gmp_lib.mpz_clear(n);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of n to 10000.
            Dim n As New mpz_t()
            gmp_lib.mpz_init_set_si(n, 10000)
            
            ' Assert that returned value is |n - 3 * ceiling(n / 3)|.
            Assert.IsTrue(gmp_lib.mpz_cdiv_ui(n, 3UI) = 2UI)
            
            ' Release unmanaged memory allocated for n.
            gmp_lib.mpz_clear(n)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_clear(Math.Gmp.Native.mpz_t)">
            <summary>
            Free the space occupied by <paramref name="x"/>.
            </summary>
            <param name="x">The integer.</param>
            <remarks>
            <para>
            Call this function for all <see cref="T:Math.Gmp.Native.mpz_t">mpz_t</see> variables when you are done with them.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_clears(Math.Gmp.Native.mpz_t[])">mpz_clears</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_init(Math.Gmp.Native.mpz_t)">mpz_init</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_inits(Math.Gmp.Native.mpz_t[])">mpz_inits</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_init2(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_init2</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_realloc2(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_realloc2</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Initializing_Integers">Initializing Integers</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Initializing-Integers.html#Initializing-Integers">GNU MP - Initializing Integers</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize a new integer x.
            mpz_t x = new mpz_t();
            gmp_lib.mpz_init(x);
            
            // Assert that the value of x is 0.
            Assert.IsTrue(gmp_lib.mpz_get_ui(x) == 0U);
            
            // Release unmanaged memory allocated for x.
            gmp_lib.mpz_clear(x);
            </code> 
            <code language="VB.NET">
            ' Create and initialize a new integer x.
            Dim x As New mpz_t()
            gmp_lib.mpz_init(x)
            
            ' Assert that the value of x is 0.
            Assert.IsTrue(gmp_lib.mpz_get_ui(x) = 0UI)
            
            ' Release unmanaged memory allocated for x.
            gmp_lib.mpz_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_clears(Math.Gmp.Native.mpz_t[])">
            <summary>
            Free the space occupied by a NULL-terminated list of <see cref="T:Math.Gmp.Native.mpz_t">mpz_t</see> variables.
            </summary>
            <param name="x">A NULL-terminated list of <see cref="T:Math.Gmp.Native.mpz_t">mpz_t</see> variables.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_clear(Math.Gmp.Native.mpz_t)">mpz_clear</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_init(Math.Gmp.Native.mpz_t)">mpz_init</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_inits(Math.Gmp.Native.mpz_t[])">mpz_inits</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_init2(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_init2</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_realloc2(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_realloc2</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Initializing_Integers">Initializing Integers</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Initializing-Integers.html#Initializing-Integers">GNU MP - Initializing Integers</a></seealso>
            <example>
            <code language="C#">
            // Create new integers x1, x2 and x3.
            mpz_t x1 = new mpz_t();
            mpz_t x2 = new mpz_t();
            mpz_t x3 = new mpz_t();
            
            // Initialize the integers.
            gmp_lib.mpz_inits(x1, x2, x3, null);
            
            // Assert that their value is 0.
            Assert.IsTrue(gmp_lib.mpz_get_si(x1) == 0);
            Assert.IsTrue(gmp_lib.mpz_get_si(x2) == 0);
            Assert.IsTrue(gmp_lib.mpz_get_si(x3) == 0);
            
            // Release unmanaged memory allocated for the integers.
            gmp_lib.mpz_clears(x1, x2, x3, null);
            </code> 
            <code language="VB.NET">
            ' Create new integers x1, x2 and x3.
            Dim x1 As New mpz_t()
            Dim x2 As New mpz_t()
            Dim x3 As New mpz_t()
            
            ' Initialize the integers.
            gmp_lib.mpz_inits(x1, x2, x3, Nothing)
            
            ' Assert that their value is 0.
            Assert.IsTrue(gmp_lib.mpz_get_si(x1) = 0)
            Assert.IsTrue(gmp_lib.mpz_get_si(x2) = 0)
            Assert.IsTrue(gmp_lib.mpz_get_si(x3) = 0)
            
            ' Release unmanaged memory allocated for the integers.
            gmp_lib.mpz_clears(x1, x2, x3, Nothing) 
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_clrbit(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">
            <summary>
            Clear bit <paramref name="bit_index"/> in <paramref name="rop"/>.
            </summary>
            <param name="rop">The result integer.</param>
            <param name="bit_index">The index of the bit to clear.</param>
            <remarks>
            <para>
            The function behaves as if twos complement arithmetic were used (although sign-magnitude is the actual implementation).
            The least significant bit is number 0. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_and(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_and</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_ior(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_ior</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_xor(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_xor</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_com(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_com</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_popcount(Math.Gmp.Native.mpz_t)">mpz_popcount</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_hamdist(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_hamdist</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_scan0(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_scan0</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_scan1(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_scan1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_setbit(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_setbit</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_combit(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_combit</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tstbit(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_tstbit</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Logic_and_Bit_Fiddling">Integer Logic and Bit Fiddling</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Logic-and-Bit-Fiddling.html#Integer-Logic-and-Bit-Fiddling">GNU MP - Integer Logic and Bit Fiddling</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of rop to 70.
            mpz_t rop = new mpz_t();
            gmp_lib.mpz_init_set_si(rop, 70);
            
            // Clear bit 3 of rop.
            gmp_lib.mpz_clrbit(rop, 3U);
            
            // Assert that rop is 70.
            Assert.IsTrue(gmp_lib.mpz_get_si(rop) == 70);
            
            // Release unmanaged memory allocated for rop.
            gmp_lib.mpz_clear(rop);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of rop to 70.
            Dim rop As New mpz_t()
            gmp_lib.mpz_init_set_si(rop, 70)
            
            ' Clear bit 3 of rop.
            gmp_lib.mpz_clrbit(rop, 3UI)
            
            ' Assert that rop is 70.
            Assert.IsTrue(gmp_lib.mpz_get_si(rop) = 70)
            
            ' Release unmanaged memory allocated for rop.
            gmp_lib.mpz_clear(rop)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_cmp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">
            <summary>
            Compare <paramref name="op1"/> and <paramref name="op2"/>.
            </summary>
            <param name="op1">The first operand integer.</param>
            <param name="op2">The second operand integer.</param>
            <returns>Return a positive value if <paramref name="op1"/> &gt; <paramref name="op2"/>, zero if <paramref name="op1"/> = <paramref name="op2"/>, or a negative value if <paramref name="op1"/> &lt; <paramref name="op2"/>.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cmp_d(Math.Gmp.Native.mpz_t,System.Double)">mpz_cmp_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cmp_si(Math.Gmp.Native.mpz_t,System.Int32)">mpz_cmp_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cmp_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_cmp_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cmpabs(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cmpabs</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cmpabs_d(Math.Gmp.Native.mpz_t,System.Double)">mpz_cmpabs_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cmpabs_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_cmpabs_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_sgn(Math.Gmp.Native.mpz_t)">mpz_sgn</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Comparisons">Integer Comparisons</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Comparisons.html#Integer-Comparisons">GNU MP - Integer Comparisons</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op1 to 63.
            mpz_t op1 = new mpz_t();
            gmp_lib.mpz_init_set_ui(op1, 63U);
            
            // Create, initialize, and set the value of op2 to 70.
            mpz_t op2 = new mpz_t();
            gmp_lib.mpz_init_set_ui(op2, 70U);
            
            // Assert that op1 &lt; op2.
            Assert.IsTrue(gmp_lib.mpz_cmp(op1, op2) &lt; 0);
            
            // Release unmanaged memory allocated for op1 and op2.
            gmp_lib.mpz_clears(op1, op2, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op1 to 63.
            Dim op1 As New mpz_t()
            gmp_lib.mpz_init_set_ui(op1, 63UI)
            
            ' Create, initialize, and set the value of op2 to 70.
            Dim op2 As New mpz_t()
            gmp_lib.mpz_init_set_ui(op2, 70UI)
            
            ' Assert that op1 &lt; op2.
            Assert.IsTrue(gmp_lib.mpz_cmp(op1, op2) &lt; 0)
            
            ' Release unmanaged memory allocated for op1 and op2.
            gmp_lib.mpz_clears(op1, op2, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_cmp_d(Math.Gmp.Native.mpz_t,System.Double)">
            <summary>
            Compare <paramref name="op1"/> and <paramref name="op2"/>.
            </summary>
            <param name="op1">The first operand integer.</param>
            <param name="op2">The second operand integer.</param>
            <returns>Return a positive value if <paramref name="op1"/> &gt; <paramref name="op2"/>, zero if <paramref name="op1"/> = <paramref name="op2"/>, or a negative value if <paramref name="op1"/> &lt; <paramref name="op2"/>.</returns>
            <remarks>
            <para>
            <see cref="M:Math.Gmp.Native.gmp_lib.mpz_cmp_d(Math.Gmp.Native.mpz_t,System.Double)">mpz_cmp_d</see> can be called with an infinity (see <see cref="F:System.Double.PositiveInfinity">double.PositiveInfinity</see> or <see cref="F:System.Double.NegativeInfinity">double.NegativeInfinity</see>),
            but results are undefined for a <see cref="F:System.Double.NaN">double.NaN</see>.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cmp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cmp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cmp_si(Math.Gmp.Native.mpz_t,System.Int32)">mpz_cmp_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cmp_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_cmp_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cmpabs(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cmpabs</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cmpabs_d(Math.Gmp.Native.mpz_t,System.Double)">mpz_cmpabs_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cmpabs_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_cmpabs_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_sgn(Math.Gmp.Native.mpz_t)">mpz_sgn</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Comparisons">Integer Comparisons</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Comparisons.html#Integer-Comparisons">GNU MP - Integer Comparisons</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op1 to 63.
            mpz_t op1 = new mpz_t();
            gmp_lib.mpz_init_set_ui(op1, 63U);
            
            // Assert that op1 &lt; 70.0.
            Assert.IsTrue(gmp_lib.mpz_cmp_d(op1, 70.0) &lt; 0);
            
            // Release unmanaged memory allocated for op1.
            gmp_lib.mpz_clear(op1);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op1 to 63.
            Dim op1 As New mpz_t()
            gmp_lib.mpz_init_set_ui(op1, 63UI)
            
            ' Assert that op1 &lt; 70.0.
            Assert.IsTrue(gmp_lib.mpz_cmp_d(op1, 70.0) &lt; 0)
            
            ' Release unmanaged memory allocated for op1.
            gmp_lib.mpz_clear(op1)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_cmp_si(Math.Gmp.Native.mpz_t,System.Int32)">
            <summary>
            Compare <paramref name="op1"/> and <paramref name="op2"/>.
            </summary>
            <param name="op1">The first operand integer.</param>
            <param name="op2">The second operand integer.</param>
            <returns>Return a positive value if <paramref name="op1"/> &gt; <paramref name="op2"/>, zero if <paramref name="op1"/> = <paramref name="op2"/>, or a negative value if <paramref name="op1"/> &lt; <paramref name="op2"/>.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cmp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cmp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cmp_d(Math.Gmp.Native.mpz_t,System.Double)">mpz_cmp_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cmp_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_cmp_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cmpabs(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cmpabs</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cmpabs_d(Math.Gmp.Native.mpz_t,System.Double)">mpz_cmpabs_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cmpabs_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_cmpabs_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_sgn(Math.Gmp.Native.mpz_t)">mpz_sgn</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Comparisons">Integer Comparisons</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Comparisons.html#Integer-Comparisons">GNU MP - Integer Comparisons</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op1 to 63.
            mpz_t op1 = new mpz_t();
            gmp_lib.mpz_init_set_ui(op1, 63U);
            
            // Assert that op1 &lt; 70.
            Assert.IsTrue(gmp_lib.mpz_cmp_si(op1, 70) &lt; 0);
            
            // Release unmanaged memory allocated for op1.
            gmp_lib.mpz_clear(op1);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op1 to 63.
            Dim op1 As New mpz_t()
            gmp_lib.mpz_init_set_ui(op1, 63UI)
            
            ' Assert that op1 &lt; 70.
            Assert.IsTrue(gmp_lib.mpz_cmp_si(op1, 70) &lt; 0)
            
            ' Release unmanaged memory allocated for op1.
            gmp_lib.mpz_clear(op1)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_cmp_ui(Math.Gmp.Native.mpz_t,System.UInt32)">
            <summary>
            Compare <paramref name="op1"/> and <paramref name="op2"/>.
            </summary>
            <param name="op1">The first operand integer.</param>
            <param name="op2">The second operand integer.</param>
            <returns>Return a positive value if <paramref name="op1"/> &gt; <paramref name="op2"/>, zero if <paramref name="op1"/> = <paramref name="op2"/>, or a negative value if <paramref name="op1"/> &lt; <paramref name="op2"/>.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cmp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cmp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cmp_d(Math.Gmp.Native.mpz_t,System.Double)">mpz_cmp_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cmp_si(Math.Gmp.Native.mpz_t,System.Int32)">mpz_cmp_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cmpabs(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cmpabs</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cmpabs_d(Math.Gmp.Native.mpz_t,System.Double)">mpz_cmpabs_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_sgn(Math.Gmp.Native.mpz_t)">mpz_sgn</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Comparisons">Integer Comparisons</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Comparisons.html#Integer-Comparisons">GNU MP - Integer Comparisons</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op1 to 63.
            mpz_t op1 = new mpz_t();
            gmp_lib.mpz_init_set_ui(op1, 63U);
            
            // Assert that op1 &lt; 70.
            Assert.IsTrue(gmp_lib.mpz_cmp_ui(op1, 70U) &lt; 0);
            
            // Release unmanaged memory allocated for op1.
            gmp_lib.mpz_clear(op1);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op1 to 63.
            Dim op1 As New mpz_t()
            gmp_lib.mpz_init_set_ui(op1, 63UI)
            
            ' Assert that op1 &lt; 70.
            Assert.IsTrue(gmp_lib.mpz_cmp_ui(op1, 70UI) &lt; 0)
            
            ' Release unmanaged memory allocated for op1.
            gmp_lib.mpz_clear(op1)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_cmpabs(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">
            <summary>
            Compare the absolute values of <paramref name="op1"/> and <paramref name="op2"/>.
            </summary>
            <param name="op1">The first operand integer.</param>
            <param name="op2">The second operand integer.</param>
            <returns>Return a positive value if | <paramref name="op1"/> | &gt; | <paramref name="op2"/> |, zero if | <paramref name="op1"/> | = | <paramref name="op2"/> |, or a negative value if | <paramref name="op1"/> | &lt; | <paramref name="op2"/> |.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cmp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cmp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cmp_d(Math.Gmp.Native.mpz_t,System.Double)">mpz_cmp_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cmp_si(Math.Gmp.Native.mpz_t,System.Int32)">mpz_cmp_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cmp_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_cmp_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cmpabs_d(Math.Gmp.Native.mpz_t,System.Double)">mpz_cmpabs_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cmpabs_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_cmpabs_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_sgn(Math.Gmp.Native.mpz_t)">mpz_sgn</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Comparisons">Integer Comparisons</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Comparisons.html#Integer-Comparisons">GNU MP - Integer Comparisons</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op1 to -63.
            mpz_t op1 = new mpz_t();
            gmp_lib.mpz_init_set_si(op1, -63);
            
            // Create, initialize, and set the value of op2 to 70.
            mpz_t op2 = new mpz_t();
            gmp_lib.mpz_init_set_ui(op2, 70U);
            
            // Assert that |op1| &lt; |op2|.
            Assert.IsTrue(gmp_lib.mpz_cmp(op1, op2) &lt; 0);
            
            // Release unmanaged memory allocated for op1 and op2.
            gmp_lib.mpz_clears(op1, op2, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op1 to -63.
            Dim op1 As New mpz_t()
            gmp_lib.mpz_init_set_si(op1, -63)
            
            ' Create, initialize, and set the value of op2 to 70.
            Dim op2 As New mpz_t()
            gmp_lib.mpz_init_set_ui(op2, 70UI)
            
            ' Assert that |op1| &lt; |op2|.
            Assert.IsTrue(gmp_lib.mpz_cmp(op1, op2) &lt; 0)
            
            ' Release unmanaged memory allocated for op1 and op2.
            gmp_lib.mpz_clears(op1, op2, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_cmpabs_d(Math.Gmp.Native.mpz_t,System.Double)">
            <summary>
            Compare the absolute values of <paramref name="op1"/> and <paramref name="op2"/>.
            </summary>
            <param name="op1">The first operand integer.</param>
            <param name="op2">The second operand integer.</param>
            <returns>Return a positive value if | <paramref name="op1"/> | &gt; | <paramref name="op2"/> |, zero if | <paramref name="op1"/> | = | <paramref name="op2"/> |, or a negative value if | <paramref name="op1"/> | &lt; | <paramref name="op2"/> |.</returns>
            <remarks>
            <para>
            <see cref="M:Math.Gmp.Native.gmp_lib.mpz_cmpabs_d(Math.Gmp.Native.mpz_t,System.Double)">mpz_cmpabs_d</see> can be called with an infinity (see <see cref="F:System.Double.PositiveInfinity">double.PositiveInfinity</see> or <see cref="F:System.Double.NegativeInfinity">double.NegativeInfinity</see>),
            but results are undefined for a <see cref="F:System.Double.NaN">double.NaN</see>.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cmp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cmp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cmp_d(Math.Gmp.Native.mpz_t,System.Double)">mpz_cmp_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cmp_si(Math.Gmp.Native.mpz_t,System.Int32)">mpz_cmp_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cmp_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_cmp_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cmpabs(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cmpabs</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cmpabs_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_cmpabs_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_sgn(Math.Gmp.Native.mpz_t)">mpz_sgn</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Comparisons">Integer Comparisons</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Comparisons.html#Integer-Comparisons">GNU MP - Integer Comparisons</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op1 to -63.
            mpz_t op1 = new mpz_t();
            gmp_lib.mpz_init_set_si(op1, -63);
            
            // Assert that |op1| &lt; |-70.0|.
            Assert.IsTrue(gmp_lib.mpz_cmpabs_d(op1, -70.0) &lt; 0);
            
            // Release unmanaged memory allocated for op1.
            gmp_lib.mpz_clear(op1);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op1 to -63.
            Dim op1 As New mpz_t()
            gmp_lib.mpz_init_set_si(op1, -63)
            
            ' Assert that |op1| &lt; |-70.0|.
            Assert.IsTrue(gmp_lib.mpz_cmpabs_d(op1, -70.0) &lt; 0)
            
            ' Release unmanaged memory allocated for op1.
            gmp_lib.mpz_clear(op1)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_cmpabs_ui(Math.Gmp.Native.mpz_t,System.UInt32)">
            <summary>
            Compare the absolute values of <paramref name="op1"/> and <paramref name="op2"/>.
            </summary>
            <param name="op1">The first operand integer.</param>
            <param name="op2">The second operand integer.</param>
            <returns>Return a positive value if | <paramref name="op1"/> | &gt; | <paramref name="op2"/> |, zero if | <paramref name="op1"/> | = | <paramref name="op2"/> |, or a negative value if | <paramref name="op1"/> | &lt; | <paramref name="op2"/> |.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cmp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cmp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cmp_d(Math.Gmp.Native.mpz_t,System.Double)">mpz_cmp_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cmp_si(Math.Gmp.Native.mpz_t,System.Int32)">mpz_cmp_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cmp_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_cmp_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cmpabs(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cmpabs</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cmpabs_d(Math.Gmp.Native.mpz_t,System.Double)">mpz_cmpabs_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_sgn(Math.Gmp.Native.mpz_t)">mpz_sgn</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Comparisons">Integer Comparisons</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Comparisons.html#Integer-Comparisons">GNU MP - Integer Comparisons</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op1 to -63.
            mpz_t op1 = new mpz_t();
            gmp_lib.mpz_init_set_si(op1, -63);
            
            // Assert that |op1| &lt; |70|.
            Assert.IsTrue(gmp_lib.mpz_cmpabs_ui(op1, 70U) &lt; 0);
            
            // Release unmanaged memory allocated for op1.
            gmp_lib.mpz_clear(op1);
            </code> 
            <code language="VB.NET">
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_com(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">
            <summary>
            Set <paramref name="rop"/> to the one’s complement of <paramref name="op"/>.
            </summary>
            <param name="rop">The result integer.</param>
            <param name="op">The operand integer.</param>
            <remarks>
            <para>
            The function behaves as if twos complement arithmetic were used (although sign-magnitude is the actual implementation).
            The least significant bit is number 0. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_and(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_and</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_ior(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_ior</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_xor(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_xor</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_popcount(Math.Gmp.Native.mpz_t)">mpz_popcount</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_hamdist(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_hamdist</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_scan0(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_scan0</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_scan1(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_scan1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_setbit(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_setbit</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_clrbit(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_clrbit</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_combit(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_combit</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tstbit(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_tstbit</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Logic_and_Bit_Fiddling">Integer Logic and Bit Fiddling</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Logic-and-Bit-Fiddling.html#Integer-Logic-and-Bit-Fiddling">GNU MP - Integer Logic and Bit Fiddling</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op to 63.
            mpz_t op = new mpz_t();
            gmp_lib.mpz_init_set_ui(op, 63U);
            
            // Create, initialize, and set the value of rop to 0.
            mpz_t rop = new mpz_t();
            gmp_lib.mpz_init(rop);
            
            // Set rop to the one's complement of op.
            gmp_lib.mpz_com(rop, op);
            
            // Assert that rop is -64.
            Assert.IsTrue(gmp_lib.mpz_get_si(rop) == -64);
            
            // Release unmanaged memory allocated for rop and op.
            gmp_lib.mpz_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op to 63.
            Dim op As New mpz_t()
            gmp_lib.mpz_init_set_ui(op, 63UI)
            
            ' Create, initialize, and set the value of rop to 0.
            Dim rop As New mpz_t()
            gmp_lib.mpz_init(rop)
            
            ' Set rop to the one's complement of op.
            gmp_lib.mpz_com(rop, op)
            
            ' Assert that rop is -64.
            Assert.IsTrue(gmp_lib.mpz_get_si(rop) = -64)
            
            ' Release unmanaged memory allocated for rop and op.
            gmp_lib.mpz_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_combit(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">
            <summary>
            Complement bit <paramref name="bit_index"/> in <paramref name="rop"/>. 
            </summary>
            <param name="rop">The result integer.</param>
            <param name="bit_index">The index of the bit to comlpement.</param>
            <remarks>
            <para>
            The function behaves as if twos complement arithmetic were used (although sign-magnitude is the actual implementation).
            The least significant bit is number 0. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_and(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_and</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_ior(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_ior</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_xor(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_xor</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_com(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_com</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_popcount(Math.Gmp.Native.mpz_t)">mpz_popcount</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_hamdist(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_hamdist</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_scan0(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_scan0</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_scan1(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_scan1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_setbit(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_setbit</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_clrbit(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_clrbit</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tstbit(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_tstbit</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Logic_and_Bit_Fiddling">Integer Logic and Bit Fiddling</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Logic-and-Bit-Fiddling.html#Integer-Logic-and-Bit-Fiddling">GNU MP - Integer Logic and Bit Fiddling</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of rop to 70.
            mpz_t rop = new mpz_t();
            gmp_lib.mpz_init_set_si(rop, 70);
            
            // Complement bit 3 of rop.
            gmp_lib.mpz_combit(rop, 3U);
            
            // Assert that rop is 78.
            Assert.IsTrue(gmp_lib.mpz_get_si(rop) == 78);
            
            // Release unmanaged memory allocated for rop.
            gmp_lib.mpz_clear(rop);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of rop to 70.
            Dim rop As New mpz_t()
            gmp_lib.mpz_init_set_si(rop, 70)
            
            ' Complement bit 3 of rop.
            gmp_lib.mpz_combit(rop, 3UI)
            
            ' Assert that rop is 78.
            Assert.IsTrue(gmp_lib.mpz_get_si(rop) = 78)
            
            ' Release unmanaged memory allocated for rop.
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_congruent_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">
            <summary>
            Return non-zero if <paramref name="n"/> is congruent to <paramref name="c"/> modulo <paramref name="d"/>.
            </summary>
            <param name="n">An operand integer.</param>
            <param name="c">The remainder of the division by <paramref name="d"/>.</param>
            <param name="d">The divisor operand integer.</param>
            <returns>Non-zero if <paramref name="n"/> is congruent to <paramref name="c"/> modulo <paramref name="d"/>.</returns>
            <remarks>
            <para>
            <paramref name="n"/> is congruent to <paramref name="c"/> mod <paramref name="d"/> if there exists an integer q
            satisfying <paramref name="n"/> = <paramref name="c"/> + q * <paramref name="d"/>.
            Unlike the other division functions, <paramref name="d"/> = 0 is accepted and following the rule it can be seen
            that <paramref name="n"/> and <paramref name="c"/> are considered congruent mod 0 only when exactly equal.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_congruent_2exp_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_congruent_2exp_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_congruent_ui_p(Math.Gmp.Native.mpz_t,System.UInt32,System.UInt32)">mpz_congruent_ui_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divexact(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divexact</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divisible_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divisible_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_fdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mod(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_mod</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_qr</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Division">Integer Division</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Division.html#Integer-Division">GNU MP - Integer Division</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of n to 10000.
            mpz_t n = new mpz_t();
            gmp_lib.mpz_init_set_ui(n, 10000U);
            
            // Create, initialize, and set the value of d to 3.
            mpz_t d = new mpz_t();
            gmp_lib.mpz_init_set_ui(d, 3U);
            
            // Create, initialize, and set the value of c to 1.
            mpz_t c = new mpz_t();
            gmp_lib.mpz_init_set_ui(c, 1U);
            
            // Assert that n is congruent to c mod d.
            Assert.IsTrue(gmp_lib.mpz_congruent_p(n, c, d) > 0);
            
            // Release unmanaged memory allocated for n, d, and c.
            gmp_lib.mpz_clears(n, d, c, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of n to 10000.
            Dim n As New mpz_t()
            gmp_lib.mpz_init_set_ui(n, 10000UI)
            
            ' Create, initialize, and set the value of d to 3.
            Dim d As New mpz_t()
            gmp_lib.mpz_init_set_ui(d, 3UI)
            
            ' Create, initialize, and set the value of c to 1.
            Dim c As New mpz_t()
            gmp_lib.mpz_init_set_ui(c, 1UI)
            
            ' Assert that n is congruent to c mod d.
            Assert.IsTrue(gmp_lib.mpz_congruent_p(n, c, d) > 0)
            
            ' Release unmanaged memory allocated for n, d, and c.
            gmp_lib.mpz_clears(n, d, c, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_congruent_2exp_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">
            <summary>
            Return non-zero if <paramref name="n"/> is congruent to <paramref name="c"/> modulo 2^<paramref name="b"/>.
            </summary>
            <param name="n">An operand integer.</param>
            <param name="c">The remainder of the division by 2^<paramref name="b"/>.</param>
            <param name="b">The exponent of the power of two divisor.</param>
            <returns>Non-zero if <paramref name="n"/> is congruent to <paramref name="c"/> modulo 2^<paramref name="b"/>.</returns>
            <remarks>
            <para>
            <paramref name="n"/> is congruent to <paramref name="c"/> mod 2^<paramref name="b"/> if there exists an integer q
            satisfying <paramref name="n"/> = <paramref name="c"/> + q * 2^<paramref name="b"/>.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_congruent_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_congruent_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_congruent_ui_p(Math.Gmp.Native.mpz_t,System.UInt32,System.UInt32)">mpz_congruent_ui_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divexact(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divexact</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divisible_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divisible_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_fdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mod(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_mod</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_qr</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Division">Integer Division</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Division.html#Integer-Division">GNU MP - Integer Division</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of n to 10001.
            mpz_t n = new mpz_t();
            gmp_lib.mpz_init_set_ui(n, 10001U);
            
            // Create, initialize, and set the value of b to 1.
            mpz_t c = new mpz_t();
            gmp_lib.mpz_init_set_ui(c, 1U);
            
            // Assert that n is congruent to c mod 2^3.
            Assert.IsTrue(gmp_lib.mpz_congruent_2exp_p(n, c, 3U) > 0);
            
            // Release unmanaged memory allocated for n and c.
            gmp_lib.mpz_clears(n, c, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of n to 10001.
            Dim n As New mpz_t()
            gmp_lib.mpz_init_set_ui(n, 10001UI)
            
            ' Create, initialize, and set the value of b to 1.
            Dim c As New mpz_t()
            gmp_lib.mpz_init_set_ui(c, 1UI)
            
            ' Assert that n is congruent to c mod 2^3.
            Assert.IsTrue(gmp_lib.mpz_congruent_2exp_p(n, c, 3UI) > 0)
            
            ' Release unmanaged memory allocated for n and c.
            gmp_lib.mpz_clears(n, c, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_congruent_ui_p(Math.Gmp.Native.mpz_t,System.UInt32,System.UInt32)">
            <summary>
            Return non-zero if <paramref name="n"/> is congruent to <paramref name="c"/> modulo <paramref name="d"/>.
            </summary>
            <param name="n">An operand integer.</param>
            <param name="c">The remainder of the division by <paramref name="d"/>.</param>
            <param name="d">The divisor operand integer.</param>
            <returns>Non-zero if <paramref name="n"/> is congruent to <paramref name="c"/> modulo <paramref name="d"/>.</returns>
            <remarks>
            <para>
            <paramref name="n"/> is congruent to <paramref name="c"/> mod <paramref name="d"/> if there exists an integer q
            satisfying <paramref name="n"/> = <paramref name="c"/> + q * <paramref name="d"/>.
            Unlike the other division functions, <paramref name="d"/> = 0 is accepted and following the rule it can be seen
            that <paramref name="n"/> and <paramref name="c"/> are considered congruent mod 0 only when exactly equal.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_congruent_2exp_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_congruent_2exp_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_congruent_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_congruent_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divexact(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divexact</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divisible_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divisible_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_fdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mod(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_mod</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_qr</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Division">Integer Division</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Division.html#Integer-Division">GNU MP - Integer Division</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of n to 10000.
            mpz_t n = new mpz_t();
            gmp_lib.mpz_init_set_ui(n, 10000U);
            
            // Assert that n is congruent to 1 mod 3.
            Assert.IsTrue(gmp_lib.mpz_congruent_ui_p(n, 1U, 3U) > 0);
            
            // Release unmanaged memory allocated for n.
            gmp_lib.mpz_clear(n);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of n to 10000.
            Dim n As New mpz_t()
            gmp_lib.mpz_init_set_ui(n, 10000UI)
            
            ' Assert that n is congruent to 1 mod 3.
            Assert.IsTrue(gmp_lib.mpz_congruent_ui_p(n, 1UI, 3UI) > 0)
            
            ' Release unmanaged memory allocated for n.
            gmp_lib.mpz_clear(n)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_divexact(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">
            <summary>
            Set <paramref name="q"/> to <paramref name="n"/> / <paramref name="d"/> when it is known in advance that <paramref name="d"/> divides <paramref name="n"/>. 
            </summary>
            <param name="q">The result quotient integer.</param>
            <param name="n">The numerator integer.</param>
            <param name="d">The denominator integer.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_congruent_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_congruent_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divexact_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_divexact_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divisible_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divisible_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_fdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mod(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_mod</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_qr</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Division">Integer Division</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Division.html#Integer-Division">GNU MP - Integer Division</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of x to 10000.
            mpz_t x = new mpz_t();
            gmp_lib.mpz_init_set_ui(x, 10000U);
            
            // Create, initialize, and set the value of y to 5.
            mpz_t y = new mpz_t();
            gmp_lib.mpz_init_set_ui(y, 5U);
            
            // Create, initialize, and set the value of z to 0.
            mpz_t z = new mpz_t();
            gmp_lib.mpz_init(z);
            
            // Set z = x / y.
            gmp_lib.mpz_divexact(z, x, y);
            
            // Assert that z is 2000.
            Assert.IsTrue(gmp_lib.mpz_get_si(z) == 2000);
            
            // Release unmanaged memory allocated for x, y, and z.
            gmp_lib.mpz_clears(x, y, z, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of x to 10000.
            Dim x As New mpz_t()
            gmp_lib.mpz_init_set_ui(x, 10000UI)
            
            ' Create, initialize, and set the value of y to 5.
            Dim y As New mpz_t()
            gmp_lib.mpz_init_set_ui(y, 5UI)
            
            ' Create, initialize, and set the value of z to 0.
            Dim z As New mpz_t()
            gmp_lib.mpz_init(z)
            
            ' Set z = x / y.
            gmp_lib.mpz_divexact(z, x, y)
            
            ' Assert that z is 2000.
            Assert.IsTrue(gmp_lib.mpz_get_si(z) = 2000)
            
            ' Release unmanaged memory allocated for x, y, and z.
            gmp_lib.mpz_clears(x, y, z, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_divexact_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">
            <summary>
            Set <paramref name="q"/> to <paramref name="n"/> / <paramref name="d"/> when it is known in advance that <paramref name="d"/> divides <paramref name="n"/>. 
            </summary>
            <param name="q">The result quotient integer.</param>
            <param name="n">The numerator integer.</param>
            <param name="d">The denominator integer.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_congruent_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_congruent_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divexact(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divexact</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divisible_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divisible_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_fdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mod(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_mod</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_qr</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Division">Integer Division</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Division.html#Integer-Division">GNU MP - Integer Division</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of x to 10000.
            mpz_t x = new mpz_t();
            gmp_lib.mpz_init_set_ui(x, 10000U);
            
            // Create, initialize, and set the value of z to 0.
            mpz_t z = new mpz_t();
            gmp_lib.mpz_init(z);
            
            // Set z = x / 5.
            gmp_lib.mpz_divexact_ui(z, x, 5U);
            
            // Assert that z is 2000.
            Assert.IsTrue(gmp_lib.mpz_get_si(z) == 2000);
            
            // Release unmanaged memory allocated for x and z.
            gmp_lib.mpz_clears(x, z, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of x to 10000.
            Dim x As New mpz_t()
            gmp_lib.mpz_init_set_ui(x, 10000UI)
            
            ' Create, initialize, and set the value of z to 0.
            Dim z As New mpz_t()
            gmp_lib.mpz_init(z)
            
            ' Set z = x / 5.
            gmp_lib.mpz_divexact_ui(z, x, 5UI)
            
            ' Assert that z is 2000.
            Assert.IsTrue(gmp_lib.mpz_get_si(z) = 2000)
            
            ' Release unmanaged memory allocated for x and z.
            gmp_lib.mpz_clears(x, z, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_divisible_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">
            <summary>
            Return non-zero if <paramref name="n"/> is exactly divisible by <paramref name="d"/>.
            </summary>
            <param name="n">The numerator integer.</param>
            <param name="d">The denominator integer.</param>
            <returns>Non-zero if <paramref name="n"/> is exactly divisible by <paramref name="d"/>.</returns>
            <remarks>
            <para>
            <paramref name="n"/> is divisible by <paramref name="d"/> if there exists an integer q
            satisfying <paramref name="n"/> = q * <paramref name="d"/>. Unlike the other division functions,
            <paramref name="d"/> = 0 is accepted and following the rule it can be seen that only 0 is
            considered divisible by 0. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_congruent_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_congruent_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divexact(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divexact</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divisible_2exp_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_divisible_2exp_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divisible_ui_p(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_divisible_ui_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_fdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mod(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_mod</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_qr</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Division">Integer Division</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Division.html#Integer-Division">GNU MP - Integer Division</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of x to 10000.
            mpz_t x = new mpz_t();
            gmp_lib.mpz_init_set_ui(x, 10000U);
            
            // Create, initialize, and set the value of y to 5.
            mpz_t y = new mpz_t();
            gmp_lib.mpz_init_set_ui(y, 5U);
            
            // Assert that x is divisible by y.
            Assert.IsTrue(gmp_lib.mpz_divisible_p(x, y) > 0);
            
            // Release unmanaged memory allocated for x and y.
            gmp_lib.mpz_clears(x, y, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of x to 10000.
            Dim x As New mpz_t()
            gmp_lib.mpz_init_set_ui(x, 10000UI)
            
            ' Create, initialize, and set the value of y to 5.
            Dim y As New mpz_t()
            gmp_lib.mpz_init_set_ui(y, 5UI)
            
            ' Assert that x is divisible by y.
            Assert.IsTrue(gmp_lib.mpz_divisible_p(x, y) > 0)
            
            ' Release unmanaged memory allocated for x and y.
            gmp_lib.mpz_clears(x, y, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_divisible_ui_p(Math.Gmp.Native.mpz_t,System.UInt32)">
            <summary>
            Return non-zero if <paramref name="n"/> is exactly divisible by <paramref name="d"/>.
            </summary>
            <param name="n">The numerator integer.</param>
            <param name="d">The denominator integer.</param>
            <returns>Non-zero if <paramref name="n"/> is exactly divisible by <paramref name="d"/>.</returns>
            <remarks>
            <para>
            <paramref name="n"/> is divisible by <paramref name="d"/> if there exists an integer q
            satisfying <paramref name="n"/> = q * <paramref name="d"/>. Unlike the other division functions,
            <paramref name="d"/> = 0 is accepted and following the rule it can be seen that only 0 is
            considered divisible by 0. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_congruent_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_congruent_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divexact(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divexact</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divisible_2exp_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_divisible_2exp_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divisible_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divisible_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_fdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mod(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_mod</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_qr</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Division">Integer Division</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Division.html#Integer-Division">GNU MP - Integer Division</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of x to 10000.
            mpz_t x = new mpz_t();
            gmp_lib.mpz_init_set_ui(x, 10000U);
            
            // Assert that x is divisible by 5.
            Assert.IsTrue(gmp_lib.mpz_divisible_ui_p(x, 5U) > 0);
            
            // Release unmanaged memory allocated for x.
            gmp_lib.mpz_clear(x);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of x to 10000.
            Dim x As New mpz_t()
            gmp_lib.mpz_init_set_ui(x, 10000UI)
            
            ' Assert that x is divisible by 5.
            Assert.IsTrue(gmp_lib.mpz_divisible_ui_p(x, 5UI) > 0)
            
            ' Release unmanaged memory allocated for x.
            gmp_lib.mpz_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_divisible_2exp_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">
            <summary>
            Return non-zero if <paramref name="n"/> is exactly divisible by 2^<paramref name="b"/>.
            </summary>
            <param name="n">The numerator integer.</param>
            <param name="b">The exponent of the power of two denominator integer.</param>
            <returns>Non-zero if <paramref name="n"/> is exactly divisible by 2^<paramref name="b"/>.</returns>
            <remarks>
            <para>
            <paramref name="n"/> is divisible by 2^<paramref name="b"/> if there exists an integer q
            satisfying <paramref name="n"/> = q * 2^<paramref name="b"/>. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_congruent_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_congruent_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divexact(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divexact</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divisible_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divisible_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divisible_ui_p(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_divisible_ui_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_fdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mod(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_mod</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_qr</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Division">Integer Division</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Division.html#Integer-Division">GNU MP - Integer Division</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of x to 10000.
            mpz_t x = new mpz_t();
            gmp_lib.mpz_init_set_ui(x, 10000U);
            
            Assert.IsTrue(gmp_lib.mpz_divisible_2exp_p(x, 2U) > 0);
            
            // Release unmanaged memory allocated for x.
            gmp_lib.mpz_clear(x);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of x to 10000.
            Dim x As New mpz_t()
            gmp_lib.mpz_init_set_ui(x, 10000UI)
            
            Assert.IsTrue(gmp_lib.mpz_divisible_2exp_p(x, 2UI) > 0)
            
            ' Release unmanaged memory allocated for x.
            gmp_lib.mpz_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_even_p(Math.Gmp.Native.mpz_t)">
            <summary>
            Determine whether <paramref name="op"/> is even.
            </summary>
            <param name="op">The operand integer.</param>
            <returns>Return non-zero if even, zero if odd.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_ulong_p(Math.Gmp.Native.mpz_t)">mpz_fits_ulong_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_slong_p(Math.Gmp.Native.mpz_t)">mpz_fits_slong_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_uint_p(Math.Gmp.Native.mpz_t)">mpz_fits_uint_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_sint_p(Math.Gmp.Native.mpz_t)">mpz_fits_sint_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_ushort_p(Math.Gmp.Native.mpz_t)">mpz_fits_ushort_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_sshort_p(Math.Gmp.Native.mpz_t)">mpz_fits_sshort_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_odd_p(Math.Gmp.Native.mpz_t)">mpz_odd_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_sizeinbase(Math.Gmp.Native.mpz_t,System.Int32)">mpz_sizeinbase</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Miscellaneous_Integer_Functions">Miscellaneous Integer Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Miscellaneous-Integer-Functions.html#Miscellaneous-Integer-Functions">GNU MP - Miscellaneous Integer Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op to 427295.
            mpz_t op = new mpz_t();
            gmp_lib.mpz_init_set_ui(op, 427295);
            
            // Assert that op is not even but odd.
            Assert.IsTrue(gmp_lib.mpz_even_p(op) == 0);
            Assert.IsTrue(gmp_lib.mpz_odd_p(op) > 0);
            
            // Release unmanaged memory allocated for op.
            gmp_lib.mpz_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op to 427295.
            Dim op As New mpz_t()
            gmp_lib.mpz_init_set_ui(op, 427295)
            
            ' Assert that op is not even but odd.
            Assert.IsTrue(gmp_lib.mpz_even_p(op) = 0)
            Assert.IsTrue(gmp_lib.mpz_odd_p(op) > 0)
            
            ' Release unmanaged memory allocated for op.
            gmp_lib.mpz_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_export(Math.Gmp.Native.void_ptr,Math.Gmp.Native.size_t@,System.Int32,Math.Gmp.Native.size_t,System.Int32,Math.Gmp.Native.size_t,Math.Gmp.Native.mpz_t)">
            <summary>
            Fill <paramref name="rop"/> with word data from <paramref name="op"/>.
            </summary>
            <param name="rop">The result integer.</param>
            <param name="countp">The number of words produced.</param>
            <param name="order">1 for most significant word first or -1 for least significant first.</param>
            <param name="size">The number of bytes in each word.</param>
            <param name="endian">1 for most significant byte first, -1 for least significant first, or 0 for the native endianness of the host CPU.</param>
            <param name="nails">The number of most significant bits to skip.</param>
            <param name="op">The operand integer.</param>
            <returns>Either <paramref name="rop"/> or the allocated block.</returns>
            <remarks>
            <para>
            The parameters specify the format of the data produced.
            Each word will be <paramref name="size"/> bytes and <paramref name="order"/> can be 1 for most significant word first
            or -1 for least significant first.
            Within each word <paramref name="endian"/> can be 1 for most significant byte first,
            -1 for least significant first, or 0 for the native endianness of the host CPU.
            The most significant <paramref name="nails"/> bits of each word are unused and set to zero,
            this can be 0 to produce full words. 
            </para>
            <para>
            The number of words produced is written to <paramref name="countp"/>, or <paramref name="countp"/> can be NULL to discard the count.
            <paramref name="rop"/> must have enough space for the data, or if <paramref name="rop"/> is NULL then a result array of the necessary
            size is allocated using the current GMP allocation function 
            (see <a href="https://gmplib.org/manual/Custom-Allocation.html#Custom-Allocation">GNU MP - Custom Allocation</a>).
            In either case the return value is the destination used, either <paramref name="rop"/> or the allocated block. 
            </para>
            <para>
            If <paramref name="op"/> is non-zero then the most significant word produced will be non-zero.
            If <paramref name="op"/> is zero then the count returned will be zero and nothing written to <paramref name="rop"/>.
            If <paramref name="rop"/> is NULL in this case, no block is allocated, just NULL is returned. 
            </para>
            <para>
            The sign of <paramref name="op"/> is ignored, just the absolute value is exported.
            An application can use <see cref="M:Math.Gmp.Native.gmp_lib.mpz_sgn(Math.Gmp.Native.mpz_t)">mpz_sgn</see> to get the sign and handle it as desired.
            (see <a href="https://gmplib.org/manual/Integer-Comparisons.html#Integer-Comparisons">GNU MP - Integer Comparisons</a>) 
            </para>
            <para>
            There are no data alignment restrictions on <paramref name="rop"/>, any address is allowed. 
            </para>
            <para>
            When an application is allocating space itself the required size can be determined with a calculation like the following.
            Since <see cref="M:Math.Gmp.Native.gmp_lib.mpz_sizeinbase(Math.Gmp.Native.mpz_t,System.Int32)">mpz_sizeinbase</see> always returns at least 1, count here will be at least one, which avoids any portability
            problems with malloc(0), though if z is zero no space at all is actually needed (or written). 
            </para> 
            <code language="C++">
            numb = 8 * size - nail;
            count = (mpz_sizeinbase(z, 2) + numb - 1) / numb;
            p = malloc(count * size);
            </code> 
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_import(Math.Gmp.Native.mpz_t,Math.Gmp.Native.size_t,System.Int32,Math.Gmp.Native.size_t,System.Int32,Math.Gmp.Native.size_t,Math.Gmp.Native.void_ptr)">mpz_import</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Import_and_Export">Integer Import and Export</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Import-and-Export.html#Integer-Import-and-Export">GNU MP - Integer Import and Export</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op to 0x800000000000000000000001.
            mpz_t op = new mpz_t();
            char_ptr value = new char_ptr("800000000000000000000001");
            gmp_lib.mpz_init_set_str(op, value, 16);
            
            // Export op as 3 words of 4 bytes each, first word is lsb, and first byte in each word is msb.
            void_ptr data = gmp_lib.allocate(12);
            size_t countp = 0;
            gmp_lib.mpz_export(data, ref countp, -1, 4, 1, 0, op);
            
            // Assert the result.
            byte[] result = new byte[12];
            Marshal.Copy(data.ToIntPtr(), result, 0, 12);
            Assert.IsTrue(result[0] == 0x00);
            Assert.IsTrue(result[1] == 0x00);
            Assert.IsTrue(result[2] == 0x00);
            Assert.IsTrue(result[3] == 0x01);
            Assert.IsTrue(result[4] == 0x00);
            Assert.IsTrue(result[5] == 0x00);
            Assert.IsTrue(result[6] == 0x00);
            Assert.IsTrue(result[7] == 0x00);
            Assert.IsTrue(result[8] == 0x80);
            Assert.IsTrue(result[9] == 0x00);
            Assert.IsTrue(result[10] == 0x00);
            Assert.IsTrue(result[11] == 0x00);
            
            // Release unmanaged memory allocated for rop, data, and value.
            gmp_lib.mpz_clear(op);
            gmp_lib.free(data);
            gmp_lib.free(value);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op to 0x800000000000000000000001.
            Dim op As New mpz_t()
            Dim value As New char_ptr("800000000000000000000001")
            gmp_lib.mpz_init_set_str(op, value, 16)
            
            ' Export op as 3 words of 4 bytes each, first word is lsb, and first byte in each word is msb.
            Dim data As void_ptr = gmp_lib.allocate(12)
            Dim countp As size_t = 0
            gmp_lib.mpz_export(data, countp, -1, 4, 1, 0, op)
            
            ' Assert the result.
            Dim result As Byte() = New Byte(11) { }
            Marshal.Copy(data.ToIntPtr(), result, 0, 12)
            Assert.IsTrue(result(0) = &amp;H0)
            Assert.IsTrue(result(1) = &amp;H0)
            Assert.IsTrue(result(2) = &amp;H0)
            Assert.IsTrue(result(3) = &amp;H1)
            Assert.IsTrue(result(4) = &amp;H0)
            Assert.IsTrue(result(5) = &amp;H0)
            Assert.IsTrue(result(6) = &amp;H0)
            Assert.IsTrue(result(7) = &amp;H0)
            Assert.IsTrue(result(8) = &amp;H80)
            Assert.IsTrue(result(9) = &amp;H0)
            Assert.IsTrue(result(10) = &amp;H0)
            Assert.IsTrue(result(11) = &amp;H0)
            
            ' Release unmanaged memory allocated for rop, data, and value.
            gmp_lib.mpz_clear(op)
            gmp_lib.free(data)
            gmp_lib.free(value)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_export(Math.Gmp.Native.void_ptr,Math.Gmp.Native.ptr{Math.Gmp.Native.size_t},System.Int32,Math.Gmp.Native.size_t,System.Int32,Math.Gmp.Native.size_t,Math.Gmp.Native.mpz_t)">
            <summary>
            Fill <paramref name="rop"/> with word data from <paramref name="op"/>.
            </summary>
            <param name="rop">The result integer.</param>
            <param name="countp">The number of words produced.</param>
            <param name="order">1 for most significant word first or -1 for least significant first.</param>
            <param name="size">The number of bytes in each word.</param>
            <param name="endian">1 for most significant byte first, -1 for least significant first, or 0 for the native endianness of the host CPU.</param>
            <param name="nails">The number of most significant bits to skip.</param>
            <param name="op">The operand integer.</param>
            <returns>Either <paramref name="rop"/> or the allocated block.</returns>
            <remarks>
            <para>
            The parameters specify the format of the data produced.
            Each word will be <paramref name="size"/> bytes and <paramref name="order"/> can be 1 for most significant word first
            or -1 for least significant first.
            Within each word <paramref name="endian"/> can be 1 for most significant byte first,
            -1 for least significant first, or 0 for the native endianness of the host CPU.
            The most significant <paramref name="nails"/> bits of each word are unused and set to zero,
            this can be 0 to produce full words. 
            </para>
            <para>
            The number of words produced is written to <paramref name="countp"/>, or <paramref name="countp"/> can be NULL to discard the count.
            <paramref name="rop"/> must have enough space for the data, or if <paramref name="rop"/> is NULL then a result array of the necessary
            size is allocated using the current GMP allocation function 
            (see <a href="https://gmplib.org/manual/Custom-Allocation.html#Custom-Allocation">GNU MP - Custom Allocation</a>).
            In either case the return value is the destination used, either <paramref name="rop"/> or the allocated block. 
            </para>
            <para>
            If <paramref name="op"/> is non-zero then the most significant word produced will be non-zero.
            If <paramref name="op"/> is zero then the count returned will be zero and nothing written to <paramref name="rop"/>.
            If <paramref name="rop"/> is NULL in this case, no block is allocated, just NULL is returned. 
            </para>
            <para>
            The sign of <paramref name="op"/> is ignored, just the absolute value is exported.
            An application can use <see cref="M:Math.Gmp.Native.gmp_lib.mpz_sgn(Math.Gmp.Native.mpz_t)">mpz_sgn</see> to get the sign and handle it as desired.
            (see <a href="https://gmplib.org/manual/Integer-Comparisons.html#Integer-Comparisons">GNU MP - Integer Comparisons</a>) 
            </para>
            <para>
            There are no data alignment restrictions on <paramref name="rop"/>, any address is allowed. 
            </para>
            <para>
            When an application is allocating space itself the required size can be determined with a calculation like the following.
            Since <see cref="M:Math.Gmp.Native.gmp_lib.mpz_sizeinbase(Math.Gmp.Native.mpz_t,System.Int32)">mpz_sizeinbase</see> always returns at least 1, count here will be at least one, which avoids any portability
            problems with malloc(0), though if z is zero no space at all is actually needed (or written). 
            </para> 
            <code language="C++">
            numb = 8 * size - nail;
            count = (mpz_sizeinbase(z, 2) + numb - 1) / numb;
            p = malloc(count * size);
            </code> 
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_import(Math.Gmp.Native.mpz_t,Math.Gmp.Native.size_t,System.Int32,Math.Gmp.Native.size_t,System.Int32,Math.Gmp.Native.size_t,Math.Gmp.Native.void_ptr)">mpz_import</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Import_and_Export">Integer Import and Export</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Import-and-Export.html#Integer-Import-and-Export">GNU MP - Integer Import and Export</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op to 0x800000000000000000000001.
            mpz_t op = new mpz_t();
            char_ptr value = new char_ptr("800000000000000000000001");
            gmp_lib.mpz_init_set_str(op, value, 16);
            
            // Export op as 3 words of 4 bytes each, first word is lsb, and first byte in each word is msb.
            void_ptr data = gmp_lib.allocate(12);
            ptr&lt;size_t&gt; countp = new ptr&lt;size_t&gt;(0);
            gmp_lib.mpz_export(data, countp, -1, 4, 1, 0, op);
            
            // Assert the result.
            byte[] result = new byte[12];
            Marshal.Copy(data.ToIntPtr(), result, 0, 12);
            Assert.IsTrue(result[0] == 0x00);
            Assert.IsTrue(result[1] == 0x00);
            Assert.IsTrue(result[2] == 0x00);
            Assert.IsTrue(result[3] == 0x01);
            Assert.IsTrue(result[4] == 0x00);
            Assert.IsTrue(result[5] == 0x00);
            Assert.IsTrue(result[6] == 0x00);
            Assert.IsTrue(result[7] == 0x00);
            Assert.IsTrue(result[8] == 0x80);
            Assert.IsTrue(result[9] == 0x00);
            Assert.IsTrue(result[10] == 0x00);
            Assert.IsTrue(result[11] == 0x00);
            
            // Release unmanaged memory allocated for rop, data, and value.
            gmp_lib.mpz_clear(op);
            gmp_lib.free(data);
            gmp_lib.free(value);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op to 0x800000000000000000000001.
            Dim op As New mpz_t()
            Dim value As New char_ptr("800000000000000000000001")
            gmp_lib.mpz_init_set_str(op, value, 16)
            
            ' Export op as 3 words of 4 bytes each, first word is lsb, and first byte in each word is msb.
            Dim data As void_ptr = gmp_lib.allocate(12)
            Dim countp As New ptr(Of size_t)(0)
            gmp_lib.mpz_export(data, countp, -1, 4, 1, 0, op)
            
            ' Assert the result.
            Dim result As Byte() = New Byte(11) { }
            Marshal.Copy(data.ToIntPtr(), result, 0, 12)
            Assert.IsTrue(result(0) = &amp;H0)
            Assert.IsTrue(result(1) = &amp;H0)
            Assert.IsTrue(result(2) = &amp;H0)
            Assert.IsTrue(result(3) = &amp;H1)
            Assert.IsTrue(result(4) = &amp;H0)
            Assert.IsTrue(result(5) = &amp;H0)
            Assert.IsTrue(result(6) = &amp;H0)
            Assert.IsTrue(result(7) = &amp;H0)
            Assert.IsTrue(result(8) = &amp;H80)
            Assert.IsTrue(result(9) = &amp;H0)
            Assert.IsTrue(result(10) = &amp;H0)
            Assert.IsTrue(result(11) = &amp;H0)
            
            ' Release unmanaged memory allocated for rop, data, and value.
            gmp_lib.mpz_clear(op)
            gmp_lib.free(data)
            gmp_lib.free(value)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_fac_ui(Math.Gmp.Native.mpz_t,System.UInt32)">
            <summary>
            Set <paramref name="rop"/> to the factorial <paramref name="n"/>!.
            </summary>
            <param name="rop">The result integer.</param>
            <param name="n">The operand integer.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_2fac_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_2fac_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mfac_uiui(Math.Gmp.Native.mpz_t,System.UInt32,System.UInt32)">mpz_mfac_uiui</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Number_Theoretic_Functions">Number Theoretic Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions">GNU MP - Number Theoretic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of rop to 0.
            mpz_t rop = new mpz_t();
            gmp_lib.mpz_init(rop);
            
            // Set rop = 3!.
            gmp_lib.mpz_fac_ui(rop, 3U);
            
            // Assert that rop is 6.
            Assert.IsTrue(gmp_lib.mpz_get_si(rop) == 6);
            
            // Release unmanaged memory allocated for rop.
            gmp_lib.mpz_clear(rop);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of rop to 0.
            Dim rop As New mpz_t()
            gmp_lib.mpz_init(rop)
            
            ' Set rop = 3!.
            gmp_lib.mpz_fac_ui(rop, 3UI)
            
            ' Assert that rop is 6.
            Assert.IsTrue(gmp_lib.mpz_get_si(rop) = 6)
            
            ' Release unmanaged memory allocated for rop.
            gmp_lib.mpz_clear(rop)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_2fac_ui(Math.Gmp.Native.mpz_t,System.UInt32)">
            <summary>
            Set <paramref name="rop"/> to the double-factorial <paramref name="n"/>!!.
            </summary>
            <param name="rop">The result integer.</param>
            <param name="n">The operand integer.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fac_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_fac_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mfac_uiui(Math.Gmp.Native.mpz_t,System.UInt32,System.UInt32)">mpz_mfac_uiui</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Number_Theoretic_Functions">Number Theoretic Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions">GNU MP - Number Theoretic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of rop to 0.
            mpz_t rop = new mpz_t();
            gmp_lib.mpz_init(rop);
            
            // Set rop = 9!!.
            gmp_lib.mpz_2fac_ui(rop, 9U);
            
            // Assert that rop is 945.
            Assert.IsTrue(gmp_lib.mpz_get_si(rop) == 945);
            
            // Release unmanaged memory allocated for rop.
            gmp_lib.mpz_clear(rop);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of rop to 0.
            Dim rop As New mpz_t()
            gmp_lib.mpz_init(rop)
            
            ' Set rop = 9!!.
            gmp_lib.mpz_2fac_ui(rop, 9UI)
            
            ' Assert that rop is 945.
            Assert.IsTrue(gmp_lib.mpz_get_si(rop) = 945)
            
            ' Release unmanaged memory allocated for rop.
            gmp_lib.mpz_clear(rop)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_mfac_uiui(Math.Gmp.Native.mpz_t,System.UInt32,System.UInt32)">
            <summary>
            Set <paramref name="rop"/> to the m-multi-factorial <paramref name="n"/>!^(<paramref name="m"/>)n.
            </summary>
            <param name="rop">The result integer.</param>
            <param name="n">The first operand integer.</param>
            <param name="m">The second operand integer.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fac_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_fac_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_2fac_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_2fac_ui</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Number_Theoretic_Functions">Number Theoretic Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions">GNU MP - Number Theoretic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of rop to 0.
            mpz_t rop = new mpz_t();
            gmp_lib.mpz_init(rop);
            
            // Set rop = 10!^(4).
            gmp_lib.mpz_mfac_uiui(rop, 10U, 4U);
            
            // Assert that rop is 945.
            Assert.IsTrue(gmp_lib.mpz_get_si(rop) == 120);
            
            // Release unmanaged memory allocated for rop.
            gmp_lib.mpz_clear(rop);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of rop to 0.
            Dim rop As New mpz_t()
            gmp_lib.mpz_init(rop)
            
            ' Set rop = 10!^(4).
            gmp_lib.mpz_mfac_uiui(rop, 10UI, 4UI)
            
            ' Assert that rop is 945.
            Assert.IsTrue(gmp_lib.mpz_get_si(rop) = 120)
            
            ' Release unmanaged memory allocated for rop.
            gmp_lib.mpz_clear(rop)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_primorial_ui(Math.Gmp.Native.mpz_t,System.UInt32)">
            <summary>
            Set <paramref name="rop"/> to the primorial of <paramref name="n"/>, i.e. the product of all positive prime numbers &#8804; <paramref name="n"/>. 
            </summary>
            <param name="rop">The result integer.</param>
            <param name="n">The operand integer.</param>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Number_Theoretic_Functions">Number Theoretic Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions">GNU MP - Number Theoretic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of rop to 0.
            mpz_t rop = new mpz_t();
            gmp_lib.mpz_init(rop);
            
            // Set rop = 7 * 5 * 3 * 2 = 210.
            gmp_lib.mpz_primorial_ui(rop, 9U);
            
            // Assert that rop is 210.
            Assert.IsTrue(gmp_lib.mpz_get_si(rop) == 210);
            
            // Release unmanaged memory allocated for rop.
            gmp_lib.mpz_clear(rop);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of rop to 0.
            Dim rop As New mpz_t()
            gmp_lib.mpz_init(rop)
            
            ' Set rop = 7 * 5 * 3 * 2 = 210.
            gmp_lib.mpz_primorial_ui(rop, 9UI)
            
            ' Assert that rop is 210.
            Assert.IsTrue(gmp_lib.mpz_get_si(rop) = 210)
            
            ' Release unmanaged memory allocated for rop.
            gmp_lib.mpz_clear(rop)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_q(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">
            <summary>
            Set the quotient <paramref name="q"/> to floor(<paramref name="n"/> / <paramref name="d"/>).
            </summary>
            <param name="q">The result quotient integer.</param>
            <param name="n">The numerator integer.</param>
            <param name="d">The denominator integer.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_r(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_fdiv_r</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_fdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_q_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_fdiv_q_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_r_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_fdiv_r_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_qr_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_fdiv_qr_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_fdiv_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_q_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_fdiv_q_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_r_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_fdiv_r_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_congruent_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_congruent_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divexact(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divexact</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divisible_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divisible_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mod(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_mod</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_qr</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Division">Integer Division</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Division.html#Integer-Division">GNU MP - Integer Division</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of n to 10000.
            mpz_t n = new mpz_t();
            gmp_lib.mpz_init_set_si(n, 10000);
            
            // Create, initialize, and set the value of d to 3.
            mpz_t d = new mpz_t();
            gmp_lib.mpz_init_set_si(d, 3);
            
            // Create, initialize, and set the value of q to 0.
            mpz_t q = new mpz_t();
            gmp_lib.mpz_init(q);
            
            // Set q = floor(n / d).
            gmp_lib.mpz_fdiv_q(q, n, d);
            
            // Assert that q is floor(10000 / 3).
            Assert.IsTrue(gmp_lib.mpz_get_si(q) == 3333);
            
            // Release unmanaged memory allocated for n, d, and q.
            gmp_lib.mpz_clears(n, d, q, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of n to 10000.
            Dim n As New mpz_t()
            gmp_lib.mpz_init_set_si(n, 10000)
            
            ' Create, initialize, and set the value of d to 3.
            Dim d As New mpz_t()
            gmp_lib.mpz_init_set_si(d, 3)
            
            ' Create, initialize, and set the value of q to 0.
            Dim q As New mpz_t()
            gmp_lib.mpz_init(q)
            
            ' Set q = floor(n / d).
            gmp_lib.mpz_fdiv_q(q, n, d)
            
            ' Assert that q is floor(10000 / 3).
            Assert.IsTrue(gmp_lib.mpz_get_si(q) = 3333)
            
            ' Release unmanaged memory allocated for n, d, and q.
            gmp_lib.mpz_clears(n, d, q, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_q_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">
            <summary>
            Set the quotient <paramref name="q"/> to floor(<paramref name="n"/> / 2^<paramref name="b"/>).
            </summary>
            <param name="q">The result quotient integer.</param>
            <param name="n">The numerator integer.</param>
            <param name="b">The exponent of the power of two denominator.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_q(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_fdiv_q</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_r(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_fdiv_r</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_fdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_q_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_fdiv_q_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_r_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_fdiv_r_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_qr_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_fdiv_qr_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_fdiv_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_r_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_fdiv_r_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_congruent_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_congruent_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divexact(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divexact</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divisible_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divisible_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mod(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_mod</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_qr</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Division">Integer Division</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Division.html#Integer-Division">GNU MP - Integer Division</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of n to 10001.
            mpz_t n = new mpz_t();
            gmp_lib.mpz_init_set_si(n, 10001);
            
            // Create, initialize, and set the value of q to 0.
            mpz_t q = new mpz_t();
            gmp_lib.mpz_init(q);
            
            // Set q = floor(n / 2^2).
            gmp_lib.mpz_fdiv_q_2exp(q, n, 2U);
            
            // Assert that q is floor(10001 / 4).
            Assert.IsTrue(gmp_lib.mpz_get_si(q) == 2500);
            
            // Release unmanaged memory allocated for n and q.
            gmp_lib.mpz_clears(n, q, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of n to 10001.
            Dim n As New mpz_t()
            gmp_lib.mpz_init_set_si(n, 10001)
            
            ' Create, initialize, and set the value of q to 0.
            Dim q As New mpz_t()
            gmp_lib.mpz_init(q)
            
            ' Set q = floor(n / 2^2).
            gmp_lib.mpz_fdiv_q_2exp(q, n, 2UI)
            
            ' Assert that q is floor(10001 / 4).
            Assert.IsTrue(gmp_lib.mpz_get_si(q) = 2500)
            
            ' Release unmanaged memory allocated for n and q.
            gmp_lib.mpz_clears(n, q, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_q_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">
            <summary>
            Set the quotient <paramref name="q"/> to floor(<paramref name="n"/> / <paramref name="d"/>), and return the remainder r = | <paramref name="n"/> - <paramref name="q"/> * <paramref name="d"/> |.
            </summary>
            <param name="q">The result quotient integer.</param>
            <param name="n">The numerator integer.</param>
            <param name="d">The denominator integer.</param>
            <returns>Return the remainder r = | <paramref name="n"/> - <paramref name="q"/> * <paramref name="d"/> |.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_r(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_fdiv_r</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_fdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_r_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_fdiv_r_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_qr_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_fdiv_qr_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_fdiv_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_q_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_fdiv_q_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_r_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_fdiv_r_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_congruent_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_congruent_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divexact(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divexact</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divisible_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divisible_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mod(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_mod</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_qr</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Division">Integer Division</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Division.html#Integer-Division">GNU MP - Integer Division</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of n to 10000.
            mpz_t n = new mpz_t();
            gmp_lib.mpz_init_set_si(n, 10000);
            
            // Create, initialize, and set the value of q to 0.
            mpz_t q = new mpz_t();
            gmp_lib.mpz_init(q);
            
            // Set q = floor(n / 3) and return r = n - 3 * q.
            // Assert q and r values.
            Assert.IsTrue(gmp_lib.mpz_fdiv_q_ui(q, n, 3U) == 1U);
            Assert.IsTrue(gmp_lib.mpz_get_si(q) == 3333);
            
            // Release unmanaged memory allocated for n and q.
            gmp_lib.mpz_clears(n, q, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of n to 10000.
            Dim n As New mpz_t()
            gmp_lib.mpz_init_set_si(n, 10000)
            
            ' Create, initialize, and set the value of q to 0.
            Dim q As New mpz_t()
            gmp_lib.mpz_init(q)
            
            ' Set q = floor(n / 3) and return r = n - 3 * q.
            ' Assert q and r values.
            Assert.IsTrue(gmp_lib.mpz_fdiv_q_ui(q, n, 3UI) = 1UI)
            Assert.IsTrue(gmp_lib.mpz_get_si(q) = 3333)
            
            ' Release unmanaged memory allocated for n and q.
            gmp_lib.mpz_clears(n, q, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">
            <summary>
            Set the quotient <paramref name="q"/> to floor(<paramref name="n"/> / <paramref name="d"/>), and set the remainder <paramref name="r"/> to <paramref name="n"/> - <paramref name="q"/> * <paramref name="d"/>.
            </summary>
            <param name="q">The result quotient integer.</param>
            <param name="r">The result remainder integer.</param>
            <param name="n">The numerator integer.</param>
            <param name="d">The denominator integer.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_q(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_fdiv_q</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_r(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_fdiv_r</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_q_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_fdiv_q_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_r_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_fdiv_r_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_qr_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_fdiv_qr_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_fdiv_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_q_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_fdiv_q_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_r_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_fdiv_r_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_congruent_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_congruent_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divexact(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divexact</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divisible_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divisible_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mod(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_mod</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_qr</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Division">Integer Division</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Division.html#Integer-Division">GNU MP - Integer Division</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of n to 10000.
            mpz_t n = new mpz_t();
            gmp_lib.mpz_init_set_si(n, 10000);
            
            // Create, initialize, and set the value of d to 3.
            mpz_t d = new mpz_t();
            gmp_lib.mpz_init_set_si(d, 3);
            
            // Create, initialize, and set the values of q and r to 0.
            mpz_t q = new mpz_t();
            mpz_t r = new mpz_t();
            gmp_lib.mpz_inits(q, r, null);
            
            // Set q = floor(n / 3) and r = n - d * q.
            gmp_lib.mpz_fdiv_qr(q, r, n, d);
            
            // Assert that q is 3333, and that r is 1.
            Assert.IsTrue(gmp_lib.mpz_get_si(q) == 3333);
            Assert.IsTrue(gmp_lib.mpz_get_si(r) == 1);
            
            // Release unmanaged memory allocated for n, d, q, and r.
            gmp_lib.mpz_clears(n, d, q, r, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of n to 10000.
            Dim n As New mpz_t()
            gmp_lib.mpz_init_set_si(n, 10000)
            
            ' Create, initialize, and set the value of d to 3.
            Dim d As New mpz_t()
            gmp_lib.mpz_init_set_si(d, 3)
            
            ' Create, initialize, and set the values of q and r to 0.
            Dim q As New mpz_t()
            Dim r As New mpz_t()
            gmp_lib.mpz_inits(q, r, Nothing)
            
            ' Set q = floor(n / 3) and r = n - d * q.
            gmp_lib.mpz_fdiv_qr(q, r, n, d)
            /// 
            ' Assert that q is 3333, and that r is 1.
            Assert.IsTrue(gmp_lib.mpz_get_si(q) = 3333)
            Assert.IsTrue(gmp_lib.mpz_get_si(r) = 1)
            
            ' Release unmanaged memory allocated for n, d, q, and r.
            gmp_lib.mpz_clears(n, d, q, r, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_qr_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">
            <summary>
            Set quotient <paramref name="q"/> to floor(<paramref name="n"/> / <paramref name="d"/>), set the remainder <paramref name="r"/> to <paramref name="n"/> - <paramref name="q"/> * <paramref name="d"/>, and return | <paramref name="r"/> |.
            </summary>
            <param name="q">The result quotient integer.</param>
            <param name="r">The result remainder integer.</param>
            <param name="n">The numerator integer.</param>
            <param name="d">The denominator integer.</param>
            <returns>Return | <paramref name="r"/> |.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_q(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_fdiv_q</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_r(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_fdiv_r</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_fdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_q_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_fdiv_q_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_r_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_fdiv_r_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_fdiv_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_q_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_fdiv_q_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_r_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_fdiv_r_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_congruent_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_congruent_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divexact(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divexact</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divisible_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divisible_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mod(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_mod</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_qr</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Division">Integer Division</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Division.html#Integer-Division">GNU MP - Integer Division</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of n to 10000.
            mpz_t n = new mpz_t();
            gmp_lib.mpz_init_set_si(n, 10000);
            
            // Create, initialize, and set the values of q and r to 0.
            mpz_t q = new mpz_t();
            mpz_t r = new mpz_t();
            gmp_lib.mpz_inits(q, r, null);
            
            // Set q = floor(n / 3), r = n - d * q, and return r.
            Assert.IsTrue(gmp_lib.mpz_fdiv_qr_ui(q, r, n, 3U) == 1U);
            
            // Assert that q is 3333, and that r is 1.
            Assert.IsTrue(gmp_lib.mpz_get_si(q) == 3333);
            Assert.IsTrue(gmp_lib.mpz_get_si(r) == 1);
            
            // Release unmanaged memory allocated for n, q, and r.
            gmp_lib.mpz_clears(n, q, r, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of n to 10000.
            Dim n As New mpz_t()
            gmp_lib.mpz_init_set_si(n, 10000)
            
            ' Create, initialize, and set the values of q and r to 0.
            Dim q As New mpz_t()
            Dim r As New mpz_t()
            gmp_lib.mpz_inits(q, r, Nothing)
            
            ' Set q = floor(n / 3), r = n - d * q, and return r.
            Assert.IsTrue(gmp_lib.mpz_fdiv_qr_ui(q, r, n, 3UI) = 1UI)
            
            ' Assert that q is 3333, and that r is 1.
            Assert.IsTrue(gmp_lib.mpz_get_si(q) = 3333)
            Assert.IsTrue(gmp_lib.mpz_get_si(r) = 1)
            
            ' Release unmanaged memory allocated for n, q, and r.
            gmp_lib.mpz_clears(n, q, r, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_r(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">
            <summary>
            Set the remainder <paramref name="r"/> to <paramref name="n"/> - q * <paramref name="d"/> where q = floor(<paramref name="n"/> / <paramref name="d"/>).
            </summary>
            <param name="r">The result remainder integer.</param>
            <param name="n">The numerator integer.</param>
            <param name="d">The denominator integer.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_q(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_fdiv_q</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_fdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_q_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_fdiv_q_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_r_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_fdiv_r_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_qr_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_fdiv_qr_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_fdiv_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_q_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_fdiv_q_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_r_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_fdiv_r_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_congruent_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_congruent_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divexact(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divexact</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divisible_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divisible_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mod(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_mod</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_qr</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Division">Integer Division</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Division.html#Integer-Division">GNU MP - Integer Division</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of n to 10000.
            mpz_t n = new mpz_t();
            gmp_lib.mpz_init_set_si(n, 10000);
            
            // Create, initialize, and set the value of d to 3.
            mpz_t d = new mpz_t();
            gmp_lib.mpz_init_set_si(d, 3);
            
            // Create, initialize, and set the value of r to 0.
            mpz_t r = new mpz_t();
            gmp_lib.mpz_init(r);
            
            // Set r = n - d * floor(n / d).
            gmp_lib.mpz_fdiv_r(r, n, d);
            
            // Assert that r is 1.
            Assert.IsTrue(gmp_lib.mpz_get_si(r) == 1);
            
            // Release unmanaged memory allocated for n, d, and r.
            gmp_lib.mpz_clears(n, d, r, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of n to 10000.
            Dim n As New mpz_t()
            gmp_lib.mpz_init_set_si(n, 10000)
            
            ' Create, initialize, and set the value of d to 3.
            Dim d As New mpz_t()
            gmp_lib.mpz_init_set_si(d, 3)
            
            ' Create, initialize, and set the value of r to 0.
            Dim r As New mpz_t()
            gmp_lib.mpz_init(r)
            
            ' Set r = n - d * floor(n / d).
            gmp_lib.mpz_fdiv_r(r, n, d)
            ' Assert that r is 1.
            Assert.IsTrue(gmp_lib.mpz_get_si(r) = 1)
            
            ' Release unmanaged memory allocated for n, d, and r.
            gmp_lib.mpz_clears(n, d, r, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_r_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">
            <summary>
            Set the remainder <paramref name="r"/> to <paramref name="n"/> - q * 2^<paramref name="b"/> where q = floor(<paramref name="n"/> / 2^<paramref name="b"/>).
            </summary>
            <param name="r">The result remainder integer.</param>
            <param name="n">The numerator integer.</param>
            <param name="b">The exponent of the power of two denominator.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_q(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_fdiv_q</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_r(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_fdiv_r</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_fdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_q_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_fdiv_q_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_r_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_fdiv_r_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_qr_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_fdiv_qr_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_fdiv_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_q_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_fdiv_q_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_congruent_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_congruent_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divexact(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divexact</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divisible_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divisible_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mod(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_mod</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_qr</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Division">Integer Division</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Division.html#Integer-Division">GNU MP - Integer Division</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of n to 10001.
            mpz_t n = new mpz_t();
            gmp_lib.mpz_init_set_si(n, 10001);
            
            // Create, initialize, and set the value of r to 0.
            mpz_t r = new mpz_t();
            gmp_lib.mpz_init(r);
            
            // Set r = n - 2^2 * floor(n / 2^2)
            gmp_lib.mpz_fdiv_r_2exp(r, n, 2U);
            
            // Assert that r is 1.
            Assert.IsTrue(gmp_lib.mpz_get_si(r) == 1);
            
            // Release unmanaged memory allocated for n and r.
            gmp_lib.mpz_clears(n, r, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of n to 10001.
            Dim n As New mpz_t()
            gmp_lib.mpz_init_set_si(n, 10001)
            
            ' Create, initialize, and set the value of r to 0.
            Dim r As New mpz_t()
            gmp_lib.mpz_init(r)
            
            ' Set r = n - 2^2 * floor(n / 2^2)
            gmp_lib.mpz_fdiv_r_2exp(r, n, 2UI)
            
            ' Assert that r is 1.
            Assert.IsTrue(gmp_lib.mpz_get_si(r) = 1)
            
            ' Release unmanaged memory allocated for n and r.
            gmp_lib.mpz_clears(n, r, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_r_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">
            <summary>
            Set the remainder <paramref name="r"/> to <paramref name="n"/> - q * <paramref name="d"/> where q = floor(<paramref name="n"/> / <paramref name="d"/>), and return | <paramref name="r"/> |.
            </summary>
            <param name="r">The result remainder integer.</param>
            <param name="n">The numerator integer.</param>
            <param name="d">The denominator integer.</param>
            <returns>Return | <paramref name="r"/> |.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_q(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_fdiv_q</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_r(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_fdiv_r</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_fdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_q_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_fdiv_q_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_qr_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_fdiv_qr_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_fdiv_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_q_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_fdiv_q_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_r_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_fdiv_r_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_congruent_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_congruent_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divexact(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divexact</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divisible_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divisible_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mod(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_mod</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_qr</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Division">Integer Division</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Division.html#Integer-Division">GNU MP - Integer Division</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of n to 10000.
            mpz_t n = new mpz_t();
            gmp_lib.mpz_init_set_si(n, 10000);
            
            // Create, initialize, and set the value of r to 0.
            mpz_t r = new mpz_t();
            gmp_lib.mpz_init(r);
            
            // Set r = n - 3 * floor(n / 3), and return |r|.
            Assert.IsTrue(gmp_lib.mpz_fdiv_r_ui(r, n, 3U) == 1U);
            
            // Assert that r is 1.
            Assert.IsTrue(gmp_lib.mpz_get_si(r) == 1);
            
            // Release unmanaged memory allocated for n and r.
            gmp_lib.mpz_clears(n, r, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of n to 10000.
            Dim n As New mpz_t()
            gmp_lib.mpz_init_set_si(n, 10000)
            
            ' Create, initialize, and set the value of r to 0.
            Dim r As New mpz_t()
            gmp_lib.mpz_init(r)
            
            ' Set r = n - 3 * floor(n / 3), and return |r|.
            Set r = n - 3 * floor(n / 3), and return |r|.
            Assert.IsTrue(gmp_lib.mpz_fdiv_r_ui(r, n, 3UI) = 1UI)
            
            ' Assert that r is 1.
            Assert.IsTrue(gmp_lib.mpz_get_si(r) = 1)
            
            ' Release unmanaged memory allocated for n and r.
            gmp_lib.mpz_clears(n, r, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_ui(Math.Gmp.Native.mpz_t,System.UInt32)">
            <summary>
            Return the remainder | r | where r = <paramref name="n"/> - q * <paramref name="d"/>, and where q = floor(<paramref name="n"/> / <paramref name="d"/>).
            </summary>
            <param name="n">The numerator integer.</param>
            <param name="d">The denominator integer.</param>
            <returns>The remainder | r | where r = <paramref name="n"/> - q * <paramref name="d"/>, and where q = floor(<paramref name="n"/> / <paramref name="d"/>).</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_q(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_fdiv_q</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_r(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_fdiv_r</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_fdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_q_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_fdiv_q_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_r_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_fdiv_r_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_qr_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_fdiv_qr_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_q_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_fdiv_q_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_r_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_fdiv_r_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_congruent_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_congruent_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divexact(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divexact</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divisible_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divisible_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mod(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_mod</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_qr</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Division">Integer Division</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Division.html#Integer-Division">GNU MP - Integer Division</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of n to 10000.
            mpz_t n = new mpz_t();
            gmp_lib.mpz_init_set_si(n, 10000);
            
            // Assert that returned value is |n - 3 * floor(n / 3)|.
            Assert.IsTrue(gmp_lib.mpz_fdiv_ui(n, 3U) == 1U);
            
            // Release unmanaged memory allocated for n.
            gmp_lib.mpz_clear(n);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of n to 10000.
            Dim n As New mpz_t()
            gmp_lib.mpz_init_set_si(n, 10000)
            
            ' Assert that returned value is |n - 3 * floor(n / 3)|.
            Assert.IsTrue(gmp_lib.mpz_fdiv_ui(n, 3UI) = 1UI)
            
            ' Release unmanaged memory allocated for n.
            gmp_lib.mpz_clear(n)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_fib_ui(Math.Gmp.Native.mpz_t,System.UInt32)">
            <summary>
            Sets <paramref name="fn"/> to to F[<paramref name="n"/>], the <paramref name="n"/>’th Fibonacci number. 
            </summary>
            <param name="fn">The F[<paramref name="n"/>] result.</param>
            <param name="n">The operand integer.</param>
            <remarks>
            <para>
            The Fibonacci numbers and Lucas numbers are related sequences, so it’s never necessary to call both
            <see cref="M:Math.Gmp.Native.gmp_lib.mpz_fib2_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_fib2_ui</see> and <see cref="M:Math.Gmp.Native.gmp_lib.mpz_lucnum2_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_lucnum2_ui</see>. 
            The formulas for going from Fibonacci to Lucas can be found in
            <a href="https://gmplib.org/manual/Lucas-Numbers-Algorithm.html#Lucas-Numbers-Algorithm">GNU MP - Lucas Numbers Algorithm</a>,
            the reverse is straightforward too.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fib2_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_fib2_ui</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Number_Theoretic_Functions">Number Theoretic Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions">GNU MP - Number Theoretic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of fn to 0.
            mpz_t fn = new mpz_t();
            gmp_lib.mpz_init(fn);
            
            // Set fn to the n'th Fibonacci number.
            gmp_lib.mpz_fib_ui(fn, 20U);
            
            // Assert that fn is 6765.
            Assert.IsTrue(gmp_lib.mpz_get_si(fn) == 6765);
            
            // Release unmanaged memory allocated for fn.
            gmp_lib.mpz_clear(fn);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of fn to 0.
            Dim fn As New mpz_t()
            gmp_lib.mpz_init(fn)
            
            ' Set fn to the n'th Fibonacci number.
            gmp_lib.mpz_fib_ui(fn, 20UI)
            
            ' Assert that fn is 6765.
            Assert.IsTrue(gmp_lib.mpz_get_si(fn) = 6765)
            
            ' Release unmanaged memory allocated for fn.
            gmp_lib.mpz_clear(fn)
            </code>
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_fib2_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">
            <summary>
            Sets <paramref name="fn"/> to F[<paramref name="n"/>], and <paramref name="fnsub1"/> to F[<paramref name="n"/> - 1]. 
            </summary>
            <param name="fn">The F[<paramref name="n"/>] result.</param>
            <param name="fnsub1">The F[<paramref name="n"/> - 1] result.</param>
            <param name="n">The operand integer.</param>
            <remarks>
            <para>
            This function is designed for calculating isolated Fibonacci numbers. 
            When a sequence of values is wanted it’s best to start with <see cref="M:Math.Gmp.Native.gmp_lib.mpz_fib2_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_fib2_ui</see> 
            and iterate the defining F[n + 1] = F[n] + F[n - 1] or similar.
            </para>
            <para>
            The Fibonacci numbers and Lucas numbers are related sequences, so it’s never necessary to call both
            <see cref="M:Math.Gmp.Native.gmp_lib.mpz_fib2_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_fib2_ui</see> and <see cref="M:Math.Gmp.Native.gmp_lib.mpz_lucnum2_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_lucnum2_ui</see>. 
            The formulas for going from Fibonacci to Lucas can be found in
            <a href="https://gmplib.org/manual/Lucas-Numbers-Algorithm.html#Lucas-Numbers-Algorithm">GNU MP - Lucas Numbers Algorithm</a>,
            the reverse is straightforward too.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fib_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_fib_ui</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Number_Theoretic_Functions">Number Theoretic Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions">GNU MP - Number Theoretic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the values of fn and fnsub1 to 0.
            mpz_t fn = new mpz_t();
            mpz_t fnsub1 = new mpz_t();
            gmp_lib.mpz_inits(fn, fnsub1, null);
            
            // Set fnsub1 and fn to the 19'th and 20'th Fibonacci numbers respectively.
            gmp_lib.mpz_fib2_ui(fn, fnsub1, 20U);
            
            // Assert that fnsub1 and fn are respectively 4181 and 6765.
            Assert.IsTrue(gmp_lib.mpz_get_si(fnsub1) == 4181);
            Assert.IsTrue(gmp_lib.mpz_get_si(fn) == 6765);
            
            // Release unmanaged memory allocated for fn and fnsub1.
            gmp_lib.mpz_clears(fn, fnsub1, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the values of fn and fnsub1 to 0.
            Dim fn As New mpz_t()
            Dim fnsub1 As New mpz_t()
            gmp_lib.mpz_inits(fn, fnsub1, Nothing)
            
            ' Set fnsub1 and fn to the 19'th and 20'th Fibonacci numbers respectively.
            gmp_lib.mpz_fib2_ui(fn, fnsub1, 20UI)
            
            ' Assert that fnsub1 and fn are respectively 4181 and 6765.
            Assert.IsTrue(gmp_lib.mpz_get_si(fnsub1) = 4181)
            Assert.IsTrue(gmp_lib.mpz_get_si(fn) = 6765)
            
            ' Release unmanaged memory allocated for fn and fnsub1.
            gmp_lib.mpz_clears(fn, fnsub1, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_fits_sint_p(Math.Gmp.Native.mpz_t)">
            <summary>
            Return non-zero iff the value of <paramref name="op"/> fits in a signed 32-bit integer. Otherwise, return zero.
            </summary>
            <param name="op">The operand integer.</param>
            <returns>Return non-zero iff the value of <paramref name="op"/> fits in a signed 32-bit integer. Otherwise, return zero.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_ulong_p(Math.Gmp.Native.mpz_t)">mpz_fits_ulong_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_slong_p(Math.Gmp.Native.mpz_t)">mpz_fits_slong_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_uint_p(Math.Gmp.Native.mpz_t)">mpz_fits_uint_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_ushort_p(Math.Gmp.Native.mpz_t)">mpz_fits_ushort_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_sshort_p(Math.Gmp.Native.mpz_t)">mpz_fits_sshort_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_odd_p(Math.Gmp.Native.mpz_t)">mpz_odd_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_even_p(Math.Gmp.Native.mpz_t)">mpz_even_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_sizeinbase(Math.Gmp.Native.mpz_t,System.Int32)">mpz_sizeinbase</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Miscellaneous_Integer_Functions">Miscellaneous Integer Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Miscellaneous-Integer-Functions.html#Miscellaneous-Integer-Functions">GNU MP - Miscellaneous Integer Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op 4294967295.
            mpz_t op = new mpz_t();
            gmp_lib.mpz_init_set_ui(op, uint.MaxValue);
            
            // Assert that op does not fit in int.
            Assert.IsTrue(gmp_lib.mpz_fits_sint_p(op) == 0);
            
            // Release unmanaged memory allocated for op.
            gmp_lib.mpz_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op 4294967295.
            Dim op As New mpz_t()
            gmp_lib.mpz_init_set_ui(op, UInteger.MaxValue)
            
            ' Assert that op does not fit in int.
            Assert.IsTrue(gmp_lib.mpz_fits_sint_p(op) = 0)
            
            ' Release unmanaged memory allocated for op.
            gmp_lib.mpz_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_fits_slong_p(Math.Gmp.Native.mpz_t)">
            <summary>
            Return non-zero iff the value of <paramref name="op"/> fits in a signed 32-bit integer. Otherwise, return zero.
            </summary>
            <param name="op">The operand integer.</param>
            <returns>Return non-zero iff the value of <paramref name="op"/> fits in a signed 32-bit integer. Otherwise, return zero.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_ulong_p(Math.Gmp.Native.mpz_t)">mpz_fits_ulong_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_uint_p(Math.Gmp.Native.mpz_t)">mpz_fits_uint_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_sint_p(Math.Gmp.Native.mpz_t)">mpz_fits_sint_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_ushort_p(Math.Gmp.Native.mpz_t)">mpz_fits_ushort_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_sshort_p(Math.Gmp.Native.mpz_t)">mpz_fits_sshort_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_odd_p(Math.Gmp.Native.mpz_t)">mpz_odd_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_even_p(Math.Gmp.Native.mpz_t)">mpz_even_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_sizeinbase(Math.Gmp.Native.mpz_t,System.Int32)">mpz_sizeinbase</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Miscellaneous_Integer_Functions">Miscellaneous Integer Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Miscellaneous-Integer-Functions.html#Miscellaneous-Integer-Functions">GNU MP - Miscellaneous Integer Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op 4294967295.
            mpz_t op = new mpz_t();
            gmp_lib.mpz_init_set_ui(op, uint.MaxValue);
            
            // Assert that op does not fit in long.
            Assert.IsTrue(gmp_lib.mpz_fits_slong_p(op) == 0);
            
            // Release unmanaged memory allocated for op.
            gmp_lib.mpz_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op 4294967295.
            Dim op As New mpz_t()
            gmp_lib.mpz_init_set_ui(op, UInteger.MaxValue)
            
            ' Assert that op does not fit in long.
            Assert.IsTrue(gmp_lib.mpz_fits_slong_p(op) = 0)
            
            ' Release unmanaged memory allocated for op.
            gmp_lib.mpz_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_fits_sshort_p(Math.Gmp.Native.mpz_t)">
            <summary>
            Return non-zero iff the value of <paramref name="op"/> fits in a signed 16-bit integer. Otherwise, return zero.
            </summary>
            <param name="op">The operand integer.</param>
            <returns>Return non-zero iff the value of <paramref name="op"/> fits in a signed 16-bit integer. Otherwise, return zero.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_ulong_p(Math.Gmp.Native.mpz_t)">mpz_fits_ulong_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_slong_p(Math.Gmp.Native.mpz_t)">mpz_fits_slong_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_uint_p(Math.Gmp.Native.mpz_t)">mpz_fits_uint_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_sint_p(Math.Gmp.Native.mpz_t)">mpz_fits_sint_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_ushort_p(Math.Gmp.Native.mpz_t)">mpz_fits_ushort_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_odd_p(Math.Gmp.Native.mpz_t)">mpz_odd_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_even_p(Math.Gmp.Native.mpz_t)">mpz_even_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_sizeinbase(Math.Gmp.Native.mpz_t,System.Int32)">mpz_sizeinbase</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Miscellaneous_Integer_Functions">Miscellaneous Integer Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Miscellaneous-Integer-Functions.html#Miscellaneous-Integer-Functions">GNU MP - Miscellaneous Integer Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op 4294967295.
            mpz_t op = new mpz_t();
            gmp_lib.mpz_init_set_ui(op, uint.MaxValue);
            
            // Assert that op does not fit in short.
            Assert.IsTrue(gmp_lib.mpz_fits_sshort_p(op) ==  0);
            
            // Release unmanaged memory allocated for op.
            gmp_lib.mpz_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op 4294967295.
            Dim op As New mpz_t()
            gmp_lib.mpz_init_set_ui(op, UInteger.MaxValue)
            
            ' Assert that op does not fit in short.
            Assert.IsTrue(gmp_lib.mpz_fits_sshort_p(op) = 0)
            
            ' Release unmanaged memory allocated for op.
            gmp_lib.mpz_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_fits_uint_p(Math.Gmp.Native.mpz_t)">
            <summary>
            Return non-zero iff the value of <paramref name="op"/> fits in an unsigned 32-bit integer. Otherwise, return zero.
            </summary>
            <param name="op">The operand integer.</param>
            <returns>Return non-zero iff the value of <paramref name="op"/> fits in an unsigned 32-bit integer. Otherwise, return zero.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_ulong_p(Math.Gmp.Native.mpz_t)">mpz_fits_ulong_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_slong_p(Math.Gmp.Native.mpz_t)">mpz_fits_slong_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_sint_p(Math.Gmp.Native.mpz_t)">mpz_fits_sint_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_ushort_p(Math.Gmp.Native.mpz_t)">mpz_fits_ushort_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_sshort_p(Math.Gmp.Native.mpz_t)">mpz_fits_sshort_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_odd_p(Math.Gmp.Native.mpz_t)">mpz_odd_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_even_p(Math.Gmp.Native.mpz_t)">mpz_even_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_sizeinbase(Math.Gmp.Native.mpz_t,System.Int32)">mpz_sizeinbase</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Miscellaneous_Integer_Functions">Miscellaneous Integer Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Miscellaneous-Integer-Functions.html#Miscellaneous-Integer-Functions">GNU MP - Miscellaneous Integer Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op 4294967295.
            mpz_t op = new mpz_t();
            gmp_lib.mpz_init_set_ui(op, uint.MaxValue);
            
            // Assert that op does not fit in uint.
            Assert.IsTrue(gmp_lib.mpz_fits_uint_p(op) > 0);
            
            // Release unmanaged memory allocated for op.
            gmp_lib.mpz_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op 4294967295.
            Dim op As New mpz_t()
            gmp_lib.mpz_init_set_ui(op, UInteger.MaxValue)
            
            ' Assert that op does not fit in uint.
            Assert.IsTrue(gmp_lib.mpz_fits_uint_p(op) > 0)
            
            ' Release unmanaged memory allocated for op.
            gmp_lib.mpz_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_fits_ulong_p(Math.Gmp.Native.mpz_t)">
            <summary>
            Return non-zero iff the value of <paramref name="op"/> fits in an unsigned 32-bit integer. Otherwise, return zero.
            </summary>
            <param name="op">The operand integer.</param>
            <returns>Return non-zero iff the value of <paramref name="op"/> fits in a signed 32-bit integer. Otherwise, return zero.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_slong_p(Math.Gmp.Native.mpz_t)">mpz_fits_slong_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_uint_p(Math.Gmp.Native.mpz_t)">mpz_fits_uint_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_sint_p(Math.Gmp.Native.mpz_t)">mpz_fits_sint_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_ushort_p(Math.Gmp.Native.mpz_t)">mpz_fits_ushort_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_sshort_p(Math.Gmp.Native.mpz_t)">mpz_fits_sshort_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_odd_p(Math.Gmp.Native.mpz_t)">mpz_odd_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_even_p(Math.Gmp.Native.mpz_t)">mpz_even_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_sizeinbase(Math.Gmp.Native.mpz_t,System.Int32)">mpz_sizeinbase</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Miscellaneous_Integer_Functions">Miscellaneous Integer Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Miscellaneous-Integer-Functions.html#Miscellaneous-Integer-Functions">GNU MP - Miscellaneous Integer Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op 4294967295.
            mpz_t op = new mpz_t();
            gmp_lib.mpz_init_set_ui(op, uint.MaxValue);
            
            // Assert that op fits in ulong.
            Assert.IsTrue(gmp_lib.mpz_fits_ulong_p(op) > 0);
            
            // Release unmanaged memory allocated for op.
            gmp_lib.mpz_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op 4294967295.
            Dim op As New mpz_t()
            gmp_lib.mpz_init_set_ui(op, UInteger.MaxValue)
            
            ' Assert that op fits in ulong.
            Assert.IsTrue(gmp_lib.mpz_fits_ulong_p(op) > 0)
            
            ' Release unmanaged memory allocated for op.
            gmp_lib.mpz_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_fits_ushort_p(Math.Gmp.Native.mpz_t)">
            <summary>
            Return non-zero iff the value of <paramref name="op"/> fits in an unsigned 16-bit integer. Otherwise, return zero.
            </summary>
            <param name="op">The operand integer.</param>
            <returns>Return non-zero iff the value of <paramref name="op"/> fits in an unsigned 16-bit integer. Otherwise, return zero.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_ulong_p(Math.Gmp.Native.mpz_t)">mpz_fits_ulong_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_slong_p(Math.Gmp.Native.mpz_t)">mpz_fits_slong_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_uint_p(Math.Gmp.Native.mpz_t)">mpz_fits_uint_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_sint_p(Math.Gmp.Native.mpz_t)">mpz_fits_sint_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_sshort_p(Math.Gmp.Native.mpz_t)">mpz_fits_sshort_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_odd_p(Math.Gmp.Native.mpz_t)">mpz_odd_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_even_p(Math.Gmp.Native.mpz_t)">mpz_even_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_sizeinbase(Math.Gmp.Native.mpz_t,System.Int32)">mpz_sizeinbase</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Miscellaneous_Integer_Functions">Miscellaneous Integer Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Miscellaneous-Integer-Functions.html#Miscellaneous-Integer-Functions">GNU MP - Miscellaneous Integer Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op 4294967295.
            mpz_t op = new mpz_t();
            gmp_lib.mpz_init_set_ui(op, uint.MaxValue);
            
            // Assert that op does not fit in ushort.
            Assert.IsTrue(gmp_lib.mpz_fits_ushort_p(op) == 0);
            
            // Release unmanaged memory allocated for op.
            gmp_lib.mpz_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op 4294967295.
            Dim op As New mpz_t()
            gmp_lib.mpz_init_set_ui(op, UInteger.MaxValue)
            
            ' Assert that op does not fit in ushort.
            Assert.IsTrue(gmp_lib.mpz_fits_ushort_p(op) = 0)
            
            ' Release unmanaged memory allocated for op.
            gmp_lib.mpz_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_gcd(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">
            <summary>
            Set <paramref name="rop"/> to the greatest common divisor of <paramref name="op1"/> and <paramref name="op2"/>.
            </summary>
            <param name="rop">The result operand integer.</param>
            <param name="op1">The first operand integer.</param>
            <param name="op2">The second operand integer.</param>
            <remarks>
            <para>
            The result is always positive even if one or both input operands are negative.
            Except if both inputs are zero; then this function defines gcd(0,0) = 0.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_gcd_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_gcd_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_gcdext(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_gcdext</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Number_Theoretic_Functions">Number Theoretic Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions">GNU MP - Number Theoretic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op1 to 63.
            mpz_t op1 = new mpz_t();
            gmp_lib.mpz_init_set_ui(op1, 63U);
            
            // Create, initialize, and set the value of op2 to 70.
            mpz_t op2 = new mpz_t();
            gmp_lib.mpz_init_set_ui(op2, 70U);
            
            // Create, initialize, and set the value of rop to 0.
            mpz_t rop = new mpz_t();
            gmp_lib.mpz_init(rop);
            
            // Set rop to the greatest common divisor of op1 and op2.
            gmp_lib.mpz_gcd(rop, op1, op2);
            
            // Assert that rop is 7.
            Assert.IsTrue(gmp_lib.mpz_get_si(rop) == 7);
            
            // Release unmanaged memory allocated for rop, op1, and op2.
            gmp_lib.mpz_clears(rop, op1, op2, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op1 to 63.
            Dim op1 As New mpz_t()
            gmp_lib.mpz_init_set_ui(op1, 63UI)
            
            ' Create, initialize, and set the value of op2 to 70.
            Dim op2 As New mpz_t()
            gmp_lib.mpz_init_set_ui(op2, 70UI)
            
            ' Create, initialize, and set the value of rop to 0.
            Dim rop As New mpz_t()
            gmp_lib.mpz_init(rop)
            
            ' Set rop to the greatest common divisor of op1 and op2.
            gmp_lib.mpz_gcd(rop, op1, op2)
            
            ' Assert that rop is 7.
            Assert.IsTrue(gmp_lib.mpz_get_si(rop) = 7)
            
            ' Release unmanaged memory allocated for rop, op1, and op2.
            gmp_lib.mpz_clears(rop, op1, op2, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_gcd_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">
            <summary>
            Compute the greatest common divisor of <paramref name="op1"/> and <paramref name="op2"/>. If <paramref name="rop"/> is not null, store the result there. 
            </summary>
            <param name="rop">The result operand integer.</param>
            <param name="op1">The first operand integer.</param>
            <param name="op2">The second operand integer.</param>
            <returns>If the result is small enough to fit in an unsigned int, it is returned. If the result does not fit, 0 is returned, and the result is equal to the argument <paramref name="op1"/>.</returns>
            <remarks>
            <para>
            Note that the result will always fit if <paramref name="op2"/> is non-zero.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_gcd(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_gcd</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_gcdext(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_gcdext</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Number_Theoretic_Functions">Number Theoretic Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions">GNU MP - Number Theoretic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op1 to 63.
            mpz_t op1 = new mpz_t();
            gmp_lib.mpz_init_set_ui(op1, 63U);
            
            // Return the greatest common divisor of op1 and 70.
            Assert.IsTrue(gmp_lib.mpz_gcd_ui(null, op1, 70U) == 7);
            
            // Release unmanaged memory allocated for op1.
            gmp_lib.mpz_clear(op1);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op1 to 63.
            Dim op1 As New mpz_t()
            gmp_lib.mpz_init_set_ui(op1, 63UI)
            
            ' Return the greatest common divisor of op1 and 70.
            Assert.IsTrue(gmp_lib.mpz_gcd_ui(Nothing, op1, 70UI) = 7)
            ' Release unmanaged memory allocated for op1.
            gmp_lib.mpz_clear(op1)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_gcdext(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">
            <summary>
            Set <paramref name="g"/> to the greatest common divisor of <paramref name="a"/> and <paramref name="b"/>, and in addition set <paramref name="s"/> and <paramref name="t"/> to coefficients satisfying <paramref name="a"/> * <paramref name="s"/> + <paramref name="b"/> * <paramref name="t"/> = <paramref name="g"/>.
            </summary>
            <param name="g">The greateast common divisor.</param>
            <param name="s">The first result coefficient.</param>
            <param name="t">The second result coefficient.</param>
            <param name="a">The first operand integer.</param>
            <param name="b">The second operand integer.</param>
            <remarks>
            <para>
            The value in <paramref name="g"/> is always positive, even if one or both of <paramref name="a"/> and <paramref name="b"/>
            are negative (or zero if both inputs are zero). The values in <paramref name="s"/> and <paramref name="t"/> are chosen such
            that normally, | <paramref name="s"/> | &lt; | <paramref name="b"/> | / (2 <paramref name="g"/>)
            and | <paramref name="t"/> | &lt; | <paramref name="a"/> | / (2 <paramref name="g"/>), and these relations
            define <paramref name="s"/> and <paramref name="t"/> uniquely. There are a few exceptional cases: 
            </para>
            <para>
            If | <paramref name="a"/> | = | <paramref name="b"/> |, then <paramref name="s"/> = 0,
            <paramref name="t"/> = sgn(<paramref name="b"/>).
            </para>
            <para>
            Otherwise, <paramref name="s"/> = sgn(<paramref name="a"/>) if <paramref name="b"/> = 0 
            or | <paramref name="b"/> | = 2 <paramref name="g"/>, and <paramref name="t"/> = sgn(<paramref name="b"/>)
            if <paramref name="a"/> = 0 or | <paramref name="a"/> | = 2 <paramref name="g"/>. 
            </para>
            <para>
            In all cases, <paramref name="s"/> = 0 if and only if
            <paramref name="g"/> = | <paramref name="b"/> |, i.e.,
            if <paramref name="b"/> divides <paramref name="a"/>
            or <paramref name="a"/> = <paramref name="b"/> = 0. 
            </para>
            <para>
            If <paramref name="t"/> is null then that value is not computed. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_gcd(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_gcd</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_gcd_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_gcd_ui</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Number_Theoretic_Functions">Number Theoretic Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions">GNU MP - Number Theoretic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op1 to 63.
            mpz_t a = new mpz_t();
            gmp_lib.mpz_init_set_ui(a, 63U);
            
            // Create, initialize, and set the value of op2 to 70.
            mpz_t b = new mpz_t();
            gmp_lib.mpz_init_set_ui(b, 70U);
            
            // Create, initialize, and set the values of g, s, and t to 0.
            mpz_t g = new mpz_t();
            mpz_t s = new mpz_t();
            mpz_t t = new mpz_t();
            gmp_lib.mpz_inits(g, s, t, null);
            
            // Set g to the the greatest common divisor of a and b, and set s and t such that a * s + b * t = g.
            gmp_lib.mpz_gcdext(g, s, t, a, b);
            
            // Assert that g is 7, and that s and t are respectively -1 and 1.
            Assert.IsTrue(gmp_lib.mpz_get_si(g) == 7);
            Assert.IsTrue(gmp_lib.mpz_get_si(s) == -1);
            Assert.IsTrue(gmp_lib.mpz_get_si(t) == 1);
            
            // Release unmanaged memory allocated for g, s, t, a, and b.
            gmp_lib.mpz_clears(g, s, t, a, b, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op1 to 63.
            Dim a As New mpz_t()
            gmp_lib.mpz_init_set_ui(a, 63UI)
            
            ' Create, initialize, and set the value of op2 to 70.
            Dim b As New mpz_t()
            gmp_lib.mpz_init_set_ui(b, 70UI)
            
            ' Create, initialize, and set the values of g, s, and t to 0.
            Dim g As New mpz_t()
            Dim s As New mpz_t()
            Dim t As New mpz_t()
            gmp_lib.mpz_inits(g, s, t, Nothing)
            
            ' Set g to the the greatest common divisor of a and b, and set s and t such that a * s + b * t = g.
            gmp_lib.mpz_gcdext(g, s, t, a, b)
            
            ' Assert that g is 7, and that s and t are respectively -1 and 1.
            Assert.IsTrue(gmp_lib.mpz_get_si(g) = 7)
            Assert.IsTrue(gmp_lib.mpz_get_si(s) = -1)
            Assert.IsTrue(gmp_lib.mpz_get_si(t) = 1)
            
            ' Release unmanaged memory allocated for g, s, t, a, and b.
            gmp_lib.mpz_clears(g, s, t, a, b, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_get_d(Math.Gmp.Native.mpz_t)">
            <summary>
            Convert <paramref name="op"/> to a double, truncating if necessary (i.e. rounding towards zero).
            </summary>
            <param name="op">The integer.</param>
            <returns> <paramref name="op"/> as a double, truncating it if necessary (i.e. rounding towards zero).</returns>
            <remarks>
            <para>
            If the exponent from the conversion is too big, the result is system dependent. An infinity is returned
            where available. A hardware overflow trap may or may not occur.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_get_d_2exp(System.Int32@,Math.Gmp.Native.mpz_t)">mpz_get_d_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_get_si(Math.Gmp.Native.mpz_t)">mpz_get_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_get_str(Math.Gmp.Native.char_ptr,System.Int32,Math.Gmp.Native.mpz_t)">mpz_get_str</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_get_ui(Math.Gmp.Native.mpz_t)">mpz_get_ui</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Converting_Integers">Converting Integers</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Converting-Integers.html#Converting-Integers">GNU MP - Converting Integers</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of x to 10.
            mpz_t x = new mpz_t();
            gmp_lib.mpz_init_set_d(x, 10.7D);
            
            // Assert that the value of x is 10.0.
            Assert.IsTrue(gmp_lib.mpz_get_d(x) == 10.0);
            
            // Release unmanaged memory allocated for x.
            gmp_lib.mpz_clear(x);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of x to 10.
            Dim x As New mpz_t()
            gmp_lib.mpz_init_set_d(x, 10.7)
            
            ' Assert that the value of x is 10.0.
            Assert.IsTrue(gmp_lib.mpz_get_d(x) = 10.0)
            
            ' Release unmanaged memory allocated for x.
            gmp_lib.mpz_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_get_d_2exp(System.Int32@,Math.Gmp.Native.mpz_t)">
            <summary>
            Convert <paramref name="op"/> to a double, truncating if necessary (i.e. rounding towards zero), and returning the exponent separately.
            </summary>
            <param name="exp">The returned exponent.</param>
            <param name="op">The integer.</param>
            <returns><paramref name="op"/> as a double, truncating if necessary (i.e. rounding towards zero).</returns>
            <remarks>
            <para>
            The return value is in the range 0.5 &#8804; | d | &lt; 1 and the exponent is stored to <paramref name="exp"/>.
            d x 2^<paramref name="exp"/> is the (truncated) <paramref name="op"/> value.
            If <paramref name="op"/> is zero, the return value is 0.0 and 0 is stored to <paramref name="exp"/>.
            </para>
            <para>
            This is similar to the standard C <c>frexp</c> function.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_get_d(Math.Gmp.Native.mpz_t)">mpz_get_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_get_si(Math.Gmp.Native.mpz_t)">mpz_get_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_get_str(Math.Gmp.Native.char_ptr,System.Int32,Math.Gmp.Native.mpz_t)">mpz_get_str</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_get_ui(Math.Gmp.Native.mpz_t)">mpz_get_ui</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Converting_Integers">Converting Integers</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Converting-Integers.html#Converting-Integers">GNU MP - Converting Integers</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of x to 2^20.
            mpz_t x = new mpz_t();
            char_ptr value = new char_ptr("100000000000000000000");
            gmp_lib.mpz_init_set_str(x, value, 2);
            
            // Assert that x is equal to 0.5^21.
            int exp = 0;
            Assert.IsTrue(gmp_lib.mpz_get_d_2exp(ref exp, x) == 0.5D);
            Assert.IsTrue(exp == 21);
            
            // Release unmanaged memory allocated for x and the string value.
            gmp_lib.mpz_clear(x);
            gmp_lib.free(value);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of x to 2^20.
            Dim x As New mpz_t()
            Dim value As New char_ptr("100000000000000000000")
            gmp_lib.mpz_init_set_str(x, value, 2)
            
            ' Assert that x is equal to 0.5^21.
            Dim exp As Integer = 0
            Assert.IsTrue(gmp_lib.mpz_get_d_2exp(exp, x) = 0.5)
            Assert.IsTrue(exp = 21)
            
            ' Release unmanaged memory allocated for x and the string value.
            gmp_lib.mpz_clear(x)
            gmp_lib.free(value)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_get_si(Math.Gmp.Native.mpz_t)">
            <summary>
            Return the value of <paramref name="op"/> as an signed long.
            </summary>
            <param name="op">The integer.</param>
            <returns>The value of <paramref name="op"/> as an signed long.</returns>
            <remarks>
            <para>
            If <paramref name="op"/> fits into a signed long int return the value of <paramref name="op"/>.
            Otherwise return the least significant part of <paramref name="op"/>, with the same sign as <paramref name="op"/>.
            </para>
            <para>
            If <paramref name="op"/> is too big to fit in a signed long int, the returned result is probably not very useful.
            To find out if the value will fit, use the function <see cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_slong_p(Math.Gmp.Native.mpz_t)">mpz_fits_slong_p</see>.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_get_d(Math.Gmp.Native.mpz_t)">mpz_get_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_get_d_2exp(System.Int32@,Math.Gmp.Native.mpz_t)">mpz_get_d_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_get_str(Math.Gmp.Native.char_ptr,System.Int32,Math.Gmp.Native.mpz_t)">mpz_get_str</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_get_ui(Math.Gmp.Native.mpz_t)">mpz_get_ui</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Converting_Integers">Converting Integers</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Converting-Integers.html#Converting-Integers">GNU MP - Converting Integers</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of x to -10.
            mpz_t x = new mpz_t();
            gmp_lib.mpz_init_set_si(x, -10);
            
            // Retrieve the value of x, and assert that it is -10.
            Assert.IsTrue(gmp_lib.mpz_get_si(x) == -10);
            
            // Release unmanaged memory allocated for x.
            gmp_lib.mpz_clear(x);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of x to -10.
            Dim x As New mpz_t()
            gmp_lib.mpz_init_set_si(x, -10)
            
            ' Retrieve the value of x, and assert that it is -10.
            Assert.IsTrue(gmp_lib.mpz_get_si(x) = -10)
            
            ' Release unmanaged memory allocated for x.
            gmp_lib.mpz_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_get_str(Math.Gmp.Native.char_ptr,System.Int32,Math.Gmp.Native.mpz_t)">
            <summary>
            Convert <paramref name="op"/> to a string of digits in base <paramref name="base"/>.
            </summary>
            <param name="str">The converted integer.</param>
            <param name="base">The base.</param>
            <param name="op">The integer.</param>
            <returns>A pointer to the result string is returned, being either the allocated block, or the given <paramref name="str"/>.</returns>
            <remarks>
            <para>
            The base argument may vary from 2 to 62 or from −2 to −36.
            </para>
            <para>
            For base in the range 2..36, digits and lower-case letters are used; for −2..−36, digits and
            upper-case letters are used; for 37..62, digits, upper-case letters, and lower-case letters (in that
            significance order) are used.
            </para>
            <para>
            If <paramref name="str"/> is <see cref="F:Math.Gmp.Native.char_ptr.Zero">char_ptr.Zero</see>, the result string is allocated using the current
            allocation function. The block will be strlen(str)+1 bytes, that being exactly enough for the string and
            null-terminator.
            </para>
            <para>
            If <paramref name="str"/> is not <see cref="F:Math.Gmp.Native.char_ptr.Zero">char_ptr.Zero</see>, it should point to a block of storage large
            enough for the result, that being <see cref="M:Math.Gmp.Native.gmp_lib.mpz_sizeinbase(Math.Gmp.Native.mpz_t,System.Int32)">mpz_sizeinbase</see>(op, base) + 2.
            The two extra bytes are for a possible minus sign, and the null-terminator.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_get_d(Math.Gmp.Native.mpz_t)">mpz_get_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_get_d_2exp(System.Int32@,Math.Gmp.Native.mpz_t)">mpz_get_d_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_get_si(Math.Gmp.Native.mpz_t)">mpz_get_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_get_ui(Math.Gmp.Native.mpz_t)">mpz_get_ui</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Converting_Integers">Converting Integers</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Converting-Integers.html#Converting-Integers">GNU MP - Converting Integers</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of x to -210.
            mpz_t x = new mpz_t();
            gmp_lib.mpz_init_set_si(x, -210);
            
            // Retrieve the string value of x, and assert that it is "-210".
            char_ptr s = gmp_lib.mpz_get_str(char_ptr.Zero, 10, x);
            Assert.IsTrue(s.ToString() == "-210");
            
            // Release unmanaged memory allocated for x and the string value.
            gmp_lib.mpz_clear(x);
            gmp_lib.free(s);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of x to -210.
            Dim x As New mpz_t()
            gmp_lib.mpz_init_set_si(x, -210)
            
            ' Retrieve the string value of x, and assert that it is "-210".
            Dim s As char_ptr = gmp_lib.mpz_get_str(char_ptr.Zero, 10, x)
            Assert.IsTrue(s.ToString() = "-210")
            
            ' Release unmanaged memory allocated for x and the string value.
            gmp_lib.mpz_clear(x)
            gmp_lib.free(s)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_get_ui(Math.Gmp.Native.mpz_t)">
            <summary>
            Return the value of <paramref name="op"/> as an unsigned long.
            </summary>
            <param name="op">The integer.</param>
            <returns>The value of <paramref name="op"/> as an unsigned long.</returns>
            <remarks>
            <para>
            If <paramref name="op"/> is too big to fit an unsigned long then just the least significant
            bits that do fit are returned. The sign of <paramref name="op"/> is ignored, only the absolute
            value is used.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_get_d(Math.Gmp.Native.mpz_t)">mpz_get_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_get_d_2exp(System.Int32@,Math.Gmp.Native.mpz_t)">mpz_get_d_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_get_si(Math.Gmp.Native.mpz_t)">mpz_get_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_get_str(Math.Gmp.Native.char_ptr,System.Int32,Math.Gmp.Native.mpz_t)">mpz_get_str</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Converting_Integers">Converting Integers</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Converting-Integers.html#Converting-Integers">GNU MP - Converting Integers</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of x to 10.
            mpz_t x = new mpz_t();
            gmp_lib.mpz_init_set_ui(x, 10U);
            
            // Retrieve the value of x, and assert that it is 10.
            Assert.IsTrue(gmp_lib.mpz_get_ui(x) == 10U);
            
            // Release unmanaged memory allocated for x.
            gmp_lib.mpz_clear(x);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of x to 10.
            Dim x As New mpz_t()
            gmp_lib.mpz_init_set_ui(x, 10UI)
            
            ' Retrieve the value of x, and assert that it is 10.
            Assert.IsTrue(gmp_lib.mpz_get_ui(x) = 10UI)
            
            ' Release unmanaged memory allocated for x.
            gmp_lib.mpz_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_getlimbn(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">
            <summary>
            Return limb number <paramref name="n"/> from <paramref name="op"/>.
            </summary>
            <param name="op">The operand integer.</param>
            <param name="n">The zero-based limb index.</param>
            <returns>The limb number <paramref name="n"/> from <paramref name="op"/>.</returns>
            <remarks>
            <para>
            The sign of <paramref name="op"/> is ignored, just the absolute value is used.
            The least significant limb is number 0.
            </para>
            <para>
            <see cref="M:Math.Gmp.Native.gmp_lib.mpz_size(Math.Gmp.Native.mpz_t)">mpz_size</see> can be used to find how many limbs make up <paramref name="op"/>.
            <see cref="M:Math.Gmp.Native.gmp_lib.mpz_getlimbn(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">mpz_getlimbn</see> returns zero if <paramref name="n"/> is outside the range 0
            to mpz_size(<paramref name="op"/>) - 1.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib._mpz_realloc(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">_mpz_realloc</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_size(Math.Gmp.Native.mpz_t)">mpz_size</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_limbs_read(Math.Gmp.Native.mpz_t)">mpz_limbs_read</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_limbs_write(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">mpz_limbs_write</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_limbs_modify(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">mpz_limbs_modify</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_limbs_finish(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">mpz_limbs_finish</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_roinit_n(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpz_roinit_n</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Special_Functions">Integer Special Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Special-Functions.html#Integer-Special-Functions">GNU MP - Integer Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize new integer x.
            mpz_t op = new mpz_t();
            char_ptr value = new char_ptr("1000 ABCD 1234 7AB8 24FD");
            gmp_lib.mpz_init_set_str(op, value, 16);
            
            // Assert the value of the limbs of op.
            if (gmp_lib.mp_bytes_per_limb == 4)
            {
                Assert.IsTrue(gmp_lib.mpz_getlimbn(op, 0) == 0x7AB824FD);
                Assert.IsTrue(gmp_lib.mpz_getlimbn(op, 1) == 0xABCD1234);
                Assert.IsTrue(gmp_lib.mpz_getlimbn(op, 2) == 0x00001000);
            }
            else // gmp_lib.mp_bytes_per_limb == 8
            {
                Assert.IsTrue(gmp_lib.mpz_getlimbn(op, 0) == 0xABCD12347AB824FD);
                Assert.IsTrue(gmp_lib.mpz_getlimbn(op, 1) == 0x0000000000001000);
            }
            
            // Release unmanaged memory allocated for op and value.
            gmp_lib.mpz_clear(op);
            gmp_lib.free(value);
            </code> 
            <code language="VB.NET">
            ' Create and initialize new integer x.
            Dim op As New mpz_t()
            Dim value As New char_ptr("1000 ABCD 1234 7AB8 24FD")
            gmp_lib.mpz_init_set_str(op, value, 16)
            
            ' Assert the value of the limbs of op.
            If gmp_lib.mp_bytes_per_limb = 4 Then
                Assert.IsTrue(gmp_lib.mpz_getlimbn(op, 0) = &amp;H7ab824fd)
                Assert.IsTrue(gmp_lib.mpz_getlimbn(op, 1) = &amp;Habcd1234UI)
                Assert.IsTrue(gmp_lib.mpz_getlimbn(op, 2) = &amp;H1000)
            Else ' gmp_lib.mp_bytes_per_limb == 8
                Assert.IsTrue(gmp_lib.mpz_getlimbn(op, 0) = &amp;Habcd12347ab824fdUL)
                Assert.IsTrue(gmp_lib.mpz_getlimbn(op, 1) = &amp;H1000)
            End If
            
            ' Release unmanaged memory allocated for op and value.
            gmp_lib.mpz_clear(op)
            gmp_lib.free(value)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_hamdist(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">
            <summary>
            Return the hamming distance between the two operands.
            </summary>
            <param name="op1">The first operanf integer.</param>
            <param name="op2">The second operanf integer.</param>
            <returns>The hamming distance between the two operands.</returns>
            <remarks>
            <para>
            If <paramref name="op1"/> and <paramref name="op2"/> are both &#8805; 0 or both &lt; 0,
            return the hamming distance between the two operands, which is the number of bit positions where
            <paramref name="op1"/> and <paramref name="op2"/> have different bit values. If one operand is
            &#8805; 0 and the other &lt; 0 then the number of bits different is infinite, and the
            return value is the largest possible <see cref="T:Math.Gmp.Native.mp_bitcnt_t">mp_bitcnt_t</see>. 
            </para>
            <para>
            The function behaves as if twos complement arithmetic were used (although sign-magnitude is the actual implementation).
            The least significant bit is number 0. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_and(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_and</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_ior(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_ior</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_xor(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_xor</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_com(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_com</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_popcount(Math.Gmp.Native.mpz_t)">mpz_popcount</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_scan0(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_scan0</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_scan1(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_scan1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_setbit(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_setbit</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_clrbit(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_clrbit</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_combit(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_combit</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tstbit(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_tstbit</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Logic_and_Bit_Fiddling">Integer Logic and Bit Fiddling</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Logic-and-Bit-Fiddling.html#Integer-Logic-and-Bit-Fiddling">GNU MP - Integer Logic and Bit Fiddling</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op1 to 63.
            mpz_t op1 = new mpz_t();
            gmp_lib.mpz_init_set_ui(op1, 63U);
            
            // Create, initialize, and set the value of op2 to 70.
            mpz_t op2 = new mpz_t();
            gmp_lib.mpz_init_set_ui(op2, 70U);
            
            // Assert that the Hamming distance between op1 and op2 is 5.
            Assert.IsTrue(gmp_lib.mpz_hamdist(op1, op2) == 5U);
            
            // Release unmanaged memory allocated for op1 and op2.
            gmp_lib.mpz_clears(op1, op2, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op1 to 63.
            Dim op1 As New mpz_t()
            gmp_lib.mpz_init_set_ui(op1, 63UI)
            
            ' Create, initialize, and set the value of op2 to 70.
            Dim op2 As New mpz_t()
            gmp_lib.mpz_init_set_ui(op2, 70UI)
            
            ' Assert that the Hamming distance between op1 and op2 is 5.
            Assert.IsTrue(gmp_lib.mpz_hamdist(op1, op2) = 5UI)
            
            ' Release unmanaged memory allocated for op1 and op2.
            gmp_lib.mpz_clears(op1, op2, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_import(Math.Gmp.Native.mpz_t,Math.Gmp.Native.size_t,System.Int32,Math.Gmp.Native.size_t,System.Int32,Math.Gmp.Native.size_t,Math.Gmp.Native.void_ptr)">
            <summary>
            Set <paramref name="rop"/> from an array of word data at <paramref name="op"/>.
            </summary>
            <param name="rop">The result integer.</param>
            <param name="count">The number of words to read.</param>
            <param name="order">1 for most significant word first or -1 for least significant first.</param>
            <param name="size">The number of bytes in each word.</param>
            <param name="endian">1 for most significant byte first, -1 for least significant first, or 0 for the native endianness of the host CPU.</param>
            <param name="nails">The number of most significant bits to skip.</param>
            <param name="op">The operand integer.</param>
            <remarks>
            <para>
            The parameters specify the format of the data.
            <paramref name="count"/> many words are read, each <paramref name="size"/> bytes.
            <paramref name="order"/> can be 1 for most significant word first or -1 for least significant first.
            Within each word endian can be 1 for most significant byte first, -1 for least significant first, or 0 for the native endianness of the host CPU.
            The most significant <paramref name="nails"/> bits of each word are skipped, this can be 0 to use the full words. 
            </para>
            <para>
            There is no sign taken from the data, <paramref name="rop"/> will simply be a positive integer.
            An application can handle any sign itself, and apply it for instance with <see cref="M:Math.Gmp.Native.gmp_lib.mpz_neg(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_neg</see>.
            </para>
            <para>
            There are no data alignment restrictions on <paramref name="op"/>, any address is allowed. 
            </para>
            <para>
            Here’s an example converting an array of unsigned long data, most significant element first, and host byte order within each value. 
            </para>
            <code language="C++">
            unsigned long a[20];
            /* Initialize z and a */
            mpz_import(z, 20, 1, sizeof(a[0]), 0, 0, a);
            </code> 
            <para>
            This example assumes the full sizeof bytes are used for data in the given type, which is usually true,
            and certainly true for unsigned long everywhere we know of. However on Cray vector systems it may be noted that <c>short</c>
            and <c>int</c> are always stored in 8 bytes (and with sizeof indicating that) but use only 32 or 46 bits.
            The <paramref name="nails"/> feature can account for this, by passing for instance 8 * sizeof(int) - INT_BIT. 
            </para>
            </remarks>
            <seealso cref="O:Math.Gmp.Native.gmp_lib.mpz_export">O:Math.Gmp.Native.gmp_lib.mpz_export</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Import_and_Export">Integer Import and Export</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Import-and-Export.html#Integer-Import-and-Export">GNU MP - Integer Import and Export</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of rop to 0.
            mpz_t rop = new mpz_t();
            gmp_lib.mpz_init(rop);
            
            // Copy 0x800000000000000000000001, 3 words of 4 bytes each, first word is lsb, and first byte in each word is msb.
            void_ptr data = gmp_lib.allocate(12);
            Marshal.Copy(new byte[] { 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00 }, 0, data.ToIntPtr(), 12);
            
            // Import value into rop.
            gmp_lib.mpz_import(rop, 3, -1, 4, 1, 0, data);
            
            // Assert the value of rop.
            char_ptr value = gmp_lib.mpz_get_str(char_ptr.Zero, 16, rop);
            Assert.IsTrue(value.ToString() == "800000000000000000000001");
            
            // Release unmanaged memory allocated for rop, data, and value.
            gmp_lib.mpz_clear(rop);
            gmp_lib.free(data);
            gmp_lib.free(value);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of rop to 0.
            Dim rop As New mpz_t()
            gmp_lib.mpz_init(rop)
            
            ' Copy 0x800000000000000000000001, 3 words of 4 bytes each, first word is lsb, and first byte in each word is msb.
            Dim data As void_ptr = gmp_lib.allocate(12)
            Marshal.Copy(New Byte() { &amp;H0, &amp;H0, &amp;H0, &amp;H1, &amp;H0, &amp;H0, &amp;H0, &amp;H0, &amp;H80, &amp;H0, &amp;H0, &amp;H0}, 0, data.ToIntPtr(), 12)
            
            ' Import value into rop.
            gmp_lib.mpz_import(rop, 3, -1, 4, 1, 0, data)
            
            ' Assert the value of rop.
            Dim value As char_ptr = gmp_lib.mpz_get_str(char_ptr.Zero, 16, rop)
            Assert.IsTrue(value.ToString() = "800000000000000000000001")
            
            ' Release unmanaged memory allocated for rop, data, and value.
            gmp_lib.mpz_clear(rop)
            gmp_lib.free(data)
            gmp_lib.free(value)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_init(Math.Gmp.Native.mpz_t)">
            <summary>
            Initialize <paramref name="x"/>, and set its value to 0.
            </summary>
            <param name="x">The integer.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_clear(Math.Gmp.Native.mpz_t)">mpz_clear</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_clears(Math.Gmp.Native.mpz_t[])">mpz_clears</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_inits(Math.Gmp.Native.mpz_t[])">mpz_inits</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_init2(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_init2</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_realloc2(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_realloc2</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Initializing_Integers">Initializing Integers</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Initializing-Integers.html#Initializing-Integers">GNU MP - Initializing Integers</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize a new integer x.
            mpz_t x = new mpz_t();
            gmp_lib.mpz_init(x);
            
            // Assert that the value of x is 0.
            char_ptr s = gmp_lib.mpz_get_str(char_ptr.Zero, 10, x);
            Assert.IsTrue(s.ToString() == "0");
            
            // Release unmanaged memory allocated for x and its string value.
            gmp_lib.mpz_clear(x);
            gmp_lib.free(s);
            </code> 
            <code language="VB.NET">
            ' Create and initialize a new integer x.
            Dim x As New mpz_t()
            gmp_lib.mpz_init(x)
            
            ' Assert that the value of x is 0.
            Dim s As char_ptr = gmp_lib.mpz_get_str(char_ptr.Zero, 10, x)
            Assert.IsTrue(s.ToString() = "0")
            
            ' Release unmanaged memory allocated for x and its string value.
            gmp_lib.mpz_clear(x)
            gmp_lib.free(s)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_init2(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">
            <summary>
            Initialize <paramref name="x"/>, with space for <paramref name="n"/>-bit numbers, and set its value to 0.
            </summary>
            <param name="x">The integer.</param>
            <param name="n">The number of bits.</param>
            <remarks>
            <para>
            Calling this function instead of <see cref="M:Math.Gmp.Native.gmp_lib.mpz_init(Math.Gmp.Native.mpz_t)">mpz_init</see> or <see cref="M:Math.Gmp.Native.gmp_lib.mpz_inits(Math.Gmp.Native.mpz_t[])">mpz_inits</see>
            is never necessary; reallocation is handled automatically by GMP when needed.
            </para>
            <para>
            While <paramref name="n"/> defines the initial space, <paramref name="x"/> will grow automatically in the normal way,
            if necessary, for subsequent values stored.
            <see cref="M:Math.Gmp.Native.gmp_lib.mpz_init2(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_init2</see> makes it possible to avoid such reallocations if a maximum size is known in advance.
            </para>
            <para>
            In preparation for an operation, GMP often allocates one limb more than ultimately needed.
            To make sure GMP will not perform reallocation for <paramref name="x"/>, you need to add the number of bits
            in <see cref="T:Math.Gmp.Native.mp_limb_t">mp_limb_t</see> to <paramref name="n"/>.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_clear(Math.Gmp.Native.mpz_t)">mpz_clear</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_clears(Math.Gmp.Native.mpz_t[])">mpz_clears</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_init(Math.Gmp.Native.mpz_t)">mpz_init</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_inits(Math.Gmp.Native.mpz_t[])">mpz_inits</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_realloc2(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_realloc2</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Initializing_Integers">Initializing Integers</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Initializing-Integers.html#Initializing-Integers">GNU MP - Initializing Integers</a></seealso>
            <example>
            <code language="C#">
            // Create a new integer x, and initialize its size to 300 bits.
            mpz_t x = new mpz_t();
            gmp_lib.mpz_init2(x, 300);
            
            // Assert that the value of x is 0.
            Assert.IsTrue(gmp_lib.mpz_get_si(x) == 0);
            
            // Release unmanaged memory allocated for x.
            gmp_lib.mpz_clear(x);
            </code> 
            <code language="VB.NET">
            ' Create a new integer x, and initialize its size to 300 bits.
            Dim x As New mpz_t()
            gmp_lib.mpz_init2(x, 300)
            
            ' Assert that the value of x is 0.
            Assert.IsTrue(gmp_lib.mpz_get_si(x) = 0)
            
            ' Release unmanaged memory allocated for x.
            gmp_lib.mpz_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_inits(Math.Gmp.Native.mpz_t[])">
            <summary>
            Initialize a NULL-terminated list of <see cref="T:Math.Gmp.Native.mpz_t">mpz_t</see> variables, and set their values to 0.
            </summary>
            <param name="x">A NULL-terminated list of <see cref="T:Math.Gmp.Native.mpz_t">mpz_t</see> variables.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_clear(Math.Gmp.Native.mpz_t)">mpz_clear</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_clears(Math.Gmp.Native.mpz_t[])">mpz_clears</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_init(Math.Gmp.Native.mpz_t)">mpz_init</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_init2(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_init2</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_realloc2(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_realloc2</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Initializing_Integers">Initializing Integers</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Initializing-Integers.html#Initializing-Integers">GNU MP - Initializing Integers</a></seealso>
            <example>
            <code language="C#">
            // Create new integers x1, x2 and x3.
            mpz_t x1 = new mpz_t();
            mpz_t x2 = new mpz_t();
            mpz_t x3 = new mpz_t();
            
            // Initialize the integers.
            gmp_lib.mpz_inits(x1, x2, x3, null);
            
            // Assert that their value is 0.
            Assert.IsTrue(gmp_lib.mpz_get_si(x1) == 0);
            Assert.IsTrue(gmp_lib.mpz_get_si(x2) == 0);
            Assert.IsTrue(gmp_lib.mpz_get_si(x3) == 0);
            
            // Release unmanaged memory allocated for the integers.
            gmp_lib.mpz_clears(x1, x2, x3, null);
            </code> 
            <code language="VB.NET">
            ' Create new integers x1, x2 and x3.
            Dim x1 As New mpz_t()
            Dim x2 As New mpz_t()
            Dim x3 As New mpz_t()
            
            ' Initialize the integers.
            gmp_lib.mpz_inits(x1, x2, x3, Nothing)
            
            ' Assert that their value is 0.
            Assert.IsTrue(gmp_lib.mpz_get_si(x1) = 0)
            Assert.IsTrue(gmp_lib.mpz_get_si(x2) = 0)
            Assert.IsTrue(gmp_lib.mpz_get_si(x3) = 0)
            
            ' Release unmanaged memory allocated for the integers.
            gmp_lib.mpz_clears(x1, x2, x3, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_init_set(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">
            <summary>
            Initialize <paramref name="rop"/> with limb space and set the initial numeric value from <paramref name="op"/>.
            </summary>
            <param name="rop">The destination integer.</param>
            <param name="op">The source integer.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_init_set_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_init_set_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_init_set_si(Math.Gmp.Native.mpz_t,System.Int32)">mpz_init_set_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_init_set_d(Math.Gmp.Native.mpz_t,System.Double)">mpz_init_set_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_init_set_str(Math.Gmp.Native.mpz_t,Math.Gmp.Native.char_ptr,System.Int32)">mpz_init_set_str</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Simultaneous_Integer_Init_Assign">Simultaneous Integer Init &amp; Assign</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Simultaneous-Integer-Init-_0026-Assign.html#Simultaneous-Integer-Init-_0026-Assign">GNU MP - Combined Integer Initialization and Assignment</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new integer y to -210.
            mpz_t y = new mpz_t();
            gmp_lib.mpz_init(y);
            gmp_lib.mpz_set_si(y, -210);
            
            // Create, initialize, and set a new integer x to the value of y.
            mpz_t x = new mpz_t();
            gmp_lib.mpz_init_set(x, y);
            
            // Assert that x is equal to the value of y.
            Assert.IsTrue(gmp_lib.mpz_get_si(x) == -210);
            
            // Release unmanaged memory allocated for x and y.
            gmp_lib.mpz_clears(x, y, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new integer y to -210.
            Dim y As New mpz_t()
            
            gmp_lib.mpz_init(y)
            gmp_lib.mpz_set_si(y, -210)
            
            ' Create, initialize, and set a new integer x to the value of y.
            Dim x As New mpz_t()
            gmp_lib.mpz_init_set(x, y)
            
            ' Assert that x is equal to the value of y.
            Assert.IsTrue(gmp_lib.mpz_get_si(x) = -210)
            
            ' Release unmanaged memory allocated for x and y.
            gmp_lib.mpz_clears(x, y, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_init_set_d(Math.Gmp.Native.mpz_t,System.Double)">
            <summary>
            Initialize <paramref name="rop"/> with limb space and set the initial numeric value from <paramref name="op"/>.
            </summary>
            <param name="rop">The destination integer.</param>
            <param name="op">The source integer.</param>
            <remarks>
            <para>
            <see cref="M:Math.Gmp.Native.gmp_lib.mpz_init_set_d(Math.Gmp.Native.mpz_t,System.Double)">mpz_init_set_d</see> truncate <paramref name="op"/> to make it an integer.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_init_set(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_init_set</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_init_set_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_init_set_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_init_set_si(Math.Gmp.Native.mpz_t,System.Int32)">mpz_init_set_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_init_set_str(Math.Gmp.Native.mpz_t,Math.Gmp.Native.char_ptr,System.Int32)">mpz_init_set_str</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Simultaneous_Integer_Init_Assign">Simultaneous Integer Init &amp; Assign</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Simultaneous-Integer-Init-_0026-Assign.html#Simultaneous-Integer-Init-_0026-Assign">GNU MP - Combined Integer Initialization and Assignment</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of x to the truncation of 10.7.
            mpz_t x = new mpz_t();
            gmp_lib.mpz_init_set_d(x, 10.7D);
            
            // Assert that the value of x is 10.
            Assert.IsTrue(gmp_lib.mpz_get_si(x) == 10);
            
            // Release unmanaged memory allocated for x.
            gmp_lib.mpz_clear(x);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of x to the truncation of 10.7.
            Dim x As New mpz_t()
            
            gmp_lib.mpz_init_set_d(x, 10.7)
            
            ' Assert that the value of x is 10.
            Assert.IsTrue(gmp_lib.mpz_get_si(x) = 10)
            
            ' Release unmanaged memory allocated for x.
            gmp_lib.mpz_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_init_set_si(Math.Gmp.Native.mpz_t,System.Int32)">
            <summary>
            Initialize <paramref name="rop"/> with limb space and set the initial numeric value from <paramref name="op"/>.
            </summary>
            <param name="rop">The destination integer.</param>
            <param name="op">The source integer.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_init_set(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_init_set</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_init_set_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_init_set_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_init_set_d(Math.Gmp.Native.mpz_t,System.Double)">mpz_init_set_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_init_set_str(Math.Gmp.Native.mpz_t,Math.Gmp.Native.char_ptr,System.Int32)">mpz_init_set_str</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Simultaneous_Integer_Init_Assign">Simultaneous Integer Init &amp; Assign</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Simultaneous-Integer-Init-_0026-Assign.html#Simultaneous-Integer-Init-_0026-Assign">GNU MP - Combined Integer Initialization and Assignment</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of x to 10.
            mpz_t x = new mpz_t();
            gmp_lib.mpz_init_set_si(x, 10);
            
            // Assert that the value of x is 10.
            Assert.IsTrue(gmp_lib.mpz_get_si(x) == 10);
            
            // Release unmanaged memory allocated for x.
            gmp_lib.mpz_clear(x);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of x to 10.
            Dim x As New mpz_t()
            
            gmp_lib.mpz_init_set_si(x, 10)
            
            ' Assert that the value of x is 10.
            Assert.IsTrue(gmp_lib.mpz_get_si(x) = 10)
            
            ' Release unmanaged memory allocated for x.
            gmp_lib.mpz_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_init_set_str(Math.Gmp.Native.mpz_t,Math.Gmp.Native.char_ptr,System.Int32)">
            <summary>
            Initialize <paramref name="rop"/> and set its value like <see cref="M:Math.Gmp.Native.gmp_lib.mpz_set_str(Math.Gmp.Native.mpz_t,Math.Gmp.Native.char_ptr,System.Int32)">mpz_set_str</see>.
            </summary>
            <param name="rop">The destination integer.</param>
            <param name="str">The source integer.</param>
            <param name="base">The base.</param>
            <returns>If the string is a correct base <paramref name="base"/> number, the function returns 0; if an error occurs it returns −1. <paramref name="rop"/> is initialized even if an error occurs.</returns>
            <remarks>
            <para>
            See <see cref="M:Math.Gmp.Native.gmp_lib.mpz_set_str(Math.Gmp.Native.mpz_t,Math.Gmp.Native.char_ptr,System.Int32)">mpz_set_str</see> for details.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_init_set(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_init_set</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_init_set_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_init_set_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_init_set_si(Math.Gmp.Native.mpz_t,System.Int32)">mpz_init_set_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_init_set_d(Math.Gmp.Native.mpz_t,System.Double)">mpz_init_set_d</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Simultaneous_Integer_Init_Assign">Simultaneous Integer Init &amp; Assign</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Simultaneous-Integer-Init-_0026-Assign.html#Simultaneous-Integer-Init-_0026-Assign">GNU MP - Combined Integer Initialization and Assignment</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of x.
            mpz_t x = new mpz_t();
            char_ptr value = new char_ptr("  1 234 567 890 876 543 211 234 567 890 987 654 321  ");
            gmp_lib.mpz_init_set_str(x, value, 10);
            
            // Assert the value of x.
            char_ptr s = gmp_lib.mpz_get_str(char_ptr.Zero, 10, x);
            Assert.IsTrue(s.ToString() == value.ToString().Replace(" ", ""));
            
            // Release unmanaged memory allocated for x and string values.
            gmp_lib.mpz_clear(x);
            gmp_lib.free(value);
            gmp_lib.free(s);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of x.
            Dim x As New mpz_t()
            Dim value As New char_ptr("  1 234 567 890 876 543 211 234 567 890 987 654 321  ")
            gmp_lib.mpz_init_set_str(x, value, 10)
            
            ' Assert the value of x.
            Dim s As char_ptr = gmp_lib.mpz_get_str(char_ptr.Zero, 10, x)
            
            Assert.IsTrue(s.ToString() = value.ToString().Replace(" ", ""))
            ' Release unmanaged memory allocated for x and string values.
            gmp_lib.mpz_clear(x)
            gmp_lib.free(value)
            gmp_lib.free(s)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_init_set_ui(Math.Gmp.Native.mpz_t,System.UInt32)">
            <summary>
            Initialize <paramref name="rop"/> with limb space and set the initial numeric value from <paramref name="op"/>.
            </summary>
            <param name="rop">The destination integer.</param>
            <param name="op">The source integer.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_init_set(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_init_set</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_init_set_si(Math.Gmp.Native.mpz_t,System.Int32)">mpz_init_set_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_init_set_d(Math.Gmp.Native.mpz_t,System.Double)">mpz_init_set_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_init_set_str(Math.Gmp.Native.mpz_t,Math.Gmp.Native.char_ptr,System.Int32)">mpz_init_set_str</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Simultaneous_Integer_Init_Assign">Simultaneous Integer Init &amp; Assign</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Simultaneous-Integer-Init-_0026-Assign.html#Simultaneous-Integer-Init-_0026-Assign">GNU MP - Combined Integer Initialization and Assignment</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of x to 10.
            mpz_t x = new mpz_t();
            gmp_lib.mpz_init_set_ui(x, 10U);
            
            // Assert that the value of x is 10.
            Assert.IsTrue(gmp_lib.mpz_get_ui(x) == 10U);
            
            // Release unmanaged memory allocated for x.
            gmp_lib.mpz_clear(x);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of x to 10.
            Dim x As New mpz_t()
            gmp_lib.mpz_init_set_ui(x, 10UI)
            
            ' Assert that the value of x is 10.
            Assert.IsTrue(gmp_lib.mpz_get_ui(x) = 10UI)
            
            ' Release unmanaged memory allocated for x.
            gmp_lib.mpz_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_inp_raw(Math.Gmp.Native.mpz_t,Math.Gmp.Native.ptr{Math.Gmp.Native.FILE})">
            <summary>
            Input from stdio stream <paramref name="stream"/> in the format written by <see cref="M:Math.Gmp.Native.gmp_lib.mpz_out_raw(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},Math.Gmp.Native.mpz_t)">mpz_out_raw</see>, and put the result in <paramref name="rop"/>.
            </summary>
            <param name="rop">The result operand.</param>
            <param name="stream">Pointer to file stream.</param>
            <returns>Return the number of bytes read, or if an error occurred, return 0.</returns>
            <remarks>
            <para>
            This routine can read the output from <see cref="M:Math.Gmp.Native.gmp_lib.mpz_out_raw(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},Math.Gmp.Native.mpz_t)">mpz_out_raw</see> also from GMP 1,
            in spite of changes necessary for compatibility between 32-bit and 64-bit machines. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_out_str(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.Int32,Math.Gmp.Native.mpz_t)">mpz_out_str</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_inp_str(Math.Gmp.Native.mpz_t,Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.Int32)">mpz_inp_str</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_out_raw(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},Math.Gmp.Native.mpz_t)">mpz_out_raw</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#IO_of_Integers">I/O of Integers</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/I_002fO-of-Integers.html#I_002fO-of-Integers">GNU MP - I/O of Integers</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op to 123456.
            mpz_t op = new mpz_t();
            gmp_lib.mpz_init_set_ui(op, 123456U);
            
            // Write op to a temporary file.
            string pathname = System.IO.Path.GetTempFileName();
            ptr&lt;FILE&gt; stream = new ptr&lt;FILE&gt;();
            _wfopen_s(out stream.Value.Value, pathname, "w");
            Assert.IsTrue(gmp_lib.mpz_out_raw(stream, op) == 7);
            fclose(stream.Value.Value);
            
            // Read op from the temporary file, and assert that the number of bytes read is 6.
            _wfopen_s(out stream.Value.Value, pathname, "r");
            Assert.IsTrue(gmp_lib.mpz_inp_raw(op, stream) == 7);
            fclose(stream.Value.Value);
            
            // Assert that op is 123456.
            Assert.IsTrue(gmp_lib.mpz_get_ui(op) == 123456U);
            
            // Delete temporary file.
            System.IO.File.Delete(pathname);
            
            // Release unmanaged memory allocated for op.
            gmp_lib.mpz_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op to 123456.
            Dim op As New mpz_t()
            gmp_lib.mpz_init_set_ui(op, 123456UI)
            
            ' Write op to a temporary file.
            Dim pathname As String = System.IO.Path.GetTempFileName()
            Dim stream As New ptr(Of FILE)()
            _wfopen_s(stream.Value.Value, pathname, "w")
            Assert.IsTrue(gmp_lib.mpz_out_raw(stream, op) = 7)
            fclose(stream.Value.Value)
            
            ' Read op from the temporary file, and assert that the number of bytes read is 6.
            _wfopen_s(stream.Value.Value, pathname, "r")
            Assert.IsTrue(gmp_lib.mpz_inp_raw(op, stream) = 7)
            fclose(stream.Value.Value)
            
            ' Assert that op is 123456.
            Assert.IsTrue(gmp_lib.mpz_get_ui(op) = 123456UI)
            
            ' Delete temporary file.
            System.IO.File.Delete(pathname)
            
            ' Release unmanaged memory allocated for op.
            gmp_lib.mpz_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_inp_str(Math.Gmp.Native.mpz_t,Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.Int32)">
            <summary>
            Input a possibly white-space preceded string in base <paramref name="base"/> from stdio stream <paramref name="stream"/>, and put the read integer in <paramref name="rop"/>. 
            </summary>
            <param name="rop">The result integer.</param>
            <param name="stream">Pointer to file stream.</param>
            <param name="base">The base operand.</param>
            <returns>Return the number of bytes read, or if an error occurred, return 0.</returns>
            <remarks>
            <para>
            The <paramref name="base"/> may vary from 2 to 62, or if base is 0,
            then the leading characters are used: 0x and 0X for hexadecimal,
            0b and 0B for binary, 0 for octal, or decimal otherwise. 
            </para>
            <para>
            For bases up to 36, case is ignored; upper-case and lower-case letters have the same value.
            For bases 37 to 62, upper-case letter represent the usual 10..35 while
            lower-case letter represent 36..61. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_out_str(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.Int32,Math.Gmp.Native.mpz_t)">mpz_out_str</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_out_raw(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},Math.Gmp.Native.mpz_t)">mpz_out_raw</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_inp_raw(Math.Gmp.Native.mpz_t,Math.Gmp.Native.ptr{Math.Gmp.Native.FILE})">mpz_inp_raw</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#IO_of_Integers">I/O of Integers</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/I_002fO-of-Integers.html#I_002fO-of-Integers">GNU MP - I/O of Integers</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize op.
            mpz_t op = new mpz_t();
            gmp_lib.mpz_init(op);
            
            // Write op to a temporary file.
            string pathname = System.IO.Path.GetTempFileName();
            System.IO.File.WriteAllText(pathname, "123456");
            
            // Read op from the temporary file, and assert that the number of bytes read is 6.
            ptr&lt;FILE&gt; stream = new ptr&lt;FILE&gt;();
            _wfopen_s(out stream.Value.Value, pathname, "r");
            Assert.IsTrue(gmp_lib.mpz_inp_str(op, stream, 10) == 6);
            fclose(stream.Value.Value);
            
            // Assert that op is 123456.
            Assert.IsTrue(gmp_lib.mpz_get_ui(op) == 123456U);
            
            // Delete temporary file.
            System.IO.File.Delete(pathname);
            
            // Release unmanaged memory allocated for op.
            gmp_lib.mpz_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create and initialize op.
            Dim op As New mpz_t()
            gmp_lib.mpz_init(op)
            
            ' Write op to a temporary file.
            Dim pathname As String = System.IO.Path.GetTempFileName()
            System.IO.File.WriteAllText(pathname, "123456")
            
            ' Read op from the temporary file, and assert that the number of bytes read is 6.
            Dim stream As New ptr(Of FILE)()
            _wfopen_s(stream.Value.Value, pathname, "r")
            Assert.IsTrue(gmp_lib.mpz_inp_str(op, stream, 10) = 6)
            fclose(stream.Value.Value)
            
            ' Assert that op is 123456.
            Assert.IsTrue(gmp_lib.mpz_get_ui(op) = 123456UI)
            
            ' Delete temporary file.
            System.IO.File.Delete(pathname)
            
            ' Release unmanaged memory allocated for op.
            gmp_lib.mpz_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_invert(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">
            <summary>
            Compute the inverse of <paramref name="op1"/> modulo <paramref name="op2"/> and put the result in <paramref name="rop"/>.
            </summary>
            <param name="rop">The result integer.</param>
            <param name="op1">The first operand integer.</param>
            <param name="op2">The second operand integer.</param>
            <returns>If the inverse exists, the return value is non-zero. If an inverse doesn’t exist the return value is zero.</returns>
            <remarks>
            <para>
            If the inverse exists, the return value is non-zero and <paramref name="rop"/> will satisfy
            0 &#8804; <paramref name="rop"/> &lt; | <paramref name="op2"/> | (with <paramref name="rop"/> = 0
            possible only when | <paramref name="op2"/> | = 1, i.e., in the somewhat degenerate zero ring).
            If an inverse doesn’t exist the return value is zero and <paramref name="rop"/> is undefined.
            The behaviour of this function is undefined when <paramref name="op2"/> is zero.
            </para>
            </remarks>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Number_Theoretic_Functions">Number Theoretic Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions">GNU MP - Number Theoretic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op1 to 3.
            mpz_t op1 = new mpz_t();
            gmp_lib.mpz_init_set_ui(op1, 3U);
            
            // Create, initialize, and set the value of op2 to 11.
            mpz_t op2 = new mpz_t();
            gmp_lib.mpz_init_set_ui(op2, 11U);
            
            // Create, initialize, and set the value of rop to 0.
            mpz_t rop = new mpz_t();
            gmp_lib.mpz_init(rop);
            
            // Set rop to the modular inverse of op1 mod op2, i.e. b, where op1 * b mod op1 = 1.
            gmp_lib.mpz_invert(rop, op1, op2);
            
            // Assert that rop is 4,
            Assert.IsTrue(gmp_lib.mpz_get_si(rop) == 4);
            
            // Release unmanaged memory allocated for rop, op1, and op2.
            gmp_lib.mpz_clears(rop, op1, op2, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op1 to 3.
            Dim op1 As New mpz_t()
            gmp_lib.mpz_init_set_ui(op1, 3UI)
            
            ' Create, initialize, and set the value of op2 to 11.
            Dim op2 As New mpz_t()
            gmp_lib.mpz_init_set_ui(op2, 11UI)
            
            ' Create, initialize, and set the value of rop to 0.
            Dim rop As New mpz_t()
            gmp_lib.mpz_init(rop)
            
            ' Set rop to the modular inverse of op1 mod op2, i.e. b, where op1 * b mod op1 = 1.
            gmp_lib.mpz_invert(rop, op1, op2)
            
            ' Assert that rop is 4,
            Assert.IsTrue(gmp_lib.mpz_get_si(rop) = 4)
            
            ' Release unmanaged memory allocated for rop, op1, and op2.
            gmp_lib.mpz_clears(rop, op1, op2, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_ior(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> bitwise inclusive-or <paramref name="op2"/>. 
            </summary>
            <param name="rop">The result integer.</param>
            <param name="op1">The first operand integer.</param>
            <param name="op2">The second operand integer.</param>
            <remarks>
            <para>
            The function behaves as if twos complement arithmetic were used (although sign-magnitude is the actual implementation).
            The least significant bit is number 0. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_and(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_and</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_xor(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_xor</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_com(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_com</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_popcount(Math.Gmp.Native.mpz_t)">mpz_popcount</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_hamdist(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_hamdist</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_scan0(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_scan0</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_scan1(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_scan1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_setbit(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_setbit</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_clrbit(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_clrbit</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_combit(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_combit</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tstbit(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_tstbit</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Logic_and_Bit_Fiddling">Integer Logic and Bit Fiddling</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Logic-and-Bit-Fiddling.html#Integer-Logic-and-Bit-Fiddling">GNU MP - Integer Logic and Bit Fiddling</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op1 to 63.
            mpz_t op1 = new mpz_t();
            gmp_lib.mpz_init_set_ui(op1, 63U);
            
            // Create, initialize, and set the value of op2 to 70.
            mpz_t op2 = new mpz_t();
            gmp_lib.mpz_init_set_ui(op2, 70U);
            
            // Create, initialize, and set the value of rop to 0.
            mpz_t rop = new mpz_t();
            gmp_lib.mpz_init(rop);
            
            // Set rop to the bitwise inclusive or of op1 and op2.
            gmp_lib.mpz_ior(rop, op1, op2);
            
            // Assert that rop is 127.
            Assert.IsTrue(gmp_lib.mpz_get_si(rop) == 127);
            
            // Release unmanaged memory allocated for rop, op1, and op2.
            gmp_lib.mpz_clears(rop, op1, op2, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op1 to 63.
            Dim op1 As New mpz_t()
            gmp_lib.mpz_init_set_ui(op1, 63UI)
            
            ' Create, initialize, and set the value of op2 to 70.
            Dim op2 As New mpz_t()
            gmp_lib.mpz_init_set_ui(op2, 70UI)
            
            ' Create, initialize, and set the value of rop to 0.
            Dim rop As New mpz_t()
            gmp_lib.mpz_init(rop)
            
            ' Set rop to the bitwise inclusive or of op1 and op2.
            gmp_lib.mpz_ior(rop, op1, op2)
            
            ' Assert that rop is 127.
            Assert.IsTrue(gmp_lib.mpz_get_si(rop) = 127)
            
            ' Release unmanaged memory allocated for rop, op1, and op2.
            gmp_lib.mpz_clears(rop, op1, op2, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_jacobi(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">
            <summary>
            Calculate the Jacobi symbol (<paramref name="a"/>/<paramref name="b"/>).
            </summary>
            <param name="a">The first operand integer.</param>
            <param name="b">The second operand integer.</param>
            <returns>The Jacobi symbol (<paramref name="a"/>/<paramref name="b"/>).</returns>
            <remarks>
            <para>
            This is defined only for <paramref name="b"/> odd. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_legendre(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_legendre</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Number_Theoretic_Functions">Number Theoretic Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions">GNU MP - Number Theoretic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of a to 11.
            mpz_t a = new mpz_t();
            gmp_lib.mpz_init_set_ui(a, 11U);
            
            // Create, initialize, and set the value of b to 9.
            mpz_t b = new mpz_t();
            gmp_lib.mpz_init_set_ui(b, 9U);
            
            // Assert that the Jacobi symbol of (a/b) is 1.
            Assert.IsTrue(gmp_lib.mpz_jacobi(a, b) == 1);
            
            // Release unmanaged memory allocated for a and b.
            gmp_lib.mpz_clears(a, b, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of a to 11.
            Dim a As New mpz_t()
            gmp_lib.mpz_init_set_ui(a, 11UI)
            
            ' Create, initialize, and set the value of b to 9.
            Dim b As New mpz_t()
            gmp_lib.mpz_init_set_ui(b, 9UI)
            
            ' Assert that the Jacobi symbol of (a/b) is 1.
            Assert.IsTrue(gmp_lib.mpz_jacobi(a, b) = 1)
            
            ' Release unmanaged memory allocated for a and b.
            gmp_lib.mpz_clears(a, b, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_kronecker(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">
            <summary>
            Calculate the Jacobi symbol (<paramref name="a"/>/<paramref name="b"/>) with the Kronecker extension (<paramref name="a"/>/2) = (2/<paramref name="a"/>) when <paramref name="a"/> odd, or (<paramref name="a"/>/2) = 0 when <paramref name="a"/> even. 
            </summary>
            <param name="a">The first operand integer.</param>
            <param name="b">The second operand integer.</param>
            <returns>The Jacobi symbol (<paramref name="a"/>/<paramref name="b"/>) with the Kronecker extension (<paramref name="a"/>/2) = (2/<paramref name="a"/>) when <paramref name="a"/> odd, or (<paramref name="a"/>/2) = 0 when <paramref name="a"/> even.</returns>
            <remarks>
            <para>
            When <paramref name="b"/> is odd the Jacobi symbol and Kronecker symbol are identical, 
            so <see cref="M:Math.Gmp.Native.gmp_lib.mpz_kronecker_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_kronecker_ui</see>, etc. can be used for mixed precision Jacobi symbols too. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_kronecker_si(Math.Gmp.Native.mpz_t,System.Int32)">mpz_kronecker_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_kronecker_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_kronecker_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_legendre(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_legendre</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_si_kronecker(System.Int32,Math.Gmp.Native.mpz_t)">mpz_si_kronecker</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_ui_kronecker(System.UInt32,Math.Gmp.Native.mpz_t)">mpz_ui_kronecker</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Number_Theoretic_Functions">Number Theoretic Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions">GNU MP - Number Theoretic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of a to 15.
            mpz_t a = new mpz_t();
            gmp_lib.mpz_init_set_ui(a, 15U);
            
            // Create, initialize, and set the value of b to 4.
            mpz_t b = new mpz_t();
            gmp_lib.mpz_init_set_ui(b, 4U);
            
            // Assert that the Kronecker symbol of (a/b) is 1.
            Assert.IsTrue(gmp_lib.mpz_kronecker(a, b) == 1);
            
            // Release unmanaged memory allocated for a and b.
            gmp_lib.mpz_clears(a, b, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of a to 15.
            Dim a As New mpz_t()
            gmp_lib.mpz_init_set_ui(a, 15UI)
            
            ' Create, initialize, and set the value of b to 4.
            Dim b As New mpz_t()
            gmp_lib.mpz_init_set_ui(b, 4UI)
            
            ' Assert that the Kronecker symbol of (a/b) is 1.
            Assert.IsTrue(gmp_lib.mpz_kronecker(a, b) = 1)
            
            ' Release unmanaged memory allocated for a and b.
            gmp_lib.mpz_clears(a, b, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_kronecker_si(Math.Gmp.Native.mpz_t,System.Int32)">
            <summary>
            Calculate the Jacobi symbol (<paramref name="a"/>/<paramref name="b"/>) with the Kronecker extension (<paramref name="a"/>/2) = (2/<paramref name="a"/>) when <paramref name="a"/> odd, or (<paramref name="a"/>/2) = 0 when <paramref name="a"/> even. 
            </summary>
            <param name="a">The first operand integer.</param>
            <param name="b">The second operand integer.</param>
            <returns>The Jacobi symbol (<paramref name="a"/>/<paramref name="b"/>) with the Kronecker extension (<paramref name="a"/>/2) = (2/<paramref name="a"/>) when <paramref name="a"/> odd, or (<paramref name="a"/>/2) = 0 when <paramref name="a"/> even.</returns>
            <remarks>
            <para>
            When <paramref name="b"/> is odd the Jacobi symbol and Kronecker symbol are identical, 
            so <see cref="M:Math.Gmp.Native.gmp_lib.mpz_kronecker_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_kronecker_ui</see>, etc. can be used for mixed precision Jacobi symbols too. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_kronecker(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_kronecker</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_kronecker_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_kronecker_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_legendre(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_legendre</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_si_kronecker(System.Int32,Math.Gmp.Native.mpz_t)">mpz_si_kronecker</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_ui_kronecker(System.UInt32,Math.Gmp.Native.mpz_t)">mpz_ui_kronecker</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Number_Theoretic_Functions">Number Theoretic Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions">GNU MP - Number Theoretic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of a to 15.
            mpz_t a = new mpz_t();
            gmp_lib.mpz_init_set_ui(a, 15U);
            
            // Assert that the Kronecker symbol of (a/4) is 1.
            Assert.IsTrue(gmp_lib.mpz_kronecker_si(a, 4) == 1);
            
            // Release unmanaged memory allocated for a.
            gmp_lib.mpz_clear(a);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of a to 15.
            Dim a As New mpz_t()
            gmp_lib.mpz_init_set_ui(a, 15UI)
            
            ' Assert that the Kronecker symbol of (a/4) is 1.
            Assert.IsTrue(gmp_lib.mpz_kronecker_si(a, 4) = 1)
            
            ' Release unmanaged memory allocated for a.
            gmp_lib.mpz_clear(a)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_kronecker_ui(Math.Gmp.Native.mpz_t,System.UInt32)">
            <summary>
            Calculate the Jacobi symbol (<paramref name="a"/>/<paramref name="b"/>) with the Kronecker extension (<paramref name="a"/>/2) = (2/<paramref name="a"/>) when <paramref name="a"/> odd, or (<paramref name="a"/>/2) = 0 when <paramref name="a"/> even. 
            </summary>
            <param name="a">The first operand integer.</param>
            <param name="b">The second operand integer.</param>
            <returns>The Jacobi symbol (<paramref name="a"/>/<paramref name="b"/>) with the Kronecker extension (<paramref name="a"/>/2) = (2/<paramref name="a"/>) when <paramref name="a"/> odd, or (<paramref name="a"/>/2) = 0 when <paramref name="a"/> even.</returns>
            <remarks>
            <para>
            When <paramref name="b"/> is odd the Jacobi symbol and Kronecker symbol are identical, 
            so <see cref="M:Math.Gmp.Native.gmp_lib.mpz_kronecker_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_kronecker_ui</see>, etc. can be used for mixed precision Jacobi symbols too. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_kronecker(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_kronecker</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_kronecker_si(Math.Gmp.Native.mpz_t,System.Int32)">mpz_kronecker_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_legendre(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_legendre</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_si_kronecker(System.Int32,Math.Gmp.Native.mpz_t)">mpz_si_kronecker</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_ui_kronecker(System.UInt32,Math.Gmp.Native.mpz_t)">mpz_ui_kronecker</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Number_Theoretic_Functions">Number Theoretic Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions">GNU MP - Number Theoretic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of a to 15.
            mpz_t a = new mpz_t();
            gmp_lib.mpz_init_set_ui(a, 15U);
            
            // Assert that the Kronecker symbol of (a/4) is 1.
            Assert.IsTrue(gmp_lib.mpz_kronecker_ui(a, 4U) == 1);
            
            // Release unmanaged memory allocated for a.
            gmp_lib.mpz_clear(a);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of a to 15.
            Dim a As New mpz_t()
            gmp_lib.mpz_init_set_ui(a, 15UI)
            
            ' Assert that the Kronecker symbol of (a/4) is 1.
            Assert.IsTrue(gmp_lib.mpz_kronecker_ui(a, 4UI) = 1)
            
            ' Release unmanaged memory allocated for a.
            gmp_lib.mpz_clear(a)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_si_kronecker(System.Int32,Math.Gmp.Native.mpz_t)">
            <summary>
            Calculate the Jacobi symbol (<paramref name="a"/>/<paramref name="b"/>) with the Kronecker extension (<paramref name="a"/>/2) = (2/<paramref name="a"/>) when <paramref name="a"/> odd, or (<paramref name="a"/>/2) = 0 when <paramref name="a"/> even. 
            </summary>
            <param name="a">The first operand integer.</param>
            <param name="b">The second operand integer.</param>
            <returns>The Jacobi symbol (<paramref name="a"/>/<paramref name="b"/>) with the Kronecker extension (<paramref name="a"/>/2) = (2/<paramref name="a"/>) when <paramref name="a"/> odd, or (<paramref name="a"/>/2) = 0 when <paramref name="a"/> even.</returns>
            <remarks>
            <para>
            When <paramref name="b"/> is odd the Jacobi symbol and Kronecker symbol are identical, 
            so <see cref="M:Math.Gmp.Native.gmp_lib.mpz_kronecker_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_kronecker_ui</see>, etc. can be used for mixed precision Jacobi symbols too. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_kronecker(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_kronecker</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_kronecker_si(Math.Gmp.Native.mpz_t,System.Int32)">mpz_kronecker_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_kronecker_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_kronecker_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_legendre(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_legendre</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_ui_kronecker(System.UInt32,Math.Gmp.Native.mpz_t)">mpz_ui_kronecker</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Number_Theoretic_Functions">Number Theoretic Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions">GNU MP - Number Theoretic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of b to 4.
            mpz_t b = new mpz_t();
            gmp_lib.mpz_init_set_ui(b, 4U);
            
            // Assert that the Kronecker symbol of (15/b) is 1.
            Assert.IsTrue(gmp_lib.mpz_si_kronecker(15, b) == 1);
            
            // Release unmanaged memory allocated for b.
            gmp_lib.mpz_clear(b);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of b to 4.
            Dim b As New mpz_t()
            gmp_lib.mpz_init_set_ui(b, 4UI)
            
            ' Assert that the Kronecker symbol of (15/b) is 1.
            Assert.IsTrue(gmp_lib.mpz_si_kronecker(15, b) = 1)
            
            ' Release unmanaged memory allocated for b.
            gmp_lib.mpz_clear(b)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_ui_kronecker(System.UInt32,Math.Gmp.Native.mpz_t)">
            <summary>
            Calculate the Jacobi symbol (<paramref name="a"/>/<paramref name="b"/>) with the Kronecker extension (<paramref name="a"/>/2) = (2/<paramref name="a"/>) when <paramref name="a"/> odd, or (<paramref name="a"/>/2) = 0 when <paramref name="a"/> even. 
            </summary>
            <param name="a">The first operand integer.</param>
            <param name="b">The second operand integer.</param>
            <returns>The Jacobi symbol (<paramref name="a"/>/<paramref name="b"/>) with the Kronecker extension (<paramref name="a"/>/2) = (2/<paramref name="a"/>) when <paramref name="a"/> odd, or (<paramref name="a"/>/2) = 0 when <paramref name="a"/> even.</returns>
            <remarks>
            <para>
            When <paramref name="b"/> is odd the Jacobi symbol and Kronecker symbol are identical, 
            so <see cref="M:Math.Gmp.Native.gmp_lib.mpz_kronecker_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_kronecker_ui</see>, etc. can be used for mixed precision Jacobi symbols too. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_kronecker(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_kronecker</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_kronecker_si(Math.Gmp.Native.mpz_t,System.Int32)">mpz_kronecker_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_kronecker_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_kronecker_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_legendre(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_legendre</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_si_kronecker(System.Int32,Math.Gmp.Native.mpz_t)">mpz_si_kronecker</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Number_Theoretic_Functions">Number Theoretic Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions">GNU MP - Number Theoretic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of b to 4.
            mpz_t b = new mpz_t();
            gmp_lib.mpz_init_set_ui(b, 4U);
            
            // Assert that the Kronecker symbol of (15/b) is 1.
            Assert.IsTrue(gmp_lib.mpz_ui_kronecker(15U, b) == 1);
            
            // Release unmanaged memory allocated for b.
            gmp_lib.mpz_clear(b);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of b to 4.
            Dim b As New mpz_t()
            gmp_lib.mpz_init_set_ui(b, 4UI)
            
            ' Assert that the Kronecker symbol of (15/b) is 1.
            Assert.IsTrue(gmp_lib.mpz_ui_kronecker(15UI, b) = 1)
            
            ' Release unmanaged memory allocated for b.
            gmp_lib.mpz_clear(b)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_lcm(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">
            <summary>
            Set <paramref name="rop"/> to the least common multiple of <paramref name="op1"/> and <paramref name="op2"/>.
            </summary>
            <param name="rop">The result integer.</param>
            <param name="op1">The first operand integer.</param>
            <param name="op2">The second operand integer.</param>
            <remarks>
            <para>
            <paramref name="rop"/> is always positive, irrespective of the signs of <paramref name="op1"/> and <paramref name="op2"/>.
            <paramref name="rop"/> will be zero if either <paramref name="op1"/> or <paramref name="op2"/> is zero. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_lcm_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_lcm_ui</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Number_Theoretic_Functions">Number Theoretic Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions">GNU MP - Number Theoretic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op1 to 2.
            mpz_t op1 = new mpz_t();
            gmp_lib.mpz_init_set_ui(op1, 2U);
            
            // Create, initialize, and set the value of op2 to 3.
            mpz_t op2 = new mpz_t();
            gmp_lib.mpz_init_set_ui(op2, 3U);
            
            // Create, initialize, and set the value of rop to 0.
            mpz_t rop = new mpz_t();
            gmp_lib.mpz_init(rop);
            
            // Set rop to the least common multiple of op1 and op2.
            gmp_lib.mpz_lcm(rop, op1, op2);
            
            // Assert that rop is 6.
            Assert.IsTrue(gmp_lib.mpz_get_si(rop) == 6);
            
            // Release unmanaged memory allocated for rop, op1, and op2.
            gmp_lib.mpz_clears(rop, op1, op2, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op1 to 2.
            Dim op1 As New mpz_t()
            gmp_lib.mpz_init_set_ui(op1, 2UI)
            
            ' Create, initialize, and set the value of op2 to 3.
            Dim op2 As New mpz_t()
            gmp_lib.mpz_init_set_ui(op2, 3UI)
            
            ' Create, initialize, and set the value of rop to 0.
            Dim rop As New mpz_t()
            gmp_lib.mpz_init(rop)
            
            ' Set rop to the least common multiple of op1 and op2.
            gmp_lib.mpz_lcm(rop, op1, op2)
            
            ' Assert that rop is 6.
            Assert.IsTrue(gmp_lib.mpz_get_si(rop) = 6)
            
            ' Release unmanaged memory allocated for rop, op1, and op2.
            gmp_lib.mpz_clears(rop, op1, op2, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_lcm_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">
            <summary>
            Set <paramref name="rop"/> to the least common multiple of <paramref name="op1"/> and <paramref name="op2"/>.
            </summary>
            <param name="rop">The result integer.</param>
            <param name="op1">The first operand integer.</param>
            <param name="op2">The second operand integer.</param>
            <remarks>
            <para>
            <paramref name="rop"/> is always positive, irrespective of the signs of <paramref name="op1"/> and <paramref name="op2"/>.
            <paramref name="rop"/> will be zero if either <paramref name="op1"/> or <paramref name="op2"/> is zero. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_lcm(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_lcm</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Number_Theoretic_Functions">Number Theoretic Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions">GNU MP - Number Theoretic Functions</a></seealso>
            <example>
            <code language="C#">
            </code> 
            <code language="VB.NET">
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_legendre(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">
            <summary>
            Calculate the Legendre symbol (<paramref name="a"/>/<paramref name="p"/>).
            </summary>
            <param name="a">The first operand integer.</param>
            <param name="p">The second operand integer.</param>
            <returns>The Legendre symbol (<paramref name="a"/>/<paramref name="p"/>).</returns>
            <remarks>
            <para>
            This is defined only for <paramref name="p"/> an odd positive prime,
            and for such <paramref name="p"/> it’s identical to the Jacobi symbol. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_jacobi(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_jacobi</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Number_Theoretic_Functions">Number Theoretic Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions">GNU MP - Number Theoretic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of a to 20.
            mpz_t a = new mpz_t();
            gmp_lib.mpz_init_set_ui(a, 20U);
            
            // Create, initialize, and set the value of p to 11.
            mpz_t p = new mpz_t();
            gmp_lib.mpz_init_set_ui(p, 11U);
            
            // Assert that the Legendre symbol of (a/p) is 1.
            Assert.IsTrue(gmp_lib.mpz_legendre(a, p) == 1);
            
            // Release unmanaged memory allocated for a and p.
            gmp_lib.mpz_clears(a, p, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of a to 20.
            Dim a As New mpz_t()
            gmp_lib.mpz_init_set_ui(a, 20UI)
            
            ' Create, initialize, and set the value of p to 11.
            Dim p As New mpz_t()
            gmp_lib.mpz_init_set_ui(p, 11UI)
            
            ' Assert that the Legendre symbol of (a/p) is 1.
            Assert.IsTrue(gmp_lib.mpz_legendre(a, p) = 1)
            
            ' Release unmanaged memory allocated for a and p.
            gmp_lib.mpz_clears(a, p, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_lucnum_ui(Math.Gmp.Native.mpz_t,System.UInt32)">
            <summary>
            Sets <paramref name="ln"/> to to L[<paramref name="n"/>], the <paramref name="n"/>’th Lucas number. 
            </summary>
            <param name="ln">The L[<paramref name="n"/>] result.</param>
            <param name="n">The operand integer.</param>
            <remarks>
            <para>
            The Fibonacci numbers and Lucas numbers are related sequences, so it’s never necessary to call both
            <see cref="M:Math.Gmp.Native.gmp_lib.mpz_fib2_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_fib2_ui</see> and <see cref="M:Math.Gmp.Native.gmp_lib.mpz_lucnum2_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_lucnum2_ui</see>. 
            The formulas for going from Fibonacci to Lucas can be found in
            <a href="https://gmplib.org/manual/Lucas-Numbers-Algorithm.html#Lucas-Numbers-Algorithm">GNU MP - Lucas Numbers Algorithm</a>,
            the reverse is straightforward too.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_lucnum2_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_lucnum2_ui</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Number_Theoretic_Functions">Number Theoretic Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions">GNU MP - Number Theoretic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of ln to 0.
            mpz_t ln = new mpz_t();
            gmp_lib.mpz_init(ln);
            
            // Set ln to the 9'th Lucas number.
            gmp_lib.mpz_lucnum_ui(ln, 9U);
            
            // Assert that ln is 76.
            Assert.IsTrue(gmp_lib.mpz_get_si(ln) == 76);
            
            // Release unmanaged memory allocated for ln.
            gmp_lib.mpz_clear(ln);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of ln to 0.
            Dim ln As New mpz_t()
            gmp_lib.mpz_init(ln)
            
            ' Set ln to the 9'th Lucas number.
            gmp_lib.mpz_lucnum_ui(ln, 9UI)
            
            ' Assert that ln is 76.
            Assert.IsTrue(gmp_lib.mpz_get_si(ln) = 76)
            
            ' Release unmanaged memory allocated for ln.
            gmp_lib.mpz_clear(ln)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_lucnum2_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">
            <summary>
            Sets <paramref name="ln"/> to L[<paramref name="n"/>], and <paramref name="lnsub1"/> to L[<paramref name="n"/> - 1]. 
            </summary>
            <param name="ln">The L[<paramref name="n"/>] result.</param>
            <param name="lnsub1">The L[<paramref name="n"/> - 1] result.</param>
            <param name="n">The operand integer.</param>
            <remarks>
            <para>
            This function is designed for calculating isolated Lucas numbers. 
            When a sequence of values is wanted it’s best to start with <see cref="M:Math.Gmp.Native.gmp_lib.mpz_lucnum2_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_lucnum2_ui</see> 
            and iterate the defining L[n + 1] = L[n] + L[n - 1] or similar.
            </para>
            <para>
            The Fibonacci numbers and Lucas numbers are related sequences, so it’s never necessary to call both
            <see cref="M:Math.Gmp.Native.gmp_lib.mpz_fib2_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_fib2_ui</see> and <see cref="M:Math.Gmp.Native.gmp_lib.mpz_lucnum2_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_lucnum2_ui</see>. 
            The formulas for going from Fibonacci to Lucas can be found in
            <a href="https://gmplib.org/manual/Lucas-Numbers-Algorithm.html#Lucas-Numbers-Algorithm">GNU MP - Lucas Numbers Algorithm</a>,
            the reverse is straightforward too.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_lucnum_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_lucnum_ui</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Number_Theoretic_Functions">Number Theoretic Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions">GNU MP - Number Theoretic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the values of lnsub1 and ln to 0.
            mpz_t ln = new mpz_t();
            mpz_t lnsub1 = new mpz_t();
            gmp_lib.mpz_inits(ln, lnsub1, null);
            
            // Set lnsub1 and ln to the 8'th and 9'th Lucas nunbers respectively.
            gmp_lib.mpz_lucnum2_ui(ln, lnsub1, 9U);
            
            // Assert that lnsub1 and ln are respectively 47 and 76.
            Assert.IsTrue(gmp_lib.mpz_get_si(lnsub1) == 47);
            Assert.IsTrue(gmp_lib.mpz_get_si(ln) == 76);
            
            // Release unmanaged memory allocated for ln and lnsub1.
            gmp_lib.mpz_clears(ln, lnsub1, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the values of lnsub1 and ln to 0.
            Dim ln As New mpz_t()
            Dim lnsub1 As New mpz_t()
            gmp_lib.mpz_inits(ln, lnsub1, Nothing)
            
            ' Set lnsub1 and ln to the 8'th and 9'th Lucas nunbers respectively.
            gmp_lib.mpz_lucnum2_ui(ln, lnsub1, 9UI)
            
            ' Assert that lnsub1 and ln are respectively 47 and 76.
            Assert.IsTrue(gmp_lib.mpz_get_si(lnsub1) = 47)
            Assert.IsTrue(gmp_lib.mpz_get_si(ln) = 76)
            
            ' Release unmanaged memory allocated for ln and lnsub1.
            gmp_lib.mpz_clears(ln, lnsub1, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_millerrabin(Math.Gmp.Native.mpz_t,System.Int32)">
            <summary>
            An implementation of the probabilistic primality test found in Knuth's Seminumerical Algorithms book.
            </summary>
            <param name="n">The operand integer.</param>
            <param name="reps">The number of internal passes of the probabilistic algorithm.</param>
            <returns>If the function <see cref="M:Math.Gmp.Native.gmp_lib.mpz_millerrabin(Math.Gmp.Native.mpz_t,System.Int32)">mpz_millerrabin</see> returns 0 then <paramref name="n"/> is not prime. If it returns 1, then <paramref name="n"/> is 'probably' prime.</returns>
            <remarks>
            <para>
            The probability of a false positive is (1/4)^<paramref name="reps"/>, where <paramref name="reps"/>
            is the number of internal passes of the probabilistic algorithm.
            Knuth indicates that 25 passes are reasonable.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_probab_prime_p(Math.Gmp.Native.mpz_t,System.Int32)">mpz_probab_prime_p</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Number_Theoretic_Functions">Number Theoretic Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions">GNU MP - Number Theoretic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of n to 12.
            mpz_t n = new mpz_t();
            gmp_lib.mpz_init_set_ui(n, 12U);
            
            // Assert that n is a composite number.
            Assert.IsTrue(gmp_lib.mpz_millerrabin(n, 25) == 0);
            
            // Release unmanaged memory allocated for n.
            gmp_lib.mpz_clear(n);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of n to 12.
            Dim n As New mpz_t()
            gmp_lib.mpz_init_set_ui(n, 12UI)
            
            ' Assert that n is a composite number.
            Assert.IsTrue(gmp_lib.mpz_millerrabin(n, 25) = 0)
            
            ' Release unmanaged memory allocated for n.
            gmp_lib.mpz_clear(n)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_mod(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">
            <summary>
            Set <paramref name="r"/> to <paramref name="n"/> mod <paramref name="d"/>.
            </summary>
            <param name="r">The result remainder integer.</param>
            <param name="n">The numerator integer.</param>
            <param name="d">The denominator integer.</param>
            <remarks>
            <para>
            The sign of the divisor is ignored; the result is always non-negative.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_congruent_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_congruent_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divexact(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divexact</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divisible_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divisible_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_fdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mod_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_mod_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_qr</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Division">Integer Division</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Division.html#Integer-Division">GNU MP - Integer Division</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of x to 12222.
            mpz_t x = new mpz_t();
            gmp_lib.mpz_init_set_ui(x, 12222U);
            
            // Create, initialize, and set the value of y to 10000.
            mpz_t y = new mpz_t();
            gmp_lib.mpz_init_set_ui(y, 10000U);
            
            // Create, initialize, and set the value of z to 0.
            mpz_t z = new mpz_t();
            gmp_lib.mpz_init(z);
            
            // Set z = x mod y.
            gmp_lib.mpz_mod(z, x, y);
            
            // Assert that z is 12222 mod 10000.
            Assert.IsTrue(gmp_lib.mpz_get_si(z) == 12222 % 10000);
            
            // Release unmanaged memory allocated for x, y, and z.
            gmp_lib.mpz_clears(x, y, z, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of x to 12222.
            Dim x As New mpz_t()
            gmp_lib.mpz_init_set_ui(x, 12222UI)
            
            ' Create, initialize, and set the value of y to 10000.
            Dim y As New mpz_t()
            gmp_lib.mpz_init_set_ui(y, 10000UI)
            
            ' Create, initialize, and set the value of z to 0.
            Dim z As New mpz_t()
            gmp_lib.mpz_init(z)
            
            ' Set z = x mod y.
            gmp_lib.mpz_mod(z, x, y)
            
            ' Assert that z is 12222 mod 10000.
            Assert.IsTrue(gmp_lib.mpz_get_si(z) = 12222 Mod 10000)
            
            ' Release unmanaged memory allocated for x, y, and z.
            gmp_lib.mpz_clears(x, y, z, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_mod_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">
            <summary>
            Set <paramref name="r"/> to <paramref name="n"/> mod <paramref name="d"/>.
            </summary>
            <param name="r">The result remainder integer.</param>
            <param name="n">The numerator integer.</param>
            <param name="d">The denominator integer.</param>
            <returns>The remainder <paramref name="r"/>.</returns>
            <remarks>
            <para>
            The sign of the divisor is ignored; the result is always non-negative.
            </para>
            <para>
            <see cref="M:Math.Gmp.Native.gmp_lib.mpz_mod_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_mod_ui</see> is identical to <see cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_r_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_fdiv_r_ui</see>, returning the remainder as well as setting <paramref name="r"/>.
            See <see cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_fdiv_ui</see> if only the return value is wanted. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_congruent_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_congruent_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divexact(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divexact</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divisible_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divisible_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_fdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mod(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_mod</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_qr</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Division">Integer Division</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Division.html#Integer-Division">GNU MP - Integer Division</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of x to 12222.
            mpz_t x = new mpz_t();
            gmp_lib.mpz_init_set_ui(x, 12222U);
            
            // Create, initialize, and set the value of z to 0.
            mpz_t z = new mpz_t();
            gmp_lib.mpz_init(z);
            
            // Set z = x mod y, and return z.
            Assert.IsTrue(gmp_lib.mpz_mod_ui(z, x, 10000U) == 12222 % 10000);
            
            // Assert that z is 12222 mod 10000.
            Assert.IsTrue(gmp_lib.mpz_get_si(z) == 12222 % 10000);
            
            // Release unmanaged memory allocated for x and z.
            gmp_lib.mpz_clears(x, z, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of x to 12222.
            Dim x As New mpz_t()
            gmp_lib.mpz_init_set_ui(x, 12222UI)
            
            ' Create, initialize, and set the value of z to 0.
            Dim z As New mpz_t()
            gmp_lib.mpz_init(z)
            
            ' Set z = x mod y, and return z.
            Assert.IsTrue(gmp_lib.mpz_mod_ui(z, x, 10000UI) = 12222 Mod 10000)
            
            ' Assert that z is 12222 mod 10000.
            Assert.IsTrue(gmp_lib.mpz_get_si(z) = 12222 Mod 10000)
            
            ' Release unmanaged memory allocated for x and z.
            gmp_lib.mpz_clears(x, z, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_mul(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> * <paramref name="op2"/>.
            </summary>
            <param name="rop">The result integer.</param>
            <param name="op1">The first operand integer.</param>
            <param name="op2">The second operand integer.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_abs(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_abs</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_add(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_addmul(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_addmul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mul_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_mul_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mul_si(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.Int32)">mpz_mul_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mul_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_mul_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_neg(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_sub(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_submul(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_submul</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Arithmetic">Integer Arithmetic</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Arithmetic.html#Integer-Arithmetic">GNU MP - Integer Arithmetic</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of x to 10000.
            mpz_t x = new mpz_t();
            gmp_lib.mpz_init_set_ui(x, 10000U);
            
            // Create, initialize, and set the value of y to 12222.
            mpz_t y = new mpz_t();
            gmp_lib.mpz_init_set_ui(y, 12222U);
            
            // Create, initialize, and set the value of z to 0.
            mpz_t z = new mpz_t();
            gmp_lib.mpz_init(z);
            
            // Set z = x * y.
            gmp_lib.mpz_mul(z, x, y);
            
            // Assert that z is the product of x and y.
            Assert.IsTrue(gmp_lib.mpz_get_si(z) == 10000 * 12222);
            
            // Release unmanaged memory allocated for x, y, and z.
            gmp_lib.mpz_clears(x, y, z, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of x to 10000.
            Dim x As New mpz_t()
            gmp_lib.mpz_init_set_ui(x, 10000UI)
            
            ' Create, initialize, and set the value of y to 12222.
            Dim y As New mpz_t()
            gmp_lib.mpz_init_set_ui(y, 12222UI)
            
            ' Create, initialize, and set the value of z to 0.
            Dim z As New mpz_t()
            gmp_lib.mpz_init(z)
            
            ' Set z = x * y.
            gmp_lib.mpz_mul(z, x, y)
            
            ' Assert that z is the product of x and y.
            Assert.IsTrue(gmp_lib.mpz_get_si(z) = 10000 * 12222)
            
            ' Release unmanaged memory allocated for x, y, and z.
            gmp_lib.mpz_clears(x, y, z, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_mul_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> * 2^<paramref name="op2"/>.
            </summary>
            <param name="rop">The result integer.</param>
            <param name="op1">The first operand integer.</param>
            <param name="op2">The second operand integer.</param>
            <remarks>
            <para>
            This operation can also be defined as a left shift by <paramref name="op2"/> bits.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_abs(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_abs</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_add(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_addmul(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_addmul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mul(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mul_si(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.Int32)">mpz_mul_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mul_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_mul_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_neg(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_sub(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_submul(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_submul</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Arithmetic">Integer Arithmetic</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Arithmetic.html#Integer-Arithmetic">GNU MP - Integer Arithmetic</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of x to -10000.
            mpz_t x = new mpz_t();
            gmp_lib.mpz_init_set_si(x, -10000);
            
            // Create, initialize, and set the value of x to 0.
            mpz_t z = new mpz_t();
            gmp_lib.mpz_init(z);
            
            // Set z = -10000 * 2^2.
            gmp_lib.mpz_mul_2exp(z, x, 2U);
            
            // Assert that z is -40000.
            Assert.IsTrue(gmp_lib.mpz_get_si(z) == -10000 * 4);
            
            // Release unmanaged memory allocated for x and z.
            gmp_lib.mpz_clears(x, z, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of x to -10000.
            Dim x As New mpz_t()
            gmp_lib.mpz_init_set_si(x, -10000)
            
            ' Create, initialize, and set the value of x to 0.
            Dim z As New mpz_t()
            gmp_lib.mpz_init(z)
            
            ' Set z = -10000 * 2^2.
            gmp_lib.mpz_mul_2exp(z, x, 2UI)
            
            ' Assert that z is -40000.
            Assert.IsTrue(gmp_lib.mpz_get_si(z) = -10000 * 4)
            
            ' Release unmanaged memory allocated for x and z.
            gmp_lib.mpz_clears(x, z, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_mul_si(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.Int32)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> * <paramref name="op2"/>.
            </summary>
            <param name="rop">The result integer.</param>
            <param name="op1">The first operand integer.</param>
            <param name="op2">The second operand integer.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_abs(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_abs</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_add(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_addmul(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_addmul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mul(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mul_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_mul_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mul_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_mul_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_neg(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_sub(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_submul(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_submul</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Arithmetic">Integer Arithmetic</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Arithmetic.html#Integer-Arithmetic">GNU MP - Integer Arithmetic</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of x to -10000.
            mpz_t x = new mpz_t();
            gmp_lib.mpz_init_set_si(x, -10000);
            
            // Create, initialize, and set the value of z to 0.
            mpz_t z = new mpz_t();
            gmp_lib.mpz_init(z);
            
            // Set z = x * 12222.
            gmp_lib.mpz_mul_si(z, x, 12222);
            
            // Assert that z is the product of x and 12222.
            Assert.IsTrue(gmp_lib.mpz_get_si(z) == -10000 * 12222);
            
            // Release unmanaged memory allocated for x and z.
            gmp_lib.mpz_clears(x, z, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of x to -10000.
            Dim x As New mpz_t()
            gmp_lib.mpz_init_set_si(x, -10000)
            
            ' Create, initialize, and set the value of z to 0.
            Dim z As New mpz_t()
            gmp_lib.mpz_init(z)
            
            ' Set z = x * 12222.
            gmp_lib.mpz_mul_si(z, x, 12222)
            
            ' Assert that z is the product of x and 12222.
            Assert.IsTrue(gmp_lib.mpz_get_si(z) = -10000 * 12222)
            
            ' Release unmanaged memory allocated for x and z.
            gmp_lib.mpz_clears(x, z, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_mul_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> * <paramref name="op2"/>.
            </summary>
            <param name="rop">The result integer.</param>
            <param name="op1">The first operand integer.</param>
            <param name="op2">The second operand integer.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_abs(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_abs</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_add(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_addmul(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_addmul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mul(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mul_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_mul_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mul_si(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.Int32)">mpz_mul_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_neg(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_sub(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_submul(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_submul</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Arithmetic">Integer Arithmetic</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Arithmetic.html#Integer-Arithmetic">GNU MP - Integer Arithmetic</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of x to -10000.
            mpz_t x = new mpz_t();
            gmp_lib.mpz_init_set_si(x, -10000);
            
            // Create, initialize, and set the value of z to 0.
            mpz_t z = new mpz_t();
            gmp_lib.mpz_init(z);
            
            // Set z = x * 12222.
            gmp_lib.mpz_mul_ui(z, x, 12222);
            
            // Assert that z is the product of x and 12222.
            Assert.IsTrue(gmp_lib.mpz_get_si(z) == -10000 * 12222);
            
            // Release unmanaged memory allocated for x and z.
            gmp_lib.mpz_clears(x, z, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of x to -10000.
            Dim x As New mpz_t()
            gmp_lib.mpz_init_set_si(x, -10000)
            
            ' Create, initialize, and set the value of z to 0.
            Dim z As New mpz_t()
            gmp_lib.mpz_init(z)
            
            ' Set z = x * 12222.
            gmp_lib.mpz_mul_ui(z, x, 12222)
            
            ' Assert that z is the product of x and 12222.
            Assert.IsTrue(gmp_lib.mpz_get_si(z) = -10000 * 12222)
            
            ' Release unmanaged memory allocated for x and z.
            gmp_lib.mpz_clears(x, z, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_neg(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">
            <summary>
            Set <paramref name="rop"/> to -<paramref name="op"/>.
            </summary>
            <param name="rop">The result integer.</param>
            <param name="op">The operand integer.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_abs(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_abs</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_add(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_addmul(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_addmul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mul(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_neg(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_sub(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_submul(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_submul</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Arithmetic">Integer Arithmetic</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Arithmetic.html#Integer-Arithmetic">GNU MP - Integer Arithmetic</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of x to -10000.
            mpz_t x = new mpz_t();
            gmp_lib.mpz_init_set_si(x, -10000);
            
            // Create, initialize, and set the value of z to 0.
            mpz_t z = new mpz_t();
            gmp_lib.mpz_init(z);
            
            // Set z = -x.
            gmp_lib.mpz_neg(z, x);
            
            // Assert that z is -x.
            Assert.IsTrue(gmp_lib.mpz_get_si(z) == 10000);
            
            // Release unmanaged memory allocated for x and z.
            gmp_lib.mpz_clears(x, z, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of x to -10000.
            Dim x As New mpz_t()
            gmp_lib.mpz_init_set_si(x, -10000)
            
            ' Create, initialize, and set the value of z to 0.
            Dim z As New mpz_t()
            gmp_lib.mpz_init(z)
            
            ' Set z = -x.
            gmp_lib.mpz_neg(z, x)
            
            ' Assert that z is -x.
            Assert.IsTrue(gmp_lib.mpz_get_si(z) = 10000)
            
            ' Release unmanaged memory allocated for x and z.
            gmp_lib.mpz_clears(x, z, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_nextprime(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">
            <summary>
            Set <paramref name="rop"/> to the next prime greater than <paramref name="op"/>.
            </summary>
            <param name="rop">The result prime integer.</param>
            <param name="op">The operand integer.</param>
            <remarks>
            <para>
            This function uses a probabilistic algorithm to identify primes.
            For practical purposes it’s adequate, the chance of a composite passing will be extremely small.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_probab_prime_p(Math.Gmp.Native.mpz_t,System.Int32)">mpz_probab_prime_p</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Number_Theoretic_Functions">Number Theoretic Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions">GNU MP - Number Theoretic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of n to 12.
            mpz_t op = new mpz_t();
            gmp_lib.mpz_init_set_ui(op, 12U);
            
            // Create, initialize, and set the value of rop to 0.
            mpz_t rop = new mpz_t();
            gmp_lib.mpz_init(rop);
            
            // Set rop to the next following op.
            gmp_lib.mpz_nextprime(rop, op);
            
            // Assert that rop is 13.
            Assert.IsTrue(gmp_lib.mpz_get_si(rop) == 13);
            
            // Release unmanaged memory allocated for rop and op.
            gmp_lib.mpz_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of n to 12.
            Dim op As New mpz_t()
            gmp_lib.mpz_init_set_ui(op, 12UI)
            
            ' Create, initialize, and set the value of rop to 0.
            Dim rop As New mpz_t()
            gmp_lib.mpz_init(rop)
            
            ' Set rop to the next following op.
            gmp_lib.mpz_nextprime(rop, op)
            
            ' Assert that rop is 13.
            Assert.IsTrue(gmp_lib.mpz_get_si(rop) = 13)
            
            ' Release unmanaged memory allocated for rop and op.
            gmp_lib.mpz_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_odd_p(Math.Gmp.Native.mpz_t)">
            <summary>
            Determine whether <paramref name="op"/> is odd.
            </summary>
            <param name="op">The operand integer.</param>
            <returns>Return non-zero if odd, zero if even.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_ulong_p(Math.Gmp.Native.mpz_t)">mpz_fits_ulong_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_slong_p(Math.Gmp.Native.mpz_t)">mpz_fits_slong_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_uint_p(Math.Gmp.Native.mpz_t)">mpz_fits_uint_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_sint_p(Math.Gmp.Native.mpz_t)">mpz_fits_sint_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_ushort_p(Math.Gmp.Native.mpz_t)">mpz_fits_ushort_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_sshort_p(Math.Gmp.Native.mpz_t)">mpz_fits_sshort_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_even_p(Math.Gmp.Native.mpz_t)">mpz_even_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_sizeinbase(Math.Gmp.Native.mpz_t,System.Int32)">mpz_sizeinbase</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Miscellaneous_Integer_Functions">Miscellaneous Integer Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Miscellaneous-Integer-Functions.html#Miscellaneous-Integer-Functions">GNU MP - Miscellaneous Integer Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op to 427294.
            mpz_t op = new mpz_t();
            gmp_lib.mpz_init_set_ui(op, 427294);
            
            // Assert that op is not odd but even.
            Assert.IsTrue(gmp_lib.mpz_even_p(op) > 0);
            Assert.IsTrue(gmp_lib.mpz_odd_p(op) == 0);
            
            // Release unmanaged memory allocated for op.
            gmp_lib.mpz_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op to 427294.
            Dim op As New mpz_t()
            gmp_lib.mpz_init_set_ui(op, 427294)
            
            ' Assert that op is not odd but even.
            Assert.IsTrue(gmp_lib.mpz_even_p(op) > 0)
            Assert.IsTrue(gmp_lib.mpz_odd_p(op) = 0)
            
            ' Release unmanaged memory allocated for op.
            gmp_lib.mpz_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_out_raw(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},Math.Gmp.Native.mpz_t)">
            <summary>
            Output <paramref name="op"/> on stdio stream <paramref name="stream"/>, in raw binary format.
            </summary>
            <param name="stream">Pointer to file streama.</param>
            <param name="op">The operand integer.</param>
            <returns>Return the number of bytes written, or if an error occurred, return 0.</returns>
            <remarks>
            <para>
            The integer is written in a portable format, with 4 bytes of size information, and that many bytes of limbs.
            Both the size and the limbs are written in decreasing significance order (i.e., in big-endian).
            </para>
            <para>
            The output can be read with <see cref="M:Math.Gmp.Native.gmp_lib.mpz_inp_raw(Math.Gmp.Native.mpz_t,Math.Gmp.Native.ptr{Math.Gmp.Native.FILE})">mpz_inp_raw</see>. 
            </para>
            <para>
            The output of this can not be read by <c>mpz_inp_raw</c> from GMP 1,
            because of changes necessary for compatibility between 32-bit and 64-bit machines. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_out_str(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.Int32,Math.Gmp.Native.mpz_t)">mpz_out_str</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_inp_str(Math.Gmp.Native.mpz_t,Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.Int32)">mpz_inp_str</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_inp_raw(Math.Gmp.Native.mpz_t,Math.Gmp.Native.ptr{Math.Gmp.Native.FILE})">mpz_inp_raw</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#IO_of_Integers">I/O of Integers</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/I_002fO-of-Integers.html#I_002fO-of-Integers">GNU MP - I/O of Integers</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op to 123456 (0x1E240).
            mpz_t op = new mpz_t();
            gmp_lib.mpz_init_set_ui(op, 0x1E240);
            
            // Get a temporary file.
            string pathname = System.IO.Path.GetTempFileName();
            
            // Open temporary file for writing.
            ptr&lt;FILE&gt; stream = new ptr&lt;FILE&gt;();
            _wfopen_s(out stream.Value.Value, pathname, "w");
            
            // Write op to temporary file, and assert that the number of bytes written is 7.
            Assert.IsTrue(gmp_lib.mpz_out_raw(stream, op) == 7);
            
            // Close temporary file.
            fclose(stream.Value.Value);
            
            // Assert that the content of the temporary file.
            byte[] r = System.IO.File.ReadAllBytes(pathname);
            Assert.IsTrue(r[0] == 0 &amp;&amp; r[1] == 0 &amp;&amp; r[2] == 0 &amp;&amp; r[3] == 3 &amp;&amp; r[4] == 0x01 &amp;&amp; r[5] == 0xE2 &amp;&amp; r[6] == 0x40);
            
            // Delete temporary file.
            System.IO.File.Delete(pathname);
            
            // Release unmanaged memory allocated for op.
            gmp_lib.mpz_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op to 123456 (0x1E240).
            Dim op As New mpz_t()
            gmp_lib.mpz_init_set_ui(op, &amp;H1e240)
            
            ' Get a temporary file.
            Dim pathname As String = System.IO.Path.GetTempFileName()
            
            ' Open temporary file for writing.
            Dim stream As New ptr(Of FILE)()
            _wfopen_s(stream.Value.Value, pathname, "w")
            
            ' Write op to temporary file, and assert that the number of bytes written is 7.
            Assert.IsTrue(gmp_lib.mpz_out_raw(stream, op) = 7)
            
            ' Close temporary file.
            fclose(stream.Value.Value)
            
            ' Assert that the content of the temporary file.
            Dim r As Byte() = System.IO.File.ReadAllBytes(pathname)
            Assert.IsTrue(r(0) = 0 AndAlso r(1) = 0 AndAlso r(2) = 0 AndAlso r(3) = 3 AndAlso r(4) = &amp;H1 AndAlso r(5) = &amp;He2 AndAlso r(6) = &amp;H40)
            
            ' Delete temporary file.
            System.IO.File.Delete(pathname)
            
            ' Release unmanaged memory allocated for op.
            gmp_lib.mpz_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_out_str(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.Int32,Math.Gmp.Native.mpz_t)">
            <summary>
            Output <paramref name="op"/> on stdio stream <paramref name="stream"/>, as a string of digits in base <paramref name="base"/>.
            </summary>
            <param name="stream">Pointer to file stream.</param>
            <param name="base">The base operand.</param>
            <param name="op">The operand integer.</param>
            <returns>Return the number of bytes written, or if an error occurred, return 0. </returns>
            <remarks>
            <para>
            The <paramref name="base"/> argument may vary from 2 to 62 or from -2 to -36. 
            </para>
            <para>
            For <paramref name="base"/> in the range 2..36, digits and lower-case letters are used;
            for -2..-36, digits and upper-case letters are used; for 37..62, digits, upper-case letters,
            and lower-case letters (in that significance order) are used. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_inp_str(Math.Gmp.Native.mpz_t,Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.Int32)">mpz_inp_str</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_out_raw(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},Math.Gmp.Native.mpz_t)">mpz_out_raw</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_inp_raw(Math.Gmp.Native.mpz_t,Math.Gmp.Native.ptr{Math.Gmp.Native.FILE})">mpz_inp_raw</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#IO_of_Integers">I/O of Integers</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/I_002fO-of-Integers.html#I_002fO-of-Integers">GNU MP - I/O of Integers</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op to 123456.
            mpz_t op = new mpz_t();
            gmp_lib.mpz_init_set_ui(op, 123456U);
            
            // Get a temporary file.
            string pathname = System.IO.Path.GetTempFileName();
            
            // Open temporary file for writing.
            ptr&lt;FILE&gt; stream = new ptr&lt;FILE&gt;();
            _wfopen_s(out stream.Value.Value, pathname, "w");
            
            // Write op to temporary file, and assert that the number of bytes written is 6.
            Assert.IsTrue(gmp_lib.mpz_out_str(stream, 10, op) == 6);
            
            // Close temporary file.
            fclose(stream.Value.Value);
            
            // Assert that the content of the temporary file is "123456".
            string result = System.IO.File.ReadAllText(pathname);
            Assert.IsTrue(result == "123456");
            
            // Delete temporary file.
            System.IO.File.Delete(pathname);
            
            // Release unmanaged memory allocated for op.
            gmp_lib.mpz_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op to 123456.
            Dim op As New mpz_t()
            gmp_lib.mpz_init_set_ui(op, 123456UI)
            
            ' Get a temporary file.
            Dim pathname As String = System.IO.Path.GetTempFileName()
            
            ' Open temporary file for writing.
            Dim stream As New ptr(Of FILE)()
            _wfopen_s(stream.Value.Value, pathname, "w")
            
            ' Write op to temporary file, and assert that the number of bytes written is 6.
            Assert.IsTrue(gmp_lib.mpz_out_str(stream, 10, op) = 6)
            
            ' Close temporary file.
            fclose(stream.Value.Value)
            
            ' Assert that the content of the temporary file is "123456".
            Dim result As String = System.IO.File.ReadAllText(pathname)
            Assert.IsTrue(result = "123456")
            
            ' Delete temporary file.
            System.IO.File.Delete(pathname)
            
            ' Release unmanaged memory allocated for op.
            gmp_lib.mpz_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_perfect_power_p(Math.Gmp.Native.mpz_t)">
            <summary>
            Return non-zero if <paramref name="op"/> is a perfect power, i.e., if there exist integers a and b, with b &gt; 1, such that <paramref name="op"/> = a^b. 
            </summary>
            <param name="op">The operand integer.</param>
            <returns>Non-zero if <paramref name="op"/> is a perfect power, i.e., if there exist integers a and b, with b &gt; 1, such that <paramref name="op"/> = a^b.</returns>
            <remarks>
            <para>
            Under this definition both 0 and 1 are considered to be perfect powers. Negative values of <paramref name="op"/> are accepted, but of course can only be odd perfect powers. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_perfect_square_p(Math.Gmp.Native.mpz_t)">mpz_perfect_square_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_root(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_root</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_rootrem(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_rootrem</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_sqrt(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_sqrt</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_sqrtrem(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_sqrtrem</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Roots">Integer Roots</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Roots.html#Integer-Roots">GNU MP - Integer Roots</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of x to 10000.
            mpz_t op = new mpz_t();
            gmp_lib.mpz_init_set_si(op, 10000);
            
            // Assert that op is a perfect power.
            Assert.IsTrue(gmp_lib.mpz_perfect_power_p(op) > 0);
            
            // Release unmanaged memory allocated for op.
            gmp_lib.mpz_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of x to 10000.
            Dim op As New mpz_t()
            gmp_lib.mpz_init_set_si(op, 10000)
            
            ' Assert that op is a perfect power.
            Assert.IsTrue(gmp_lib.mpz_perfect_power_p(op) > 0)
            
            ' Release unmanaged memory allocated for op.
            gmp_lib.mpz_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_perfect_square_p(Math.Gmp.Native.mpz_t)">
            <summary>
            Return non-zero if <paramref name="op"/> is a perfect square, i.e., if the square root of <paramref name="op"/> is an integer.
            </summary>
            <param name="op">The operand integer.</param>
            <returns>Non-zero if <paramref name="op"/> is a perfect square, i.e., if the square root of <paramref name="op"/> is an integer.</returns>
            <remarks>
            <para>
            Under this definition both 0 and 1 are considered to be perfect squares. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_perfect_power_p(Math.Gmp.Native.mpz_t)">mpz_perfect_power_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_root(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_root</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_rootrem(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_rootrem</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_sqrt(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_sqrt</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_sqrtrem(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_sqrtrem</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Roots">Integer Roots</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Roots.html#Integer-Roots">GNU MP - Integer Roots</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of x to 10000.
            mpz_t op = new mpz_t();
            gmp_lib.mpz_init_set_si(op, 10000);
            
            // Assert that op is a perfect square.
            Assert.IsTrue(gmp_lib.mpz_perfect_square_p(op) > 0);
            
            // Release unmanaged memory allocated for op.
            gmp_lib.mpz_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of x to 10000.
            Dim op As New mpz_t()
            gmp_lib.mpz_init_set_si(op, 10000)
            
            ' Assert that op is a perfect square.
            Assert.IsTrue(gmp_lib.mpz_perfect_square_p(op) > 0)
            
            ' Release unmanaged memory allocated for op.
            gmp_lib.mpz_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_popcount(Math.Gmp.Native.mpz_t)">
            <summary>
            Return the population count of <paramref name="op"/>.
            </summary>
            <param name="op">The operand integer.</param>
            <returns>If <paramref name="op"/> &#8805; 0, return the population count of <paramref name="op"/>, which is the number of 1 bits in the binary representation. If <paramref name="op"/> &lt; 0, the number of 1s is infinite, and the return value is the largest possible <see cref="T:Math.Gmp.Native.mp_bitcnt_t">mp_bitcnt_t</see>.</returns>
            <remarks>
            <para>
            The function behaves as if twos complement arithmetic were used (although sign-magnitude is the actual implementation).
            The least significant bit is number 0. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_and(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_and</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_ior(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_ior</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_xor(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_xor</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_com(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_com</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_hamdist(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_hamdist</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_scan0(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_scan0</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_scan1(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_scan1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_setbit(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_setbit</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_clrbit(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_clrbit</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_combit(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_combit</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tstbit(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_tstbit</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Logic_and_Bit_Fiddling">Integer Logic and Bit Fiddling</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Logic-and-Bit-Fiddling.html#Integer-Logic-and-Bit-Fiddling">GNU MP - Integer Logic and Bit Fiddling</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op to 63.
            mpz_t op = new mpz_t();
            gmp_lib.mpz_init_set_ui(op, 63U);
            
            // Assert that op has 6 one bits.
            Assert.IsTrue(gmp_lib.mpz_popcount(op) == 6U);
            
            // Release unmanaged memory allocated for op.
            gmp_lib.mpz_clears(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op to 63.
            Dim op As New mpz_t()
            gmp_lib.mpz_init_set_ui(op, 63UI)
            
            ' Assert that op has 6 one bits.
            Assert.IsTrue(gmp_lib.mpz_popcount(op) = 6UI)
            
            ' Release unmanaged memory allocated for op.
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_pow_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="base"/>^<paramref name="exp"/>. The case 0^0 yields 1. 
            </summary>
            <param name="rop">The result integer.</param>
            <param name="base">The base integer.</param>
            <param name="exp">The exponent integer.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_powm(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_powm</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_powm_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32,Math.Gmp.Native.mpz_t)">mpz_powm_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_powm_sec(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_powm_sec</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_ui_pow_ui(Math.Gmp.Native.mpz_t,System.UInt32,System.UInt32)">mpz_ui_pow_ui</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Exponentiation">Integer Exponentiations</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Exponentiation.html#Integer-Exponentiation">GNU MP - Integer Exponentiation</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of base to 2.
            mpz_t @base = new mpz_t();
            gmp_lib.mpz_init_set_ui(@base, 2U);
            
            // Create, initialize, and set the value of rop to 0.
            mpz_t rop = new mpz_t();
            gmp_lib.mpz_init(rop);
            
            // Set rop = base^4.
            gmp_lib.mpz_pow_ui(rop, @base, 4U);
            
            // Assert that rop is 16.
            Assert.IsTrue(gmp_lib.mpz_get_si(rop) == 16);
            
            // Release unmanaged memory allocated for rop and base.
            gmp_lib.mpz_clears(rop, @base, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of base to 2.
            Dim base As New mpz_t()
            gmp_lib.mpz_init_set_ui(base, 2UI)
            
            ' Create, initialize, and set the value of rop to 0.
            Dim rop As New mpz_t()
            gmp_lib.mpz_init(rop)
            
            ' Set rop = base^4.
            gmp_lib.mpz_pow_ui(rop, base, 4UI)
            
            ' Assert that rop is 16.
            Assert.IsTrue(gmp_lib.mpz_get_si(rop) = 16)
            
            ' Release unmanaged memory allocated for rop and base.
            gmp_lib.mpz_clears(rop, base, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_powm(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">
            <summary>
            Set <paramref name="rop"/> to (<paramref name="base"/>^<paramref name="exp"/>) modulo <paramref name="mod"/>. 
            </summary>
            <param name="rop">The result integer.</param>
            <param name="base">The base integer.</param>
            <param name="exp">The exponent integer.</param>
            <param name="mod">The modulo integer.</param>
            <remarks>
            <para>
            Negative <paramref name="exp"/> is supported if an inverse <paramref name="base"/>^-1 modulo <paramref name="mod"/> exists (see <see cref="M:Math.Gmp.Native.gmp_lib.mpz_invert(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_invert</see>).
            If an inverse doesn’t exist then a divide by zero is raised.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_powm_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32,Math.Gmp.Native.mpz_t)">mpz_powm_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_powm_sec(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_powm_sec</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_pow_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_pow_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_ui_pow_ui(Math.Gmp.Native.mpz_t,System.UInt32,System.UInt32)">mpz_ui_pow_ui</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Exponentiation">Integer Exponentiations</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Exponentiation.html#Integer-Exponentiation">GNU MP - Integer Exponentiation</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of base to 2.
            mpz_t @base = new mpz_t();
            gmp_lib.mpz_init_set_ui(@base, 2U);
            
            // Create, initialize, and set the value of exp to 4.
            mpz_t exp = new mpz_t();
            gmp_lib.mpz_init_set_ui(exp, 4U);
            
            // Create, initialize, and set the value of mod to 3.
            mpz_t mod = new mpz_t();
            gmp_lib.mpz_init_set_ui(mod, 3U);
            
            // Create, initialize, and set the value of rop to 0.
            mpz_t rop = new mpz_t();
            gmp_lib.mpz_init(rop);
            
            // Set rop = base^exp mod mod.
            gmp_lib.mpz_powm(rop, @base, exp, mod);
            
            // Assert that rop is 1.
            Assert.IsTrue(gmp_lib.mpz_get_si(rop) == 1);
            
            // Release unmanaged memory allocated for rop, base, exp, and mod.
            gmp_lib.mpz_clears(rop, @base, exp, mod, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of base to 2.
            Dim base As New mpz_t()
            gmp_lib.mpz_init_set_ui(base, 2UI)
            
            ' Create, initialize, and set the value of exp to 4.
            Dim exp As New mpz_t()
            gmp_lib.mpz_init_set_ui(exp, 4UI)
            
            ' Create, initialize, and set the value of mod to 3.
            Dim[mod] As New mpz_t()
            gmp_lib.mpz_init_set_ui([mod], 3UI)
            
            ' Create, initialize, and set the value of rop to 0.
            Dim rop As New mpz_t()
            gmp_lib.mpz_init(rop)
            
            ' Set rop = base^exp mod mod.
            gmp_lib.mpz_powm(rop, base, exp, [mod])
            
            ' Assert that rop is 1.
            Assert.IsTrue(gmp_lib.mpz_get_si(rop) = 1)
            
            ' Release unmanaged memory allocated for rop, base, exp, and mod.
            gmp_lib.mpz_clears(rop, base, exp, [mod], Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_powm_sec(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">
            <summary>
            Set <paramref name="rop"/> to (<paramref name="base"/>^<paramref name="exp"/>) modulo <paramref name="mod"/>.
            </summary>
            <param name="rop">The result integer.</param>
            <param name="base">The base integer.</param>
            <param name="exp">The exponent integer.</param>
            <param name="mod">The modulo integer.</param>
            <remarks>
            <para>
            It is required that <paramref name="exp"/> &gt; 0 and that <paramref name="mod"/> is odd.
            </para>
            <para>
            This function is designed to take the same time and have the same cache access patterns for any two same-size arguments,
            assuming that function arguments are placed at the same position and that the machine state is identical upon function entry.
            This function is intended for cryptographic purposes, where resilience to side-channel attacks is desired. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_powm(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_powm</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_powm_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32,Math.Gmp.Native.mpz_t)">mpz_powm_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_pow_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_pow_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_ui_pow_ui(Math.Gmp.Native.mpz_t,System.UInt32,System.UInt32)">mpz_ui_pow_ui</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Exponentiation">Integer Exponentiations</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Exponentiation.html#Integer-Exponentiation">GNU MP - Integer Exponentiation</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of base to 2.
            mpz_t @base = new mpz_t();
            gmp_lib.mpz_init_set_ui(@base, 2U);
            
            // Create, initialize, and set the value of exp to 4.
            mpz_t exp = new mpz_t();
            gmp_lib.mpz_init_set_ui(exp, 4U);
            
            // Create, initialize, and set the value of mod to 3.
            mpz_t mod = new mpz_t();
            gmp_lib.mpz_init_set_ui(mod, 3U);
            
            // Create, initialize, and set the value of rop to 0.
            mpz_t rop = new mpz_t();
            gmp_lib.mpz_init(rop);
            
            // Set rop = base^exp mod mod.
            gmp_lib.mpz_powm_sec(rop, @base, exp, mod);
            
            // Assert that rop is 1.
            Assert.IsTrue(gmp_lib.mpz_get_si(rop) == 1);
            
            // Release unmanaged memory allocated for rop, base, exp, and mod.
            gmp_lib.mpz_clears(rop, @base, exp, mod, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of base to 2.
            Dim base As New mpz_t()
            gmp_lib.mpz_init_set_ui(base, 2UI)
            
            ' Create, initialize, and set the value of exp to 4.
            Dim exp As New mpz_t()
            gmp_lib.mpz_init_set_ui(exp, 4UI)
            
            ' Create, initialize, and set the value of mod to 3.
            Dim[mod] As New mpz_t()
            gmp_lib.mpz_init_set_ui([mod], 3UI)
            
            ' Create, initialize, and set the value of rop to 0.
            Dim rop As New mpz_t()
            gmp_lib.mpz_init(rop)
            
            ' Set rop = base^exp mod mod.
            gmp_lib.mpz_powm_sec(rop, base, exp, [mod])
            
            ' Assert that rop is 1.
            Assert.IsTrue(gmp_lib.mpz_get_si(rop) = 1)
            
            ' Release unmanaged memory allocated for rop, base, exp, and mod.
            gmp_lib.mpz_clears(rop, base, exp, [mod], Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_powm_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32,Math.Gmp.Native.mpz_t)">
            <summary>
            Set <paramref name="rop"/> to (<paramref name="base"/>^<paramref name="exp"/>) modulo <paramref name="mod"/>. 
            </summary>
            <param name="rop">The result integer.</param>
            <param name="base">The base integer.</param>
            <param name="exp">The exponent integer.</param>
            <param name="mod">The modulo integer.</param>
            <remarks>
            <para>
            Negative <paramref name="exp"/> is supported if an inverse <paramref name="base"/>^-1 modulo <paramref name="mod"/> exists (see <see cref="M:Math.Gmp.Native.gmp_lib.mpz_invert(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_invert</see>).
            If an inverse doesn’t exist then a divide by zero is raised.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_powm(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_powm</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_powm_sec(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_powm_sec</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_pow_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_pow_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_ui_pow_ui(Math.Gmp.Native.mpz_t,System.UInt32,System.UInt32)">mpz_ui_pow_ui</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Exponentiation">Integer Exponentiations</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Exponentiation.html#Integer-Exponentiation">GNU MP - Integer Exponentiation</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of base to 2.
            mpz_t @base = new mpz_t();
            gmp_lib.mpz_init_set_ui(@base, 2U);
            
            mpz_t mod = new mpz_t();
            gmp_lib.mpz_init_set_ui(mod, 3U);
            
            // Create, initialize, and set the value of rop to 0.
            mpz_t rop = new mpz_t();
            gmp_lib.mpz_init(rop);
            
            // Set rop = base^4 mod mod.
            gmp_lib.mpz_powm_ui(rop, @base, 4U, mod);
            
            // Assert that rop is 1.
            Assert.IsTrue(gmp_lib.mpz_get_si(rop) == 1);
            
            // Release unmanaged memory allocated for rop, base, and mod.
            gmp_lib.mpz_clears(rop, @base, mod, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of base to 2.
            Dim base As New mpz_t()
            gmp_lib.mpz_init_set_ui(base, 2UI)
            Dim[mod] As New mpz_t()
            gmp_lib.mpz_init_set_ui([mod], 3UI)
            
            ' Create, initialize, and set the value of rop to 0.
            Dim rop As New mpz_t()
            gmp_lib.mpz_init(rop)
            
            ' Set rop = base^4 mod mod.
            gmp_lib.mpz_powm_ui(rop, base, 4UI, [mod])
            
            ' Assert that rop is 1.
            Assert.IsTrue(gmp_lib.mpz_get_si(rop) = 1)
            
            ' Release unmanaged memory allocated for rop, base, and mod.
            gmp_lib.mpz_clears(rop, base, [mod], Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_probab_prime_p(Math.Gmp.Native.mpz_t,System.Int32)">
            <summary>
            Determine whether <paramref name="n"/> is prime.
            </summary>
            <param name="n">The operand integer.</param>
            <param name="reps">The number of Miller-Rabin probabilistic primality tests to perform.</param>
            <returns>Return 2 if <paramref name="n"/> is definitely prime, return 1 if <paramref name="n"/> is probably prime (without being certain), or return 0 if <paramref name="n"/> is definitely non-prime.</returns>
            <remarks>
            <para>
            This function performs some trial divisions, then <paramref name="reps"/> Miller-Rabin probabilistic primality tests.
            A higher <paramref name="reps"/> value will reduce the chances of a non-prime being identified as “probably prime”.
            A composite number will be identified as a prime with a probability of less than 4^(-reps).
            Reasonable values of <paramref name="reps"/> are between 15 and 50.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_millerrabin(Math.Gmp.Native.mpz_t,System.Int32)">mpz_millerrabin</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_nextprime(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_nextprime</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Number_Theoretic_Functions">Number Theoretic Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions">GNU MP - Number Theoretic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of n to 12.
            mpz_t n = new mpz_t();
            gmp_lib.mpz_init_set_ui(n, 12U);
            
            // Assert that n is a composite number.
            Assert.IsTrue(gmp_lib.mpz_probab_prime_p(n, 25) == 0);
            
            // Release unmanaged memory allocated for n.
            gmp_lib.mpz_clear(n);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of n to 12.
            Dim n As New mpz_t()
            gmp_lib.mpz_init_set_ui(n, 12UI)
            
            ' Assert that n is a composite number.
            Assert.IsTrue(gmp_lib.mpz_probab_prime_p(n, 25) = 0)
            
            ' Release unmanaged memory allocated for n.
            gmp_lib.mpz_clear(n)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_random(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">
            <summary>
            Generate a random integer of at most <paramref name="max_size"/> limbs.
            </summary>
            <param name="rop">The result integer.</param>
            <param name="max_size">The maximum number of limbs.</param>
            <remarks>
            <para>
            The generated random number doesn’t satisfy any particular requirements of randomness.
            Negative random numbers are generated when <paramref name="max_size"/> is negative.
            </para>
            <para>
            This function is obsolete. Use <see cref="M:Math.Gmp.Native.gmp_lib.mpz_urandomb(Math.Gmp.Native.mpz_t,Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_urandomb</see> or <see cref="M:Math.Gmp.Native.gmp_lib.mpz_urandomm(Math.Gmp.Native.mpz_t,Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.mpz_t)">mpz_urandomm</see> instead.
            </para>
            <para>
            The random number functions of GMP come in two groups; older function that rely on a global state, 
            and newer functions that accept a state parameter that is read and modified.
            Please see the <a href="https://gmplib.org/manual/Random-Number-Functions.html#Random-Number-Functions">GNU MP - Random Number Functions</a>
            for more information on how to use and not to use random number functions.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_urandomb(Math.Gmp.Native.mpz_t,Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_urandomb</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_urandomm(Math.Gmp.Native.mpz_t,Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.mpz_t)">mpz_urandomm</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_rrandomb(Math.Gmp.Native.mpz_t,Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_rrandomb</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_random2(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">mpz_random2</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Random_Numbers">Integer Random Numbers</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Random-Numbers.html#Integer-Random-Numbers">GNU MP - Integer Random Numbers</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of rop to 0.
            mpz_t rop = new mpz_t();
            gmp_lib.mpz_init(rop);
            
            // Generate a random integer.
            gmp_lib.mpz_random(rop, 500);
            
            // Free all memory occupied by state and rop.
            gmp_lib.mpz_clear(rop);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of rop to 0.
            Dim rop As New mpz_t()
            gmp_lib.mpz_init(rop)
            
            ' Generate a random integer.
            gmp_lib.mpz_random(rop, 500)
            
            ' Free all memory occupied by state and rop.
            gmp_lib.mpz_clear(rop)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_random2(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">
            <summary>
            Generate a random integer of at most <paramref name="max_size"/> limbs, with long strings of zeros and ones in the binary representation.
            </summary>
            <param name="rop">The result integer.</param>
            <param name="max_size">The maximum number of limbs.</param>
            <remarks>
            <para>
            Useful for testing functions and algorithms, since this kind of random numbers have proven to be more likely to trigger corner-case bugs.
            Negative random numbers are generated when <paramref name="max_size"/> is negative. 
            </para>
            <para>
            This function is obsolete. Use <see cref="M:Math.Gmp.Native.gmp_lib.mpz_rrandomb(Math.Gmp.Native.mpz_t,Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_rrandomb</see> instead.
            </para>
            <para>
            The random number functions of GMP come in two groups; older function that rely on a global state, 
            and newer functions that accept a state parameter that is read and modified.
            Please see the <a href="https://gmplib.org/manual/Random-Number-Functions.html#Random-Number-Functions">GNU MP - Random Number Functions</a>
            for more information on how to use and not to use random number functions.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_urandomb(Math.Gmp.Native.mpz_t,Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_urandomb</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_urandomm(Math.Gmp.Native.mpz_t,Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.mpz_t)">mpz_urandomm</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_rrandomb(Math.Gmp.Native.mpz_t,Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_rrandomb</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_random(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">mpz_random</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Random_Numbers">Integer Random Numbers</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Random-Numbers.html#Integer-Random-Numbers">GNU MP - Integer Random Numbers</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of rop to 0.
            mpz_t rop = new mpz_t();
            gmp_lib.mpz_init(rop);
            
            // Generate a random integer.
            gmp_lib.mpz_random(rop, 100);
            
            // Free all memory occupied by rop.
            gmp_lib.mpz_clear(rop);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of rop to 0.
            Dim rop As New mpz_t()
            gmp_lib.mpz_init(rop)
            
            ' Generate a random integer.
            gmp_lib.mpz_random(rop, 100)
            
            ' Free all memory occupied by rop.
            gmp_lib.mpz_clear(rop)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_realloc2(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">
            <summary>
            Change the space allocated for <paramref name="x"/> to <paramref name="n"/> bits.
            </summary>
            <param name="x">The integer.</param>
            <param name="n">The number of bits.</param>
            <remarks>
            <para>
            The value in <paramref name="x"/> is preserved if it fits, or is set to 0 if not.
            </para>
            <para>
            Calling this function is never necessary; reallocation is handled automatically by GMP when
            needed. But this function can be used to increase the space for a variable in order to avoid
            repeated automatic reallocations, or to decrease it to give memory back to the heap.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_clear(Math.Gmp.Native.mpz_t)">mpz_clear</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_clears(Math.Gmp.Native.mpz_t[])">mpz_clears</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_init(Math.Gmp.Native.mpz_t)">mpz_init</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_inits(Math.Gmp.Native.mpz_t[])">mpz_inits</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_init2(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_init2</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Initializing_Integers">Initializing Integers</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Initializing-Integers.html#Initializing-Integers">GNU MP - Initializing Integers</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize new integer x.
            mpz_t x = new mpz_t();
            gmp_lib.mpz_init(x);
            
            // Set the value of x to a 77-bit integer.
            char_ptr value = new char_ptr("1000 0000 0000 0000 0000");
            gmp_lib.mpz_set_str(x, value, 16);
            
            // Resize x to 512 bits, and assert that its value has not changed.
            gmp_lib.mpz_realloc2(x, 512U);
            char_ptr s = gmp_lib.mpz_get_str(char_ptr.Zero, 16, x);
            Assert.IsTrue(s.ToString() == "1000 0000 0000 0000 0000".Replace(" ", ""));
            
            // Resize x to 2 bits, and assert that its value has changed to 0.
            gmp_lib.mpz_realloc2(x, 2U);
            Assert.IsTrue(gmp_lib.mpz_get_si(x) == 0);
            
            // Release unmanaged memory allocated for x and string values.
            gmp_lib.mpz_clear(x);
            gmp_lib.free(value);
            gmp_lib.free(s);
            </code> 
            <code language="VB.NET">
            ' Create and initialize new integer x.
            Dim x As New mpz_t()
            gmp_lib.mpz_init(x)
            
            ' Set the value of x to a 77-bit integer.
            Dim value As New char_ptr("1000 0000 0000 0000 0000")
            gmp_lib.mpz_set_str(x, value, 16)
            
            ' Resize x to 512 bits, and assert that its value has not changed.
            gmp_lib.mpz_realloc2(x, 512UI)
            Dim s As char_ptr = gmp_lib.mpz_get_str(char_ptr.Zero, 16, x)
            Assert.IsTrue(s.ToString() = "1000 0000 0000 0000 0000".Replace(" ", ""))
            
            ' Resize x to 2 bits, and assert that its value has changed to 0.
            gmp_lib.mpz_realloc2(x, 2UI)
            Assert.IsTrue(gmp_lib.mpz_get_si(x) = 0)
            
            ' Release unmanaged memory allocated for x and string values.
            gmp_lib.mpz_clear(x)
            gmp_lib.free(value)
            gmp_lib.free(s)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_remove(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">
            <summary>
            Remove all occurrences of the factor <paramref name="f"/> from <paramref name="op"/> and store the result in <paramref name="rop"/>.
            </summary>
            <param name="rop">The result integer.</param>
            <param name="op">The operand integer.</param>
            <param name="f">The factor operand integer.</param>
            <returns>The return value is how many such occurrences were removed.</returns>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Number_Theoretic_Functions">Number Theoretic Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions">GNU MP - Number Theoretic Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op to 45.
            mpz_t op = new mpz_t();
            gmp_lib.mpz_init_set_ui(op, 45U);
            
            // Create, initialize, and set the value of f to 3.
            mpz_t f = new mpz_t();
            gmp_lib.mpz_init_set_ui(f, 3U);
            
            // Create, initialize, and set the value of rop to 0.
            mpz_t rop = new mpz_t();
            gmp_lib.mpz_init(rop);
            
            // Set rop = op / f^n, and return n, the largest integer greater than or equal to 0, such that f^n divides op.
            Assert.IsTrue(gmp_lib.mpz_remove(rop, op, f) == 2);
            
            // Assert that rop is 5.
            Assert.IsTrue(gmp_lib.mpz_get_si(rop) == 5);
            
            // Release unmanaged memory allocated for rop, op, and f.
            gmp_lib.mpz_clears(rop, op, f, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op to 45.
            Dim op As New mpz_t()
            gmp_lib.mpz_init_set_ui(op, 45UI)
            
            ' Create, initialize, and set the value of f to 3.
            Dim f As New mpz_t()
            gmp_lib.mpz_init_set_ui(f, 3UI)
            
            ' Create, initialize, and set the value of rop to 0.
            Dim rop As New mpz_t()
            gmp_lib.mpz_init(rop)
            
            ' Set rop = op / f^n, and return n, the largest integer greater than or equal to 0, such that f^n divides op.
            Assert.IsTrue(gmp_lib.mpz_remove(rop, op, f) = 2)
            
            ' Assert that rop is 5.
            Assert.IsTrue(gmp_lib.mpz_get_si(rop) = 5)
            
            ' Release unmanaged memory allocated for rop, op, and f.
            gmp_lib.mpz_clears(rop, op, f, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_root(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">
            <summary>
            Set <paramref name="rop"/> to the truncated integer part of the <paramref name="n"/>th root of <paramref name="op"/>.
            </summary>
            <param name="rop">The result root integer.</param>
            <param name="op">The first operand integer.</param>
            <param name="n">The second operand integer.</param>
            <returns>Return non-zero if the computation was exact, i.e., if <paramref name="op"/> is <paramref name="rop"/> to the <paramref name="n"/>th power.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_perfect_power_p(Math.Gmp.Native.mpz_t)">mpz_perfect_power_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_perfect_square_p(Math.Gmp.Native.mpz_t)">mpz_perfect_square_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_rootrem(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_rootrem</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_sqrt(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_sqrt</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_sqrtrem(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_sqrtrem</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Roots">Integer Roots</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Roots.html#Integer-Roots">GNU MP - Integer Roots</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op to 10000.
            mpz_t op = new mpz_t();
            gmp_lib.mpz_init_set_si(op, 10000);
            
            // Create, initialize, and set the value of rop to 0.
            mpz_t rop = new mpz_t();
            gmp_lib.mpz_init(rop);
            
            // Set rop = trunc(cbrt(10000)).
            gmp_lib.mpz_root(rop, op, 3U);
            
            // Assert that rop is 21.
            Assert.IsTrue(gmp_lib.mpz_get_si(rop) == 21);
            
            // Release unmanaged memory allocated for rop.
            gmp_lib.mpz_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op to 10000.
            Dim op As New mpz_t()
            gmp_lib.mpz_init_set_si(op, 10000)
            
            ' Create, initialize, and set the value of rop to 0.
            Dim rop As New mpz_t()
            gmp_lib.mpz_init(rop)
            
            ' Set rop = trunc(cbrt(10000)).
            gmp_lib.mpz_root(rop, op, 3UI)
            
            ' Assert that rop is 21.
            Assert.IsTrue(gmp_lib.mpz_get_si(rop) = 21)
            
            ' Release unmanaged memory allocated for rop.
            gmp_lib.mpz_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_rootrem(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">
            <summary>
            Set <paramref name="root"/> to the truncated integer part of the <paramref name="n"/>th root of <paramref name="u"/>. Set <paramref name="rem"/> to the remainder, <paramref name="u"/> - <paramref name="root"/>^<paramref name="n"/>. 
            </summary>
            <param name="root">The result root integer.</param>
            <param name="rem">The result remainder integer.</param>
            <param name="u">The first operand integer.</param>
            <param name="n">The second operand integer.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_perfect_power_p(Math.Gmp.Native.mpz_t)">mpz_perfect_power_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_perfect_square_p(Math.Gmp.Native.mpz_t)">mpz_perfect_square_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_root(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_root</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_sqrt(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_sqrt</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_sqrtrem(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_sqrtrem</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Roots">Integer Roots</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Roots.html#Integer-Roots">GNU MP - Integer Roots</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of u to 10000.
            mpz_t u = new mpz_t();
            gmp_lib.mpz_init_set_si(u, 10000);
            
            // Create, initialize, and set the values of root and rem to 0.
            mpz_t root = new mpz_t();
            mpz_t rem = new mpz_t();
            gmp_lib.mpz_inits(root, rem, null);
            
            // Set root = trunc(cbrt(10000)) and rem = u - root.
            gmp_lib.mpz_rootrem(root, rem, u, 3U);
            
            // Assert that root is 21, and rem is 739.
            Assert.IsTrue(gmp_lib.mpz_get_si(root) == 21);
            Assert.IsTrue(gmp_lib.mpz_get_si(rem) == 739);
            
            // Release unmanaged memory allocated for root, rem, and u.
            gmp_lib.mpz_clears(root, rem, u, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of u to 10000.
            Dim u As New mpz_t()
            gmp_lib.mpz_init_set_si(u, 10000)
            
            ' Create, initialize, and set the values of root and rem to 0.
            Dim root As New mpz_t()
            Dim[rem] As New mpz_t()
            gmp_lib.mpz_inits(root, [rem], Nothing)
            
            ' Set root = trunc(cbrt(10000)) and rem = u - root.
            gmp_lib.mpz_rootrem(root, [rem], u, 3UI)
            
            ' Assert that root is 21, and rem is 739.
            Assert.IsTrue(gmp_lib.mpz_get_si(root) = 21)
            Assert.IsTrue(gmp_lib.mpz_get_si([rem]) = 739)
            
            ' Release unmanaged memory allocated for root, rem, and u.
            gmp_lib.mpz_clears(root, [rem], u, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_rrandomb(Math.Gmp.Native.mpz_t,Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.mp_bitcnt_t)">
            <summary>
            Generate a random integer with long strings of zeros and ones in the binary representation.
            </summary>
            <param name="rop">The result integer.</param>
            <param name="state">The random number generator state.</param>
            <param name="n">The operand integer.</param>
            <remarks>
            <para>
            Useful for testing functions and algorithms, since this kind of random numbers have proven to be more
            likely to trigger corner-case bugs. The random number will be in the
            range 2^(<paramref name="n"/> - 1) to 2^<paramref name="n"/> - 1, inclusive. 
            </para>
            <para>
            The variable <paramref name="state"/> must be initialized by calling one of the <c>gmp_randinit</c>
            functions (<a href="https://gmplib.org/manual/Random-State-Initialization.html#Random-State-Initialization">GNU MP - Random State Initialization</a>) before invoking this function. 
            </para>
            <para>
            The random number functions of GMP come in two groups; older function that rely on a global state, 
            and newer functions that accept a state parameter that is read and modified.
            Please see the <a href="https://gmplib.org/manual/Random-Number-Functions.html#Random-Number-Functions">GNU MP - Random Number Functions</a>
            for more information on how to use and not to use random number functions.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_urandomb(Math.Gmp.Native.mpz_t,Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_urandomb</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_urandomm(Math.Gmp.Native.mpz_t,Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.mpz_t)">mpz_urandomm</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_random(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">mpz_random</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_random2(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">mpz_random2</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Random_Numbers">Integer Random Numbers</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Random-Numbers.html#Integer-Random-Numbers">GNU MP - Integer Random Numbers</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and seed a new random number generator.
            gmp_randstate_t state = new gmp_randstate_t();
            gmp_lib.gmp_randinit_mt(state);
            gmp_lib.gmp_randseed_ui(state, 100000U);
            
            // Create, initialize, and set the value of rop to 0.
            mpz_t rop = new mpz_t();
            gmp_lib.mpz_init(rop);
            
            // Generate a random integer in the range [2^(50-1), (2^50)-1].
            gmp_lib.mpz_rrandomb(rop, state, 50);
            
            // Free all memory occupied by state and rop.
            gmp_lib.gmp_randclear(state);
            gmp_lib.mpz_clear(rop);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and seed a new random number generator.
            Dim state As New gmp_randstate_t()
            gmp_lib.gmp_randinit_mt(state)
            gmp_lib.gmp_randseed_ui(state, 100000UI)
            
            ' Create, initialize, and set the value of rop to 0.
            Dim rop As New mpz_t()
            gmp_lib.mpz_init(rop)
            
            ' Generate a random integer in the range [2^(50-1), (2^50)-1].
            gmp_lib.mpz_rrandomb(rop, state, 50)
            
            ' Free all memory occupied by state and rop.
            gmp_lib.gmp_randclear(state)
            gmp_lib.mpz_clear(rop)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_scan0(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">
            <summary>
            Scan <paramref name="op"/> for 0 bit.
            </summary>
            <param name="op">The operand integer.</param>
            <param name="starting_bit">The start bit index position.</param>
            <returns>Return the index of the found bit.</returns>
            <remarks>
            <para>
            Scan <paramref name="op"/>, starting from bit <paramref name="starting_bit"/>, towards more significant bits,
            until the first 0 bit is found. Return the index of the found bit.
            </para>
            <para>
            If the bit at <paramref name="starting_bit"/> is already what’s sought,
            then <paramref name="starting_bit"/> is returned. 
            </para>
            <para>
            If there’s no bit found, then the largest possible <see cref="T:Math.Gmp.Native.mp_bitcnt_t">mp_bitcnt_t</see> is returned.
            This will happen in <see cref="M:Math.Gmp.Native.gmp_lib.mpz_scan0(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_scan0</see> past the end of a negative number,
            or <see cref="M:Math.Gmp.Native.gmp_lib.mpz_scan1(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_scan1</see> past the end of a nonnegative number. 
            </para>
            <para>
            The function behaves as if twos complement arithmetic were used (although sign-magnitude is the actual implementation).
            The least significant bit is number 0. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_and(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_and</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_ior(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_ior</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_xor(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_xor</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_com(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_com</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_popcount(Math.Gmp.Native.mpz_t)">mpz_popcount</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_hamdist(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_hamdist</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_scan1(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_scan1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_setbit(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_setbit</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_clrbit(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_clrbit</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_combit(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_combit</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tstbit(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_tstbit</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Logic_and_Bit_Fiddling">Integer Logic and Bit Fiddling</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Logic-and-Bit-Fiddling.html#Integer-Logic-and-Bit-Fiddling">GNU MP - Integer Logic and Bit Fiddling</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op to 70.
            mpz_t op = new mpz_t();
            gmp_lib.mpz_init_set_ui(op, 70U);
            
            // Assert that the first 0 bit starting from bit 1 in op is bit 3.
            Assert.IsTrue(gmp_lib.mpz_scan0(op, 1U) == 3U);
            
            // Release unmanaged memory allocated for op.
            gmp_lib.mpz_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op to 70.
            Dim op As New mpz_t()
            gmp_lib.mpz_init_set_ui(op, 70UI)
            
            ' Assert that the first 0 bit starting from bit 1 in op is bit 3.
            Assert.IsTrue(gmp_lib.mpz_scan0(op, 1UI) = 3UI)
            
            ' Release unmanaged memory allocated for op.
            gmp_lib.mpz_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_scan1(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">
            <summary>
            Scan <paramref name="op"/> for 1 bit.
            </summary>
            <param name="op">The operand integer.</param>
            <param name="starting_bit">The start bit index position.</param>
            <returns>Return the index of the found bit.</returns>
            <remarks>
            <para>
            Scan <paramref name="op"/>, starting from bit <paramref name="starting_bit"/>, towards more significant bits,
            until the first 1 bit is found. Return the index of the found bit.
            </para>
            <para>
            If the bit at <paramref name="starting_bit"/> is already what’s sought,
            then <paramref name="starting_bit"/> is returned. 
            </para>
            <para>
            If there’s no bit found, then the largest possible <see cref="T:Math.Gmp.Native.mp_bitcnt_t">mp_bitcnt_t</see> is returned.
            This will happen in <see cref="M:Math.Gmp.Native.gmp_lib.mpz_scan0(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_scan0</see> past the end of a negative number,
            or <see cref="M:Math.Gmp.Native.gmp_lib.mpz_scan1(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_scan1</see> past the end of a nonnegative number. 
            </para>
            <para>
            The function behaves as if twos complement arithmetic were used (although sign-magnitude is the actual implementation).
            The least significant bit is number 0. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_and(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_and</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_ior(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_ior</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_xor(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_xor</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_com(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_com</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_popcount(Math.Gmp.Native.mpz_t)">mpz_popcount</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_hamdist(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_hamdist</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_scan0(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_scan0</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_setbit(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_setbit</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_clrbit(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_clrbit</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_combit(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_combit</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tstbit(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_tstbit</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Logic_and_Bit_Fiddling">Integer Logic and Bit Fiddling</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Logic-and-Bit-Fiddling.html#Integer-Logic-and-Bit-Fiddling">GNU MP - Integer Logic and Bit Fiddling</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op to 70.
            mpz_t op = new mpz_t();
            gmp_lib.mpz_init_set_ui(op, 70U);
            
            // Assert that the first 1 bit starting from bit 3 in op is bit 6.
            Assert.IsTrue(gmp_lib.mpz_scan1(op, 3U) == 6U);
            
            // Release unmanaged memory allocated for op.
            gmp_lib.mpz_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op to 70.
            Dim op As New mpz_t()
            gmp_lib.mpz_init_set_ui(op, 70UI)
            
            ' Assert that the first 1 bit starting from bit 3 in op is bit 6.
            Assert.IsTrue(gmp_lib.mpz_scan1(op, 3UI) = 6UI)
            
            ' Release unmanaged memory allocated for op.
            gmp_lib.mpz_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_set(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">
            <summary>
            Set the value of <paramref name="rop"/> from <paramref name="op"/>.
            </summary>
            <param name="rop">The destination integer.</param>
            <param name="op">The source integer.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_set_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_set_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_set_si(Math.Gmp.Native.mpz_t,System.Int32)">mpz_set_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_set_d(Math.Gmp.Native.mpz_t,System.Double)">mpz_set_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_set_q(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpq_t)">mpz_set_q</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_set_f(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpf_t)">mpz_set_f</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_set_str(Math.Gmp.Native.mpz_t,Math.Gmp.Native.char_ptr,System.Int32)">mpz_set_str</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_swap(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_swap</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Assigning_Integers">Assigning Integers</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Assigning-Integers.html#Assigning-Integers">GNU MP - Assigning Integers</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new integer x to 10.
            mpz_t x = new mpz_t();
            gmp_lib.mpz_init(x);
            gmp_lib.mpz_set_si(x, 10);
            
            // Create, initialize, and set a new integer y to -210.
            mpz_t y = new mpz_t();
            gmp_lib.mpz_init(y);
            gmp_lib.mpz_set_si(y, -210);
            
            // Assign the value of y to x.
            gmp_lib.mpz_set(x, y);
            
            // Assert that the value of x is -210.
            Assert.IsTrue(gmp_lib.mpz_get_si(x) == -210);
            
            // Release unmanaged memory allocated for x and y.
            gmp_lib.mpz_clears(x, y, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new integer x to 10.
            Dim x As New mpz_t()
            
            gmp_lib.mpz_init(x)
            gmp_lib.mpz_set_si(x, 10)
            
            ' Create, initialize, and set a new integer y to -210.
            Dim y As New mpz_t()
            gmp_lib.mpz_init(y)
            gmp_lib.mpz_set_si(y, -210)
            
            ' Assign the value of y to x.
            gmp_lib.mpz_set(x, y)
            
            ' Assert that the value of x is -210.
            Assert.IsTrue(gmp_lib.mpz_get_si(x) = -210)
            
            ' Release unmanaged memory allocated for x and y.
            gmp_lib.mpz_clears(x, y, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_set_d(Math.Gmp.Native.mpz_t,System.Double)">
            <summary>
            Set the value of <paramref name="rop"/> from <paramref name="op"/>.
            </summary>
            <param name="rop">The destination integer.</param>
            <param name="op">The source integer.</param>
            <remarks>
            <para>
            <see cref="M:Math.Gmp.Native.gmp_lib.mpz_set_d(Math.Gmp.Native.mpz_t,System.Double)">mpz_set_d</see> truncate <paramref name="op"/> to make it an integer.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_set(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_set</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_set_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_set_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_set_si(Math.Gmp.Native.mpz_t,System.Int32)">mpz_set_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_set_q(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpq_t)">mpz_set_q</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_set_f(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpf_t)">mpz_set_f</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_set_str(Math.Gmp.Native.mpz_t,Math.Gmp.Native.char_ptr,System.Int32)">mpz_set_str</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_swap(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_swap</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Assigning_Integers">Assigning Integers</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Assigning-Integers.html#Assigning-Integers">GNU MP - Assigning Integers</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize a new integer x.
            mpz_t x = new mpz_t();
            gmp_lib.mpz_init(x);
            
            // Set the value of x to the truncation of 10.7.
            gmp_lib.mpz_set_d(x, 10.7D);
            
            // Assert that the value of x is 10.
            Assert.IsTrue(gmp_lib.mpz_get_si(x) == 10);
            
            // Release unmanaged memory allocated for x.
            gmp_lib.mpz_clear(x);
            </code> 
            <code language="VB.NET">
            ' Create and initialize a new integer x.
            Dim x As New mpz_t()
            gmp_lib.mpz_init(x)
            
            ' Set the value of x to the truncation of 10.7.
            gmp_lib.mpz_set_d(x, 10.7)
            
            ' Assert that the value of x is 10.
            Assert.IsTrue(gmp_lib.mpz_get_si(x) = 10)
            
            ' Release unmanaged memory allocated for x.
            gmp_lib.mpz_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_set_f(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpf_t)">
            <summary>
            Set the value of <paramref name="rop"/> from <paramref name="op"/>.
            </summary>
            <param name="rop">The destination integer.</param>
            <param name="op">The source integer.</param>
            <remarks>
            <para>
            <see cref="M:Math.Gmp.Native.gmp_lib.mpz_set_f(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpf_t)">mpz_set_f</see> truncate <paramref name="op"/> to make it an integer.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_set(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_set</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_set_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_set_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_set_si(Math.Gmp.Native.mpz_t,System.Int32)">mpz_set_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_set_d(Math.Gmp.Native.mpz_t,System.Double)">mpz_set_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_set_q(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpq_t)">mpz_set_q</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_set_str(Math.Gmp.Native.mpz_t,Math.Gmp.Native.char_ptr,System.Int32)">mpz_set_str</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_swap(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_swap</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Assigning_Integers">Assigning Integers</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Assigning-Integers.html#Assigning-Integers">GNU MP - Assigning Integers</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize new integer x, and float y.
            mpz_t x = new mpz_t();
            gmp_lib.mpz_init(x);
            mpf_t y = "1.7007e3";
            
            // Set the value of x to the truncation of 1700.7.
            gmp_lib.mpz_set_f(x, y);
            
            // Assert that the value of x is 1700.
            Assert.IsTrue(gmp_lib.mpz_get_si(x) == 1700);
            
            // Release unmanaged memory allocated for x and y.
            gmp_lib.mpz_clear(x);
            gmp_lib.mpf_clear(y);
            </code> 
            <code language="VB.NET">
            ' Create and initialize new integer x, and float y.
            Dim x As New mpz_t()
            gmp_lib.mpz_init(x)
            Dim y As mpf_t = "1.7007e3"
            
            ' Set the value of x to the truncation of 1700.7.
            gmp_lib.mpz_set_f(x, y)
            
            ' Assert that the value of x is 1700.
            Assert.IsTrue(gmp_lib.mpz_get_si(x) = 1700)
            
            ' Release unmanaged memory allocated for x and y.
            gmp_lib.mpz_clear(x)
            gmp_lib.mpf_clear(y)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_set_q(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpq_t)">
            <summary>
            Set the value of <paramref name="rop"/> from <paramref name="op"/>.
            </summary>
            <param name="rop">The destination integer.</param>
            <param name="op">The source integer.</param>
            <remarks>
            <para>
            <see cref="M:Math.Gmp.Native.gmp_lib.mpz_set_q(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpq_t)">mpz_set_q</see> truncate <paramref name="op"/> to make it an integer.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_set(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_set</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_set_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_set_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_set_si(Math.Gmp.Native.mpz_t,System.Int32)">mpz_set_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_set_d(Math.Gmp.Native.mpz_t,System.Double)">mpz_set_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_set_f(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpf_t)">mpz_set_f</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_set_str(Math.Gmp.Native.mpz_t,Math.Gmp.Native.char_ptr,System.Int32)">mpz_set_str</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_swap(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_swap</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Assigning_Integers">Assigning Integers</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Assigning-Integers.html#Assigning-Integers">GNU MP - Assigning Integers</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize new integer x, and rational y.
            mpz_t x = new mpz_t();
            gmp_lib.mpz_init(x);
            mpq_t y = "100/3";
            
            // Set the value of x to the truncation of 100/3.
            gmp_lib.mpz_set_q(x, y);
            
            // Assert that the value of x is 33.
            Assert.IsTrue(gmp_lib.mpz_get_si(x) == 33);
            
            // Release unmanaged memory allocated for x and y.
            gmp_lib.mpz_clear(x);
            gmp_lib.mpq_clear(y);
            </code> 
            <code language="VB.NET">
            ' Create and initialize new integer x, and rational y.
            Dim x As New mpz_t()
            gmp_lib.mpz_init(x)
            Dim y As mpq_t = "100/3"
            
            ' Set the value of x to the truncation of 100/3.
            gmp_lib.mpz_set_q(x, y)
            
            ' Assert that the value of x is 33.
            Assert.IsTrue(gmp_lib.mpz_get_si(x) = 33)
            
            ' Release unmanaged memory allocated for x and y.
            gmp_lib.mpz_clear(x)
            gmp_lib.mpq_clear(y)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_set_si(Math.Gmp.Native.mpz_t,System.Int32)">
            <summary>
            Set the value of <paramref name="rop"/> from <paramref name="op"/>.
            </summary>
            <param name="rop">The destination integer.</param>
            <param name="op">The source integer.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_set(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_set</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_set_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_set_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_set_d(Math.Gmp.Native.mpz_t,System.Double)">mpz_set_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_set_q(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpq_t)">mpz_set_q</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_set_f(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpf_t)">mpz_set_f</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_set_str(Math.Gmp.Native.mpz_t,Math.Gmp.Native.char_ptr,System.Int32)">mpz_set_str</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_swap(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_swap</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Assigning_Integers">Assigning Integers</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Assigning-Integers.html#Assigning-Integers">GNU MP - Assigning Integers</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize a new integer x.
            mpz_t x = new mpz_t();
            gmp_lib.mpz_init(x);
            
            // Set the value of x to -10.
            gmp_lib.mpz_set_si(x, -10);
            
            // Assert that the value of x is -10.
            Assert.IsTrue(gmp_lib.mpz_get_si(x) == -10);
            
            // Release unmanaged memory allocated for x.
            gmp_lib.mpz_clear(x);
            </code> 
            <code language="VB.NET">
            ' Create and initialize a new integer x.
            Dim x As New mpz_t()
            gmp_lib.mpz_init(x)
            
            ' Set the value of x to -10.
            gmp_lib.mpz_set_si(x, -10)
            
            ' Assert that the value of x is -10.
            Assert.IsTrue(gmp_lib.mpz_get_si(x) = -10)
            
            ' Release unmanaged memory allocated for x.
            gmp_lib.mpz_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_set_str(Math.Gmp.Native.mpz_t,Math.Gmp.Native.char_ptr,System.Int32)">
            <summary>
            Set the value of <paramref name="rop"/> from <paramref name="str"/>, a null-terminated C string in base <paramref name="base"/>.
            </summary>
            <param name="rop">The destination integer.</param>
            <param name="str">The source integer.</param>
            <param name="base">The base.</param>
            <returns>This function returns 0 if the entire string is a valid number in base <paramref name="base"/>. Otherwise it returns −1.</returns>
            <remarks>
            <para>
            White space is allowed in the string, and is simply ignored.
            </para>
            <para>
            The base may vary from 2 to 62, or if base is 0, then the leading characters are
            used: 0x and 0X for hexadecimal, 0b and 0B for binary, 0 for octal,
            or decimal otherwise.
            </para>
            <para>
            For bases up to 36, case is ignored; upper-case and lower-case letters have the same value.
            For bases 37 to 62, upper-case letter represent the usual 10..35 while lower-case
            letter represent 36..61.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_set(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_set</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_set_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_set_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_set_si(Math.Gmp.Native.mpz_t,System.Int32)">mpz_set_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_set_d(Math.Gmp.Native.mpz_t,System.Double)">mpz_set_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_set_q(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpq_t)">mpz_set_q</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_set_f(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpf_t)">mpz_set_f</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_swap(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_swap</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Assigning_Integers">Assigning Integers</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Assigning-Integers.html#Assigning-Integers">GNU MP - Assigning Integers</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize a new integer x.
            mpz_t x = new mpz_t();
            gmp_lib.mpz_init(x);
            
            // Set the value of x.
            char_ptr value = new char_ptr("12 345 678 909 876 543 211 234 567 890 987 654 321");
            gmp_lib.mpz_set_str(x, value, 10);
            
            // Assert the value of x.
            char_ptr s = gmp_lib.mpz_get_str(char_ptr.Zero, 10, x);
            Assert.IsTrue(s.ToString() == value.ToString().Replace(" ", ""));
            
            // Release unmanaged memory allocated for x and string values.
            gmp_lib.mpz_clear(x);
            gmp_lib.free(value);
            gmp_lib.free(s);
            </code> 
            <code language="VB.NET">
            ' Create and initialize a new integer x.
            Dim x As New mpz_t()
            gmp_lib.mpz_init(x)
            
            ' Set the value of x.
            Dim value As New char_ptr("12 345 678 909 876 543 211 234 567 890 987 654 321")
            gmp_lib.mpz_set_str(x, value, 10)
            
            ' Assert the value of x.
            Dim s As char_ptr = gmp_lib.mpz_get_str(char_ptr.Zero, 10, x)
            Assert.IsTrue(s.ToString() = value.ToString().Replace(" ", ""))
            
            ' Release unmanaged memory allocated for x and string values.
            gmp_lib.mpz_clear(x)
            gmp_lib.free(value)
            gmp_lib.free(s) 
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_set_ui(Math.Gmp.Native.mpz_t,System.UInt32)">
            <summary>
            Set the value of <paramref name="rop"/> from <paramref name="op"/>.
            </summary>
            <param name="rop">The destination integer.</param>
            <param name="op">The source integer.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_set(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_set</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_set_si(Math.Gmp.Native.mpz_t,System.Int32)">mpz_set_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_set_d(Math.Gmp.Native.mpz_t,System.Double)">mpz_set_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_set_q(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpq_t)">mpz_set_q</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_set_f(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpf_t)">mpz_set_f</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_set_str(Math.Gmp.Native.mpz_t,Math.Gmp.Native.char_ptr,System.Int32)">mpz_set_str</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_swap(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_swap</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Assigning_Integers">Assigning Integers</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Assigning-Integers.html#Assigning-Integers">GNU MP - Assigning Integers</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize a new integer x.
            mpz_t x = new mpz_t();
            gmp_lib.mpz_init(x);
            
            // Set the value of x to 10.
            gmp_lib.mpz_set_ui(x, 10U);
            
            // Assert that the value of x is 10.
            Assert.IsTrue(gmp_lib.mpz_get_ui(x) == 10U);
            
            // Release unmanaged memory allocated for x.
            gmp_lib.mpz_clear(x);
            </code> 
            <code language="VB.NET">
            ' Create and initialize a new integer x.
            Dim x As New mpz_t()
            
            gmp_lib.mpz_init(x)
            
            ' Set the value of x to 10.
            gmp_lib.mpz_set_ui(x, 10UI)
            
            ' Assert that the value of x is 10.
            Assert.IsTrue(gmp_lib.mpz_get_ui(x) = 10UI)
            
            ' Release unmanaged memory allocated for x.
            gmp_lib.mpz_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_setbit(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">
            <summary>
            Set bit <paramref name="bit_index"/> in <paramref name="rop"/>.
            </summary>
            <param name="rop">The result integer.</param>
            <param name="bit_index">The index of the bit to set.</param>
            <remarks>
            <para>
            The function behaves as if twos complement arithmetic were used (although sign-magnitude is the actual implementation).
            The least significant bit is number 0. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_and(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_and</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_ior(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_ior</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_xor(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_xor</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_com(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_com</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_popcount(Math.Gmp.Native.mpz_t)">mpz_popcount</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_hamdist(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_hamdist</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_scan0(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_scan0</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_scan1(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_scan1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_clrbit(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_clrbit</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_combit(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_combit</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tstbit(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_tstbit</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Logic_and_Bit_Fiddling">Integer Logic and Bit Fiddling</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Logic-and-Bit-Fiddling.html#Integer-Logic-and-Bit-Fiddling">GNU MP - Integer Logic and Bit Fiddling</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of rop to 70.
            mpz_t rop = new mpz_t();
            gmp_lib.mpz_init_set_si(rop, 70);
            
            // Set bit 3 of rop.
            gmp_lib.mpz_setbit(rop, 3U);
            
            // Assert that rop is 78.
            Assert.IsTrue(gmp_lib.mpz_get_si(rop) == 78);
            
            // Release unmanaged memory allocated for rop.
            gmp_lib.mpz_clear(rop);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of rop to 70.
            Dim rop As New mpz_t()
            gmp_lib.mpz_init_set_si(rop, 70)
            
            ' Set bit 3 of rop.
            gmp_lib.mpz_setbit(rop, 3UI)
            
            ' Assert that rop is 78.
            Assert.IsTrue(gmp_lib.mpz_get_si(rop) = 78)
            
            ' Release unmanaged memory allocated for rop.
            gmp_lib.mpz_clear(rop)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_sgn(Math.Gmp.Native.mpz_t)">
            <summary>
            Return +1 if <paramref name="op"/> &gt; 0, 0 if <paramref name="op"/> = 0, and -1 if <paramref name="op"/> &lt; 0.
            </summary>
            <param name="op">The operand integer.</param>
            <returns>Return +1 if <paramref name="op"/> &gt; 0, 0 if <paramref name="op"/> = 0, and -1 if <paramref name="op"/> &lt; 0.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cmp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cmp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cmp_d(Math.Gmp.Native.mpz_t,System.Double)">mpz_cmp_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cmp_si(Math.Gmp.Native.mpz_t,System.Int32)">mpz_cmp_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cmp_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_cmp_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cmpabs(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cmpabs</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cmpabs_d(Math.Gmp.Native.mpz_t,System.Double)">mpz_cmpabs_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cmpabs_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_cmpabs_ui</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Comparisons">Integer Comparisons</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Comparisons.html#Integer-Comparisons">GNU MP - Integer Comparisons</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op to -10.
            mpz_t op = new mpz_t();
            gmp_lib.mpz_init_set_si(op, -10);
            
            // Assert that the sign of op is -1.
            Assert.IsTrue(gmp_lib.mpz_sgn(op) == -1);
            
            // Release unmanaged memory allocated for op.
            gmp_lib.mpz_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op to -10.
            Dim op As New mpz_t()
            gmp_lib.mpz_init_set_si(op, -10)
            
            ' Assert that the sign of op is -1.
            Assert.IsTrue(gmp_lib.mpz_sgn(op) = -1)
            
            ' Release unmanaged memory allocated for op.
            gmp_lib.mpz_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_size(Math.Gmp.Native.mpz_t)">
             <summary>
             Return the size of <paramref name="op"/> measured in number of limbs.
             </summary>
             <param name="op">The operand integer.</param>
             <returns>The size of <paramref name="op"/> measured in number of limbs.</returns>
             <remarks>
             <para>
             If <paramref name="op"/> is zero, the returned value will be zero.
             </para>
             </remarks>
             <seealso cref="M:Math.Gmp.Native.gmp_lib._mpz_realloc(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">_mpz_realloc</seealso>
             <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_getlimbn(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">mpz_getlimbn</seealso>
             <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_limbs_read(Math.Gmp.Native.mpz_t)">mpz_limbs_read</seealso>
             <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_limbs_write(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">mpz_limbs_write</seealso>
             <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_limbs_modify(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">mpz_limbs_modify</seealso>
             <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_limbs_finish(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">mpz_limbs_finish</seealso>
             <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_roinit_n(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpz_roinit_n</seealso>
             <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Special_Functions">Integer Special Functions</a></seealso>
             <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Special-Functions.html#Integer-Special-Functions">GNU MP - Integer Special Functions</a></seealso>
             <example>
             <code language="C#">
             // Create and initialize new integer x.
             mpz_t op = new mpz_t();
             char_ptr value = new char_ptr("1000 ABCD 1234 7AB8 24FD");
             gmp_lib.mpz_init_set_str(op, value, 16);
            
             // Assert the value of the limbs of op.
             if (gmp_lib.mp_bytes_per_limb == 4)
                 Assert.IsTrue(gmp_lib.mpz_size(op) == 3);
             else // gmp_lib.mp_bytes_per_limb == 8
                 Assert.IsTrue(gmp_lib.mpz_size(op) == 2);
             
             // Release unmanaged memory allocated for op and value.
             gmp_lib.mpz_clear(op);
             gmp_lib.free(value);
             </code> 
             <code language="VB.NET">
             ' Create and initialize new integer x.
             Dim op As New mpz_t()
             Dim value As New char_ptr("1000 ABCD 1234 7AB8 24FD")
             gmp_lib.mpz_init_set_str(op, value, 16)
             
             ' Assert the value of the limbs of op.
             If gmp_lib.mp_bytes_per_limb = 4 Then
                 Assert.IsTrue(gmp_lib.mpz_size(op) = 3)
             Else ' gmp_lib.mp_bytes_per_limb == 8
                 Assert.IsTrue(gmp_lib.mpz_size(op) = 2)
             End If
             
             ' Release unmanaged memory allocated for op and value.
             gmp_lib.mpz_clear(op)
             gmp_lib.free(value)
             </code> 
             </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_sizeinbase(Math.Gmp.Native.mpz_t,System.Int32)">
            <summary>
            Return the size of <paramref name="op"/> measured in number of digits in the given <paramref name="base"/>.
            </summary>
            <param name="op">The operand integer</param>
            <param name="base">The base.</param>
            <returns>The size of <paramref name="op"/> measured in number of digits in the given <paramref name="base"/>.</returns>
            <remarks>
            <para>
            <paramref name="base"/> can vary from 2 to 62.
            The sign of <paramref name="op"/> is ignored, just the absolute value is used.
            The result will be either exact or 1 too big.
            If <paramref name="base"/> is a power of 2, the result is always exact.
            If <paramref name="op"/> is zero the return value is always 1.
            </para>
            <para>
            This function can be used to determine the space required when converting <paramref name="op"/> to a string.
            The right amount of allocation is normally two more than the value returned by <see cref="M:Math.Gmp.Native.gmp_lib.mpz_sizeinbase(Math.Gmp.Native.mpz_t,System.Int32)">mpz_sizeinbase</see>,
            one extra for a minus sign and one for the null-terminator. 
            </para>
            <para>
            It will be noted that mpz_sizeinbase(<paramref name="op"/>, 2) can be used to locate the most
            significant 1 bit in <paramref name="op"/>, counting from 1.
            (Unlike the bitwise functions which start from 0,
            see <a href="https://gmplib.org/manual/Integer-Logic-and-Bit-Fiddling.html#Integer-Logic-and-Bit-Fiddling">GNU MP - Logical and Bit Manipulation Functions</a>.)
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_ulong_p(Math.Gmp.Native.mpz_t)">mpz_fits_ulong_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_slong_p(Math.Gmp.Native.mpz_t)">mpz_fits_slong_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_uint_p(Math.Gmp.Native.mpz_t)">mpz_fits_uint_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_sint_p(Math.Gmp.Native.mpz_t)">mpz_fits_sint_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_ushort_p(Math.Gmp.Native.mpz_t)">mpz_fits_ushort_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fits_sshort_p(Math.Gmp.Native.mpz_t)">mpz_fits_sshort_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_odd_p(Math.Gmp.Native.mpz_t)">mpz_odd_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_even_p(Math.Gmp.Native.mpz_t)">mpz_even_p</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Miscellaneous_Integer_Functions">Miscellaneous Integer Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Miscellaneous-Integer-Functions.html#Miscellaneous-Integer-Functions">GNU MP - Miscellaneous Integer Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op to 10000.
            mpz_t op = new mpz_t();
            gmp_lib.mpz_init_set_si(op, 10000);
            
            // Assert size in different bases.
            Assert.IsTrue(gmp_lib.mpz_sizeinbase(op, 2) == 14);
            Assert.IsTrue(gmp_lib.mpz_sizeinbase(op, 8) == 5);
            Assert.IsTrue(gmp_lib.mpz_sizeinbase(op, 10) == 5);
            Assert.IsTrue(gmp_lib.mpz_sizeinbase(op, 16) == 4);
            
            // Release unmanaged memory allocated for op.
            gmp_lib.mpz_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op to 10000.
            Dim op As New mpz_t()
            gmp_lib.mpz_init_set_si(op, 10000)
            
            ' Assert size in different bases.
            Assert.IsTrue(gmp_lib.mpz_sizeinbase(op, 2) = 14)
            Assert.IsTrue(gmp_lib.mpz_sizeinbase(op, 8) = 5)
            Assert.IsTrue(gmp_lib.mpz_sizeinbase(op, 10) = 5)
            Assert.IsTrue(gmp_lib.mpz_sizeinbase(op, 16) = 4)
            
            ' Release unmanaged memory allocated for op.
            gmp_lib.mpz_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_sqrt(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">
            <summary>
            Set <paramref name="rop"/> to the truncated integer part of the square root of <paramref name="op"/>.
            </summary>
            <param name="rop">The result square root integer.</param>
            <param name="op">The operand integer.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_perfect_power_p(Math.Gmp.Native.mpz_t)">mpz_perfect_power_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_perfect_square_p(Math.Gmp.Native.mpz_t)">mpz_perfect_square_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_root(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_root</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_rootrem(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_rootrem</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_sqrtrem(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_sqrtrem</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Roots">Integer Roots</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Roots.html#Integer-Roots">GNU MP - Integer Roots</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op to 10000.
            mpz_t op = new mpz_t();
            gmp_lib.mpz_init_set_si(op, 10000);
            
            // Create, initialize, and set the value of rop to 0.
            mpz_t rop = new mpz_t();
            gmp_lib.mpz_init(rop);
            
            // Set rop = trunc(sqrt(op)).
            gmp_lib.mpz_sqrt(rop, op);
            
            // Assert that rop is 100.
            Assert.IsTrue(gmp_lib.mpz_get_si(rop) == 100);
            
            // Release unmanaged memory allocated for rop and op.
            gmp_lib.mpz_clears(rop, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op to 10000.
            Dim op As New mpz_t()
            gmp_lib.mpz_init_set_si(op, 10000)
            
            ' Create, initialize, and set the value of rop to 0.
            Dim rop As New mpz_t()
            gmp_lib.mpz_init(rop)
            
            ' Set rop = trunc(sqrt(op)).
            gmp_lib.mpz_sqrt(rop, op)
            
            ' Assert that rop is 100.
            Assert.IsTrue(gmp_lib.mpz_get_si(rop) = 100)
            
            ' Release unmanaged memory allocated for rop and op.
            gmp_lib.mpz_clears(rop, op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_sqrtrem(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">
            <summary>
            Set <paramref name="rop1"/> to the truncated integer part of the square root of <paramref name="op"/>, like <see cref="M:Math.Gmp.Native.gmp_lib.mpz_sqrt(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_sqrt</see>. Set <paramref name="rop2"/> to the remainder <paramref name="op"/> - <paramref name="rop1"/> * <paramref name="rop1"/>, which will be zero if <paramref name="op"/> is a perfect square.
            </summary>
            <param name="rop1">The result square root integer.</param>
            <param name="rop2">The result remainder integer.</param>
            <param name="op">The operand integer.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_perfect_power_p(Math.Gmp.Native.mpz_t)">mpz_perfect_power_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_perfect_square_p(Math.Gmp.Native.mpz_t)">mpz_perfect_square_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_root(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_root</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_rootrem(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_rootrem</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_sqrt(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_sqrt</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Roots">Integer Roots</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Roots.html#Integer-Roots">GNU MP - Integer Roots</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op to 10000.
            mpz_t op = new mpz_t();
            gmp_lib.mpz_init_set_si(op, 10000);
            
            // Create, initialize, and set the values of root and rem to 0.
            mpz_t root = new mpz_t();
            mpz_t rem = new mpz_t();
            gmp_lib.mpz_inits(root, rem);
            
            // Set root = trunc(sqrt(op)), and rem = op - root.
            gmp_lib.mpz_sqrtrem(root, rem, op);
            
            // Assert that root is 100, and rem is 0.
            Assert.IsTrue(gmp_lib.mpz_get_si(root) == 100);
            Assert.IsTrue(gmp_lib.mpz_get_si(rem) == 0);
            
            // Release unmanaged memory allocated for root, rem, and op.
            gmp_lib.mpz_clears(root, rem, op, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op to 10000.
            Dim op As New mpz_t()
            gmp_lib.mpz_init_set_si(op, 10000)
            
            ' Create, initialize, and set the values of root and rem to 0.
            Dim root As New mpz_t()
            Dim[rem] As New mpz_t()
            gmp_lib.mpz_inits(root, [rem])
            
            ' Set root = trunc(sqrt(op)), and rem = op - root.
            gmp_lib.mpz_sqrtrem(root, [rem], op)
            
            ' Assert that root is 100, and rem is 0.
            Assert.IsTrue(gmp_lib.mpz_get_si(root) = 100)
            Assert.IsTrue(gmp_lib.mpz_get_si([rem]) = 0)
            
            ' Release unmanaged memory allocated for root, rem, and op.
            gmp_lib.mpz_clears(root, [rem], op, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_sub(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> - <paramref name="op2"/>.
            </summary>
            <param name="rop">The result integer.</param>
            <param name="op1">The first operand integer.</param>
            <param name="op2">The second operand integer.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_abs(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_abs</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_add(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_addmul(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_addmul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mul(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_neg(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_sub_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_sub_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_submul(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_submul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_ui_sub(Math.Gmp.Native.mpz_t,System.UInt32,Math.Gmp.Native.mpz_t)">mpz_ui_sub</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Arithmetic">Integer Arithmetic</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Arithmetic.html#Integer-Arithmetic">GNU MP - Integer Arithmetic</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of x to 10000.
            mpz_t x = new mpz_t();
            gmp_lib.mpz_init_set_ui(x, 10000U);
            
            // Create, initialize, and set the value of y to 12222.
            mpz_t y = new mpz_t();
            gmp_lib.mpz_init_set_ui(y, 12222U);
            
            // Create, initialize, and set the value of z to 0.
            mpz_t z = new mpz_t();
            gmp_lib.mpz_init(z);
            
            // Set z = x - y.
            gmp_lib.mpz_sub(z, x, y);
            
            // Assert that z = x - y.
            Assert.IsTrue(gmp_lib.mpz_get_si(z) == -2222);
            
            // Release unmanaged memory allocated for x, y, and z.
            gmp_lib.mpz_clears(x, y, z, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of x to 10000.
            Dim x As New mpz_t()
            gmp_lib.mpz_init_set_ui(x, 10000UI)
            
            ' Create, initialize, and set the value of y to 12222.
            Dim y As New mpz_t()
            gmp_lib.mpz_init_set_ui(y, 12222UI)
            
            ' Create, initialize, and set the value of z to 0.
            Dim z As New mpz_t()
            gmp_lib.mpz_init(z)
            
            ' Set z = x - y.
            gmp_lib.mpz_sub(z, x, y)
            
            ' Assert that z = x - y.
            Assert.IsTrue(gmp_lib.mpz_get_si(z) = -2222)
            
            ' Release unmanaged memory allocated for x, y, and z.
            gmp_lib.mpz_clears(x, y, z, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_sub_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> - <paramref name="op2"/>.
            </summary>
            <param name="rop">The result integer.</param>
            <param name="op1">The first operand integer.</param>
            <param name="op2">The second operand integer.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_abs(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_abs</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_add(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_addmul(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_addmul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mul(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_neg(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_sub(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_submul(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_submul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_ui_sub(Math.Gmp.Native.mpz_t,System.UInt32,Math.Gmp.Native.mpz_t)">mpz_ui_sub</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Arithmetic">Integer Arithmetic</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Arithmetic.html#Integer-Arithmetic">GNU MP - Integer Arithmetic</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of x to 10000.
            mpz_t x = new mpz_t();
            gmp_lib.mpz_init_set_ui(x, 10000U);
            
            // Create, initialize, and set the value of z to 0.
            mpz_t z = new mpz_t();
            gmp_lib.mpz_init(z);
            
            // Set z = x - 12222.
            gmp_lib.mpz_sub_ui(z, x, 12222U);
            
            // Assert that z = x - 12222.
            Assert.IsTrue(gmp_lib.mpz_get_si(z) == -2222);
            
            // Release unmanaged memory allocated for x and z.
            gmp_lib.mpz_clears(x, z, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of x to 10000.
            Dim x As New mpz_t()
            gmp_lib.mpz_init_set_ui(x, 10000UI)
            
            ' Create, initialize, and set the value of z to 0.
            Dim z As New mpz_t()
            gmp_lib.mpz_init(z)
            
            ' Set z = x - 12222.
            gmp_lib.mpz_sub_ui(z, x, 12222UI)
            
            ' Assert that z = x - 12222.
            Assert.IsTrue(gmp_lib.mpz_get_si(z) = -2222)
            
            ' Release unmanaged memory allocated for x and z.
            gmp_lib.mpz_clears(x, z, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_ui_sub(Math.Gmp.Native.mpz_t,System.UInt32,Math.Gmp.Native.mpz_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> - <paramref name="op2"/>.
            </summary>
            <param name="rop">The result integer.</param>
            <param name="op1">The first operand integer.</param>
            <param name="op2">The second operand integer.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_abs(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_abs</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_add(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_addmul(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_addmul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mul(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_neg(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_sub(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_sub_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_sub_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_submul(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_submul</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Arithmetic">Integer Arithmetic</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Arithmetic.html#Integer-Arithmetic">GNU MP - Integer Arithmetic</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of x to 10000.
            mpz_t x = new mpz_t();
            gmp_lib.mpz_init_set_ui(x, 10000U);
            
            // Create, initialize, and set the value of z to 0.
            mpz_t z = new mpz_t();
            gmp_lib.mpz_init(z);
            
            // Set z = 12222 - x.
            gmp_lib.mpz_ui_sub(z, 12222U, x);
            
            // Assert that z = 12222 - x.
            Assert.IsTrue(gmp_lib.mpz_get_si(z) == 2222);
            
            // Release unmanaged memory allocated for x and z.
            gmp_lib.mpz_clears(x, z, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of x to 10000.
            Dim x As New mpz_t()
            gmp_lib.mpz_init_set_ui(x, 10000UI)
            
            ' Create, initialize, and set the value of z to 0.
            Dim z As New mpz_t()
            gmp_lib.mpz_init(z)
            
            ' Set z = 12222 - x.
            gmp_lib.mpz_ui_sub(z, 12222UI, x)
            
            ' Assert that z = 12222 - x.
            Assert.IsTrue(gmp_lib.mpz_get_si(z) = 2222)
            
            ' Release unmanaged memory allocated for x and z.
            gmp_lib.mpz_clears(x, z, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_submul(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="rop"/> - <paramref name="op1"/> * <paramref name="op2"/>.
            </summary>
            <param name="rop">The result integer.</param>
            <param name="op1">The first operand integer.</param>
            <param name="op2">The second operand integer.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_abs(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_abs</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_add(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_addmul(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_addmul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mul(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_neg(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_sub(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_submul_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_submul_ui</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Arithmetic">Integer Arithmetic</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Arithmetic.html#Integer-Arithmetic">GNU MP - Integer Arithmetic</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of x to 10000.
            mpz_t x = new mpz_t();
            gmp_lib.mpz_init_set_ui(x, 10000U);
            
            // Create, initialize, and set the value of y to 12222.
            mpz_t y = new mpz_t();
            gmp_lib.mpz_init_set_ui(y, 12222U);
            
            // Create, initialize, and set the value of z to 20000.
            mpz_t z = new mpz_t();
            gmp_lib.mpz_init_set_si(z, 20000);
            
            // Set z -= x * y.
            gmp_lib.mpz_submul(z, x, y);
            
            // Assert that z has been decremented by 10000 * 12222.
            Assert.IsTrue(gmp_lib.mpz_get_si(z) == 20000 - 10000 * 12222);
            
            // Release unmanaged memory allocated for x, y, and z.
            gmp_lib.mpz_clears(x, y, z, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of x to 10000.
            Dim x As New mpz_t()
            gmp_lib.mpz_init_set_ui(x, 10000UI)
            
            ' Create, initialize, and set the value of y to 12222.
            Dim y As New mpz_t()
            gmp_lib.mpz_init_set_ui(y, 12222UI)
            
            ' Create, initialize, and set the value of z to 20000.
            Dim z As New mpz_t()
            gmp_lib.mpz_init_set_si(z, 20000)
            
            ' Set z -= x * y.
            gmp_lib.mpz_submul(z, x, y)
            
            ' Assert that z has been decremented by 10000 * 12222.
            Assert.IsTrue(gmp_lib.mpz_get_si(z) = 20000 - 10000 * 12222)
            
            ' Release unmanaged memory allocated for x, y, and z.
            gmp_lib.mpz_clears(x, y, z, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_submul_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="rop"/> - <paramref name="op1"/> * <paramref name="op2"/>.
            </summary>
            <param name="rop">The result integer.</param>
            <param name="op1">The first operand integer.</param>
            <param name="op2">The second operand integer.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_abs(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_abs</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_add(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_addmul(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_addmul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mul(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_neg(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_sub(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_submul(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_submul</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Arithmetic">Integer Arithmetic</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Arithmetic.html#Integer-Arithmetic">GNU MP - Integer Arithmetic</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of x to -10000.
            mpz_t x = new mpz_t();
            gmp_lib.mpz_init_set_si(x, -10000);
            
            // Create, initialize, and set the value of z to 20000.
            mpz_t z = new mpz_t();
            gmp_lib.mpz_init_set_si(z, 20000);
            
            // Set z -= x * 12222U.
            gmp_lib.mpz_submul_ui(z, x, 12222U);
            
            // Assert that z has been decremented by -10000 * 12222.
            Assert.IsTrue(gmp_lib.mpz_get_si(z) == 20000 - -10000 * 12222);
            
            // Release unmanaged memory allocated for x and z.
            gmp_lib.mpz_clears(x, z, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of x to -10000.
            Dim x As New mpz_t()
            gmp_lib.mpz_init_set_si(x, -10000)
            
            ' Create, initialize, and set the value of z to 20000.
            Dim z As New mpz_t()
            gmp_lib.mpz_init_set_si(z, 20000)
            
            ' Set z -= x * 12222U.
            gmp_lib.mpz_submul_ui(z, x, 12222UI)
            
            ' Assert that z has been decremented by -10000 * 12222.
            Assert.IsTrue(gmp_lib.mpz_get_si(z) = 20000 - -10000 * 12222)
            
            ' Release unmanaged memory allocated for x and z.
            gmp_lib.mpz_clears(x, z, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_swap(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">
            <summary>
            Swap the values <paramref name="rop1"/> and <paramref name="rop2"/> efficiently.
            </summary>
            <param name="rop1">The first integer.</param>
            <param name="rop2">The second integer.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_set(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_set</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_set_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_set_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_set_si(Math.Gmp.Native.mpz_t,System.Int32)">mpz_set_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_set_d(Math.Gmp.Native.mpz_t,System.Double)">mpz_set_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_set_q(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpq_t)">mpz_set_q</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_set_f(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpf_t)">mpz_set_f</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_set_str(Math.Gmp.Native.mpz_t,Math.Gmp.Native.char_ptr,System.Int32)">mpz_set_str</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Assigning_Integers">Assigning Integers</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Assigning-Integers.html#Assigning-Integers">GNU MP - Assigning Integers</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new integer x to 10.
            mpz_t x = new mpz_t();
            gmp_lib.mpz_init_set_si(x, 10);
            
            // Create, initialize, and set a new integer x to -210.
            mpz_t y = new mpz_t();
            gmp_lib.mpz_init_set_si(y, -210);
            
            // Swap the values of x and y.
            gmp_lib.mpz_swap(x, y);
            
            // Assert that the values have been swapped.
            Assert.IsTrue(gmp_lib.mpz_get_si(x) == -210);
            Assert.IsTrue(gmp_lib.mpz_get_si(y) == 10);
            
            // Release unmanaged memory allocated for x and y.
            gmp_lib.mpz_clears(x, y, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new integer x to 10.
            Dim x As New mpz_t()
            gmp_lib.mpz_init_set_si(x, 10)
            
            ' Create, initialize, and set a new integer x to -210.
            Dim y As New mpz_t()
            gmp_lib.mpz_init_set_si(y, -210)
            
            ' Swap the values of x and y.
            gmp_lib.mpz_swap(x, y)
            
            ' Assert that the values have been swapped.
            Assert.IsTrue(gmp_lib.mpz_get_si(x) = -210)
            Assert.IsTrue(gmp_lib.mpz_get_si(y) = 10)
            
            ' Release unmanaged memory allocated for x and y.
            gmp_lib.mpz_clears(x, y, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_ui(Math.Gmp.Native.mpz_t,System.UInt32)">
            <summary>
            Return the remainder | r | where r = <paramref name="n"/> - q * <paramref name="d"/>, and where q = trunc(<paramref name="n"/> / <paramref name="d"/>).
            </summary>
            <param name="n">The numerator integer.</param>
            <param name="d">The denominator integer.</param>
            <returns>The remainder | r | where r = <paramref name="n"/> - q * <paramref name="d"/>, and where q = trunc(<paramref name="n"/> / <paramref name="d"/>).</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_congruent_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_congruent_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divexact(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divexact</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divisible_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divisible_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_fdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mod(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_mod</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_q(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_q</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_r(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_r</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_q_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_tdiv_q_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_r_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_tdiv_r_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_qr_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_tdiv_qr_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_q_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_tdiv_q_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_r_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_tdiv_r_2exp</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Division">Integer Division</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Division.html#Integer-Division">GNU MP - Integer Division</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of n to 10000.
            mpz_t n = new mpz_t();
            gmp_lib.mpz_init_set_si(n, 10000);
            
            // Assert that returned value is |n - 3 * trunc(n / 3)|.
            Assert.IsTrue(gmp_lib.mpz_tdiv_ui(n, 3U) == 1U);
            
            // Release unmanaged memory allocated for n.
            gmp_lib.mpz_clear(n);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of n to 10000.
            Dim n As New mpz_t()
            gmp_lib.mpz_init_set_si(n, 10000)
            
            ' Assert that returned value is |n - 3 * trunc(n / 3)|.
            Assert.IsTrue(gmp_lib.mpz_tdiv_ui(n, 3UI) = 1UI)
            
            ' Release unmanaged memory allocated for n.
            gmp_lib.mpz_clear(n)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_q(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">
            <summary>
            Set the quotient <paramref name="q"/> to trunc(<paramref name="n"/> / <paramref name="d"/>).
            </summary>
            <param name="q">The result quotient integer.</param>
            <param name="n">The numerator integer.</param>
            <param name="d">The denominator integer.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_congruent_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_congruent_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divexact(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divexact</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divisible_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divisible_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_fdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mod(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_mod</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_r(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_r</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_q_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_tdiv_q_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_r_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_tdiv_r_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_qr_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_tdiv_qr_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_tdiv_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_q_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_tdiv_q_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_r_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_tdiv_r_2exp</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Division">Integer Division</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Division.html#Integer-Division">GNU MP - Integer Division</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of n to 10000.
            mpz_t n = new mpz_t();
            gmp_lib.mpz_init_set_si(n, 10000);
            
            // Create, initialize, and set the value of d to 3.
            mpz_t d = new mpz_t();
            gmp_lib.mpz_init_set_si(d, 3);
            
            // Create, initialize, and set the value of q to 0.
            mpz_t q = new mpz_t();
            gmp_lib.mpz_init(q);
            
            // Set q = trunc(n / d).
            gmp_lib.mpz_tdiv_q(q, n, d);
            
            // Assert that q is trunc(10000 / 3).
            Assert.IsTrue(gmp_lib.mpz_get_si(q) == 3333);
            
            // Release unmanaged memory allocated for n, d, and q.
            gmp_lib.mpz_clears(n, d, q, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of n to 10000.
            Dim n As New mpz_t()
            gmp_lib.mpz_init_set_si(n, 10000)
            
            ' Create, initialize, and set the value of d to 3.
            Dim d As New mpz_t()
            gmp_lib.mpz_init_set_si(d, 3)
            
            ' Create, initialize, and set the value of q to 0.
            Dim q As New mpz_t()
            gmp_lib.mpz_init(q)
            
            ' Set q = trunc(n / d).
            gmp_lib.mpz_tdiv_q(q, n, d)
            
            ' Assert that q is trunc(10000 / 3).
            Assert.IsTrue(gmp_lib.mpz_get_si(q) = 3333)
            
            ' Release unmanaged memory allocated for n, d, and q.
            gmp_lib.mpz_clears(n, d, q, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_q_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">
            <summary>
            Set the quotient <paramref name="q"/> to trunc(<paramref name="n"/> / 2^<paramref name="b"/>).
            </summary>
            <param name="q">The result quotient integer.</param>
            <param name="n">The numerator integer.</param>
            <param name="b">The exponent of the power of two denominator.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_congruent_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_congruent_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divexact(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divexact</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divisible_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divisible_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_fdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mod(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_mod</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_q(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_q</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_r(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_r</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_q_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_tdiv_q_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_r_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_tdiv_r_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_qr_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_tdiv_qr_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_tdiv_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_r_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_tdiv_r_2exp</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Division">Integer Division</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Division.html#Integer-Division">GNU MP - Integer Division</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of n to 10001.
            mpz_t n = new mpz_t();
            gmp_lib.mpz_init_set_si(n, 10001);
            
            // Create, initialize, and set the value of q to 0.
            mpz_t q = new mpz_t();
            gmp_lib.mpz_init(q);
            
            // Set q = trunc(n / 2^2).
            gmp_lib.mpz_tdiv_q_2exp(q, n, 2U);
            
            // Assert that q is trunc(10001 / 4).
            Assert.IsTrue(gmp_lib.mpz_get_si(q) == 2500);
            
            // Release unmanaged memory allocated for n and q.
            gmp_lib.mpz_clears(n, q, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of n to 10001.
            Dim n As New mpz_t()
            gmp_lib.mpz_init_set_si(n, 10001)
            
            ' Create, initialize, and set the value of q to 0.
            Dim q As New mpz_t()
            gmp_lib.mpz_init(q)
            
            ' Set q = trunc(n / 2^2).
            gmp_lib.mpz_tdiv_q_2exp(q, n, 2UI)
            
            ' Assert that q is trunc(10001 / 4).
            Assert.IsTrue(gmp_lib.mpz_get_si(q) = 2500)
            
            ' Release unmanaged memory allocated for n and q.
            gmp_lib.mpz_clears(n, q, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_q_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">
            <summary>
            Set the quotient <paramref name="q"/> to trunc(<paramref name="n"/> / <paramref name="d"/>), and return the remainder r = | <paramref name="n"/> - <paramref name="q"/> * <paramref name="d"/> |.
            </summary>
            <param name="q">The result quotient integer.</param>
            <param name="n">The numerator integer.</param>
            <param name="d">The denominator integer.</param>
            <returns>Return the remainder r = | <paramref name="n"/> - <paramref name="q"/> * <paramref name="d"/> |.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_congruent_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_congruent_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divexact(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divexact</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divisible_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divisible_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_fdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mod(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_mod</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_q(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_q</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_r(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_r</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_r_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_tdiv_r_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_qr_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_tdiv_qr_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_tdiv_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_q_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_tdiv_q_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_r_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_tdiv_r_2exp</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Division">Integer Division</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Division.html#Integer-Division">GNU MP - Integer Division</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of n to 10000.
            mpz_t n = new mpz_t();
            gmp_lib.mpz_init_set_si(n, 10000);
            
            // Create, initialize, and set the value of q to 0.
            mpz_t q = new mpz_t();
            gmp_lib.mpz_init(q);
            
            // Set q = trunc(n / 3) and return r = n - 3 * q.
            // Assert q and r values.
            Assert.IsTrue(gmp_lib.mpz_tdiv_q_ui(q, n, 3U) == 1U);
            Assert.IsTrue(gmp_lib.mpz_get_si(q) == 3333);
            
            // Release unmanaged memory allocated for n and q.
            gmp_lib.mpz_clears(n, q, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of n to 10000.
            Dim n As New mpz_t()
            gmp_lib.mpz_init_set_si(n, 10000)
            
            ' Create, initialize, and set the value of q to 0.
            Dim q As New mpz_t()
            gmp_lib.mpz_init(q)
            
            ' Set q = trunc(n / 3) and return r = n - 3 * q.
            ' Assert q and r values.
            Assert.IsTrue(gmp_lib.mpz_tdiv_q_ui(q, n, 3UI) = 1UI)
            Assert.IsTrue(gmp_lib.mpz_get_si(q) = 3333)
            
            ' Release unmanaged memory allocated for n and q.
            gmp_lib.mpz_clears(n, q, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">
            <summary>
            Set the quotient <paramref name="q"/> to trunc(<paramref name="n"/> / <paramref name="d"/>), and set the remainder <paramref name="r"/> to <paramref name="n"/> - <paramref name="q"/> * <paramref name="d"/>.
            </summary>
            <param name="q">The result quotient integer.</param>
            <param name="r">The result remainder integer.</param>
            <param name="n">The numerator integer.</param>
            <param name="d">The denominator integer.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_congruent_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_congruent_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divexact(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divexact</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divisible_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divisible_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_fdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mod(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_mod</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_q(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_q</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_r(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_r</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_q_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_tdiv_q_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_r_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_tdiv_r_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_qr_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_tdiv_qr_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_tdiv_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_q_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_tdiv_q_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_r_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_tdiv_r_2exp</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Division">Integer Division</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Division.html#Integer-Division">GNU MP - Integer Division</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of n to 10000.
            mpz_t n = new mpz_t();
            gmp_lib.mpz_init_set_si(n, 10000);
            
            // Create, initialize, and set the value of d to 3.
            mpz_t d = new mpz_t();
            gmp_lib.mpz_init_set_si(d, 3);
            
            // Create, initialize, and set the values of q and r to 0.
            mpz_t q = new mpz_t();
            mpz_t r = new mpz_t();
            gmp_lib.mpz_inits(q, r, null);
            
            // Set q = trunc(n / 3) and r = n - d * q.
            gmp_lib.mpz_tdiv_qr(q, r, n, d);
            
            // Assert that q is 3333, and that r is 1.
            Assert.IsTrue(gmp_lib.mpz_get_si(q) == 3333);
            Assert.IsTrue(gmp_lib.mpz_get_si(r) == 1);
            
            // Release unmanaged memory allocated for n, d, q, and r.
            gmp_lib.mpz_clears(n, d, q, r, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of n to 10000.
            Dim n As New mpz_t()
            gmp_lib.mpz_init_set_si(n, 10000)
            
            ' Create, initialize, and set the value of d to 3.
            Dim d As New mpz_t()
            gmp_lib.mpz_init_set_si(d, 3)
            
            ' Create, initialize, and set the values of q and r to 0.
            Dim q As New mpz_t()
            Dim r As New mpz_t()
            gmp_lib.mpz_inits(q, r, Nothing)
            
            ' Set q = trunc(n / 3) and r = n - d * q.
            gmp_lib.mpz_tdiv_qr(q, r, n, d)
            
            ' Assert that q is 3333, and that r is 1.
            Assert.IsTrue(gmp_lib.mpz_get_si(q) = 3333)
            Assert.IsTrue(gmp_lib.mpz_get_si(r) = 1)
            
            ' Release unmanaged memory allocated for n, d, q, and r.
            gmp_lib.mpz_clears(n, d, q, r, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_qr_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">
            <summary>
            Set quotient <paramref name="q"/> to trunc(<paramref name="n"/> / <paramref name="d"/>), set the remainder <paramref name="r"/> to <paramref name="n"/> - <paramref name="q"/> * <paramref name="d"/>, and return | <paramref name="r"/> |.
            </summary>
            <param name="q">The result quotient integer.</param>
            <param name="r">The result remainder integer.</param>
            <param name="n">The numerator integer.</param>
            <param name="d">The denominator integer.</param>
            <returns>Return | <paramref name="r"/> |.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_congruent_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_congruent_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divexact(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divexact</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divisible_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divisible_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_fdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mod(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_mod</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_q(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_q</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_r(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_r</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_q_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_tdiv_q_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_r_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_tdiv_r_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_tdiv_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_q_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_tdiv_q_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_r_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_tdiv_r_2exp</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Division">Integer Division</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Division.html#Integer-Division">GNU MP - Integer Division</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of n to 10000.
            mpz_t n = new mpz_t();
            gmp_lib.mpz_init_set_si(n, 10000);
            
            // Create, initialize, and set the values of q and r to 0.
            mpz_t q = new mpz_t();
            mpz_t r = new mpz_t();
            gmp_lib.mpz_inits(q, r, null);
            
            // Set q = trunc(n / 3), r = n - d * q, and return r.
            Assert.IsTrue(gmp_lib.mpz_tdiv_qr_ui(q, r, n, 3U) == 1U);
            
            // Assert that q is 3333, and that r is 1.
            Assert.IsTrue(gmp_lib.mpz_get_si(q) == 3333);
            Assert.IsTrue(gmp_lib.mpz_get_si(r) == 1);
            
            // Release unmanaged memory allocated for n, q, and r.
            gmp_lib.mpz_clears(n, q, r, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of n to 10000.
            Dim n As New mpz_t()
            gmp_lib.mpz_init_set_si(n, 10000)
            
            ' Create, initialize, and set the values of q and r to 0.
            Dim q As New mpz_t()
            Dim r As New mpz_t()
            gmp_lib.mpz_inits(q, r, Nothing)
            
            ' Set q = trunc(n / 3), r = n - d * q, and return r.
            Assert.IsTrue(gmp_lib.mpz_tdiv_qr_ui(q, r, n, 3UI) = 1UI)
            
            ' Assert that q is 3333, and that r is 1.
            Assert.IsTrue(gmp_lib.mpz_get_si(q) = 3333)
            Assert.IsTrue(gmp_lib.mpz_get_si(r) = 1)
            
            ' Release unmanaged memory allocated for n, q, and r.
            gmp_lib.mpz_clears(n, q, r, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_r(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">
            <summary>
            Set the remainder <paramref name="r"/> to <paramref name="n"/> - q * <paramref name="d"/> where q = trunc(<paramref name="n"/> / <paramref name="d"/>).
            </summary>
            <param name="r">The result remainder integer.</param>
            <param name="n">The numerator integer.</param>
            <param name="d">The denominator integer.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_congruent_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_congruent_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divexact(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divexact</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divisible_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divisible_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_fdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mod(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_mod</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_q(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_q</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_q_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_tdiv_q_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_r_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_tdiv_r_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_qr_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_tdiv_qr_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_tdiv_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_q_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_tdiv_q_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_r_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_tdiv_r_2exp</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Division">Integer Division</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Division.html#Integer-Division">GNU MP - Integer Division</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of n to 10000.
            mpz_t n = new mpz_t();
            gmp_lib.mpz_init_set_si(n, 10000);
            
            // Create, initialize, and set the value of d to 3.
            mpz_t d = new mpz_t();
            gmp_lib.mpz_init_set_si(d, 3);
            
            // Create, initialize, and set the value of r to 0.
            mpz_t r = new mpz_t();
            gmp_lib.mpz_init(r);
            
            // Set r = n - d * trunc(n / d).
            gmp_lib.mpz_tdiv_r(r, n, d);
            
            // Assert that r is 1.
            Assert.IsTrue(gmp_lib.mpz_get_si(r) == 1);
            
            // Release unmanaged memory allocated for n, d, and r.
            gmp_lib.mpz_clears(n, d, r, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of n to 10000.
            Dim n As New mpz_t()
            gmp_lib.mpz_init_set_si(n, 10000)
            
            ' Create, initialize, and set the value of d to 3.
            Dim d As New mpz_t()
            gmp_lib.mpz_init_set_si(d, 3)
            
            ' Create, initialize, and set the value of r to 0.
            Dim r As New mpz_t()
            gmp_lib.mpz_init(r)
            
            ' Set r = n - d * trunc(n / d).
            gmp_lib.mpz_tdiv_r(r, n, d)
            
            ' Assert that r is 1.
            Assert.IsTrue(gmp_lib.mpz_get_si(r) = 1)
            
            ' Release unmanaged memory allocated for n, d, and r.
            gmp_lib.mpz_clears(n, d, r, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_r_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">
            <summary>
            Set the remainder <paramref name="r"/> to <paramref name="n"/> - q * 2^<paramref name="b"/> where q = trunc(<paramref name="n"/> / 2^<paramref name="b"/>).
            </summary>
            <param name="r">The result remainder integer.</param>
            <param name="n">The numerator integer.</param>
            <param name="b">The exponent of the power of two denominator.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_congruent_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_congruent_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divexact(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divexact</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divisible_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divisible_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_fdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mod(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_mod</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_q(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_q</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_r(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_r</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_q_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_tdiv_q_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_r_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_tdiv_r_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_qr_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_tdiv_qr_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_tdiv_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_q_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_tdiv_q_2exp</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Division">Integer Division</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Division.html#Integer-Division">GNU MP - Integer Division</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of n to 10001.
            mpz_t n = new mpz_t();
            gmp_lib.mpz_init_set_si(n, 10001);
            
            // Create, initialize, and set the value of r to 0.
            mpz_t r = new mpz_t();
            gmp_lib.mpz_init(r);
            
            // Set r = n - 2^2 * trunc(n / 2^2)
            gmp_lib.mpz_tdiv_r_2exp(r, n, 2U);
            
            // Assert that r is 1.
            Assert.IsTrue(gmp_lib.mpz_get_si(r) == 1);
            
            // Release unmanaged memory allocated for n and r.
            gmp_lib.mpz_clears(n, r, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of n to 10001.
            Dim n As New mpz_t()
            gmp_lib.mpz_init_set_si(n, 10001)
            
            ' Create, initialize, and set the value of r to 0.
            Dim r As New mpz_t()
            gmp_lib.mpz_init(r)
            
            ' Set r = n - 2^2 * trunc(n / 2^2)
            gmp_lib.mpz_tdiv_r_2exp(r, n, 2UI)
            
            ' Assert that r is 1.
            Assert.IsTrue(gmp_lib.mpz_get_si(r) = 1)
            
            ' Release unmanaged memory allocated for n and r.
            gmp_lib.mpz_clears(n, r, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_r_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">
            <summary>
            Set the remainder <paramref name="r"/> to <paramref name="n"/> - q * <paramref name="d"/> where q = trunc(<paramref name="n"/> / <paramref name="d"/>), and return | <paramref name="r"/> |.
            </summary>
            <param name="r">The result remainder integer.</param>
            <param name="n">The numerator integer.</param>
            <param name="d">The denominator integer.</param>
            <returns>Return | <paramref name="r"/> |.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_cdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_cdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_congruent_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_congruent_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divexact(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divexact</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_divisible_p(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_divisible_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_fdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_fdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_mod(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_mod</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_q(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_q</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_r(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_r</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_qr(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_tdiv_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_q_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_tdiv_q_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_qr_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_tdiv_qr_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_ui(Math.Gmp.Native.mpz_t,System.UInt32)">mpz_tdiv_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_q_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_tdiv_q_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tdiv_r_2exp(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_tdiv_r_2exp</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Division">Integer Division</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Division.html#Integer-Division">GNU MP - Integer Division</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of n to 10000.
            mpz_t n = new mpz_t();
            gmp_lib.mpz_init_set_si(n, 10000);
            
            // Create, initialize, and set the value of r to 0.
            mpz_t r = new mpz_t();
            gmp_lib.mpz_init(r);
            
            // Set r = n - 3 * trunc(n / 3), and return |r|.
            Assert.IsTrue(gmp_lib.mpz_tdiv_r_ui(r, n, 3U) == 1U);
            
            // Assert that r is 1.
            Assert.IsTrue(gmp_lib.mpz_get_si(r) == 1);
            
            // Release unmanaged memory allocated for n and r.
            gmp_lib.mpz_clears(n, r, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of n to 10000.
            Dim n As New mpz_t()
            gmp_lib.mpz_init_set_si(n, 10000)
            
            ' Create, initialize, and set the value of r to 0.
            Dim r As New mpz_t()
            gmp_lib.mpz_init(r)
            
            ' Set r = n - 3 * trunc(n / 3), and return |r|.
            Assert.IsTrue(gmp_lib.mpz_tdiv_r_ui(r, n, 3UI) = 1UI)
            
            ' Assert that r is 1.
            Assert.IsTrue(gmp_lib.mpz_get_si(r) = 1)
            
            ' Release unmanaged memory allocated for n and r.
            gmp_lib.mpz_clears(n, r, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_tstbit(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">
            <summary>
            Test bit <paramref name="bit_index"/> in <paramref name="op"/> and return 0 or 1 accordingly. 
            </summary>
            <param name="op"></param>
            <param name="bit_index"></param>
            <returns>Test bit <paramref name="bit_index"/> in <paramref name="op"/> and return 0 or 1 accordingly.</returns>
            <remarks>
            <para>
            The function behaves as if twos complement arithmetic were used (although sign-magnitude is the actual implementation).
            The least significant bit is number 0. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_and(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_and</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_ior(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_ior</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_xor(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_xor</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_com(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_com</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_popcount(Math.Gmp.Native.mpz_t)">mpz_popcount</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_hamdist(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_hamdist</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_scan0(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_scan0</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_scan1(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_scan1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_setbit(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_setbit</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_clrbit(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_clrbit</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_combit(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_combit</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Logic_and_Bit_Fiddling">Integer Logic and Bit Fiddling</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Logic-and-Bit-Fiddling.html#Integer-Logic-and-Bit-Fiddling">GNU MP - Integer Logic and Bit Fiddling</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of rop to 70.
            mpz_t rop = new mpz_t();
            gmp_lib.mpz_init_set_si(rop, 70);
            
            // Assert that bit 3 of rop is 0.
            Assert.IsTrue(gmp_lib.mpz_tstbit(rop, 3U) == 0);
            
            // Release unmanaged memory allocated for rop.
            gmp_lib.mpz_clear(rop);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of rop to 70.
            Dim rop As New mpz_t()
            gmp_lib.mpz_init_set_si(rop, 70)
            
            ' Assert that bit 3 of rop is 0.
            Assert.IsTrue(gmp_lib.mpz_tstbit(rop, 3UI) = 0)
            
            ' Release unmanaged memory allocated for rop.
            gmp_lib.mpz_clear(rop)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_ui_pow_ui(Math.Gmp.Native.mpz_t,System.UInt32,System.UInt32)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="base"/>^<paramref name="exp"/>. The case 0^0 yields 1.
            </summary>
            <param name="rop">The result integer.</param>
            <param name="base">The base integer.</param>
            <param name="exp">The exponent integer.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_powm(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_powm</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_powm_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32,Math.Gmp.Native.mpz_t)">mpz_powm_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_powm_sec(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_powm_sec</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_pow_ui(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,System.UInt32)">mpz_pow_ui</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Exponentiation">Integer Exponentiations</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Exponentiation.html#Integer-Exponentiation">GNU MP - Integer Exponentiation</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of rop to 0.
            mpz_t rop = new mpz_t();
            gmp_lib.mpz_init(rop);
            
            // Set rop = 2^4.
            gmp_lib.mpz_ui_pow_ui(rop, 2U, 4U);
            
            // Assert that rop is 16.
            Assert.IsTrue(gmp_lib.mpz_get_si(rop) == 16);
            
            // Release unmanaged memory allocated for rop.
            gmp_lib.mpz_clear(rop);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of rop to 0.
            Dim rop As New mpz_t()
            gmp_lib.mpz_init(rop)
            
            ' Set rop = 2^4.
            gmp_lib.mpz_ui_pow_ui(rop, 2UI, 4UI)
            
            ' Assert that rop is 16.
            Assert.IsTrue(gmp_lib.mpz_get_si(rop) = 16)
            
            ' Release unmanaged memory allocated for rop.
            gmp_lib.mpz_clear(rop)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_urandomb(Math.Gmp.Native.mpz_t,Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.mp_bitcnt_t)">
            <summary>
            Generate a uniformly distributed random integer in the range 0 to 2^<paramref name="n"/> - 1, inclusive.
            </summary>
            <param name="rop">The result integer.</param>
            <param name="state">The random number generator state.</param>
            <param name="n">The operand integer.</param>
            <remarks>
            <para>
            The variable <paramref name="state"/> must be initialized by calling one of the <c>gmp_randinit</c>
            functions (<a href="https://gmplib.org/manual/Random-State-Initialization.html#Random-State-Initialization">GNU MP - Random State Initialization</a>) before invoking this function.
            </para>
            <para>
            The random number functions of GMP come in two groups; older function that rely on a global state, 
            and newer functions that accept a state parameter that is read and modified.
            Please see the <a href="https://gmplib.org/manual/Random-Number-Functions.html#Random-Number-Functions">GNU MP - Random Number Functions</a>
            for more information on how to use and not to use random number functions.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_urandomm(Math.Gmp.Native.mpz_t,Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.mpz_t)">mpz_urandomm</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_rrandomb(Math.Gmp.Native.mpz_t,Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_rrandomb</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_random(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">mpz_random</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_random2(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">mpz_random2</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Random_Numbers">Integer Random Numbers</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Random-Numbers.html#Integer-Random-Numbers">GNU MP - Integer Random Numbers</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and seed a new random number generator.
            gmp_randstate_t state = new gmp_randstate_t();
            gmp_lib.gmp_randinit_mt(state);
            gmp_lib.gmp_randseed_ui(state, 100000U);
            
            // Create, initialize, and set the value of rop to 0.
            mpz_t rop = new mpz_t();
            gmp_lib.mpz_init(rop);
            
            // Generate a random integer in the range [0, (2^50)-1].
            gmp_lib.mpz_urandomb(rop, state, 50);
            
            // Free all memory occupied by state and rop.
            gmp_lib.gmp_randclear(state);
            gmp_lib.mpz_clear(rop);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and seed a new random number generator.
            Dim state As New gmp_randstate_t()
            gmp_lib.gmp_randinit_mt(state)
            gmp_lib.gmp_randseed_ui(state, 100000UI)
            
            ' Create, initialize, and set the value of rop to 0.
            Dim rop As New mpz_t()
            gmp_lib.mpz_init(rop)
            
            ' Generate a random integer in the range [0, (2^50)-1].
            gmp_lib.mpz_urandomb(rop, state, 50)
            
            ' Free all memory occupied by state and rop.
            gmp_lib.gmp_randclear(state)
            gmp_lib.mpz_clear(rop)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_urandomm(Math.Gmp.Native.mpz_t,Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.mpz_t)">
            <summary>
            Generate a uniform random integer in the range 0 to <paramref name="n"/> - 1, inclusive.
            </summary>
            <param name="rop">The result integer.</param>
            <param name="state">The random number generator state.</param>
            <param name="n">The operand integer.</param>
            <remarks>
            <para>
            The variable <paramref name="state"/> must be initialized by calling one of the <c>gmp_randinit</c>
            functions (<a href="https://gmplib.org/manual/Random-State-Initialization.html#Random-State-Initialization">GNU MP - Random State Initialization</a>) before invoking this function. 
            </para>
            <para>
            The random number functions of GMP come in two groups; older function that rely on a global state, 
            and newer functions that accept a state parameter that is read and modified.
            Please see the <a href="https://gmplib.org/manual/Random-Number-Functions.html#Random-Number-Functions">GNU MP - Random Number Functions</a>
            for more information on how to use and not to use random number functions.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_urandomb(Math.Gmp.Native.mpz_t,Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_urandomb</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_rrandomb(Math.Gmp.Native.mpz_t,Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_rrandomb</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_random(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">mpz_random</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_random2(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">mpz_random2</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Random_Numbers">Integer Random Numbers</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Random-Numbers.html#Integer-Random-Numbers">GNU MP - Integer Random Numbers</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and seed a new random number generator.
            gmp_randstate_t state = new gmp_randstate_t();
            gmp_lib.gmp_randinit_mt(state);
            gmp_lib.gmp_randseed_ui(state, 100000U);
            
            // Create, initialize, and set the value of rop to 0.
            mpz_t rop = new mpz_t();
            gmp_lib.mpz_init(rop);
            
            // Create, initialize, and set a large integer.
            mpz_t n = new mpz_t();
            char_ptr value = new char_ptr("123 456 789 012 345 678 901");
            gmp_lib.mpz_init_set_str(n, value, 10);
            
            // Generate a random integer in the range [0, n-1].
            gmp_lib.mpz_urandomm(rop, state, n);
            
            // Free all memory occupied by state, rop, and n.
            gmp_lib.gmp_randclear(state);
            gmp_lib.mpz_clears(rop, n, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and seed a new random number generator.
            Dim state As New gmp_randstate_t()
            gmp_lib.gmp_randinit_mt(state)
            gmp_lib.gmp_randseed_ui(state, 100000UI)
            
            ' Create, initialize, and set the value of rop to 0.
            Dim rop As New mpz_t()
            gmp_lib.mpz_init(rop)
            
            ' Create, initialize, and set a large integer.
            Dim n As New mpz_t()
            Dim value As New char_ptr("123 456 789 012 345 678 901")
            gmp_lib.mpz_init_set_str(n, value, 10)
            
            ' Generate a random integer in the range [0, n-1].
            gmp_lib.mpz_urandomm(rop, state, n)
            
            ' Free all memory occupied by state, rop, and n.
            gmp_lib.gmp_randclear(state)
            gmp_lib.mpz_clears(rop, n, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_xor(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> bitwise exclusive-or <paramref name="op2"/>. 
            </summary>
            <param name="rop">The result integer.</param>
            <param name="op1">The first operand integer.</param>
            <param name="op2">The second operand integer.</param>
            <remarks>
            <para>
            The function behaves as if twos complement arithmetic were used (although sign-magnitude is the actual implementation).
            The least significant bit is number 0. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_and(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_and</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_ior(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_ior</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_com(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_com</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_popcount(Math.Gmp.Native.mpz_t)">mpz_popcount</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_hamdist(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_hamdist</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_scan0(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_scan0</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_scan1(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_scan1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_setbit(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_setbit</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_clrbit(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_clrbit</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_combit(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_combit</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_tstbit(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_bitcnt_t)">mpz_tstbit</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Logic_and_Bit_Fiddling">Integer Logic and Bit Fiddling</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Logic-and-Bit-Fiddling.html#Integer-Logic-and-Bit-Fiddling">GNU MP - Integer Logic and Bit Fiddling</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op1 to 63.
            mpz_t op1 = new mpz_t();
            gmp_lib.mpz_init_set_ui(op1, 63U);
            
            // Create, initialize, and set the value of op2 to 70.
            mpz_t op2 = new mpz_t();
            gmp_lib.mpz_init_set_ui(op2, 70U);
            
            // Create, initialize, and set the value of rop to 0.
            mpz_t rop = new mpz_t();
            gmp_lib.mpz_init(rop);
            
            // Set rop to the bitwise exclusive or of op1 and op2.
            gmp_lib.mpz_xor(rop, op1, op2);
            
            // Assert that rop is 121.
            Assert.IsTrue(gmp_lib.mpz_get_si(rop) == 121);
            
            // Release unmanaged memory allocated for rop, op1, and op2.
            gmp_lib.mpz_clears(rop, op1, op2, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op1 to 63.
            Dim op1 As New mpz_t()
            gmp_lib.mpz_init_set_ui(op1, 63UI)
            
            ' Create, initialize, and set the value of op2 to 70.
            Dim op2 As New mpz_t()
            gmp_lib.mpz_init_set_ui(op2, 70UI)
            
            ' Create, initialize, and set the value of rop to 0.
            Dim rop As New mpz_t()
            gmp_lib.mpz_init(rop)
            
            ' Set rop to the bitwise exclusive or of op1 and op2.
            gmp_lib.mpz_xor(rop, op1, op2)
            
            ' Assert that rop is 121.
            Assert.IsTrue(gmp_lib.mpz_get_si(rop) = 121)
            
            ' Release unmanaged memory allocated for rop, op1, and op2.
            gmp_lib.mpz_clears(rop, op1, op2, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_limbs_read(Math.Gmp.Native.mpz_t)">
            <summary>
            Return a pointer to the limb array representing the absolute value of <paramref name="x"/>.
            </summary>
            <param name="x">The integer.</param>
            <returns>A pointer to the limb array representing the absolute value of <paramref name="x"/>.</returns>
            <remarks>
            <para>
            The size of the array is <see cref="M:Math.Gmp.Native.gmp_lib.mpz_size(Math.Gmp.Native.mpz_t)">mpz_size</see>(x). Intended for read access only.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib._mpz_realloc(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">_mpz_realloc</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_getlimbn(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">mpz_getlimbn</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_size(Math.Gmp.Native.mpz_t)">mpz_size</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_limbs_write(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">mpz_limbs_write</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_limbs_modify(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">mpz_limbs_modify</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_limbs_finish(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">mpz_limbs_finish</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_roinit_n(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpz_roinit_n</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Special_Functions">Integer Special Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Special-Functions.html#Integer-Special-Functions">GNU MP - Integer Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize new integer x.
            mpz_t x = new mpz_t();
            gmp_lib.mpz_init(x);
            
            // Set the value of x.
            char_ptr value = new char_ptr("10000 00000000000000000000000000000000");
            gmp_lib.mpz_set_str(x, value, gmp_lib.mp_bytes_per_limb == 4 ? 2 : 4);
            
            // Get pointer to the limbs of x.
            mp_ptr limbs = gmp_lib.mpz_limbs_read(x);
            
            // Assert the values of the limbs based on current architecture (x86 or x64).
            Assert.IsTrue(limbs[0] == 0);
            Assert.IsTrue(limbs[1] == (gmp_lib.mp_bytes_per_limb == 4 ? 16U : 256U));
            
            // Release unmanaged memory allocated for x and value.
            gmp_lib.mpz_clear(x);
            gmp_lib.free(value);
            </code> 
            <code language="VB.NET">
            ' Create and initialize new integer x.
            Dim x As New mpz_t()
            gmp_lib.mpz_init(x)
            
            ' Set the value of x.
            Dim value As New char_ptr("10000 00000000000000000000000000000000")
            gmp_lib.mpz_set_str(x, value, If(gmp_lib.mp_bytes_per_limb = 4, 2, 4))
            
            ' Get pointer to the limbs of x.
            Dim limbs As mp_ptr = gmp_lib.mpz_limbs_read(x)
            
            ' Assert the values of the limbs based on current architecture (x86 or x64).
            Assert.IsTrue(limbs(0) = 0)
            Assert.IsTrue(limbs(1) = (If(gmp_lib.mp_bytes_per_limb = 4, 16UI, 256UI)))
            
            ' Release unmanaged memory allocated for x and value.
            gmp_lib.mpz_clear(x)
            gmp_lib.free(value)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_limbs_write(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">
            <summary>
            Return a pointer to the limb array of <paramref name="x"/>, intended for write access.
            </summary>
            <param name="x">The operand integer.</param>
            <param name="n">The number of limbs.</param>
            <returns>A pointer to the limb array of <paramref name="x"/>, intended for write access.</returns>
            <remarks>
            <para>
            The array is reallocated as needed, to make room for <paramref name="n"/> limbs.
            Requires <paramref name="n"/> &gt; 0.
            The <see cref="M:Math.Gmp.Native.gmp_lib.mpz_limbs_write(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">mpz_limbs_write</see> function may destroy the old value and
            return an array with unspecified contents.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib._mpz_realloc(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">_mpz_realloc</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_getlimbn(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">mpz_getlimbn</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_size(Math.Gmp.Native.mpz_t)">mpz_size</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_limbs_read(Math.Gmp.Native.mpz_t)">mpz_limbs_read</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_limbs_modify(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">mpz_limbs_modify</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_limbs_finish(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">mpz_limbs_finish</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_roinit_n(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpz_roinit_n</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Special_Functions">Integer Special Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Special-Functions.html#Integer-Special-Functions">GNU MP - Integer Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize new integer x.
            mpz_t x = new mpz_t();
            gmp_lib.mpz_init(x);
            
            // Resize x to 3 limbs, and get pointer to the limbs.
            gmp_lib.mpz_set_ui(x, 2U);
            mp_ptr limbs = gmp_lib.mpz_limbs_write(x, 3);
            
            // Set the values of the limbs.
            limbs[0] = 0U;
            limbs[1] = 0U;
            limbs[2] = (gmp_lib.mp_bytes_per_limb == 4 ? 2U : 4U);
            gmp_lib.mpz_limbs_finish(x, -3);
            
            // Assert the value of x based on current architecture (x86 or x64).
            char_ptr s = gmp_lib.mpz_get_str(char_ptr.Zero, gmp_lib.mp_bytes_per_limb == 4 ? 2 : 4, x);
            Assert.IsTrue(s.ToString() == "-10 00000000000000000000000000000000 00000000000000000000000000000000".Replace(" ", ""));
            
            // Release unmanaged memory allocated for x and s.
            gmp_lib.mpz_clear(x);
            gmp_lib.free(s);
            </code> 
            <code language="VB.NET">
            ' Create and initialize new integer x.
            Dim x As New mpz_t()
            gmp_lib.mpz_init(x)
            
            ' Resize x to 3 limbs, and get pointer to the limbs.
            gmp_lib.mpz_set_ui(x, 2UI)
            Dim limbs As mp_ptr = gmp_lib.mpz_limbs_write(x, 3)
            
            ' Set the values of the limbs.
            limbs(0) = 0UI
            limbs(1) = 0UI
            limbs(2) = (If(gmp_lib.mp_bytes_per_limb = 4, 2UI, 4UI))
            gmp_lib.mpz_limbs_finish(x, -3)
            
            ' Assert the value of x based on current architecture (x86 or x64).
            Dim s As char_ptr = gmp_lib.mpz_get_str(char_ptr.Zero, If(gmp_lib.mp_bytes_per_limb = 4, 2, 4), x)
            Assert.IsTrue(s.ToString() = "-10 00000000000000000000000000000000 00000000000000000000000000000000".Replace(" ", ""))
            
            ' Release unmanaged memory allocated for x and s.
            gmp_lib.mpz_clear(x)
            gmp_lib.free(s)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_limbs_modify(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">
            <summary>
            Return a pointer to the limb array of <paramref name="x"/>, intended for write access.
            </summary>
            <param name="x">The operand integer.</param>
            <param name="n">The number of limbs.</param>
            <returns>A pointer to the limb array of <paramref name="x"/>, intended for write access.</returns>
            <remarks>
            <para>
            The array is reallocated as needed, to make room for <paramref name="n"/> limbs.
            Requires <paramref name="n"/> &gt; 0.
            The <see cref="M:Math.Gmp.Native.gmp_lib.mpz_limbs_modify(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">mpz_limbs_modify</see> function returns an array that holds the old absolute
            value of <paramref name="x"/>
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib._mpz_realloc(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">_mpz_realloc</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_getlimbn(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">mpz_getlimbn</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_size(Math.Gmp.Native.mpz_t)">mpz_size</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_limbs_read(Math.Gmp.Native.mpz_t)">mpz_limbs_read</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_limbs_write(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">mpz_limbs_write</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_limbs_finish(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">mpz_limbs_finish</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_roinit_n(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpz_roinit_n</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Special_Functions">Integer Special Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Special-Functions.html#Integer-Special-Functions">GNU MP - Integer Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of x to 2.
            mpz_t x = new mpz_t();
            gmp_lib.mpz_init_set_ui(x, 2U);
            
            // Resize x to 3 limbs, and get pointer to the limbs.
            mp_ptr limbs = gmp_lib.mpz_limbs_modify(x, 3);
            
            // Set the value of x.
            limbs[0] = 0;
            limbs[1] = 0;
            limbs[2] = (IntPtr.Size == 4 ? 8U : 64U);
            gmp_lib.mpz_limbs_finish(x, -3);
            
            // Assert the value of x based on current architecture (x86 or x64).
            char_ptr s = gmp_lib.mpz_get_str(char_ptr.Zero, gmp_lib.mp_bytes_per_limb == 4 ? 2 : 4, x);
            Assert.IsTrue(s.ToString() == "-1000 00000000000000000000000000000000 00000000000000000000000000000000".Replace(" ", ""));
            
            // Release unmanaged memory allocated for x and s.
            gmp_lib.mpz_clear(x);
            gmp_lib.free(s);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of x to 2.
            Dim x As New mpz_t()
            gmp_lib.mpz_init_set_ui(x, 2UI)
            
            ' Resize x to 3 limbs, and get pointer to the limbs.
            Dim limbs As mp_ptr = gmp_lib.mpz_limbs_modify(x, 3)
            
            ' Set the value of x.
            limbs(0) = 0
            limbs(1) = 0
            limbs(2) = (If(IntPtr.Size = 4, 8UI, 64UI))
            gmp_lib.mpz_limbs_finish(x, -3)
            
            ' Assert the value of x based on current architecture (x86 or x64).
            Dim s As char_ptr = gmp_lib.mpz_get_str(char_ptr.Zero, If(gmp_lib.mp_bytes_per_limb = 4, 2, 4), x)
            Assert.IsTrue(s.ToString() = "-1000 00000000000000000000000000000000 00000000000000000000000000000000".Replace(" ", ""))
            
            ' Release unmanaged memory allocated for x and s.
            gmp_lib.mpz_clear(x)
            gmp_lib.free(s)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_limbs_finish(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">
            <summary>
            Updates the internal size field of <paramref name="x"/>.
            </summary>
            <param name="x">The operand integer.</param>
            <param name="s">The number of limbs and the sign of <paramref name="x"/>.</param>
            <remarks>
            <para>
            Used after writing to the limb array pointer returned by <see cref="M:Math.Gmp.Native.gmp_lib.mpz_limbs_write(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">mpz_limbs_write</see>
            or <see cref="M:Math.Gmp.Native.gmp_lib.mpz_limbs_modify(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">mpz_limbs_modify</see> is completed. The array should contain | <paramref name="s"/> |
            valid limbs, representing the new absolute value for <paramref name="x"/>, and the sign of <paramref name="x"/>
            is taken from the sign of <paramref name="s"/>.
            This function never reallocates <paramref name="x"/>, so the limb pointer remains valid.
            </para>
            <code language="C++">
            void foo (mpz_t x)
            {
                mp_size_t n, i;
                mp_limb_t* xp;
            
                n = mpz_size(x);
                xp = mpz_limbs_modify(x, 2 * n);
                for (i = 0; i &lt; n; i++)
                    xp[n + i] = xp[n - 1 - i];
                mpz_limbs_finish(x, mpz_sgn(x) &lt; 0 ? - 2 * n : 2 * n);
            }
            </code> 
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib._mpz_realloc(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">_mpz_realloc</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_getlimbn(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">mpz_getlimbn</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_size(Math.Gmp.Native.mpz_t)">mpz_size</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_limbs_read(Math.Gmp.Native.mpz_t)">mpz_limbs_read</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_limbs_write(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">mpz_limbs_write</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_limbs_modify(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">mpz_limbs_modify</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_roinit_n(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpz_roinit_n</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Special_Functions">Integer Special Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Special-Functions.html#Integer-Special-Functions">GNU MP - Integer Special Functions</a></seealso>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpz_roinit_n(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">
            <summary>
            Special initialization of <paramref name="x"/>, using the given limb array and size.
            </summary>
            <param name="x">The operand integer.</param>
            <param name="xp">The limbs array.</param>
            <param name="xs">The number of limbs and the sign.</param>
            <returns>For convenience, the function returns <paramref name="x"/>, but cast to a const pointer type.</returns>
            <remarks>
            <para>
            <paramref name="x"/> should be treated as readonly: it can be passed safely as input to any mpz function, but not as an output.
            The array <paramref name="xp"/> must point to at least a readable limb, its size is | <paramref name="xs"/> |, and the
            sign of <paramref name="x"/> is the sign of <paramref name="xs"/>.
            </para>
            <code language="C++">
            void foo (mpz_t x)
            {
                static const mp_limb_t y[3] = { 0x1, 0x2, 0x3 };
                mpz_t tmp;
                mpz_add(x, x, mpz_roinit_n(tmp, y, 3));
            }
            </code> 
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib._mpz_realloc(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">_mpz_realloc</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_getlimbn(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">mpz_getlimbn</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_size(Math.Gmp.Native.mpz_t)">mpz_size</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_limbs_read(Math.Gmp.Native.mpz_t)">mpz_limbs_read</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_limbs_write(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">mpz_limbs_write</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_limbs_modify(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">mpz_limbs_modify</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpz_limbs_finish(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mp_size_t)">mpz_limbs_finish</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Integer_Special_Functions">Integer Special Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Integer-Special-Functions.html#Integer-Special-Functions">GNU MP - Integer Special Functions</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize new integer x.
            mpz_t x = new mpz_t();
            gmp_lib.mpz_init(x);
            
            // Prepare new limbs for x.
            mp_ptr limbs;
            if (gmp_lib.mp_bytes_per_limb == 4)
                limbs = new mp_ptr(new uint[] { 0U, 0U, 2U });
            else
                limbs = new mp_ptr(new ulong[] { 0UL, 0UL, 4UL });
            
            // Assign new limbs to x, and make x negative.
            x = gmp_lib.mpz_roinit_n(x, limbs, -3);
            
            // Assert new value of x.
            char_ptr s = gmp_lib.mpz_get_str(char_ptr.Zero, gmp_lib.mp_bytes_per_limb == 4 ? 2 : 4, x);
            Assert.IsTrue(s.ToString() == "-10 00000000000000000000000000000000 00000000000000000000000000000000".Replace(" ", ""));
            
            // Release unmanaged memory allocated for x and s.
            gmp_lib.mpz_clear(x);
            gmp_lib.free(s);
            </code> 
            <code language="VB.NET">
            ' Create and initialize new integer x.
            Dim x As New mpz_t()
            gmp_lib.mpz_init(x)
            
            ' Prepare new limbs for x.
            Dim limbs As mp_ptr
            If gmp_lib.mp_bytes_per_limb = 4 Then
                limbs = New mp_ptr(New UInteger() { 0UI, 0UI, 2UI})
            Else
                limbs = New mp_ptr(New ULong() { 0UL, 0UL, 4UL})
            End If
            
            ' Assign new limbs to x, and make x negative.
            x = gmp_lib.mpz_roinit_n(x, limbs, -3)
            
            ' Assert new value of x.
            Dim s As char_ptr = gmp_lib.mpz_get_str(char_ptr.Zero, If(gmp_lib.mp_bytes_per_limb = 4, 2, 4), x)
            Assert.IsTrue(s.ToString() = "-10 00000000000000000000000000000000 00000000000000000000000000000000".Replace(" ", ""))
            
            ' Release unmanaged memory allocated for x and s.
            gmp_lib.mpz_clear(x)
            gmp_lib.free(s)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpq_abs(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">
            <summary>
            Set <paramref name="rop"/> to the absolute value of <paramref name="op"/>.
            </summary>
            <param name="rop">The result rational.</param>
            <param name="op">The operand rational.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_add(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_sub(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_mul(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_mul_2exp(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,System.UInt32)">mpq_mul_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_div(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_div</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_div_2exp(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,System.UInt32)">mpq_div_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_neg(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_inv(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_inv</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Rational_Arithmetic">Rational Arithmetic</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Rational-Arithmetic.html#Rational-Arithmetic">GNU MP - Rational Arithmetic</a></seealso>
            <example>
            <code language="C#">
            </code> 
            <code language="VB.NET">
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpq_add(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">
            <summary>
            Set <paramref name="sum"/> to <paramref name="addend1"/> + <paramref name="addend2"/>. 
            </summary>
            <param name="sum">The result rational.</param>
            <param name="addend1">The first operand rational.</param>
            <param name="addend2">The second operand rational.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_sub(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_mul(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_mul_2exp(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,System.UInt32)">mpq_mul_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_div(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_div</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_div_2exp(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,System.UInt32)">mpq_div_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_neg(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_abs(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_abs</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_inv(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_inv</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Rational_Arithmetic">Rational Arithmetic</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Rational-Arithmetic.html#Rational-Arithmetic">GNU MP - Rational Arithmetic</a></seealso>
            <example>
            <code language="C#">
            </code> 
            <code language="VB.NET">
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpq_canonicalize(Math.Gmp.Native.mpq_t)">
            <summary>
            Remove any factors that are common to the numerator and denominator of <paramref name="op"/>, and make the denominator positive.
            </summary>
            <param name="op">The operand rational.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_init(Math.Gmp.Native.mpq_t)">mpq_init</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_inits(Math.Gmp.Native.mpq_t[])">mpq_inits</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_clears(Math.Gmp.Native.mpq_t[])">mpq_clears</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_set</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_z(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpz_t)">mpq_set_z</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_ui(Math.Gmp.Native.mpq_t,System.UInt32,System.UInt32)">mpq_set_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_si(Math.Gmp.Native.mpq_t,System.Int32,System.UInt32)">mpq_set_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_str(Math.Gmp.Native.mpq_t,Math.Gmp.Native.char_ptr,System.Int32)">mpq_set_str</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_swap(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_swap</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Initializing_Rationals">Initializing Rationals</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Initializing-Rationals.html#Initializing-Rationals">GNU MP - Initializing Rationals</a></seealso>
            <example>
            <code language="C#">
            </code> 
            <code language="VB.NET">
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpq_clear(Math.Gmp.Native.mpq_t)">
            <summary>
            Free the space occupied by <paramref name="x"/>.
            </summary>
            <param name="x">The operand rational.</param>
            <remarks>
            <para>
            Make sure to call this function for all <see cref="T:Math.Gmp.Native.mpq_t">mpq_t</see> variables when you are done with them. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_canonicalize(Math.Gmp.Native.mpq_t)">mpq_canonicalize</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_init(Math.Gmp.Native.mpq_t)">mpq_init</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_inits(Math.Gmp.Native.mpq_t[])">mpq_inits</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_clears(Math.Gmp.Native.mpq_t[])">mpq_clears</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_set</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_z(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpz_t)">mpq_set_z</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_ui(Math.Gmp.Native.mpq_t,System.UInt32,System.UInt32)">mpq_set_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_si(Math.Gmp.Native.mpq_t,System.Int32,System.UInt32)">mpq_set_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_str(Math.Gmp.Native.mpq_t,Math.Gmp.Native.char_ptr,System.Int32)">mpq_set_str</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_swap(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_swap</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Initializing_Rationals">Initializing Rationals</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Initializing-Rationals.html#Initializing-Rationals">GNU MP - Initializing Rationals</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize a new rational x.
            mpq_t x = new mpq_t();
            gmp_lib.mpq_init(x);
            
            // Assert that the value of x is 0.0.
            Assert.IsTrue(gmp_lib.mpq_get_d(x) == 0.0);
            
            // Release unmanaged memory allocated for x.
            gmp_lib.mpq_clear(x);
            </code> 
            <code language="VB.NET">
            ' Create and initialize a new rational x.
            Dim x As New mpq_t()
            gmp_lib.mpq_init(x)
            
            ' Assert that the value of x is 0.0.
            Assert.IsTrue(gmp_lib.mpq_get_d(x) = 0.0)
            
            ' Release unmanaged memory allocated for x.
            gmp_lib.mpq_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpq_clears(Math.Gmp.Native.mpq_t[])">
            <summary>
            Free the space occupied by a NULL-terminated list of <see cref="T:Math.Gmp.Native.mpq_t">mpq_t</see> variables. 
            </summary>
            <param name="x">The operand rational.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_canonicalize(Math.Gmp.Native.mpq_t)">mpq_canonicalize</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_init(Math.Gmp.Native.mpq_t)">mpq_init</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_inits(Math.Gmp.Native.mpq_t[])">mpq_inits</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_clear(Math.Gmp.Native.mpq_t)">mpq_clear</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_set</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_z(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpz_t)">mpq_set_z</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_ui(Math.Gmp.Native.mpq_t,System.UInt32,System.UInt32)">mpq_set_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_si(Math.Gmp.Native.mpq_t,System.Int32,System.UInt32)">mpq_set_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_str(Math.Gmp.Native.mpq_t,Math.Gmp.Native.char_ptr,System.Int32)">mpq_set_str</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_swap(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_swap</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Initializing_Rationals">Initializing Rationals</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Initializing-Rationals.html#Initializing-Rationals">GNU MP - Initializing Rationals</a></seealso>
            <example>
            <code language="C#">
            // Create new rationals x1, x2 and x3.
            mpq_t x1 = new mpq_t();
            mpq_t x2 = new mpq_t();
            mpq_t x3 = new mpq_t();
            
            // Initialize the rationals.
            gmp_lib.mpq_inits(x1, x2, x3, null);
            
            // Assert that their value is 0.0.
            Assert.IsTrue(gmp_lib.mpq_get_d(x1) == 0.0);
            Assert.IsTrue(gmp_lib.mpq_get_d(x2) == 0.0);
            Assert.IsTrue(gmp_lib.mpq_get_d(x3) == 0.0);
            
            // Release unmanaged memory allocated for the rationals.
            gmp_lib.mpq_clears(x1, x2, x3, null);
            </code> 
            <code language="VB.NET">
            ' Create new rationals x1, x2 and x3.
            Dim x1 As New mpq_t()
            Dim x2 As New mpq_t()
            Dim x3 As New mpq_t()
            
            ' Initialize the rationals.
            gmp_lib.mpq_inits(x1, x2, x3, Nothing)
            
            ' Assert that their value is 0.0.
            Assert.IsTrue(gmp_lib.mpq_get_d(x1) = 0.0)
            Assert.IsTrue(gmp_lib.mpq_get_d(x2) = 0.0)
            Assert.IsTrue(gmp_lib.mpq_get_d(x3) = 0.0)
            
            ' Release unmanaged memory allocated for the rationals.
            gmp_lib.mpq_clears(x1, x2, x3, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpq_cmp(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">
            <summary>
            Compare <paramref name="op1"/> and <paramref name="op2"/>.
            </summary>
            <param name="op1">The first operand rational.</param>
            <param name="op2">The second operand rational.</param>
            <returns>Return a positive value if <paramref name="op1"/> &gt; <paramref name="op2"/>, zero if <paramref name="op1"/> = <paramref name="op2"/>, and a negative value if <paramref name="op1"/> &lt; <paramref name="op2"/>.</returns>
            <remarks>
            <para>
            To determine if two rationals are equal, <see cref="M:Math.Gmp.Native.gmp_lib.mpq_equal(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_equal</see> is faster than <see cref="M:Math.Gmp.Native.gmp_lib.mpq_cmp(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_cmp</see>. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_cmp_z(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpz_t)">mpq_cmp_z</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_cmp_ui(Math.Gmp.Native.mpq_t,System.UInt32,System.UInt32)">mpq_cmp_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_cmp_si(Math.Gmp.Native.mpq_t,System.Int32,System.UInt32)">mpq_cmp_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_sgn(Math.Gmp.Native.mpq_t)">mpq_sgn</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_equal(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_equal</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Comparing_Rationals">Comparing Rationals</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Comparing-Rationals.html#Comparing-Rationals">GNU MP - Comparing Rationals</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op1 to 1 / 2.
            mpq_t op1 = new mpq_t();
            gmp_lib.mpq_init(op1);
            gmp_lib.mpq_set_si(op1, 1, 2U);
            
            // Create, initialize, and set the value of op2 to 1 / 3.
            mpq_t op2 = new mpq_t();
            gmp_lib.mpq_init(op2);
            gmp_lib.mpq_set_si(op2, 1, 3U);
            
            // Assert that op1 > op2.
            Assert.IsTrue(gmp_lib.mpq_cmp(op1, op2) > 0);
            
            // Release unmanaged memory allocated for op1 and op2.
            gmp_lib.mpq_clears(op1, op2, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op1 to 1 / 2.
            Dim op1 As New mpq_t()
            gmp_lib.mpq_init(op1)
            gmp_lib.mpq_set_si(op1, 1, 2UI)
            
            ' Create, initialize, and set the value of op2 to 1 / 3.
            Dim op2 As New mpq_t()
            gmp_lib.mpq_init(op2)
            gmp_lib.mpq_set_si(op2, 1, 3UI)
            
            ' Assert that op1 > op2.
            Assert.IsTrue(gmp_lib.mpq_cmp(op1, op2) > 0)
            
            ' Release unmanaged memory allocated for op1 and op2.
            gmp_lib.mpq_clears(op1, op2, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpq_cmp_si(Math.Gmp.Native.mpq_t,System.Int32,System.UInt32)">
            <summary>
            Compare <paramref name="op1"/> and <paramref name="num2"/> / <paramref name="den2"/>.
            </summary>
            <param name="op1">The first operand rational.</param>
            <param name="num2">The second operand numerator integer.</param>
            <param name="den2">The second operand denominator integer.</param>
            <returns>Return a positive value if <paramref name="op1"/> &gt; <paramref name="num2"/> / <paramref name="den2"/>, zero if <paramref name="op1"/> = <paramref name="num2"/> / <paramref name="den2"/>, and a negative value if <paramref name="op1"/> &lt; <paramref name="num2"/> / <paramref name="den2"/>.</returns>
            <remarks>
            <para>
            <paramref name="num2"/> and <paramref name="den2"/> are allowed to have common factors. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_cmp(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_cmp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_cmp_z(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpz_t)">mpq_cmp_z</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_cmp_ui(Math.Gmp.Native.mpq_t,System.UInt32,System.UInt32)">mpq_cmp_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_sgn(Math.Gmp.Native.mpq_t)">mpq_sgn</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_equal(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_equal</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Comparing_Rationals">Comparing Rationals</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Comparing-Rationals.html#Comparing-Rationals">GNU MP - Comparing Rationals</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op1 to 1 / 2.
            mpq_t op1 = new mpq_t();
            gmp_lib.mpq_init(op1);
            gmp_lib.mpq_set_si(op1, 1, 2U);
            
            // Assert that op1 &lt; 5/6.
            Assert.IsTrue(gmp_lib.mpq_cmp_si(op1, 5, 6U) &lt; 0);
            
            // Release unmanaged memory allocated for op1.
            gmp_lib.mpq_clear(op1);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op1 to 1 / 2.
            Dim op1 As New mpq_t()
            gmp_lib.mpq_init(op1)
            gmp_lib.mpq_set_si(op1, 1, 2UI)
            
            ' Assert that op1 &lt; 5/6.
            Assert.IsTrue(gmp_lib.mpq_cmp_si(op1, 5, 6UI) &lt; 0)
            
            ' Release unmanaged memory allocated for op1.
            gmp_lib.mpq_clear(op1)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpq_cmp_ui(Math.Gmp.Native.mpq_t,System.UInt32,System.UInt32)">
            <summary>
            Compare <paramref name="op1"/> and <paramref name="num2"/> / <paramref name="den2"/>.
            </summary>
            <param name="op1">The first operand rational.</param>
            <param name="num2">The second operand numerator integer.</param>
            <param name="den2">The second operand denominator integer.</param>
            <returns>Return a positive value if <paramref name="op1"/> &gt; <paramref name="num2"/> / <paramref name="den2"/>, zero if <paramref name="op1"/> = <paramref name="num2"/> / <paramref name="den2"/>, and a negative value if <paramref name="op1"/> &lt; <paramref name="num2"/> / <paramref name="den2"/>.</returns>
            <remarks>
            <para>
            <paramref name="num2"/> and <paramref name="den2"/> are allowed to have common factors. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_cmp(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_cmp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_cmp_z(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpz_t)">mpq_cmp_z</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_cmp_si(Math.Gmp.Native.mpq_t,System.Int32,System.UInt32)">mpq_cmp_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_sgn(Math.Gmp.Native.mpq_t)">mpq_sgn</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_equal(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_equal</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Comparing_Rationals">Comparing Rationals</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Comparing-Rationals.html#Comparing-Rationals">GNU MP - Comparing Rationals</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op1 to 1 / 2.
            mpq_t op1 = new mpq_t();
            gmp_lib.mpq_init(op1);
            gmp_lib.mpq_set_si(op1, 1, 2U);
            
            // Assert that op1 == 3/6.
            Assert.IsTrue(gmp_lib.mpq_cmp_ui(op1, 3, 6U) == 0);
            
            // Release unmanaged memory allocated for op1.
            gmp_lib.mpq_clear(op1);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op1 to 1 / 2.
            Dim op1 As New mpq_t()
            gmp_lib.mpq_init(op1)
            gmp_lib.mpq_set_si(op1, 1, 2UI)
            
            ' Assert that op1 == 3/6.
            Assert.IsTrue(gmp_lib.mpq_cmp_ui(op1, 3, 6UI) = 0)
            
            ' Release unmanaged memory allocated for op1.
            gmp_lib.mpq_clear(op1)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpq_cmp_z(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpz_t)">
            <summary>
            Compare <paramref name="op1"/> and <paramref name="op2"/>.
            </summary>
            <param name="op1">The first operand rational.</param>
            <param name="op2">The second operand rational.</param>
            <returns>Return a positive value if <paramref name="op1"/> &gt; <paramref name="op2"/>, zero if <paramref name="op1"/> = <paramref name="op2"/>, and a negative value if <paramref name="op1"/> &lt; <paramref name="op2"/>.</returns>
            <remarks>
            <para>
            To determine if two rationals are equal, <see cref="M:Math.Gmp.Native.gmp_lib.mpq_equal(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_equal</see> is faster than <see cref="M:Math.Gmp.Native.gmp_lib.mpq_cmp(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_cmp</see>. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_cmp(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_cmp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_cmp_ui(Math.Gmp.Native.mpq_t,System.UInt32,System.UInt32)">mpq_cmp_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_cmp_si(Math.Gmp.Native.mpq_t,System.Int32,System.UInt32)">mpq_cmp_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_sgn(Math.Gmp.Native.mpq_t)">mpq_sgn</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_equal(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_equal</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Comparing_Rationals">Comparing Rationals</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Comparing-Rationals.html#Comparing-Rationals">GNU MP - Comparing Rationals</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op1 to 1 / 2.
            mpq_t op1 = new mpq_t();
            gmp_lib.mpq_init(op1);
            gmp_lib.mpq_set_si(op1, 1, 2U);
            
            // Create, initialize, and set the value of op2 to 3.
            mpz_t op2 = new mpz_t();
            gmp_lib.mpz_init(op2);
            gmp_lib.mpz_set_si(op2, 3);
            
            // Assert that op1 &lt; op2.
            Assert.IsTrue(gmp_lib.mpq_cmp_z(op1, op2) &lt; 0);
            
            // Release unmanaged memory allocated for op1 and op2.
            gmp_lib.mpq_clear(op1);
            gmp_lib.mpz_clear(op2);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op1 to 1 / 2.
            Dim op1 As New mpq_t()
            gmp_lib.mpq_init(op1)
            gmp_lib.mpq_set_si(op1, 1, 2UI)
            
            ' Create, initialize, and set the value of op2 to 3.
            Dim op2 As New mpz_t()
            gmp_lib.mpz_init(op2)
            gmp_lib.mpz_set_si(op2, 3)
            
            ' Assert that op1 &lt; op2.
            Assert.IsTrue(gmp_lib.mpq_cmp_z(op1, op2) &lt; 0)
            
            ' Release unmanaged memory allocated for op1 and op2.
            gmp_lib.mpq_clear(op1)
            gmp_lib.mpz_clear(op2)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpq_denref(Math.Gmp.Native.mpq_t)">
            <summary>
            Return a reference to the denominator <paramref name="op"/>.
            </summary>
            <param name="op">The operand rational.</param>
            <returns>Return a reference to the denominator <paramref name="op"/>.</returns>
            <remarks>
            <para>
            The <c>mpz</c> functions can be used on the returned reference. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_numref(Math.Gmp.Native.mpq_t)">mpq_numref</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_get_num(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpq_t)">mpq_get_num</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_get_den(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpq_t)">mpq_get_den </seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_num(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpz_t)">mpq_set_num</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_den(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpz_t)">mpq_set_den</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Applying_Integer_Functions">Applying Integer Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Applying-Integer-Functions.html#Applying-Integer-Functions">GNU MP - Applying Integer Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op to -1 / 3.
            mpq_t op = new mpq_t();
            gmp_lib.mpq_init(op);
            gmp_lib.mpq_set_si(op, -1, 3U);
            
            // Get reference to denominator, and increment it by 2.
            mpz_t num = gmp_lib.mpq_denref(op);
            gmp_lib.mpz_add_ui(num, num, 2U);
            
            // Assert that op is -1 / 5.
            Assert.IsTrue(gmp_lib.mpq_cmp_si(op, -1, 5U) == 0);
            
            // Release unmanaged memory allocated for op.
            gmp_lib.mpq_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op to -1 / 3.
            Dim op As New mpq_t()
            gmp_lib.mpq_init(op)
            gmp_lib.mpq_set_si(op, -1, 3UI)
            
            ' Get reference to denominator, and increment it by 2.
            Dim num As mpz_t = gmp_lib.mpq_denref(op)
            gmp_lib.mpz_add_ui(num, num, 2UI)
            
            ' Assert that op is -1 / 5.
            Assert.IsTrue(gmp_lib.mpq_cmp_si(op, -1, 5UI) = 0)
            
            ' Release unmanaged memory allocated for op.
            gmp_lib.mpq_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpq_div(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">
            <summary>
            Set <paramref name="quotient"/> to <paramref name="dividend"/> / <paramref name="divisor"/>. 
            </summary>
            <param name="quotient">The result rational.</param>
            <param name="dividend">The first operand rational.</param>
            <param name="divisor">The second operand rational.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_add(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_sub(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_mul(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_mul_2exp(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,System.UInt32)">mpq_mul_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_div_2exp(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,System.UInt32)">mpq_div_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_neg(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_abs(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_abs</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_inv(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_inv</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Rational_Arithmetic">Rational Arithmetic</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Rational-Arithmetic.html#Rational-Arithmetic">GNU MP - Rational Arithmetic</a></seealso>
            <example>
            <code language="C#">
            </code> 
            <code language="VB.NET">
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpq_div_2exp(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,System.UInt32)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> / 2^<paramref name="op2"/>.
            </summary>
            <param name="rop">The result rational.</param>
            <param name="op1">The first operand rational.</param>
            <param name="op2">The second operand rational.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_add(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_sub(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_mul(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_mul_2exp(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,System.UInt32)">mpq_mul_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_div(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_div</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_neg(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_abs(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_abs</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_inv(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_inv</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Rational_Arithmetic">Rational Arithmetic</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Rational-Arithmetic.html#Rational-Arithmetic">GNU MP - Rational Arithmetic</a></seealso>
            <example>
            <code language="C#">
            </code> 
            <code language="VB.NET">
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpq_equal(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">
            <summary>
            Return non-zero if <paramref name="op1"/> and <paramref name="op2"/> are equal, zero if they are non-equal. 
            </summary>
            <param name="op1">The first operand rational.</param>
            <param name="op2">The second operand rational.</param>
            <returns>Return non-zero if <paramref name="op1"/> and <paramref name="op2"/> are equal, zero if they are non-equal.</returns>
            <remarks>
            <para>
            Although <see cref="M:Math.Gmp.Native.gmp_lib.mpq_cmp(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_cmp</see> can be used for the same purpose, this function is much faster. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_cmp(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_cmp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_cmp_z(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpz_t)">mpq_cmp_z</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_cmp_ui(Math.Gmp.Native.mpq_t,System.UInt32,System.UInt32)">mpq_cmp_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_cmp_si(Math.Gmp.Native.mpq_t,System.Int32,System.UInt32)">mpq_cmp_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_sgn(Math.Gmp.Native.mpq_t)">mpq_sgn</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Comparing_Rationals">Comparing Rationals</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Comparing-Rationals.html#Comparing-Rationals">GNU MP - Comparing Rationals</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op1 to 1 / 2.
            mpq_t op1 = new mpq_t();
            gmp_lib.mpq_init(op1);
            gmp_lib.mpq_set_si(op1, 1, 2U);
            
            // Create, initialize, and set the value of op2 to 1 / 3.
            mpq_t op2 = new mpq_t();
            gmp_lib.mpq_init(op2);
            gmp_lib.mpq_set_si(op2, 1, 3U);
            
            // Assert that op1 != op2.
            Assert.IsTrue(gmp_lib.mpq_equal(op1, op2) == 0);
            
            // Release unmanaged memory allocated for op1 and op2.
            gmp_lib.mpq_clears(op1, op2, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op1 to 1 / 2.
            Dim op1 As New mpq_t()
            gmp_lib.mpq_init(op1)
            gmp_lib.mpq_set_si(op1, 1, 2UI)
            
            ' Create, initialize, and set the value of op2 to 1 / 3.
            Dim op2 As New mpq_t()
            gmp_lib.mpq_init(op2)
            gmp_lib.mpq_set_si(op2, 1, 3UI)
            
            ' Assert that op1 != op2.
            Assert.IsTrue(gmp_lib.mpq_equal(op1, op2) = 0)
             
            ' Release unmanaged memory allocated for op1 and op2.
            gmp_lib.mpq_clears(op1, op2, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpq_get_num(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpq_t)">
            <summary>
            Set <paramref name="numerator"/> to the numerator of <paramref name="rational"/>.
            </summary>
            <param name="numerator">The result integer.</param>
            <param name="rational">The operand rational.</param>
            <remarks>
            <para>
            The function is equivalent to calling <see cref="M:Math.Gmp.Native.gmp_lib.mpz_set(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_set</see> with <see cref="M:Math.Gmp.Native.gmp_lib.mpq_numref(Math.Gmp.Native.mpq_t)">mpq_numref</see>.
            Direct use of <see cref="M:Math.Gmp.Native.gmp_lib.mpq_numref(Math.Gmp.Native.mpq_t)">mpq_numref</see> is recommended instead of this functions. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_numref(Math.Gmp.Native.mpq_t)">mpq_numref</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_denref(Math.Gmp.Native.mpq_t)">mpq_denref</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_get_den(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpq_t)">mpq_get_den </seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_num(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpz_t)">mpq_set_num</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_den(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpz_t)">mpq_set_den</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Applying_Integer_Functions">Applying Integer Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Applying-Integer-Functions.html#Applying-Integer-Functions">GNU MP - Applying Integer Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op to -1 / 3.
            mpq_t op = new mpq_t();
            gmp_lib.mpq_init(op);
            gmp_lib.mpq_set_si(op, -1, 3U);
            
            // Create and initialize a new integer.
            mpz_t num = new mpz_t();
            gmp_lib.mpz_init(num);
            
            // Set integer to numerator of rational, and increment integer by 2.
            gmp_lib.mpq_get_num(num, op);
            gmp_lib.mpz_add_ui(num, num, 2U);
            
            // Assert that num is 1, and op is -1 / 3.
            Assert.IsTrue(gmp_lib.mpz_cmp_si(num, 1) == 0);
            Assert.IsTrue(gmp_lib.mpq_cmp_si(op, -1, 3U) == 0);
            
            // Release unmanaged memory allocated for op and num.
            gmp_lib.mpq_clear(op);
            gmp_lib.mpz_clear(num);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op to -1 / 3.
            Dim op As New mpq_t()
            gmp_lib.mpq_init(op)
            gmp_lib.mpq_set_si(op, -1, 3UI)
            
            ' Create and initialize a new integer.
            Dim num As New mpz_t()
            gmp_lib.mpz_init(num)
            
            ' Set integer to numerator of rational, and increment integer by 2.
            gmp_lib.mpq_get_num(num, op)
            gmp_lib.mpz_add_ui(num, num, 2UI)
            
            ' Assert that num is 1, and op is -1 / 3.
            Assert.IsTrue(gmp_lib.mpz_cmp_si(num, 1) = 0)
            Assert.IsTrue(gmp_lib.mpq_cmp_si(op, -1, 3UI) = 0)
            
            ' Release unmanaged memory allocated for op and num.
            gmp_lib.mpq_clear(op)
            gmp_lib.mpz_clear(num)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpq_get_den(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpq_t)">
            <summary>
            Set <paramref name="denominator"/> to the denominator of <paramref name="rational"/>.
            </summary>
            <param name="denominator">The result integer.</param>
            <param name="rational">The operand rational.</param>
            <remarks>
            <para>
            The function is equivalent to calling <see cref="M:Math.Gmp.Native.gmp_lib.mpz_set(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_set</see> with <see cref="M:Math.Gmp.Native.gmp_lib.mpq_denref(Math.Gmp.Native.mpq_t)">mpq_denref</see>.
            Direct use of <see cref="M:Math.Gmp.Native.gmp_lib.mpq_denref(Math.Gmp.Native.mpq_t)">mpq_denref</see> is recommended instead of this functions. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_numref(Math.Gmp.Native.mpq_t)">mpq_numref</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_denref(Math.Gmp.Native.mpq_t)">mpq_denref</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_get_num(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpq_t)">mpq_get_num</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_get_den(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpq_t)">mpq_get_den </seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_num(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpz_t)">mpq_set_num</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_den(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpz_t)">mpq_set_den</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Applying_Integer_Functions">Applying Integer Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Applying-Integer-Functions.html#Applying-Integer-Functions">GNU MP - Applying Integer Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op to -1 / 3.
            mpq_t op = new mpq_t();
            gmp_lib.mpq_init(op);
            gmp_lib.mpq_set_si(op, -1, 3U);
            
            // Create and initialize a new integer.
            mpz_t den = new mpz_t();
            gmp_lib.mpz_init(den);
            
            // Set integer to numerator of rational, and increment integer by 2..
            gmp_lib.mpq_get_den(den, op);
            gmp_lib.mpz_add_ui(den, den, 2U);
            
            // Assert that num is 1, and op is -1 / 3.
            Assert.IsTrue(gmp_lib.mpz_cmp_si(den, 5) == 0);
            Assert.IsTrue(gmp_lib.mpq_cmp_si(op, -1, 3U) == 0);
            
            // Release unmanaged memory allocated for op and num.
            gmp_lib.mpq_clear(op);
            gmp_lib.mpz_clear(den);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op to -1 / 3.
            Dim op As New mpq_t()
            gmp_lib.mpq_init(op)
            gmp_lib.mpq_set_si(op, -1, 3UI)
            
            ' Create and initialize a new integer.
            Dim den As New mpz_t()
            gmp_lib.mpz_init(den)
            
            ' Set integer to numerator of rational, and increment integer by 2..
            gmp_lib.mpq_get_den(den, op)
            gmp_lib.mpz_add_ui(den, den, 2UI)
            
            ' Assert that num is 1, and op is -1 / 3.
            Assert.IsTrue(gmp_lib.mpz_cmp_si(den, 5) = 0)
            Assert.IsTrue(gmp_lib.mpq_cmp_si(op, -1, 3UI) = 0)
            
            ' Release unmanaged memory allocated for op and num.
            gmp_lib.mpq_clear(op)
            gmp_lib.mpz_clear(den)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpq_get_d(Math.Gmp.Native.mpq_t)">
            <summary>
            Convert <paramref name="op"/> to a <see cref="T:System.Double">double</see>, truncating if necessary (i.e. rounding towards zero). 
            </summary>
            <param name="op">The operand rational.</param>
            <returns>The converted <see cref="T:System.Double">double</see>.</returns>
            <remarks>
            <para>
            If the exponent from the conversion is too big or too small to fit a <see cref="T:System.Double">double</see> then the result is system dependent.
            For too big an infinity is returned when available.
            For too small 0.0 is normally returned.
            Hardware overflow, underflow and denorm traps may or may not occur. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_d(Math.Gmp.Native.mpq_t,System.Double)">mpq_set_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_f(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpf_t)">mpq_set_f</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_get_str(Math.Gmp.Native.char_ptr,System.Int32,Math.Gmp.Native.mpq_t)">mpq_get_str</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Rational_Conversions">Rational Conversions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Rational-Conversions.html#Rational-Conversions">GNU MP - Rational Conversions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of x to 10 / 11.
            mpq_t x = new mpq_t();
            gmp_lib.mpq_init(x);
            gmp_lib.mpq_set_si(x, 10, 11U);
            
            // Assert that the value of x is 10.0.
            Assert.IsTrue(gmp_lib.mpq_get_d(x) == 10.0 / 11.0);
            
            // Release unmanaged memory allocated for x.
            gmp_lib.mpq_clear(x);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of x to 10 / 11.
            Dim x As New mpq_t()
            gmp_lib.mpq_init(x)
            gmp_lib.mpq_set_si(x, 10, 11UI)
            
            ' Assert that the value of x is 10.0.
            Assert.IsTrue(gmp_lib.mpq_get_d(x) = 10.0 / 11.0)
            
            ' Release unmanaged memory allocated for x.
            gmp_lib.mpq_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpq_get_str(Math.Gmp.Native.char_ptr,System.Int32,Math.Gmp.Native.mpq_t)">
            <summary>
            Convert <paramref name="op"/> to a string of digits in base <paramref name="base"/>.
            </summary>
            <param name="str">The result string.</param>
            <param name="base">The base.</param>
            <param name="op">The operand rational.</param>
            <returns>A pointer to the result string is returned, being either the allocated block, or the given <paramref name="str"/>.</returns>
            <remarks>
            <para>
            The base may vary from 2 to 36. The string will be of the form "num/den", or if the denominator is 1 then just "num". 
            </para>
            <para>
            If <paramref name="str"/> is NULL, the result string is allocated using the current allocation function
            (see <a href="https://gmplib.org/manual/Custom-Allocation.html#Custom-Allocation">GNU MP - Custom Allocation</a>).
            The block will be strlen(<paramref name="str"/>) + 1 bytes, that being exactly enough for the string and null-terminator. 
            </para>
            <para>
            If <paramref name="str"/> is not NULL, it should point to a block of storage large enough for the result, that being 
            </para>
            <code language="C++">
            mpz_sizeinbase(mpq_numref(op), base) + mpz_sizeinbase(mpq_denref(op), base) + 3
            </code> 
            <para>
            The three extra bytes are for a possible minus sign, possible slash, and the null-terminator.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_get_d(Math.Gmp.Native.mpq_t)">mpq_get_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_d(Math.Gmp.Native.mpq_t,System.Double)">mpq_set_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_f(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpf_t)">mpq_set_f</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Rational_Conversions">Rational Conversions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Rational-Conversions.html#Rational-Conversions">GNU MP - Rational Conversions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of x to -210 / 13.
            mpq_t x = new mpq_t();
            gmp_lib.mpq_init(x);
            gmp_lib.mpq_set_si(x, -210, 13U);
            
            // Retrieve the string value of x, and assert that it is "-210/13".
            char_ptr s = gmp_lib.mpq_get_str(char_ptr.Zero, 10, x);
            Assert.IsTrue(s.ToString() == "-210/13");
            
            // Release unmanaged memory allocated for x and the string value.
            gmp_lib.mpq_clear(x);
            gmp_lib.free(s);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of x to -210 / 13.
            Dim x As New mpq_t()
            gmp_lib.mpq_init(x)
            gmp_lib.mpq_set_si(x, -210, 13UI)
            
            ' Retrieve the string value of x, and assert that it is "-210/13".
            Dim s As char_ptr = gmp_lib.mpq_get_str(char_ptr.Zero, 10, x)
            Assert.IsTrue(s.ToString() = "-210/13")
            
            ' Release unmanaged memory allocated for x and the string value.
            gmp_lib.mpq_clear(x)
            gmp_lib.free(s)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpq_init(Math.Gmp.Native.mpq_t)">
            <summary>
            Initialize <paramref name="x"/> and set it to 0/1.
            </summary>
            <param name="x">The operand rational.</param>
            <remarks>
            <para>
             Each variable should normally only be initialized once, or at least cleared out
             (using the function <see cref="M:Math.Gmp.Native.gmp_lib.mpq_clear(Math.Gmp.Native.mpq_t)">mpq_clear</see>) between each initialization. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_canonicalize(Math.Gmp.Native.mpq_t)">mpq_canonicalize</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_inits(Math.Gmp.Native.mpq_t[])">mpq_inits</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_clear(Math.Gmp.Native.mpq_t)">mpq_clear</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_clears(Math.Gmp.Native.mpq_t[])">mpq_clears</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_set</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_z(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpz_t)">mpq_set_z</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_ui(Math.Gmp.Native.mpq_t,System.UInt32,System.UInt32)">mpq_set_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_si(Math.Gmp.Native.mpq_t,System.Int32,System.UInt32)">mpq_set_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_str(Math.Gmp.Native.mpq_t,Math.Gmp.Native.char_ptr,System.Int32)">mpq_set_str</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_swap(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_swap</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Initializing_Rationals">Initializing Rationals</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Initializing-Rationals.html#Initializing-Rationals">GNU MP - Initializing Rationals</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize a new rational x.
            mpq_t x = new mpq_t();
            gmp_lib.mpq_init(x);
            
            // Assert that the value of x is 0.
            char_ptr s = gmp_lib.mpq_get_str(char_ptr.Zero, 10, x);
            Assert.IsTrue(s.ToString() == "0");
            
            // Release unmanaged memory allocated for x and its string value.
            gmp_lib.mpq_clear(x);
            gmp_lib.free(s);
            </code> 
            <code language="VB.NET">
            ' Create and initialize a new rational x.
            Dim x As New mpq_t()
            gmp_lib.mpq_init(x)
            
            ' Assert that the value of x is 0.
            Dim s As char_ptr = gmp_lib.mpq_get_str(char_ptr.Zero, 10, x)
            Assert.IsTrue(s.ToString() = "0")
            
            ' Release unmanaged memory allocated for x and its string value.
            gmp_lib.mpq_clear(x)
            gmp_lib.free(s)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpq_inits(Math.Gmp.Native.mpq_t[])">
            <summary>
            Initialize a NULL-terminated list of <see cref="T:Math.Gmp.Native.mpq_t">mpq_t</see> variables, and set their values to 0/1. 
            </summary>
            <param name="x">The operand rational.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_canonicalize(Math.Gmp.Native.mpq_t)">mpq_canonicalize</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_init(Math.Gmp.Native.mpq_t)">mpq_init</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_clear(Math.Gmp.Native.mpq_t)">mpq_clear</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_clears(Math.Gmp.Native.mpq_t[])">mpq_clears</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_set</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_z(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpz_t)">mpq_set_z</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_ui(Math.Gmp.Native.mpq_t,System.UInt32,System.UInt32)">mpq_set_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_si(Math.Gmp.Native.mpq_t,System.Int32,System.UInt32)">mpq_set_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_str(Math.Gmp.Native.mpq_t,Math.Gmp.Native.char_ptr,System.Int32)">mpq_set_str</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_swap(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_swap</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Initializing_Rationals">Initializing Rationals</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Initializing-Rationals.html#Initializing-Rationals">GNU MP - Initializing Rationals</a></seealso>
            <example>
            <code language="C#">
            // Create new rationals x1, x2 and x3.
            mpq_t x1 = new mpq_t();
            mpq_t x2 = new mpq_t();
            mpq_t x3 = new mpq_t();
            
            // Initialize the rationals.
            gmp_lib.mpq_inits(x1, x2, x3);
            
            // Assert that their value is 0.
            Assert.IsTrue(gmp_lib.mpq_get_d(x1) == 0.0);
            Assert.IsTrue(gmp_lib.mpq_get_d(x2) == 0.0);
            Assert.IsTrue(gmp_lib.mpq_get_d(x3) == 0.0);
            
            // Release unmanaged memory allocated for the rationals.
            gmp_lib.mpq_clears(x1, x2, x3, null);
            </code> 
            <code language="VB.NET">
            ' Create new rationals x1, x2 and x3.
            Dim x1 As New mpq_t()
            Dim x2 As New mpq_t()
            Dim x3 As New mpq_t()
            
            ' Initialize the rationals.
            gmp_lib.mpq_inits(x1, x2, x3)
            
            ' Assert that their value is 0.
            Assert.IsTrue(gmp_lib.mpq_get_d(x1) = 0.0)
            Assert.IsTrue(gmp_lib.mpq_get_d(x2) = 0.0)
            Assert.IsTrue(gmp_lib.mpq_get_d(x3) = 0.0)
            
            ' Release unmanaged memory allocated for the rationals.
            gmp_lib.mpq_clears(x1, x2, x3, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpq_inp_str(Math.Gmp.Native.mpq_t,Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.Int32)">
            <summary>
            Read a string of digits from <paramref name="stream"/> and convert them to a rational in <paramref name="rop"/>.
            </summary>
            <param name="rop">The result rational.</param>
            <param name="stream">Pointer to file stream.</param>
            <param name="base">The base.</param>
            <returns>Return the number of characters read (including white space), or 0 if a rational could not be read.</returns>
            <remarks>
            <para>
            Any initial white-space characters are read and discarded.
            </para>
            <para>
            The input can be a fraction like "17/63" or just an integer like "123".
            Reading stops at the first character not in this form, and white space is not permitted within the string.
            If the input might not be in canonical form, then <see cref="M:Math.Gmp.Native.gmp_lib.mpq_canonicalize(Math.Gmp.Native.mpq_t)">mpq_canonicalize</see> must be called
            (see <a href="https://gmplib.org/manual/Rational-Number-Functions.html#Rational-Number-Functions">GNU MP - Rational Number Functions</a>). 
            </para>
            <para>
            The base can be between 2 and 36, or can be 0 in which case the leading characters
            of the string determine the base, "0x" or "0X" for hexadecimal, "0" for octal, or decimal otherwise.
            The leading characters are examined separately for the numerator and denominator of a fraction, so for instance
            "0x10/11" is 16/11, whereas "0x10/0x11" is 16/17. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_out_str(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.Int32,Math.Gmp.Native.mpq_t)">mpq_out_str</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#IO_of_Rationals">I/O of Rationals</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/I_002fO-of-Rationals.html#I_002fO-of-Rationals">GNU MP - I/O of Rationals</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op to 123/456.
            mpq_t op = new mpq_t();
            gmp_lib.mpq_init(op);
            
            // Write rational to a temporary file.
            string pathname = System.IO.Path.GetTempFileName();
            System.IO.File.WriteAllText(pathname, "123/456");
            
            // Read op from the temporary file, and assert that the number of bytes read is 7.
            ptr&lt;FILE&gt; stream = new ptr&lt;FILE&gt;();
            _wfopen_s(out stream.Value.Value, pathname, "r");
            Assert.IsTrue(gmp_lib.mpq_inp_str(op, stream, 10) == 7);
            fclose(stream.Value.Value);
            
            // Assert that op is 123/456.
            Assert.IsTrue(gmp_lib.mpq_cmp_ui(op, 123, 456U) == 0);
            
            // Delete temporary file.
            System.IO.File.Delete(pathname);
            
            // Release unmanaged memory allocated for op.
            gmp_lib.mpq_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op to 123/456.
            Dim op As New mpq_t()
            gmp_lib.mpq_init(op)
            
            ' Write rational to a temporary file.
            Dim pathname As String = System.IO.Path.GetTempFileName()
            System.IO.File.WriteAllText(pathname, "123/456")
            
            ' Read op from the temporary file, and assert that the number of bytes read is 7.
            Dim stream As New ptr(Of FILE)()
            _wfopen_s(stream.Value.Value, pathname, "r")
            Assert.IsTrue(gmp_lib.mpq_inp_str(op, stream, 10) = 7)
            fclose(stream.Value.Value)
            
            ' Assert that op is 123/456.
            Assert.IsTrue(gmp_lib.mpq_cmp_ui(op, 123, 456UI) = 0)
            
            ' Delete temporary file.
            System.IO.File.Delete(pathname)
            
            ' Release unmanaged memory allocated for op.
            gmp_lib.mpq_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpq_inv(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">
            <summary>
            Set <paramref name="inverted_number"/> to 1 / <paramref name="number"/>.
            </summary>
            <param name="inverted_number">The result rational.</param>
            <param name="number">The operand rational.</param>
            <remarks>
            <para>
            If the new denominator is zero, this routine will divide by zero.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_add(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_sub(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_mul(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_mul_2exp(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,System.UInt32)">mpq_mul_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_div(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_div</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_div_2exp(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,System.UInt32)">mpq_div_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_neg(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_abs(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_abs</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Rational_Arithmetic">Rational Arithmetic</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Rational-Arithmetic.html#Rational-Arithmetic">GNU MP - Rational Arithmetic</a></seealso>
            <example>
            <code language="C#">
            </code> 
            <code language="VB.NET">
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpq_mul(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">
            <summary>
            Set <paramref name="product"/> to <paramref name="multiplier"/> * <paramref name="multiplicand"/>. 
            </summary>
            <param name="product">The result rational.</param>
            <param name="multiplier">The first operand rational.</param>
            <param name="multiplicand">The second operand rational.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_add(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_sub(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_mul_2exp(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,System.UInt32)">mpq_mul_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_div(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_div</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_div_2exp(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,System.UInt32)">mpq_div_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_neg(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_abs(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_abs</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_inv(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_inv</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Rational_Arithmetic">Rational Arithmetic</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Rational-Arithmetic.html#Rational-Arithmetic">GNU MP - Rational Arithmetic</a></seealso>
            <example>
            <code language="C#">
            </code> 
            <code language="VB.NET">
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpq_mul_2exp(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,System.UInt32)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> * 2*<paramref name="op2"/>.
            </summary>
            <param name="rop">The result rational.</param>
            <param name="op1">The first operand rational.</param>
            <param name="op2">The second operand rational.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_add(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_sub(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_mul(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_div(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_div</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_div_2exp(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,System.UInt32)">mpq_div_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_neg(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_abs(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_abs</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_inv(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_inv</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Rational_Arithmetic">Rational Arithmetic</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Rational-Arithmetic.html#Rational-Arithmetic">GNU MP - Rational Arithmetic</a></seealso>
            <example>
            <code language="C#">
            </code> 
            <code language="VB.NET">
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpq_neg(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">
            <summary>
            Set <paramref name="negated_operand"/> to -<paramref name="operand"/>.
            </summary>
            <param name="negated_operand">The result rational.</param>
            <param name="operand">The operand rational.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_add(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_sub(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_mul(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_mul_2exp(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,System.UInt32)">mpq_mul_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_div(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_div</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_div_2exp(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,System.UInt32)">mpq_div_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_abs(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_abs</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_inv(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_inv</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Rational_Arithmetic">Rational Arithmetic</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Rational-Arithmetic.html#Rational-Arithmetic">GNU MP - Rational Arithmetic</a></seealso>
            <example>
            <code language="C#">
            </code> 
            <code language="VB.NET">
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpq_numref(Math.Gmp.Native.mpq_t)">
            <summary>
            Return a reference to the numerator <paramref name="op"/>.
            </summary>
            <param name="op">The operand rational.</param>
            <returns>Return a reference to the numerator <paramref name="op"/>.</returns>
            <remarks>
            <para>
            The <c>mpz</c> functions can be used on the returned reference. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_denref(Math.Gmp.Native.mpq_t)">mpq_denref</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_get_num(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpq_t)">mpq_get_num</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_get_den(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpq_t)">mpq_get_den </seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_num(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpz_t)">mpq_set_num</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_den(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpz_t)">mpq_set_den</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Applying_Integer_Functions">Applying Integer Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Applying-Integer-Functions.html#Applying-Integer-Functions">GNU MP - Applying Integer Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op to -1 / 3.
            mpq_t op = new mpq_t();
            gmp_lib.mpq_init(op);
            gmp_lib.mpq_set_si(op, -1, 3U);
            
            // Get reference to numerator, and increment it by 2.
            mpz_t num = gmp_lib.mpq_numref(op);
            gmp_lib.mpz_add_ui(num, num, 2U);
            
            // Assert that op is 1 / 3.
            Assert.IsTrue(gmp_lib.mpq_cmp_si(op, 1, 3U) == 0);
            
            // Release unmanaged memory allocated for op.
            gmp_lib.mpq_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op to -1 / 3.
            Dim op As New mpq_t()
            gmp_lib.mpq_init(op)
            gmp_lib.mpq_set_si(op, -1, 3UI)
            
            ' Get reference to numerator, and increment it by 2.
            Dim num As mpz_t = gmp_lib.mpq_numref(op)
            gmp_lib.mpz_add_ui(num, num, 2UI)
            
            ' Assert that op is 1 / 3.
            Assert.IsTrue(gmp_lib.mpq_cmp_si(op, 1, 3UI) = 0)
            
            ' Release unmanaged memory allocated for op.
            gmp_lib.mpq_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpq_out_str(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.Int32,Math.Gmp.Native.mpq_t)">
            <summary>
            Output <paramref name="op"/> on stdio stream <paramref name="stream"/>, as a string of digits in base <paramref name="base"/>.
            </summary>
            <param name="stream">Pointer to file stream.</param>
            <param name="base">The base.</param>
            <param name="op">The operand rational.</param>
            <returns>Return the number of bytes written, or if an error occurred, return 0.</returns>
            <remarks>
            <para>
            The <paramref name="base"/> may vary from 2 to 36.
            Output is in the form "num/den" or if the denominator is 1 then just "num". 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_inp_str(Math.Gmp.Native.mpq_t,Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.Int32)">mpq_inp_str</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#IO_of_Rationals">I/O of Rationals</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/I_002fO-of-Rationals.html#I_002fO-of-Rationals">GNU MP - I/O of Rationals</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op to 123/456.
            mpq_t op = new mpq_t();
            gmp_lib.mpq_init(op);
            gmp_lib.mpq_set_ui(op, 123, 456U);
            
            // Get a temporary file.
            string pathname = System.IO.Path.GetTempFileName();
            
            // Open temporary file for writing.
            ptr&lt;FILE&gt; stream = new ptr&lt;FILE&gt;();
            _wfopen_s(out stream.Value.Value, pathname, "w");
            
            // Write op to temporary file, and assert that the number of bytes written is 7.
            Assert.IsTrue(gmp_lib.mpq_out_str(stream, 10, op) == 7);
            
            // Close temporary file.
            fclose(stream.Value.Value);
            
            // Assert that the content of the temporary file is "123/456".
            string result = System.IO.File.ReadAllText(pathname);
            Assert.IsTrue(result == "123/456");
            
            // Delete temporary file.
            System.IO.File.Delete(pathname);
            
            // Release unmanaged memory allocated for op.
            gmp_lib.mpq_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op to 123/456.
            Dim op As New mpq_t()
            gmp_lib.mpq_init(op)
            gmp_lib.mpq_set_ui(op, 123, 456UI)
            
            ' Get a temporary file.
            Dim pathname As String = System.IO.Path.GetTempFileName()
            
            ' Open temporary file for writing.
            Dim stream As New ptr(Of FILE)()
            _wfopen_s(stream.Value.Value, pathname, "w")
            
            ' Write op to temporary file, and assert that the number of bytes written is 7.
            Assert.IsTrue(gmp_lib.mpq_out_str(stream, 10, op) = 7)
            
            ' Close temporary file.
            fclose(stream.Value.Value)
            
            ' Assert that the content of the temporary file is "123/456".
            Dim result As String = System.IO.File.ReadAllText(pathname)
            
            Assert.IsTrue(result = "123/456")
            
            ' Delete temporary file.
            System.IO.File.Delete(pathname)
            
            ' Release unmanaged memory allocated for op.
            gmp_lib.mpq_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpq_set(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">
            <summary>
            Assign <paramref name="rop"/> from <paramref name="op"/>.
            </summary>
            <param name="rop">The result rational.</param>
            <param name="op">The operand rational.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_canonicalize(Math.Gmp.Native.mpq_t)">mpq_canonicalize</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_init(Math.Gmp.Native.mpq_t)">mpq_init</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_inits(Math.Gmp.Native.mpq_t[])">mpq_inits</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_clear(Math.Gmp.Native.mpq_t)">mpq_clear</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_clears(Math.Gmp.Native.mpq_t[])">mpq_clears</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_z(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpz_t)">mpq_set_z</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_ui(Math.Gmp.Native.mpq_t,System.UInt32,System.UInt32)">mpq_set_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_si(Math.Gmp.Native.mpq_t,System.Int32,System.UInt32)">mpq_set_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_str(Math.Gmp.Native.mpq_t,Math.Gmp.Native.char_ptr,System.Int32)">mpq_set_str</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_swap(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_swap</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Initializing_Rationals">Initializing Rationals</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Initializing-Rationals.html#Initializing-Rationals">GNU MP - Initializing Rationals</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new rational x to 10 / 11.
            mpq_t x = new mpq_t();
            gmp_lib.mpq_init(x);
            gmp_lib.mpq_set_si(x, 10, 11);
            
            // Create, initialize, and set a new rational y to -210 / 13.
            mpq_t y = new mpq_t();
            gmp_lib.mpq_init(y);
            gmp_lib.mpq_set_si(y, -210, 13);
            
            // Assign the value of y to x.
            gmp_lib.mpq_set(x, y);
            
            // Assert that the value of x is -210 / 13.
            Assert.IsTrue(gmp_lib.mpq_cmp_si(x, -210, 13) == 0);
            
            // Release unmanaged memory allocated for x and y.
            gmp_lib.mpq_clears(x, y, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new rational x to 10 / 11.
            Dim x As New mpq_t()
            gmp_lib.mpq_init(x)
            gmp_lib.mpq_set_si(x, 10, 11)
            
            ' Create, initialize, and set a new rational y to -210 / 13.
            Dim y As New mpq_t()
            gmp_lib.mpq_init(y)
            gmp_lib.mpq_set_si(y, -210, 13)
            
            ' Assign the value of y to x.
            gmp_lib.mpq_set(x, y)
            
            ' Assert that the value of x is -210 / 13.
            Assert.IsTrue(gmp_lib.mpq_cmp_si(x, -210, 13) = 0)
            
            ' Release unmanaged memory allocated for x and y.
            gmp_lib.mpq_clears(x, y, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpq_set_d(Math.Gmp.Native.mpq_t,System.Double)">
            <summary>
            Set <paramref name="rop"/> to the value of <paramref name="op"/>. There is no rounding, this conversion is exact. 
            </summary>
            <param name="rop">The result rational.</param>
            <param name="op">The operand <see cref="T:System.Double">double</see>.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_canonicalize(Math.Gmp.Native.mpq_t)">mpq_canonicalize</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_get_d(Math.Gmp.Native.mpq_t)">mpq_get_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_f(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpf_t)">mpq_set_f</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_get_str(Math.Gmp.Native.char_ptr,System.Int32,Math.Gmp.Native.mpq_t)">mpq_get_str</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Rational_Conversions">Rational Conversions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Rational-Conversions.html#Rational-Conversions">GNU MP - Rational Conversions</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize a new rational.
            mpq_t x = new mpq_t();
            gmp_lib.mpq_init(x);
            
            // Set the value of x to 10.0 / 11.0.
            gmp_lib.mpq_set_d(x, 10.0D / 11.0);
            
            // Assert that the value of x is 10.0 / 11.0.
            Assert.IsTrue(gmp_lib.mpq_get_d(x) == 10.0D / 11.0);
            
            // Release unmanaged memory allocated for x.
            gmp_lib.mpq_clear(x);
            </code> 
            <code language="VB.NET">
            ' Create and initialize a new rational.
            Dim x As New mpq_t()
            gmp_lib.mpq_init(x)
            
            ' Set the value of x to 10.0 / 11.0.
            gmp_lib.mpq_set_d(x, 10.0 / 11.0)
            
            ' Assert that the value of x is 10.0 / 11.0.
            Assert.IsTrue(gmp_lib.mpq_get_d(x) = 10.0 / 11.0)
            
            ' Release unmanaged memory allocated for x.
            gmp_lib.mpq_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpq_set_den(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpz_t)">
            <summary>
            Set the denominator of <paramref name="rational"/> to <paramref name="denominator"/>.
            </summary>
            <param name="rational">The result rational.</param>
            <param name="denominator">The operand integer.</param>
            <remarks>
            The function is equivalent to calling <see cref="M:Math.Gmp.Native.gmp_lib.mpz_set(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_set</see> with <see cref="M:Math.Gmp.Native.gmp_lib.mpq_denref(Math.Gmp.Native.mpq_t)">mpq_denref</see>.
            Direct use of <see cref="M:Math.Gmp.Native.gmp_lib.mpq_denref(Math.Gmp.Native.mpq_t)">mpq_denref</see> is recommended instead of this functions. 
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_numref(Math.Gmp.Native.mpq_t)">mpq_numref</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_denref(Math.Gmp.Native.mpq_t)">mpq_denref</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_get_num(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpq_t)">mpq_get_num</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_get_den(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpq_t)">mpq_get_den </seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_num(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpz_t)">mpq_set_num</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Applying_Integer_Functions">Applying Integer Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Applying-Integer-Functions.html#Applying-Integer-Functions">GNU MP - Applying Integer Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op to -1 / 3.
            mpq_t op = new mpq_t();
            gmp_lib.mpq_init(op);
            gmp_lib.mpq_set_si(op, -1, 3U);
            
            // Create, initialize, and set the value of a new integer to 5.
            mpz_t den = new mpz_t();
            gmp_lib.mpz_init_set_ui(den, 5U);
            
            // Set the denominator of op.
            gmp_lib.mpq_set_den(op, den);
            
            // Assert that op is -1 / 5.
            Assert.IsTrue(gmp_lib.mpq_cmp_si(op, -1, 5U) == 0);
            
            // Release unmanaged memory allocated for op and num.
            gmp_lib.mpq_clear(op);
            gmp_lib.mpz_clear(den);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op to -1 / 3.
            Dim op As New mpq_t()
            gmp_lib.mpq_init(op)
            gmp_lib.mpq_set_si(op, -1, 3UI)
            
            ' Create, initialize, and set the value of a new integer to 5.
            Dim den As New mpz_t()
            gmp_lib.mpz_init_set_ui(den, 5UI)
            
            ' Set the denominator of op.
            gmp_lib.mpq_set_den(op, den)
            
            ' Assert that op is -1 / 5.
            Assert.IsTrue(gmp_lib.mpq_cmp_si(op, -1, 5UI) = 0)
            
            ' Release unmanaged memory allocated for op and num.
            gmp_lib.mpq_clear(op)
            gmp_lib.mpz_clear(den)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpq_set_f(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpf_t)">
            <summary>
            Set <paramref name="rop"/> to the value of <paramref name="op"/>. There is no rounding, this conversion is exact. 
            </summary>
            <param name="rop">The result rational.</param>
            <param name="op">The operand <see cref="T:System.Single">float</see>.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_get_d(Math.Gmp.Native.mpq_t)">mpq_get_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_d(Math.Gmp.Native.mpq_t,System.Double)">mpq_set_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_get_str(Math.Gmp.Native.char_ptr,System.Int32,Math.Gmp.Native.mpq_t)">mpq_get_str</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Rational_Conversions">Rational Conversions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Rational-Conversions.html#Rational-Conversions">GNU MP - Rational Conversions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new rational x to 10 / 11.
            mpq_t x = new mpq_t();
            gmp_lib.mpq_init(x);
            gmp_lib.mpq_set_si(x, 10, 11);
            
            // Create, initialize, and set a new float y to -210.
            mpf_t y = new mpf_t();
            gmp_lib.mpf_init(y);
            gmp_lib.mpf_set_si(y, -210);
            
            // Assign the value of y to x.
            gmp_lib.mpq_set_f(x, y);
            
            // Assert that the value of x is -210 / 1.
            Assert.IsTrue(gmp_lib.mpq_cmp_si(x, -210, 1) == 0);
            
            // Release unmanaged memory allocated for x and y.
            gmp_lib.mpq_clear(x);
            gmp_lib.mpf_clear(y);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new rational x to 10 / 11.
            Dim x As New mpq_t()
            gmp_lib.mpq_init(x)
            gmp_lib.mpq_set_si(x, 10, 11)
            
            ' Create, initialize, and set a new float y to -210.
            Dim y As New mpf_t()
            gmp_lib.mpf_init(y)
            gmp_lib.mpf_set_si(y, -210)
            
            ' Assign the value of y to x.
            gmp_lib.mpq_set_f(x, y)
            
            ' Assert that the value of x is -210 / 1.
            Assert.IsTrue(gmp_lib.mpq_cmp_si(x, -210, 1) = 0)
            
            ' Release unmanaged memory allocated for x and y.
            gmp_lib.mpq_clear(x)
            gmp_lib.mpf_clear(y)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpq_set_num(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpz_t)">
            <summary>
            Set the numerator of <paramref name="rational"/> to <paramref name="numerator"/>.
            </summary>
            <param name="rational">The result rational.</param>
            <param name="numerator">The operand integer.</param>
            <remarks>
            <para>
            The function is equivalent to calling <see cref="M:Math.Gmp.Native.gmp_lib.mpz_set(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpz_t)">mpz_set</see> with <see cref="M:Math.Gmp.Native.gmp_lib.mpq_numref(Math.Gmp.Native.mpq_t)">mpq_numref</see>.
            Direct use of <see cref="M:Math.Gmp.Native.gmp_lib.mpq_numref(Math.Gmp.Native.mpq_t)">mpq_numref</see> is recommended instead of this functions. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_numref(Math.Gmp.Native.mpq_t)">mpq_numref</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_denref(Math.Gmp.Native.mpq_t)">mpq_denref</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_get_num(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpq_t)">mpq_get_num</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_get_den(Math.Gmp.Native.mpz_t,Math.Gmp.Native.mpq_t)">mpq_get_den </seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_den(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpz_t)">mpq_set_den</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Applying_Integer_Functions">Applying Integer Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Applying-Integer-Functions.html#Applying-Integer-Functions">GNU MP - Applying Integer Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op to -1 / 3.
            mpq_t op = new mpq_t();
            gmp_lib.mpq_init(op);
            gmp_lib.mpq_set_si(op, -1, 3U);
            
            // Create, initialize, and set the value of a new integer to 5.
            mpz_t num = new mpz_t();
            gmp_lib.mpz_init_set_ui(num, 5U);
            
            // Set the numerator of op.
            gmp_lib.mpq_set_num(op, num);
            
            // Assert that op is 5 / 3.
            Assert.IsTrue(gmp_lib.mpq_cmp_si(op, 5, 3U) == 0);
            
            // Release unmanaged memory allocated for op and num.
            gmp_lib.mpq_clear(op);
            gmp_lib.mpz_clear(num);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op to -1 / 3.
            Dim op As New mpq_t()
            gmp_lib.mpq_init(op)
            gmp_lib.mpq_set_si(op, -1, 3UI)
            
            ' Create, initialize, and set the value of a new integer to 5.
            Dim num As New mpz_t()
            gmp_lib.mpz_init_set_ui(num, 5UI)
            
            ' Set the numerator of op.
            gmp_lib.mpq_set_num(op, num)
            
            ' Assert that op is 5 / 3.
            Assert.IsTrue(gmp_lib.mpq_cmp_si(op, 5, 3UI) = 0)
            
            ' Release unmanaged memory allocated for op and num.
            gmp_lib.mpq_clear(op)
            gmp_lib.mpz_clear(num)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpq_set_si(Math.Gmp.Native.mpq_t,System.Int32,System.UInt32)">
            <summary>
            Set the value of <paramref name="rop"/> to <paramref name="op1"/> / <paramref name="op2"/>.
            </summary>
            <param name="rop">The result rational.</param>
            <param name="op1">The first operand rational.</param>
            <param name="op2">The second operand rational.</param>
            <remarks>
            <para>
            Note that if <paramref name="op1"/> and <paramref name="op2"/> have common factors,
            <paramref name="rop"/> has to be passed to <see cref="M:Math.Gmp.Native.gmp_lib.mpq_canonicalize(Math.Gmp.Native.mpq_t)">mpq_canonicalize</see> before any
            operations are performed on <paramref name="rop"/>. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_canonicalize(Math.Gmp.Native.mpq_t)">mpq_canonicalize</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_init(Math.Gmp.Native.mpq_t)">mpq_init</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_inits(Math.Gmp.Native.mpq_t[])">mpq_inits</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_clear(Math.Gmp.Native.mpq_t)">mpq_clear</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_clears(Math.Gmp.Native.mpq_t[])">mpq_clears</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_set</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_z(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpz_t)">mpq_set_z</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_ui(Math.Gmp.Native.mpq_t,System.UInt32,System.UInt32)">mpq_set_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_str(Math.Gmp.Native.mpq_t,Math.Gmp.Native.char_ptr,System.Int32)">mpq_set_str</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_swap(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_swap</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Initializing_Rationals">Initializing Rationals</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Initializing-Rationals.html#Initializing-Rationals">GNU MP - Initializing Rationals</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize a new rational x.
            mpq_t x = new mpq_t();
            gmp_lib.mpq_init(x);
            
            // Set the value of x to -10 / 11.
            gmp_lib.mpq_set_si(x, -10, 11);
            
            // Assert that the value of x is -10 / 1.
            Assert.IsTrue(gmp_lib.mpq_cmp_si(x, -10, 11U) == 0);
            
            // Release unmanaged memory allocated for x.
            gmp_lib.mpq_clear(x);
            </code> 
            <code language="VB.NET">
            ' Create and initialize a new rational x.
            Dim x As New mpq_t()
            gmp_lib.mpq_init(x)
            
            ' Set the value of x to -10 / 11.
            gmp_lib.mpq_set_si(x, -10, 11)
            
            ' Assert that the value of x is -10 / 1.
            Assert.IsTrue(gmp_lib.mpq_cmp_si(x, -10, 11UI) = 0)
            
            ' Release unmanaged memory allocated for x.
            gmp_lib.mpq_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpq_set_str(Math.Gmp.Native.mpq_t,Math.Gmp.Native.char_ptr,System.Int32)">
            <summary>
            Set <paramref name="rop"/> from a null-terminated string <paramref name="str"/> in the given <paramref name="base"/>.
            </summary>
            <param name="rop">The result rational.</param>
            <param name="str">The source string.</param>
            <param name="base">The base,</param>
            <returns>The return value is 0 if the entire string is a valid number, or -1 if not.</returns>
            <remarks>
            <para>
            The string can be an integer like "41" or a fraction like "41/152".
            The fraction must be in canonical form
            (see <a href="https://gmplib.org/manual/Rational-Number-Functions.html#Rational-Number-Functions">GNU MP - Rational Number Functions</a>),
            or if not then <see cref="M:Math.Gmp.Native.gmp_lib.mpq_canonicalize(Math.Gmp.Native.mpq_t)">mpq_canonicalize</see> must be called.
            </para>
            <para>
            The numerator and optional denominator are parsed the same as in <see cref="M:Math.Gmp.Native.gmp_lib.mpz_set_str(Math.Gmp.Native.mpz_t,Math.Gmp.Native.char_ptr,System.Int32)">mpz_set_str</see>
            (see <a href="https://gmplib.org/manual/Assigning-Integers.html#Assigning-Integers">GNU MP - Assigning Integers</a>).
            White space is allowed in the string, and is simply ignored.
            The base can vary from 2 to 62, or if <paramref name="base"/> is 0 then the leading characters are used:
            0x or 0X for hex, 0b or 0B for binary, 0 for octal, or decimal otherwise.
            Note that this is done separately for the numerator and denominator, so for instance 0xEF/100 is 239/100,
            whereas 0xEF/0x100 is 239/256.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_canonicalize(Math.Gmp.Native.mpq_t)">mpq_canonicalize</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_init(Math.Gmp.Native.mpq_t)">mpq_init</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_inits(Math.Gmp.Native.mpq_t[])">mpq_inits</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_clear(Math.Gmp.Native.mpq_t)">mpq_clear</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_clears(Math.Gmp.Native.mpq_t[])">mpq_clears</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_set</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_z(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpz_t)">mpq_set_z</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_ui(Math.Gmp.Native.mpq_t,System.UInt32,System.UInt32)">mpq_set_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_si(Math.Gmp.Native.mpq_t,System.Int32,System.UInt32)">mpq_set_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_swap(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_swap</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Initializing_Rationals">Initializing Rationals</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Initializing-Rationals.html#Initializing-Rationals">GNU MP - Initializing Rationals</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize a new rational x.
            mpq_t x = new mpq_t();
            gmp_lib.mpq_init(x);
            
            // Set the value of x.
            char_ptr value = new char_ptr("12 345 678 909 876 543 211 234 567 890 987 654 321 / 234 567 890");
            gmp_lib.mpq_set_str(x, value, 10);
            
            // Assert the value of x.
            char_ptr s = gmp_lib.mpq_get_str(char_ptr.Zero, 10, x);
            Assert.IsTrue(s.ToString() == value.ToString().Replace(" ", ""));
            
            // Release unmanaged memory allocated for x and string values.
            gmp_lib.mpq_clear(x);
            gmp_lib.free(value);
            gmp_lib.free(s);
            </code> 
            <code language="VB.NET">
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpq_set_ui(Math.Gmp.Native.mpq_t,System.UInt32,System.UInt32)">
            <summary>
            Set the value of <paramref name="rop"/> to <paramref name="op1"/> / <paramref name="op2"/>.
            </summary>
            <param name="rop">The result rational.</param>
            <param name="op1">The first operand rational.</param>
            <param name="op2">The second operand rational.</param>
            <remarks>
            <para>
            Note that if <paramref name="op1"/> and <paramref name="op2"/> have common factors,
            <paramref name="rop"/> has to be passed to <see cref="M:Math.Gmp.Native.gmp_lib.mpq_canonicalize(Math.Gmp.Native.mpq_t)">mpq_canonicalize</see> before any
            operations are performed on <paramref name="rop"/>. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_canonicalize(Math.Gmp.Native.mpq_t)">mpq_canonicalize</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_init(Math.Gmp.Native.mpq_t)">mpq_init</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_inits(Math.Gmp.Native.mpq_t[])">mpq_inits</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_clear(Math.Gmp.Native.mpq_t)">mpq_clear</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_clears(Math.Gmp.Native.mpq_t[])">mpq_clears</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_set</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_z(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpz_t)">mpq_set_z</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_si(Math.Gmp.Native.mpq_t,System.Int32,System.UInt32)">mpq_set_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_str(Math.Gmp.Native.mpq_t,Math.Gmp.Native.char_ptr,System.Int32)">mpq_set_str</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_swap(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_swap</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Initializing_Rationals">Initializing Rationals</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Initializing-Rationals.html#Initializing-Rationals">GNU MP - Initializing Rationals</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize a new rational x.
            mpq_t x = new mpq_t();
            gmp_lib.mpq_init(x);
            
            // Set the value of x to 10 / 11.
            gmp_lib.mpq_set_ui(x, 10U, 11U);
            
            // Assert that the value of x is 10 / 11.
            Assert.IsTrue(gmp_lib.mpq_cmp_ui(x, 10U, 11U) == 0);
            
            // Release unmanaged memory allocated for x.
            gmp_lib.mpq_clear(x);
            </code> 
            <code language="VB.NET">
            ' Create and initialize a new rational x.
            Dim x As New mpq_t()
            gmp_lib.mpq_init(x)
            
            ' Set the value of x to 10 / 11.
            gmp_lib.mpq_set_ui(x, 10UI, 11UI)
            
            ' Assert that the value of x is 10 / 11.
            Assert.IsTrue(gmp_lib.mpq_cmp_ui(x, 10UI, 11UI) = 0)
            
            ' Release unmanaged memory allocated for x.
            gmp_lib.mpq_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpq_set_z(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpz_t)">
            <summary>
            Assign <paramref name="rop"/> from <paramref name="op"/>.
            </summary>
            <param name="rop">The result rational.</param>
            <param name="op">The operand integer.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_canonicalize(Math.Gmp.Native.mpq_t)">mpq_canonicalize</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_init(Math.Gmp.Native.mpq_t)">mpq_init</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_inits(Math.Gmp.Native.mpq_t[])">mpq_inits</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_clear(Math.Gmp.Native.mpq_t)">mpq_clear</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_clears(Math.Gmp.Native.mpq_t[])">mpq_clears</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_set</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_ui(Math.Gmp.Native.mpq_t,System.UInt32,System.UInt32)">mpq_set_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_si(Math.Gmp.Native.mpq_t,System.Int32,System.UInt32)">mpq_set_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_str(Math.Gmp.Native.mpq_t,Math.Gmp.Native.char_ptr,System.Int32)">mpq_set_str</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_swap(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_swap</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Initializing_Rationals">Initializing Rationals</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Initializing-Rationals.html#Initializing-Rationals">GNU MP - Initializing Rationals</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new rational x to 10 / 11.
            mpq_t x = new mpq_t();
            gmp_lib.mpq_init(x);
            gmp_lib.mpq_set_si(x, 10, 11);
            
            // Create, initialize, and set a new integer y to -210.
            mpz_t y = new mpz_t();
            gmp_lib.mpz_init(y);
            gmp_lib.mpz_set_si(y, -210);
            
            // Assign the value of y to x.
            gmp_lib.mpq_set_z(x, y);
            
            // Assert that the value of x is -210 / 1.
            Assert.IsTrue(gmp_lib.mpq_cmp_si(x, -210, 1) == 0);
            
            // Release unmanaged memory allocated for x and y.
            gmp_lib.mpq_clear(x);
            gmp_lib.mpz_clear(y);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new rational x to 10 / 11.
            Dim x As New mpq_t()
            gmp_lib.mpq_init(x)
            gmp_lib.mpq_set_si(x, 10, 11)
            
            ' Create, initialize, and set a new integer y to -210.
            Dim y As New mpz_t()
            gmp_lib.mpz_init(y)
            gmp_lib.mpz_set_si(y, -210)
            
            ' Assign the value of y to x.
            gmp_lib.mpq_set_z(x, y)
            
            ' Assert that the value of x is -210 / 1.
            Assert.IsTrue(gmp_lib.mpq_cmp_si(x, -210, 1) = 0)
            
            ' Release unmanaged memory allocated for x and y.
            gmp_lib.mpq_clear(x)
            gmp_lib.mpz_clear(y)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpq_sgn(Math.Gmp.Native.mpq_t)">
            <summary>
            Return +1 if <paramref name="op"/> &gt; 0, 0 if <paramref name="op"/> = 0, and -1 if <paramref name="op"/> &lt; 0. 
            </summary>
            <param name="op">The operand rational.</param>
            <returns>Return +1 if <paramref name="op"/> &gt; 0, 0 if <paramref name="op"/> = 0, and -1 if <paramref name="op"/> &lt; 0.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_cmp(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_cmp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_cmp_z(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpz_t)">mpq_cmp_z</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_cmp_ui(Math.Gmp.Native.mpq_t,System.UInt32,System.UInt32)">mpq_cmp_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_cmp_si(Math.Gmp.Native.mpq_t,System.Int32,System.UInt32)">mpq_cmp_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_equal(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_equal</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Comparing_Rationals">Comparing Rationals</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Comparing-Rationals.html#Comparing-Rationals">GNU MP - Comparing Rationals</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new rational x to -10 / 11.
            mpq_t op = new mpq_t();
            gmp_lib.mpq_init(op);
            gmp_lib.mpq_set_si(op, -10, 11);
            
            // Assert that op is negative.
            Assert.IsTrue(gmp_lib.mpq_sgn(op) == -1);
            
            // Release unmanaged memory allocated for x and y.
            gmp_lib.mpq_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new rational x to -10 / 11.
            Dim op As New mpq_t()
            gmp_lib.mpq_init(op)
            gmp_lib.mpq_set_si(op, -10, 11)
            
            ' Assert that op is negative.
            Assert.IsTrue(gmp_lib.mpq_sgn(op) = -1)
            
            ' Release unmanaged memory allocated for x and y.
            gmp_lib.mpq_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpq_sub(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">
            <summary>
            Set <paramref name="difference"/> to <paramref name="minuend"/> - <paramref name="subtrahend"/>.
            </summary>
            <param name="difference">The result rational.</param>
            <param name="minuend">The first operand rational.</param>
            <param name="subtrahend">The second operand rational.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_add(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_mul(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_mul_2exp(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,System.UInt32)">mpq_mul_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_div(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_div</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_div_2exp(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t,System.UInt32)">mpq_div_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_neg(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_abs(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_abs</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_inv(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_inv</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Rational_Arithmetic">Rational Arithmetic</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Rational-Arithmetic.html#Rational-Arithmetic">GNU MP - Rational Arithmetic</a></seealso>
            <example>
            <code language="C#">
            </code> 
            <code language="VB.NET">
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpq_swap(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">
            <summary>
            Swap the values <paramref name="rop1"/> and <paramref name="rop2"/> efficiently. 
            </summary>
            <param name="rop1">The first rational.</param>
            <param name="rop2">The second rational.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_canonicalize(Math.Gmp.Native.mpq_t)">mpq_canonicalize</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_init(Math.Gmp.Native.mpq_t)">mpq_init</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_inits(Math.Gmp.Native.mpq_t[])">mpq_inits</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_clear(Math.Gmp.Native.mpq_t)">mpq_clear</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_clears(Math.Gmp.Native.mpq_t[])">mpq_clears</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpq_t)">mpq_set</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_z(Math.Gmp.Native.mpq_t,Math.Gmp.Native.mpz_t)">mpq_set_z</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_ui(Math.Gmp.Native.mpq_t,System.UInt32,System.UInt32)">mpq_set_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_si(Math.Gmp.Native.mpq_t,System.Int32,System.UInt32)">mpq_set_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpq_set_str(Math.Gmp.Native.mpq_t,Math.Gmp.Native.char_ptr,System.Int32)">mpq_set_str</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Initializing_Rationals">Initializing Rationals</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Initializing-Rationals.html#Initializing-Rationals">GNU MP - Initializing Rationals</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new rational x to 10 / 11.
            mpq_t x = new mpq_t();
            gmp_lib.mpq_init(x);
            gmp_lib.mpq_set_si(x, 10, 11U);
            
            // Create, initialize, and set a new rational x to -210 / 13.
            mpq_t y = new mpq_t();
            gmp_lib.mpq_init(y);
            gmp_lib.mpq_set_si(y, -210, 13U);
            
            // Swap the values of x and y.
            gmp_lib.mpq_swap(x, y);
            
            // Assert that the values have been swapped.
            Assert.IsTrue(gmp_lib.mpq_cmp_si(x, -210, 13U) == 0);
            Assert.IsTrue(gmp_lib.mpq_cmp_si(y, 10, 11U) == 0);
            
            // Release unmanaged memory allocated for x and y.
            gmp_lib.mpq_clears(x, y, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new rational x to 10 / 11.
            Dim x As New mpq_t()
            gmp_lib.mpq_init(x)
            gmp_lib.mpq_set_si(x, 10, 11UI)
            
            ' Create, initialize, and set a new rational x to -210 / 13.
            Dim y As New mpq_t()
            gmp_lib.mpq_init(y)
            gmp_lib.mpq_set_si(y, -210, 13UI)
            
            ' Swap the values of x and y.
            gmp_lib.mpq_swap(x, y)
            
            ' Assert that the values have been swapped.
            Assert.IsTrue(gmp_lib.mpq_cmp_si(x, -210, 13UI) = 0)
            Assert.IsTrue(gmp_lib.mpq_cmp_si(y, 10, 11UI) = 0)
            
            ' Release unmanaged memory allocated for x and y.
            gmp_lib.mpq_clears(x, y, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_abs(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">
            <summary>
            Set <paramref name="rop"/> to | <paramref name="op"/> |. 
            </summary>
            <param name="rop">The result float.</param>
            <param name="op">The operand.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_add(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_sub(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_mul(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_div(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_div</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_sqrt(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_sqrt</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_pow_ui(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,System.UInt32)">mpf_pow_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_neg(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_abs(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_abs</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Float_Arithmetic">Float Arithmetic</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Float-Arithmetic.html#Float-Arithmetic">GNU MP - Float Arithmetic</a></seealso>
            <example>
            <code language="C#">
            // Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64U);
            
            // Create, initialize, and set a new floating-point number x to -10.
            mpf_t x = new mpf_t();
            gmp_lib.mpf_init_set_si(x, -10);
            
            // Create and initialize a new floating-point number z.
            mpf_t z = new mpf_t();
            gmp_lib.mpf_init(z);
            
            // Set z = |x|.
            gmp_lib.mpf_abs(z, x);
            
            // Assert that the value of z is 10.
            Assert.IsTrue(gmp_lib.mpf_get_d(z) == 10.0);
            
            // Release unmanaged memory allocated for x and z.
            gmp_lib.mpf_clears(x, z, null);
            </code> 
            <code language="VB.NET">
            ' Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64UI)
            
            ' Create, initialize, and set a new floating-point number x to -10.
            Dim x As New mpf_t()
            gmp_lib.mpf_init_set_si(x, -10)
            
            ' Create and initialize a new floating-point number z.
            Dim z As New mpf_t()
            gmp_lib.mpf_init(z)
            
            ' Set z = |x|.
            gmp_lib.mpf_absg(z, x)
            
            ' Assert that the value of z is 10.
            Assert.IsTrue(gmp_lib.mpf_get_d(z) = 10.0)
            
            ' Release unmanaged memory allocated for x and z.
            gmp_lib.mpf_clears(x, z, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_add(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> + <paramref name="op2"/>.
            </summary>
            <param name="rop">The result float.</param>
            <param name="op1">The first operand.</param>
            <param name="op2">The second operand.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_add_ui(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,System.UInt32)">mpf_add_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_sub(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_mul(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_div(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_div</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_sqrt(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_sqrt</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_pow_ui(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,System.UInt32)">mpf_pow_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_neg(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_abs(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_abs</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Float_Arithmetic">Float Arithmetic</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Float-Arithmetic.html#Float-Arithmetic">GNU MP - Float Arithmetic</a></seealso>
            <example>
            <code language="C#">
            // Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64U);
            
            // Create, initialize, and set a new floating-point number x to 10.
            mpf_t x = new mpf_t();
            gmp_lib.mpf_init_set_si(x, 10);
            
            // Create, initialize, and set a new floating-point number y to -210.
            mpf_t y = new mpf_t();
            gmp_lib.mpf_init_set_si(y, -210);
            
            // Create and initialize a new floating-point number z.
            mpf_t z = new mpf_t();
            gmp_lib.mpf_init(z);
            
            // Set z = x + y.
            gmp_lib.mpf_add(z, x, y);
            
            // Assert that the value of z is -200.
            Assert.IsTrue(gmp_lib.mpf_get_d(z) == -200.0);
            
            // Release unmanaged memory allocated for x, y, and z.
            gmp_lib.mpf_clears(x, y, z, null);
            </code> 
            <code language="VB.NET">
            ' Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64UI)
            
            ' Create, initialize, and set a new floating-point number x to 10.
            Dim x As New mpf_t()
            gmp_lib.mpf_init_set_si(x, 10)
            
            ' Create, initialize, and set a new floating-point number y to -210.
            Dim y As New mpf_t()
            gmp_lib.mpf_init_set_si(y, -210)
            
            ' Create and initialize a new floating-point number z.
            Dim z As New mpf_t()
            gmp_lib.mpf_init(z)
            
            ' Set z = x + y.
            gmp_lib.mpf_add(z, x, y)
            
            ' Assert that the value of z is -200.
            Assert.IsTrue(gmp_lib.mpf_get_d(z) = -200.0)
            
            ' Release unmanaged memory allocated for x, y, and z.
            gmp_lib.mpf_clears(x, y, z, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_add_ui(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,System.UInt32)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> + <paramref name="op2"/>.
            </summary>
            <param name="rop">The result float.</param>
            <param name="op1">The first operand.</param>
            <param name="op2">The second operand.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_add(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_sub(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_mul(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_div(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_div</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_sqrt(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_sqrt</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_pow_ui(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,System.UInt32)">mpf_pow_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_neg(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_abs(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_abs</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Float_Arithmetic">Float Arithmetic</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Float-Arithmetic.html#Float-Arithmetic">GNU MP - Float Arithmetic</a></seealso>
            <example>
            <code language="C#">
            // Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64U);
            
            // Create, initialize, and set a new floating-point number x to 10.
            mpf_t x = new mpf_t();
            gmp_lib.mpf_init_set_si(x, 10);
            
            // Create and initialize a new floating-point number z.
            mpf_t z = new mpf_t();
            gmp_lib.mpf_init(z);
            
            // Set z = x + 210.
            gmp_lib.mpf_add_ui(z, x, 210U);
            
            // Assert that the value of z is 220.
            Assert.IsTrue(gmp_lib.mpf_get_d(z) == 220.0);
            
            // Release unmanaged memory allocated for x and z.
            gmp_lib.mpf_clears(x, z, null);
            </code> 
            <code language="VB.NET">
            ' Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64UI)
            
            ' Create, initialize, and set a new floating-point number x to 10.
            Dim x As New mpf_t()
            gmp_lib.mpf_init_set_si(x, 10)
            
            ' Create and initialize a new floating-point number z.
            Dim z As New mpf_t()
            gmp_lib.mpf_init(z)
            
            ' Set z = x + 210.
            gmp_lib.mpf_add_ui(z, x, 210UI)
            
            ' Assert that the value of z is 220.
            Assert.IsTrue(gmp_lib.mpf_get_d(z) = 220.0)
            
            ' Release unmanaged memory allocated for x and z.
            gmp_lib.mpf_clears(x, z, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_ceil(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op"/> rounded to the next higher integer. 
            </summary>
            <param name="rop">The result float.</param>
            <param name="op">The operand float.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_floor(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_floor</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_trunc(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_trunc</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_integer_p(Math.Gmp.Native.mpf_t)">mpf_integer_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_ulong_p(Math.Gmp.Native.mpf_t)">mpf_fits_ulong_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_slong_p(Math.Gmp.Native.mpf_t)">mpf_fits_slong_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_uint_p(Math.Gmp.Native.mpf_t)">mpf_fits_uint_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_sint_p(Math.Gmp.Native.mpf_t)">mpf_fits_sint_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_ushort_p(Math.Gmp.Native.mpf_t)">mpf_fits_ushort_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_sshort_p(Math.Gmp.Native.mpf_t)">mpf_fits_sshort_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_urandomb(Math.Gmp.Native.mpf_t,Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.mp_bitcnt_t)">mpf_urandomb</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_random2(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_exp_t)">mpf_random2</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Miscellaneous_Float_Functions">Miscellaneous Float Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Miscellaneous-Float-Functions.html#Miscellaneous-Float-Functions">GNU MP - Miscellaneous Float Functions</a></seealso>
            <example>
            <code language="C#">
            // Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64U);
            
            // Create, initialize, and set a new floating-point number x to 10.4.
            mpf_t x = new mpf_t();
            gmp_lib.mpf_init_set_d(x, 10.4);
            
            // Create and initialize a new floating-point number z.
            mpf_t z = new mpf_t();
            gmp_lib.mpf_init(z);
            
            // Set z = ceil(x).
            gmp_lib.mpf_ceil(z, x);
            
            // Assert that the value of z is 11.
            Assert.IsTrue(gmp_lib.mpf_get_d(z) == 11.0);
            
            // Release unmanaged memory allocated for x and z.
            gmp_lib.mpf_clears(x, z, null);
            </code> 
            <code language="VB.NET">
            ' Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64UI)
            
            ' Create, initialize, and set a new floating-point number x to 10.4.
            Dim x As New mpf_t()
            gmp_lib.mpf_init_set_d(x, 10.4)
            
            ' Create and initialize a new floating-point number z.
            Dim z As New mpf_t()
            gmp_lib.mpf_init(z)
            
            ' Set z = ceil(x).
            gmp_lib.mpf_ceil(z, x)
            
            ' Assert that the value of z is 11.
            Assert.IsTrue(gmp_lib.mpf_get_d(z) = 11.0)
            
            ' Release unmanaged memory allocated for x and z.
            gmp_lib.mpf_clears(x, z, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_clear(Math.Gmp.Native.mpf_t)">
            <summary>
            Free the space occupied by <paramref name="x"/>.
            </summary>
            <param name="x">The operand float.</param>
            <remarks>
            <para>
            Make sure to call this function for all <see cref="T:Math.Gmp.Native.mpf_t">mpf_t</see> variables when you are done with them. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_default_prec(Math.Gmp.Native.mp_bitcnt_t)">mpf_set_default_prec</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_get_default_prec">mpf_get_default_prec</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_init(Math.Gmp.Native.mpf_t)">mpf_init</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_init2(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_bitcnt_t)">mpf_init2</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_inits(Math.Gmp.Native.mpf_t[])">mpf_inits</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_clears(Math.Gmp.Native.mpf_t[])">mpf_clears</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_get_prec(Math.Gmp.Native.mpf_t)">mpf_get_prec</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_prec(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_bitcnt_t)">mpf_set_prec</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_prec_raw(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_bitcnt_t)">mpf_set_prec_raw</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Initializing_Floats">Initializing Floats</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Initializing-Floats.html#Initializing-Floats">GNU MP - Initializing Floats</a></seealso>
            <example>
            <code language="C#">
            // Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64U);
            
            // Create and initialize a new floating-point number x.
            mpf_t x = new mpf_t();
            gmp_lib.mpf_init(x);
            
            // Assert that the value of x is 0.0.
            Assert.IsTrue(gmp_lib.mpf_get_d(x) == 0.0);
            
            // Release unmanaged memory allocated for x.
            gmp_lib.mpf_clear(x);
            </code> 
            <code language="VB.NET">
            ' Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64UI)
            
            ' Create and initialize a new floating-point number x.
            Dim x As New mpf_t()
            gmp_lib.mpf_init(x)
            
            ' Assert that the value of x is 0.0.
            Assert.IsTrue(gmp_lib.mpf_get_d(x) = 0.0)
            
            ' Release unmanaged memory allocated for x.
            gmp_lib.mpf_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_clears(Math.Gmp.Native.mpf_t[])">
            <summary>
            Free the space occupied by a NULL-terminated list of <see cref="T:Math.Gmp.Native.mpf_t">mpf_t</see> variables. 
            </summary>
            <param name="x">The operand float.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_default_prec(Math.Gmp.Native.mp_bitcnt_t)">mpf_set_default_prec</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_get_default_prec">mpf_get_default_prec</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_init(Math.Gmp.Native.mpf_t)">mpf_init</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_init2(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_bitcnt_t)">mpf_init2</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_inits(Math.Gmp.Native.mpf_t[])">mpf_inits</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_clear(Math.Gmp.Native.mpf_t)">mpf_clear</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_get_prec(Math.Gmp.Native.mpf_t)">mpf_get_prec</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_prec(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_bitcnt_t)">mpf_set_prec</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_prec_raw(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_bitcnt_t)">mpf_set_prec_raw</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Initializing_Floats">Initializing Floats</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Initializing-Floats.html#Initializing-Floats">GNU MP - Initializing Floats</a></seealso>
            <example>
            <code language="C#">
            // Create new floating-point numbers x1, x2 and x3.
            mpf_t x1 = new mpf_t();
            mpf_t x2 = new mpf_t();
            mpf_t x3 = new mpf_t();
            
            // Initialize the floating-point numbers.
            gmp_lib.mpf_inits(x1, x2, x3, null);
            
            // Assert that their value is 0.
            Assert.IsTrue(gmp_lib.mpf_get_d(x1) == 0.0);
            Assert.IsTrue(gmp_lib.mpf_get_d(x2) == 0.0);
            Assert.IsTrue(gmp_lib.mpf_get_d(x3) == 0.0);
            
            // Release unmanaged memory allocated for the floating-point numbers.
            gmp_lib.mpf_clears(x1, x2, x3, null);
            </code> 
            <code language="VB.NET">
            ' Create new floating-point numbers x1, x2 and x3.
            Dim x1 As New mpf_t()
            Dim x2 As New mpf_t()
            Dim x3 As New mpf_t()
            
            ' Initialize the floating-point numbers.
            gmp_lib.mpf_inits(x1, x2, x3, Nothing)
            
            ' Assert that their value is 0.
            Assert.IsTrue(gmp_lib.mpf_get_d(x1) = 0.0)
            Assert.IsTrue(gmp_lib.mpf_get_d(x2) = 0.0)
            Assert.IsTrue(gmp_lib.mpf_get_d(x3) = 0.0)
            
            ' Release unmanaged memory allocated for the floating-point numbers.
            gmp_lib.mpf_clears(x1, x2, x3, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_cmp(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">
            <summary>
            Compare <paramref name="op1"/> and <paramref name="op2"/>.
            </summary>
            <param name="op1">The first operand float.</param>
            <param name="op2">The second operand float.</param>
            <returns>Return a positive value if op1 &gt; op2, zero if op1 = op2, and a negative value if op1 &lt; op2.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_cmp_z(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpz_t)">mpf_cmp_z</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_cmp_d(Math.Gmp.Native.mpf_t,System.Double)">mpf_cmp_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_cmp_ui(Math.Gmp.Native.mpf_t,System.UInt32)">mpf_cmp_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_cmp_si(Math.Gmp.Native.mpf_t,System.Int32)">mpf_cmp_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_reldiff(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_reldiff</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_sgn(Math.Gmp.Native.mpf_t)">mpf_sgn</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Float_Comparison">Float Comparison</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Float-Comparison.html#Float-Comparison">GNU MP - Float Comparison</a></seealso>
            <example>
            <code language="C#">
            // Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64U);
            
            // Create, initialize, and set a new floating-point number x to 512.
            mpf_t x = new mpf_t();
            gmp_lib.mpf_init_set_si(x, 512);
            
            // Create and initialize a new floating-point number z.
            mpf_t z = new mpf_t();
            gmp_lib.mpf_init_set_si(z, 128);
            
            // Assert that x > z.
            Assert.IsTrue(gmp_lib.mpf_cmp(x, z) > 0);
            
            // Release unmanaged memory allocated for x and z.
            gmp_lib.mpf_clears(x, z, null);
            </code> 
            <code language="VB.NET">
            ' Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64UI)
            
            ' Create, initialize, and set a new floating-point number x to 512.
            Dim x As New mpf_t()
            gmp_lib.mpf_init_set_si(x, 512)
            
            ' Create and initialize a new floating-point number z.
            Dim z As New mpf_t()
            gmp_lib.mpf_init_set_si(z, 128)
            
            ' Assert that x > z.
            Assert.IsTrue(gmp_lib.mpf_cmp(x, z) > 0)
            
            ' Release unmanaged memory allocated for x and z.
            gmp_lib.mpf_clears(x, z, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_cmp_z(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpz_t)">
            <summary>
            Compare <paramref name="op1"/> and <paramref name="op2"/>.
            </summary>
            <param name="op1">The first operand float.</param>
            <param name="op2">The second operand float.</param>
            <returns>Return a positive value if op1 &gt; op2, zero if op1 = op2, and a negative value if op1 &lt; op2.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_cmp(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_cmp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_cmp_d(Math.Gmp.Native.mpf_t,System.Double)">mpf_cmp_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_cmp_ui(Math.Gmp.Native.mpf_t,System.UInt32)">mpf_cmp_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_cmp_si(Math.Gmp.Native.mpf_t,System.Int32)">mpf_cmp_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_reldiff(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_reldiff</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_sgn(Math.Gmp.Native.mpf_t)">mpf_sgn</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Float_Comparison">Float Comparison</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Float-Comparison.html#Float-Comparison">GNU MP - Float Comparison</a></seealso>
            <example>
            <code language="C#">
            // Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64U);
            
            // Create, initialize, and set a new floating-point number x to 512.
            mpf_t x = new mpf_t();
            gmp_lib.mpf_init_set_si(x, 512);
            
            // Create and initialize a new integer z.
            mpz_t z = new mpz_t();
            gmp_lib.mpz_init_set_si(z, 128);
            
            // Assert that x > z.
            Assert.IsTrue(gmp_lib.mpf_cmp_z(x, z) > 0);
            
            // Release unmanaged memory allocated for x and z.
            gmp_lib.mpf_clear(x);
            gmp_lib.mpz_clear(z);
            /// </code> 
            <code language="VB.NET">
            ' Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64UI)
            
            ' Create, initialize, and set a new floating-point number x to 512.
            Dim x As New mpf_t()
            gmp_lib.mpf_init_set_si(x, 512)
            
            ' Create and initialize a new integer z.
            Dim z As New mpz_t()
            gmp_lib.mpz_init_set_si(z, 128)
            
            ' Assert that x > z.
            Assert.IsTrue(gmp_lib.mpf_cmp_z(x, z) > 0)
            
            ' Release unmanaged memory allocated for x and z.
            gmp_lib.mpf_clear(x)
            gmp_lib.mpz_clear(z)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_cmp_d(Math.Gmp.Native.mpf_t,System.Double)">
            <summary>
            Compare <paramref name="op1"/> and <paramref name="op2"/>.
            </summary>
            <param name="op1">The first operand float.</param>
            <param name="op2">The second operand float.</param>
            <returns>Return a positive value if op1 &gt; op2, zero if op1 = op2, and a negative value if op1 &lt; op2.</returns>
            <remarks>
            <para>
            <see cref="M:Math.Gmp.Native.gmp_lib.mpf_cmp_d(Math.Gmp.Native.mpf_t,System.Double)">mpf_cmp_d</see> can be called with an infinity, but results are undefined for a NaN. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_cmp(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_cmp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_cmp_z(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpz_t)">mpf_cmp_z</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_cmp_ui(Math.Gmp.Native.mpf_t,System.UInt32)">mpf_cmp_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_cmp_si(Math.Gmp.Native.mpf_t,System.Int32)">mpf_cmp_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_reldiff(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_reldiff</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_sgn(Math.Gmp.Native.mpf_t)">mpf_sgn</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Float_Comparison">Float Comparison</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Float-Comparison.html#Float-Comparison">GNU MP - Float Comparison</a></seealso>
            <example>
            <code language="C#">
            // Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64U);
            
            // Create, initialize, and set a new floating-point number x to 512.
            mpf_t x = new mpf_t();
            gmp_lib.mpf_init_set_si(x, 512);
            
            // Assert that x > 128.0.
            Assert.IsTrue(gmp_lib.mpf_cmp_d(x, 128.0) > 0);
            
            // Release unmanaged memory allocated for x.
            gmp_lib.mpf_clear(x);
            </code> 
            <code language="VB.NET">
            ' Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64UI)
            
            ' Create, initialize, and set a new floating-point number x to 512.
            Dim x As New mpf_t()
            gmp_lib.mpf_init_set_si(x, 512)
            
            ' Assert that x > 128.0.
            Assert.IsTrue(gmp_lib.mpf_cmp_d(x, 128.0) > 0)
            
            ' Release unmanaged memory allocated for x.
            gmp_lib.mpf_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_cmp_si(Math.Gmp.Native.mpf_t,System.Int32)">
            <summary>
            Compare <paramref name="op1"/> and <paramref name="op2"/>.
            </summary>
            <param name="op1">The first operand float.</param>
            <param name="op2">The second operand float.</param>
            <returns>Return a positive value if op1 &gt; op2, zero if op1 = op2, and a negative value if op1 &lt; op2.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_cmp(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_cmp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_cmp_z(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpz_t)">mpf_cmp_z</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_cmp_d(Math.Gmp.Native.mpf_t,System.Double)">mpf_cmp_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_cmp_ui(Math.Gmp.Native.mpf_t,System.UInt32)">mpf_cmp_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_reldiff(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_reldiff</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_sgn(Math.Gmp.Native.mpf_t)">mpf_sgn</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Float_Comparison">Float Comparison</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Float-Comparison.html#Float-Comparison">GNU MP - Float Comparison</a></seealso>
            <example>
            <code language="C#">
            // Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64U);
            
            // Create, initialize, and set a new floating-point number x to 512.
            mpf_t x = new mpf_t();
            gmp_lib.mpf_init_set_si(x, 512);
            
            // Assert that x > 128.
            Assert.IsTrue(gmp_lib.mpf_cmp_si(x, 128) > 0);
            
            // Release unmanaged memory allocated for x.
            gmp_lib.mpf_clear(x);
            </code> 
            <code language="VB.NET">
            ' Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64UI)
            
            ' Create, initialize, and set a new floating-point number x to 512.
            Dim x As New mpf_t()
            
            gmp_lib.mpf_init_set_si(x, 512)
            
            ' Assert that x > 128.
            Assert.IsTrue(gmp_lib.mpf_cmp_si(x, 128) > 0)
            
            ' Release unmanaged memory allocated for x.
            gmp_lib.mpf_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_cmp_ui(Math.Gmp.Native.mpf_t,System.UInt32)">
            <summary>
            Compare <paramref name="op1"/> and <paramref name="op2"/>.
            </summary>
            <param name="op1">The first operand float.</param>
            <param name="op2">The second operand float.</param>
            <returns>Return a positive value if op1 &gt; op2, zero if op1 = op2, and a negative value if op1 &lt; op2.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_cmp(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_cmp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_cmp_z(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpz_t)">mpf_cmp_z</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_cmp_d(Math.Gmp.Native.mpf_t,System.Double)">mpf_cmp_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_cmp_si(Math.Gmp.Native.mpf_t,System.Int32)">mpf_cmp_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_reldiff(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_reldiff</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_sgn(Math.Gmp.Native.mpf_t)">mpf_sgn</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Float_Comparison">Float Comparison</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Float-Comparison.html#Float-Comparison">GNU MP - Float Comparison</a></seealso>
            <example>
            <code language="C#">
            // Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64U);
            
            // Create, initialize, and set a new floating-point number x to 512.
            mpf_t x = new mpf_t();
            gmp_lib.mpf_init_set_si(x, 512);
            
            // Assert that x > 128.
            Assert.IsTrue(gmp_lib.mpf_cmp_ui(x, 128) > 0);
            
            // Release unmanaged memory allocated for x.
            gmp_lib.mpf_clear(x);
            </code> 
            <code language="VB.NET">
            ' Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64UI)
            
            ' Create, initialize, and set a new floating-point number x to 512.
            Dim x As New mpf_t()
            gmp_lib.mpf_init_set_si(x, 512)
            
            ' Assert that x > 128.
            Assert.IsTrue(gmp_lib.mpf_cmp_ui(x, 128) > 0)
            
            ' Release unmanaged memory allocated for x.
            gmp_lib.mpf_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_div(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> / <paramref name="op2"/>. 
            </summary>
            <param name="rop">The result float.</param>
            <param name="op1">The first operand.</param>
            <param name="op2">The second operand.</param>
            <remarks>
            <para>
            Division is undefined if the divisor is zero, and passing a zero divisor to the divide
            functions will make it intentionally divide by zero.
            This lets the user handle arithmetic exceptions in division functions in the same manner
            as other arithmetic exceptions. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_add(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_sub(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_mul(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_ui_div(Math.Gmp.Native.mpf_t,System.UInt32,Math.Gmp.Native.mpf_t)">mpf_ui_div</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_div_ui(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,System.UInt32)">mpf_div_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_sqrt(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_sqrt</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_pow_ui(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,System.UInt32)">mpf_pow_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_neg(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_abs(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_abs</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_div_2exp(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,System.UInt32)">mpf_div_2exp</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Float_Arithmetic">Float Arithmetic</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Float-Arithmetic.html#Float-Arithmetic">GNU MP - Float Arithmetic</a></seealso>
            <example>
            <code language="C#">
            // Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64U);
            
            // Create, initialize, and set a new floating-point number x to 10.
            mpf_t x = new mpf_t();
            gmp_lib.mpf_init_set_si(x, 10);
            
            // Create, initialize, and set a new floating-point number y to -210.
            mpf_t y = new mpf_t();
            gmp_lib.mpf_init_set_si(y, -210);
            
            // Create and initialize a new floating-point number z.
            mpf_t z = new mpf_t();
            gmp_lib.mpf_init(z);
            
            // Set z = y / x.
            gmp_lib.mpf_div(z, y, x);
            
            // Assert that the value of z is -21.
            Assert.IsTrue(gmp_lib.mpf_get_d(z) == -21.0);
            
            // Release unmanaged memory allocated for x, y, and z.
            gmp_lib.mpf_clears(x, y, z, null);
            </code> 
            <code language="VB.NET">
            ' Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64UI)
            
            ' Create, initialize, and set a new floating-point number x to 10.
            Dim x As New mpf_t()
            gmp_lib.mpf_init_set_si(x, 10)
            
            ' Create, initialize, and set a new floating-point number y to -210.
            Dim y As New mpf_t()
            gmp_lib.mpf_init_set_si(y, -210)
            
            ' Create and initialize a new floating-point number z.
            Dim z As New mpf_t()
            gmp_lib.mpf_init(z)
            
            ' Set z = y / x.
            gmp_lib.mpf_div(z, y, x)
            
            ' Assert that the value of z is -21.
            Assert.IsTrue(gmp_lib.mpf_get_d(z) = -21.0)
            
            ' Release unmanaged memory allocated for x, y, and z.
            gmp_lib.mpf_clears(x, y, z, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_div_2exp(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,System.UInt32)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> / 2^<paramref name="op2"/>. 
            </summary>
            <param name="rop">The result float.</param>
            <param name="op1">The fisrt operand.</param>
            <param name="op2">The second operand.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_add(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_sub(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_mul(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_div(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_div</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_ui_div(Math.Gmp.Native.mpf_t,System.UInt32,Math.Gmp.Native.mpf_t)">mpf_ui_div</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_div_ui(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,System.UInt32)">mpf_div_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_sqrt(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_sqrt</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_pow_ui(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,System.UInt32)">mpf_pow_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_neg(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_abs(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_abs</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Float_Arithmetic">Float Arithmetic</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Float-Arithmetic.html#Float-Arithmetic">GNU MP - Float Arithmetic</a></seealso>
            <example>
            <code language="C#">
            // Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64U);
            
            // Create, initialize, and set a new floating-point number x to 512.
            mpf_t x = new mpf_t();
            gmp_lib.mpf_init_set_si(x, 512);
            
            // Create and initialize a new floating-point number z.
            mpf_t z = new mpf_t();
            gmp_lib.mpf_init(z);
            
            // Set z = x / 2^8.
            gmp_lib.mpf_div_2exp(z, x, 8U);
            
            // Assert that the value of z is 2.
            Assert.IsTrue(gmp_lib.mpf_get_d(z) == 2.0);
            
            // Release unmanaged memory allocated for x and z.
            gmp_lib.mpf_clears(x, z, null);
            </code> 
            <code language="VB.NET">
            ' Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64UI)
            
            ' Create, initialize, and set a new floating-point number x to 512.
            Dim x As New mpf_t()
            gmp_lib.mpf_init_set_si(x, 512)
            
            ' Create and initialize a new floating-point number z.
            Dim z As New mpf_t()
            gmp_lib.mpf_init(z)
            
            ' Set z = x / 2^8.
            gmp_lib.mpf_div_2exp(z, x, 8UI)
            
            ' Assert that the value of z is 2.
            Assert.IsTrue(gmp_lib.mpf_get_d(z) = 2.0)
            
            ' Release unmanaged memory allocated for x and z.
            gmp_lib.mpf_clears(x, z, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_div_ui(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,System.UInt32)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> / <paramref name="op2"/>. 
            </summary>
            <param name="rop">The result float.</param>
            <param name="op1">The first operand.</param>
            <param name="op2">The second operand.</param>
            <remarks>
            <para>
            Division is undefined if the divisor is zero, and passing a zero divisor to the divide
            functions will make it intentionally divide by zero.
            This lets the user handle arithmetic exceptions in division functions in the same manner
            as other arithmetic exceptions. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_add(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_sub(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_mul(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_div(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_div</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_ui_div(Math.Gmp.Native.mpf_t,System.UInt32,Math.Gmp.Native.mpf_t)">mpf_ui_div</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_sqrt(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_sqrt</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_pow_ui(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,System.UInt32)">mpf_pow_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_neg(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_abs(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_abs</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_div_2exp(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,System.UInt32)">mpf_div_2exp</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Float_Arithmetic">Float Arithmetic</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Float-Arithmetic.html#Float-Arithmetic">GNU MP - Float Arithmetic</a></seealso>
            <example>
            <code language="C#">
            // Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64U);
            
            // Create, initialize, and set a new floating-point number y to -210.
            mpf_t y = new mpf_t();
            gmp_lib.mpf_init_set_si(y, -210);
            
            // Create and initialize a new floating-point number z.
            mpf_t z = new mpf_t();
            gmp_lib.mpf_init(z);
            
            // Set z = y / 10.
            gmp_lib.mpf_div_ui(z, y, 10U);
            
            // Assert that the value of z is -21.
            Assert.IsTrue(gmp_lib.mpf_get_d(z) == -21.0);
            
            // Release unmanaged memory allocated for y and z.
            gmp_lib.mpf_clears(y, z, null);
            </code> 
            <code language="VB.NET">
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_fits_sint_p(Math.Gmp.Native.mpf_t)">
            <summary>
            Return non-zero if <paramref name="op"/> fits in a 32-bit integer, when truncated to an integer. 
            </summary>
            <param name="op">The operand float.</param>
            <returns>Return non-zero if <paramref name="op"/> fits in a 32-bit integer, when truncated to an integer.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_ceil(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_ceil</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_floor(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_floor</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_trunc(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_trunc</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_integer_p(Math.Gmp.Native.mpf_t)">mpf_integer_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_ulong_p(Math.Gmp.Native.mpf_t)">mpf_fits_ulong_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_slong_p(Math.Gmp.Native.mpf_t)">mpf_fits_slong_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_uint_p(Math.Gmp.Native.mpf_t)">mpf_fits_uint_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_ushort_p(Math.Gmp.Native.mpf_t)">mpf_fits_ushort_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_sshort_p(Math.Gmp.Native.mpf_t)">mpf_fits_sshort_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_urandomb(Math.Gmp.Native.mpf_t,Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.mp_bitcnt_t)">mpf_urandomb</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_random2(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_exp_t)">mpf_random2</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Miscellaneous_Float_Functions">Miscellaneous Float Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Miscellaneous-Float-Functions.html#Miscellaneous-Float-Functions">GNU MP - Miscellaneous Float Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op 4294967295.
            mpf_t op = new mpf_t();
            gmp_lib.mpf_init_set_ui(op, uint.MaxValue);
            
            // Assert that op does not fit in int.
            Assert.IsTrue(gmp_lib.mpf_fits_sint_p(op) == 0);
            
            // Release unmanaged memory allocated for op.
            gmp_lib.mpf_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op 4294967295.
            Dim op As New mpf_t()
            gmp_lib.mpf_init_set_ui(op, UInteger.MaxValue)
            
            ' Assert that op does not fit in int.
            Assert.IsTrue(gmp_lib.mpf_fits_sint_p(op) = 0)
            
            ' Release unmanaged memory allocated for op.
            gmp_lib.mpf_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_fits_slong_p(Math.Gmp.Native.mpf_t)">
            <summary>
            Return non-zero if <paramref name="op"/> fits in a 32-bit integer, when truncated to an integer. 
            </summary>
            <param name="op">The operand float.</param>
            <returns>Return non-zero if <paramref name="op"/> fits in a 32-bit integer, when truncated to an integer.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_ceil(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_ceil</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_floor(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_floor</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_trunc(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_trunc</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_integer_p(Math.Gmp.Native.mpf_t)">mpf_integer_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_ulong_p(Math.Gmp.Native.mpf_t)">mpf_fits_ulong_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_uint_p(Math.Gmp.Native.mpf_t)">mpf_fits_uint_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_sint_p(Math.Gmp.Native.mpf_t)">mpf_fits_sint_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_ushort_p(Math.Gmp.Native.mpf_t)">mpf_fits_ushort_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_sshort_p(Math.Gmp.Native.mpf_t)">mpf_fits_sshort_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_urandomb(Math.Gmp.Native.mpf_t,Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.mp_bitcnt_t)">mpf_urandomb</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_random2(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_exp_t)">mpf_random2</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Miscellaneous_Float_Functions">Miscellaneous Float Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Miscellaneous-Float-Functions.html#Miscellaneous-Float-Functions">GNU MP - Miscellaneous Float Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op 4294967295.
            mpf_t op = new mpf_t();
            gmp_lib.mpf_init_set_ui(op, uint.MaxValue);
            
            // Assert that op does not fit in long.
            Assert.IsTrue(gmp_lib.mpf_fits_slong_p(op) == 0);
            
            // Release unmanaged memory allocated for op.
            gmp_lib.mpf_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op 4294967295.
            Dim op As New mpf_t()
            gmp_lib.mpf_init_set_ui(op, UInteger.MaxValue)
            
            ' Assert that op does not fit in long.
            Assert.IsTrue(gmp_lib.mpf_fits_slong_p(op) = 0)
            
            ' Release unmanaged memory allocated for op.
            gmp_lib.mpf_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_fits_sshort_p(Math.Gmp.Native.mpf_t)">
            <summary>
            Return non-zero if <paramref name="op"/> fits in a 16-bit integer, when truncated to an integer. 
            </summary>
            <param name="op">The operand float.</param>
            <returns>Return non-zero if <paramref name="op"/> fits in a 16-bit integer, when truncated to an integer.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_ceil(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_ceil</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_floor(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_floor</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_trunc(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_trunc</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_integer_p(Math.Gmp.Native.mpf_t)">mpf_integer_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_ulong_p(Math.Gmp.Native.mpf_t)">mpf_fits_ulong_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_slong_p(Math.Gmp.Native.mpf_t)">mpf_fits_slong_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_uint_p(Math.Gmp.Native.mpf_t)">mpf_fits_uint_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_sint_p(Math.Gmp.Native.mpf_t)">mpf_fits_sint_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_ushort_p(Math.Gmp.Native.mpf_t)">mpf_fits_ushort_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_urandomb(Math.Gmp.Native.mpf_t,Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.mp_bitcnt_t)">mpf_urandomb</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_random2(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_exp_t)">mpf_random2</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Miscellaneous_Float_Functions">Miscellaneous Float Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Miscellaneous-Float-Functions.html#Miscellaneous-Float-Functions">GNU MP - Miscellaneous Float Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op 4294967295.
            mpf_t op = new mpf_t();
            gmp_lib.mpf_init_set_ui(op, uint.MaxValue);
            
            // Assert that op does not fit in short.
            Assert.IsTrue(gmp_lib.mpf_fits_sshort_p(op) == 0);
            
            // Release unmanaged memory allocated for op.
            gmp_lib.mpf_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op 4294967295.
            Dim op As New mpf_t()
            gmp_lib.mpf_init_set_ui(op, UInteger.MaxValue)
            
            ' Assert that op does not fit in short.
            Assert.IsTrue(gmp_lib.mpf_fits_sshort_p(op) = 0)
            
            ' Release unmanaged memory allocated for op.
            gmp_lib.mpf_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_fits_uint_p(Math.Gmp.Native.mpf_t)">
            <summary>
            Return non-zero if <paramref name="op"/> fits in an unsigned 32-bit integer, when truncated to an integer. 
            </summary>
            <param name="op">The operand float.</param>
            <returns>Return non-zero if <paramref name="op"/> fits in an unsigned 32-bit integer, when truncated to an integer.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_ceil(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_ceil</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_floor(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_floor</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_trunc(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_trunc</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_integer_p(Math.Gmp.Native.mpf_t)">mpf_integer_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_ulong_p(Math.Gmp.Native.mpf_t)">mpf_fits_ulong_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_slong_p(Math.Gmp.Native.mpf_t)">mpf_fits_slong_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_sint_p(Math.Gmp.Native.mpf_t)">mpf_fits_sint_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_ushort_p(Math.Gmp.Native.mpf_t)">mpf_fits_ushort_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_sshort_p(Math.Gmp.Native.mpf_t)">mpf_fits_sshort_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_urandomb(Math.Gmp.Native.mpf_t,Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.mp_bitcnt_t)">mpf_urandomb</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_random2(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_exp_t)">mpf_random2</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Miscellaneous_Float_Functions">Miscellaneous Float Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Miscellaneous-Float-Functions.html#Miscellaneous-Float-Functions">GNU MP - Miscellaneous Float Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op 4294967295.
            mpf_t op = new mpf_t();
            gmp_lib.mpf_init_set_ui(op, uint.MaxValue);
            
            // Assert that op does not fit in uint.
            Assert.IsTrue(gmp_lib.mpf_fits_uint_p(op) > 0);
            
            // Release unmanaged memory allocated for op.
            gmp_lib.mpf_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op 4294967295.
            Dim op As New mpf_t()
            gmp_lib.mpf_init_set_ui(op, UInteger.MaxValue)
            
            ' Assert that op does not fit in uint.
            Assert.IsTrue(gmp_lib.mpf_fits_uint_p(op) > 0)
            
            ' Release unmanaged memory allocated for op.
            gmp_lib.mpf_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_fits_ulong_p(Math.Gmp.Native.mpf_t)">
            <summary>
            Return non-zero if <paramref name="op"/> fits in an unsigned 32-bit integer, when truncated to an integer. 
            </summary>
            <param name="op">The operand float.</param>
            <returns>Return non-zero if <paramref name="op"/> fits in an unsigned 32-bit integer, when truncated to an integer.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_ceil(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_ceil</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_floor(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_floor</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_trunc(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_trunc</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_integer_p(Math.Gmp.Native.mpf_t)">mpf_integer_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_slong_p(Math.Gmp.Native.mpf_t)">mpf_fits_slong_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_uint_p(Math.Gmp.Native.mpf_t)">mpf_fits_uint_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_sint_p(Math.Gmp.Native.mpf_t)">mpf_fits_sint_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_ushort_p(Math.Gmp.Native.mpf_t)">mpf_fits_ushort_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_sshort_p(Math.Gmp.Native.mpf_t)">mpf_fits_sshort_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_urandomb(Math.Gmp.Native.mpf_t,Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.mp_bitcnt_t)">mpf_urandomb</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_random2(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_exp_t)">mpf_random2</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Miscellaneous_Float_Functions">Miscellaneous Float Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Miscellaneous-Float-Functions.html#Miscellaneous-Float-Functions">GNU MP - Miscellaneous Float Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op 4294967295.
            mpf_t op = new mpf_t();
            gmp_lib.mpf_init_set_ui(op, uint.MaxValue);
            
            // Assert that op does not fit in int.
            Assert.IsTrue(gmp_lib.mpf_fits_sint_p(op) == 0);
            
            // Release unmanaged memory allocated for op.
            gmp_lib.mpf_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op 4294967295.
            Dim op As New mpf_t()
            gmp_lib.mpf_init_set_ui(op, UInteger.MaxValue)
            
            ' Assert that op does not fit in int.
            Assert.IsTrue(gmp_lib.mpf_fits_sint_p(op) = 0)
            
            ' Release unmanaged memory allocated for op.
            gmp_lib.mpf_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_fits_ushort_p(Math.Gmp.Native.mpf_t)">
            <summary>
            Return non-zero if <paramref name="op"/> fits in an unsigned 16-bit integer, when truncated to an integer. 
            </summary>
            <param name="op">The operand float.</param>
            <returns>Return non-zero if <paramref name="op"/> fits in an unsigned 16-bit integer, when truncated to an integer.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_ceil(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_ceil</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_floor(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_floor</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_trunc(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_trunc</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_integer_p(Math.Gmp.Native.mpf_t)">mpf_integer_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_ulong_p(Math.Gmp.Native.mpf_t)">mpf_fits_ulong_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_slong_p(Math.Gmp.Native.mpf_t)">mpf_fits_slong_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_uint_p(Math.Gmp.Native.mpf_t)">mpf_fits_uint_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_sint_p(Math.Gmp.Native.mpf_t)">mpf_fits_sint_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_sshort_p(Math.Gmp.Native.mpf_t)">mpf_fits_sshort_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_urandomb(Math.Gmp.Native.mpf_t,Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.mp_bitcnt_t)">mpf_urandomb</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_random2(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_exp_t)">mpf_random2</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Miscellaneous_Float_Functions">Miscellaneous Float Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Miscellaneous-Float-Functions.html#Miscellaneous-Float-Functions">GNU MP - Miscellaneous Float Functions</a></seealso>
            <example>
            <code language="C#">
            </code> 
            <code language="VB.NET">
            // Create, initialize, and set the value of op 4294967295.
            mpf_t op = new mpf_t();
            gmp_lib.mpf_init_set_ui(op, uint.MaxValue);
            
            // Assert that op does not fit in ushort.
            Assert.IsTrue(gmp_lib.mpf_fits_ushort_p(op) == 0);
            
            // Release unmanaged memory allocated for op.
            gmp_lib.mpf_clear(op);
            ' Create, initialize, and set the value of op 4294967295.
            Dim op As New mpf_t()
            gmp_lib.mpf_init_set_ui(op, UInteger.MaxValue)
            
            ' Assert that op does not fit in ushort.
            Assert.IsTrue(gmp_lib.mpf_fits_ushort_p(op) = 0)
            
            ' Release unmanaged memory allocated for op.
            gmp_lib.mpf_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_floor(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op"/> rounded to the next lower integer.
            </summary>
            <param name="rop">The result float.</param>
            <param name="op">The operand float.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_ceil(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_ceil</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_trunc(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_trunc</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_integer_p(Math.Gmp.Native.mpf_t)">mpf_integer_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_ulong_p(Math.Gmp.Native.mpf_t)">mpf_fits_ulong_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_slong_p(Math.Gmp.Native.mpf_t)">mpf_fits_slong_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_uint_p(Math.Gmp.Native.mpf_t)">mpf_fits_uint_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_sint_p(Math.Gmp.Native.mpf_t)">mpf_fits_sint_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_ushort_p(Math.Gmp.Native.mpf_t)">mpf_fits_ushort_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_sshort_p(Math.Gmp.Native.mpf_t)">mpf_fits_sshort_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_urandomb(Math.Gmp.Native.mpf_t,Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.mp_bitcnt_t)">mpf_urandomb</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_random2(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_exp_t)">mpf_random2</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Miscellaneous_Float_Functions">Miscellaneous Float Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Miscellaneous-Float-Functions.html#Miscellaneous-Float-Functions">GNU MP - Miscellaneous Float Functions</a></seealso>
            <example>
            <code language="C#">
            / Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64U);
            
            // Create, initialize, and set a new floating-point number x to 10.4.
            mpf_t x = new mpf_t();
            gmp_lib.mpf_init_set_d(x, 10.4);
            
            // Create and initialize a new floating-point number z.
            mpf_t z = new mpf_t();
            gmp_lib.mpf_init(z);
            
            // Set z = floor(x).
            gmp_lib.mpf_floor(z, x);
            
            // Assert that the value of z is 10.
            Assert.IsTrue(gmp_lib.mpf_get_d(z) == 10.0);
            
            // Release unmanaged memory allocated for x and z.
            gmp_lib.mpf_clears(x, z, null);
            </code> 
            <code language="VB.NET">
            ' Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64UI)
            
            ' Create, initialize, and set a new floating-point number x to 10.4.
            Dim x As New mpf_t()
            gmp_lib.mpf_init_set_d(x, 10.4)
            
            ' Create and initialize a new floating-point number z.
            Dim z As New mpf_t()
            gmp_lib.mpf_init(z)
            
            ' Set z = floor(x).
            gmp_lib.mpf_floor(z, x)
            
            ' Assert that the value of z is 10.
            Assert.IsTrue(gmp_lib.mpf_get_d(z) = 10.0)
            
            ' Release unmanaged memory allocated for x and z.
            gmp_lib.mpf_clears(x, z, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_get_d(Math.Gmp.Native.mpf_t)">
            <summary>
            Convert <paramref name="op"/> to a <see cref="T:System.Double">double</see>, truncating if necessary (i.e. rounding towards zero). 
            </summary>
            <param name="op">The operand float.</param>
            <returns>The cpnverted <see cref="T:System.Double">double</see>.</returns>
            <remarks>
            <para>
            If the exponent in <paramref name="op"/> is too big or too small to fit a <see cref="T:System.Double">double</see> then the result is system dependent.
            For too big an infinity is returned when available.
            For too small 0.0 is normally returned.
            Hardware overflow, underflow and denorm traps may or may not occur. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_get_d_2exp(Math.Gmp.Native.ptr{System.Int32},Math.Gmp.Native.mpf_t)">mpf_get_d_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_get_si(Math.Gmp.Native.mpf_t)">mpf_get_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_get_ui(Math.Gmp.Native.mpf_t)">mpf_get_ui</seealso>
            <seealso cref="O:Math.Gmp.Native.gmp_lib.mpf_get_str">O:Math.Gmp.Native.gmp_lib.mpf_get_str</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Converting_Floats">Converting Floats</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Converting-Floats.html#Converting-Floats">GNU MP - Converting Floats</a></seealso>
            <example>
            <code language="C#">
            // Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64U);
            
            // Create, initialize, and set a new floating-point number to -123.0
            mpf_t x = new mpf_t();
            gmp_lib.mpf_init_set_d(x, -123.0);
            
            // Assert that the value of x is -123.0.
            Assert.IsTrue(gmp_lib.mpf_get_d(x) == -123.0);
            
            // Release unmanaged memory allocated for x.
            gmp_lib.mpf_clear(x);
            </code> 
            <code language="VB.NET">
            ' Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64UI)
            
            ' Create, initialize, and set a new floating-point number to -123.0
            Dim x As New mpf_t()
            gmp_lib.mpf_init_set_d(x, -123.0)
            
            ' Assert that the value of x is -123.0.
            Assert.IsTrue(gmp_lib.mpf_get_d(x) = -123.0)
            
            ' Release unmanaged memory allocated for x.
            gmp_lib.mpf_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_get_d_2exp(Math.Gmp.Native.ptr{System.Int32},Math.Gmp.Native.mpf_t)">
            <summary>
            Convert op to a double, truncating if necessary (i.e. rounding towards zero), and with an exponent returned separately. 
            </summary>
            <param name="exp">Pointer to 32-bit signed integer.</param>
            <param name="op">The operand float.</param>
            <returns>The return value is in the range 0.5 &#8804; | d | &lt; 1 and the exponent is stored at <paramref name="exp"/>. d * 2^<paramref name="exp"/> is the (truncated) <paramref name="op"/> value. If <paramref name="op"/> is zero, the return is 0.0 and 0 is stored at <paramref name="exp"/>.</returns>
            <remarks>
            <para>
            This is similar to the standard C <c>frexp</c> function
            (see <a href="https://www.gnu.org/software/libc/manual/html_node/Normalization-Functions.html#Normalization-Functions">GNU C - Normalization Functions</a> in The GNU C Library Reference Manual). 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_get_d(Math.Gmp.Native.mpf_t)">mpf_get_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_get_si(Math.Gmp.Native.mpf_t)">mpf_get_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_get_ui(Math.Gmp.Native.mpf_t)">mpf_get_ui</seealso>
            <seealso cref="O:Math.Gmp.Native.gmp_lib.mpf_get_str">O:Math.Gmp.Native.gmp_lib.mpf_get_str</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Converting_Floats">Converting Floats</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Converting-Floats.html#Converting-Floats">GNU MP - Converting Floats</a></seealso>
            <example>
            <code language="C#">
            // Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64U);
            
            // Create, initialize, and set a new floating-point number to -8.0
            mpf_t x = new mpf_t();
            gmp_lib.mpf_init_set_d(x, -8.0);
            
            // Assert that the absolute value of x is 0.5 x 2^4.
            ptr&lt;int&gt; exp = new ptr&lt;int&gt;(0);
            Assert.IsTrue(gmp_lib.mpf_get_d_2exp(exp, x) == 0.5);
            Assert.IsTrue(exp.Value == 4);
            
            // Release unmanaged memory allocated for x and exp.
            gmp_lib.mpf_clear(x);
            </code> 
            <code language="VB.NET">
            ' Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64UI)
            
            ' Create, initialize, and set a new floating-point number to -8.0
            Dim x As New mpf_t()
            gmp_lib.mpf_init_set_d(x, -8.0)
            
            ' Assert that the absolute value of x is 0.5 x 2^4.
            Dim exp As New ptr(Of Integer)(0)
            Assert.IsTrue(gmp_lib.mpf_get_d_2exp(exp, x) = 0.5)
            Assert.IsTrue(exp.Value = 4)
            
            ' Release unmanaged memory allocated for x and exp.
            gmp_lib.mpf_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_get_default_prec">
            <summary>
            Return the default precision actually used. 
            </summary>
            <returns>The default precision actually used.</returns>
            <remarks>
            <para>
            An <see cref="T:Math.Gmp.Native.mpf_t">mpf_t</see> object must be initialized before storing the first value in it.
            The functions <see cref="M:Math.Gmp.Native.gmp_lib.mpf_init(Math.Gmp.Native.mpf_t)">mpf_init</see> and <see cref="M:Math.Gmp.Native.gmp_lib.mpf_init2(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_bitcnt_t)">mpf_init2</see> are used for that purpose. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_default_prec(Math.Gmp.Native.mp_bitcnt_t)">mpf_set_default_prec</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_init(Math.Gmp.Native.mpf_t)">mpf_init</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_init2(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_bitcnt_t)">mpf_init2</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_inits(Math.Gmp.Native.mpf_t[])">mpf_inits</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_clear(Math.Gmp.Native.mpf_t)">mpf_clear</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_clears(Math.Gmp.Native.mpf_t[])">mpf_clears</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_get_prec(Math.Gmp.Native.mpf_t)">mpf_get_prec</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_prec(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_bitcnt_t)">mpf_set_prec</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_prec_raw(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_bitcnt_t)">mpf_set_prec_raw</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Initializing_Floats">Initializing Floats</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Initializing-Floats.html#Initializing-Floats">GNU MP - Initializing Floats</a></seealso>
            <example>
            <code language="C#">
            // Set default precision to 128 bits.
            gmp_lib.mpf_set_default_prec(128U);
            
            // Assert that the value of x is 128 bits.
            Assert.IsTrue(gmp_lib.mpf_get_default_prec() == 128U);
            </code> 
            <code language="VB.NET">
            ' Set default precision to 128 bits.
            gmp_lib.mpf_set_default_prec(128UI)
            
            ' Assert that the value of x is 128 bits.
            Assert.IsTrue(gmp_lib.mpf_get_default_prec() = 128UI)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_get_prec(Math.Gmp.Native.mpf_t)">
            <summary>
            Return the current precision of <paramref name="op"/>, in bits. 
            </summary>
            <param name="op">The operand float.</param>
            <returns>The current precision of <paramref name="op"/>, in bits.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_default_prec(Math.Gmp.Native.mp_bitcnt_t)">mpf_set_default_prec</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_get_default_prec">mpf_get_default_prec</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_init(Math.Gmp.Native.mpf_t)">mpf_init</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_init2(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_bitcnt_t)">mpf_init2</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_inits(Math.Gmp.Native.mpf_t[])">mpf_inits</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_clear(Math.Gmp.Native.mpf_t)">mpf_clear</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_clears(Math.Gmp.Native.mpf_t[])">mpf_clears</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_prec(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_bitcnt_t)">mpf_set_prec</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_prec_raw(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_bitcnt_t)">mpf_set_prec_raw</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Initializing_Floats">Initializing Floats</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Initializing-Floats.html#Initializing-Floats">GNU MP - Initializing Floats</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize a new floating-point number x with 64-bit precision.
            mpf_t x = new mpf_t();
            gmp_lib.mpf_init2(x, 64U);
            
            // Assert that the value of x is 0.0, and that its precision is 64 bits.
            Assert.IsTrue(gmp_lib.mpf_get_d(x) == 0.0);
            Assert.IsTrue(gmp_lib.mpf_get_prec(x) == 64U);
            
            // Release unmanaged memory allocated for x.
            gmp_lib.mpf_clear(x);
            </code> 
            <code language="VB.NET">
            ' Create and initialize a new floating-point number x with 64-bit precision.
            Dim x As New mpf_t()
            gmp_lib.mpf_init2(x, 64UI)
            
            ' Assert that the value of x is 0.0, and that its precision is 64 bits.
            Assert.IsTrue(gmp_lib.mpf_get_d(x) = 0.0)
            Assert.IsTrue(gmp_lib.mpf_get_prec(x) = 64UI)
            
            ' Release unmanaged memory allocated for x.
            gmp_lib.mpf_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_get_si(Math.Gmp.Native.mpf_t)">
            <summary>
            Convert <paramref name="op"/> to a 32-bit integer, truncating any fraction part.
            </summary>
            <param name="op">The operand float.</param>
            <returns>The converted integer.</returns>
            <remarks>
            <para>
            If <paramref name="op"/> is too big for the return type, the result is undefined. 
            </para>
            <para>
            See also <see cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_slong_p(Math.Gmp.Native.mpf_t)">mpf_fits_slong_p</see> and <see cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_ulong_p(Math.Gmp.Native.mpf_t)">mpf_fits_ulong_p</see>
            (see <a href="https://gmplib.org/manual/Miscellaneous-Float-Functions.html#Miscellaneous-Float-Functions">GNU MP - Miscellaneous Float Functions</a>). 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_get_d(Math.Gmp.Native.mpf_t)">mpf_get_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_get_d_2exp(Math.Gmp.Native.ptr{System.Int32},Math.Gmp.Native.mpf_t)">mpf_get_d_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_get_ui(Math.Gmp.Native.mpf_t)">mpf_get_ui</seealso>
            <seealso cref="O:Math.Gmp.Native.gmp_lib.mpf_get_str">O:Math.Gmp.Native.gmp_lib.mpf_get_str</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Converting_Floats">Converting Floats</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Converting-Floats.html#Converting-Floats">GNU MP - Converting Floats</a></seealso>
            <example>
            <code language="C#">
            // Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64U);
            
            // Create, initialize, and set a new floating-point number to -8.0
            mpf_t x = new mpf_t();
            gmp_lib.mpf_init_set_d(x, -8.0);
            
            // Assert that the value of x is -8.
            Assert.IsTrue(gmp_lib.mpf_get_si(x) == -8);
            
            // Release unmanaged memory allocated for x.
            gmp_lib.mpf_clear(x);
            </code> 
            <code language="VB.NET">
            ' Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64UI)
            
            ' Create, initialize, and set a new floating-point number to -8.0
            Dim x As New mpf_t()
            gmp_lib.mpf_init_set_d(x, -8.0)
            
            ' Assert that the value of x is -8.
            Assert.IsTrue(gmp_lib.mpf_get_si(x) = -8)
            
            ' Release unmanaged memory allocated for x.
            gmp_lib.mpf_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_get_str(Math.Gmp.Native.char_ptr,Math.Gmp.Native.mp_exp_t@,System.Int32,Math.Gmp.Native.size_t,Math.Gmp.Native.mpf_t)">
            <summary>
            Convert <paramref name="op"/> to a string of digits in base <paramref name="base"/>.
            </summary>
            <param name="str">The output string.</param>
            <param name="expptr">The exponent.</param>
            <param name="base">The base.</param>
            <param name="n_digits">Maximum number of output digits.</param>
            <param name="op">The operand floating-point number.</param>
            <returns>A pointer to the result string is returned, being either the allocated block or the given <paramref name="str"/>.</returns>
            <remarks>
            <para>
            The <paramref name="base"/> argument may vary from 2 to 62 or from -2 to -36.
            Up to <paramref name="n_digits"/> digits will be generated.
            Trailing zeros are not returned.
            No more digits than can be accurately represented by <paramref name="op"/> are ever generated.
            If <paramref name="n_digits"/> is 0 then that accurate maximum number of digits are generated. 
            </para>
            <para>
            For <paramref name="base"/> in the range 2..36, digits and lower-case letters are used; for -2..-36,
            digits and upper-case letters are used; for 37..62, digits, upper-case letters, and lower-case letters
            (in that significance order) are used. 
            </para>
            <para>
            If <paramref name="str"/> is NULL, the result string is allocated using the current allocation function
            (see <a href="https://gmplib.org/manual/Custom-Allocation.html#Custom-Allocation">GNU MP - Custom Allocation</a>).
            The block will be strlen(str) + 1 bytes, that being exactly enough for the string and null-terminator.
            </para>
            <para>
            If <paramref name="str"/> is not NULL, it should point to a block of <paramref name="n_digits"/> + 2 bytes,
            that being enough for the mantissa, a possible minus sign, and a null-terminator.
            When <paramref name="n_digits"/> is 0 to get all significant digits, an application won’t be able to know
            the space required, and <paramref name="str"/> should be NULL in that case. 
            </para>
            <para>
            The generated string is a fraction, with an implicit radix point immediately to the left of the first digit.
            The applicable exponent is written through the <paramref name="expptr"/> pointer.
            For example, the number 3.1416 would be returned as string "31416" and exponent 1.
            </para>
            <para>
            When <paramref name="op"/> is zero, an empty string is produced and the exponent returned is 0. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_get_d(Math.Gmp.Native.mpf_t)">mpf_get_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_get_d_2exp(Math.Gmp.Native.ptr{System.Int32},Math.Gmp.Native.mpf_t)">mpf_get_d_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_get_si(Math.Gmp.Native.mpf_t)">mpf_get_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_get_ui(Math.Gmp.Native.mpf_t)">mpf_get_ui</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Converting_Floats">Converting Floats</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Converting-Floats.html#Converting-Floats">GNU MP - Converting Floats</a></seealso>
            <example>
            <code language="C#">
            // Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64U);
            
            // Create, initialize, and set a new floating-point number to -8.0
            mpf_t x = new mpf_t();
            gmp_lib.mpf_init_set_d(x, -8.0);
            
            // Assert that the value of x is -8.
            mp_exp_t exp = 0;
            char_ptr value = gmp_lib.mpf_get_str(char_ptr.Zero, ref exp, 10, 0, x);
            Assert.IsTrue(value.ToString() == "-8");
            Assert.IsTrue(exp == 1);
            
            // Release unmanaged memory allocated for x.
            gmp_lib.mpf_clear(x);
            gmp_lib.free(value);
            </code> 
            <code language="VB.NET">
            ' Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64UI)
            
            ' Create, initialize, and set a new floating-point number to -8.0
            Dim x As New mpf_t()
            gmp_lib.mpf_init_set_d(x, -8.0)
            
            ' Assert that the value of x is -8.
            Dim exp As mp_exp_t = 0
            Dim value As char_ptr = gmp_lib.mpf_get_str(char_ptr.Zero, exp, 10, 0, x)
            Assert.IsTrue(value.ToString() = "-8")
            Assert.IsTrue(exp = 1)
            
            ' Release unmanaged memory allocated for x.
            gmp_lib.mpf_clear(x)
            gmp_lib.free(value)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_get_str(Math.Gmp.Native.char_ptr,Math.Gmp.Native.ptr{Math.Gmp.Native.mp_exp_t},System.Int32,Math.Gmp.Native.size_t,Math.Gmp.Native.mpf_t)">
            <summary>
            Convert <paramref name="op"/> to a string of digits in base <paramref name="base"/>.
            </summary>
            <param name="str">The output string.</param>
            <param name="expptr">The exponent.</param>
            <param name="base">The base.</param>
            <param name="n_digits">Maximum number of output digits.</param>
            <param name="op">The operand floating-point number.</param>
            <returns>A pointer to the result string is returned, being either the allocated block or the given <paramref name="str"/>.</returns>
            <remarks>
            <para>
            The <paramref name="base"/> argument may vary from 2 to 62 or from -2 to -36.
            Up to <paramref name="n_digits"/> digits will be generated.
            Trailing zeros are not returned.
            No more digits than can be accurately represented by <paramref name="op"/> are ever generated.
            If <paramref name="n_digits"/> is 0 then that accurate maximum number of digits are generated. 
            </para>
            <para>
            For <paramref name="base"/> in the range 2..36, digits and lower-case letters are used; for -2..-36,
            digits and upper-case letters are used; for 37..62, digits, upper-case letters, and lower-case letters
            (in that significance order) are used. 
            </para>
            <para>
            If <paramref name="str"/> is NULL, the result string is allocated using the current allocation function
            (see <a href="https://gmplib.org/manual/Custom-Allocation.html#Custom-Allocation">GNU MP - Custom Allocation</a>).
            The block will be strlen(str) + 1 bytes, that being exactly enough for the string and null-terminator.
            </para>
            <para>
            If <paramref name="str"/> is not NULL, it should point to a block of <paramref name="n_digits"/> + 2 bytes,
            that being enough for the mantissa, a possible minus sign, and a null-terminator.
            When <paramref name="n_digits"/> is 0 to get all significant digits, an application won’t be able to know
            the space required, and <paramref name="str"/> should be NULL in that case. 
            </para>
            <para>
            The generated string is a fraction, with an implicit radix point immediately to the left of the first digit.
            The applicable exponent is written through the <paramref name="expptr"/> pointer.
            For example, the number 3.1416 would be returned as string "31416" and exponent 1.
            </para>
            <para>
            When <paramref name="op"/> is zero, an empty string is produced and the exponent returned is 0. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_get_d(Math.Gmp.Native.mpf_t)">mpf_get_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_get_d_2exp(Math.Gmp.Native.ptr{System.Int32},Math.Gmp.Native.mpf_t)">mpf_get_d_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_get_si(Math.Gmp.Native.mpf_t)">mpf_get_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_get_ui(Math.Gmp.Native.mpf_t)">mpf_get_ui</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Converting_Floats">Converting Floats</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Converting-Floats.html#Converting-Floats">GNU MP - Converting Floats</a></seealso>
            <example>
            <code language="C#">
            // Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64U);
            
            // Create, initialize, and set a new floating-point number to -8.0
            mpf_t x = new mpf_t();
            gmp_lib.mpf_init_set_d(x, -8.0);
            
            // Assert that the value of x is -8.
            ptr&lt;mp_exp_t&gt; exp = new ptr&lt;mp_exp_t&gt;(0);
            char_ptr value = gmp_lib.mpf_get_str(char_ptr.Zero, exp, 10, 0, x);
            Assert.IsTrue(value.ToString() == "-8");
            Assert.IsTrue(exp.Value == 1);
            
            // Release unmanaged memory allocated for x.
            gmp_lib.mpf_clear(x);
            gmp_lib.free(value);
            </code> 
            <code language="VB.NET">
            ' Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64UI)
            
            ' Create, initialize, and set a new floating-point number to -8.0
            Dim x As New mpf_t()
            gmp_lib.mpf_init_set_d(x, -8.0)
            
            ' Assert that the value of x is -8.
            Dim exp As New ptr(Of mp_exp_t)(0)
            Dim value As char_ptr = gmp_lib.mpf_get_str(char_ptr.Zero, exp, 10, 0, x)
            Assert.IsTrue(value.ToString() = "-8")
            Assert.IsTrue(exp.Value = 1)
            
            ' Release unmanaged memory allocated for x.
            gmp_lib.mpf_clear(x)
            gmp_lib.free(value)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_get_ui(Math.Gmp.Native.mpf_t)">
            <summary>
            Convert <paramref name="op"/> to an unsigned 32-bit integer, truncating any fraction part.
            </summary>
            <param name="op">The operand float.</param>
            <returns>The converted integer.</returns>
            <remarks>
            <para>
            If <paramref name="op"/> is too big for the return type, the result is undefined. 
            </para>
            <para>
            See also <see cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_slong_p(Math.Gmp.Native.mpf_t)">mpf_fits_slong_p</see> and <see cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_ulong_p(Math.Gmp.Native.mpf_t)">mpf_fits_ulong_p</see>
            (see <a href="https://gmplib.org/manual/Miscellaneous-Float-Functions.html#Miscellaneous-Float-Functions">GNU MP - Miscellaneous Float Functions</a>). 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_get_d(Math.Gmp.Native.mpf_t)">mpf_get_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_get_d_2exp(Math.Gmp.Native.ptr{System.Int32},Math.Gmp.Native.mpf_t)">mpf_get_d_2exp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_get_si(Math.Gmp.Native.mpf_t)">mpf_get_si</seealso>
            <seealso cref="O:Math.Gmp.Native.gmp_lib.mpf_get_str">O:Math.Gmp.Native.gmp_lib.mpf_get_str</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Converting_Floats">Converting Floats</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Converting-Floats.html#Converting-Floats">GNU MP - Converting Floats</a></seealso>
            <example>
            <code language="C#">
            </code> 
            <code language="VB.NET">
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_init(Math.Gmp.Native.mpf_t)">
            <summary>
            Initialize <paramref name="x"/> to 0.
            </summary>
            <param name="x">The operand float.</param>
            <remarks>
            <para>
            Normally, a variable should be initialized once only or at least be cleared, using <see cref="M:Math.Gmp.Native.gmp_lib.mpf_clear(Math.Gmp.Native.mpf_t)">mpf_clear</see>,
            between initializations. The precision of <paramref name="x"/> is undefined unless a default precision has
            already been established by a call to <see cref="M:Math.Gmp.Native.gmp_lib.mpf_set_default_prec(Math.Gmp.Native.mp_bitcnt_t)">mpf_set_default_prec</see>. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_default_prec(Math.Gmp.Native.mp_bitcnt_t)">mpf_set_default_prec</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_get_default_prec">mpf_get_default_prec</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_init2(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_bitcnt_t)">mpf_init2</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_inits(Math.Gmp.Native.mpf_t[])">mpf_inits</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_clear(Math.Gmp.Native.mpf_t)">mpf_clear</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_clears(Math.Gmp.Native.mpf_t[])">mpf_clears</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_get_prec(Math.Gmp.Native.mpf_t)">mpf_get_prec</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_prec(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_bitcnt_t)">mpf_set_prec</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_prec_raw(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_bitcnt_t)">mpf_set_prec_raw</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Initializing_Floats">Initializing Floats</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Initializing-Floats.html#Initializing-Floats">GNU MP - Initializing Floats</a></seealso>
            <example>
            <code language="C#">
            // Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64U);
            
            // Create and initialize a new floating-point number x.
            mpf_t x = new mpf_t();
            gmp_lib.mpf_init(x);
            
            // Assert that the value of x is 0.0.
            Assert.IsTrue(gmp_lib.mpf_get_d(x) == 0.0);
            
            // Release unmanaged memory allocated for x.
            gmp_lib.mpf_clear(x);
            </code> 
            <code language="VB.NET">
            ' Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64UI)
            
            ' Create and initialize a new floating-point number x.
            Dim x As New mpf_t()
            
            gmp_lib.mpf_init(x)
            
            ' Assert that the value of x is 0.0.
            Assert.IsTrue(gmp_lib.mpf_get_d(x) = 0.0)
            
            ' Release unmanaged memory allocated for x.
            gmp_lib.mpf_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_init2(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_bitcnt_t)">
            <summary>
            Initialize <paramref name="x"/> to 0 and set its precision to be at least <paramref name="prec"/> bits.
            </summary>
            <param name="x">The operand float.</param>
            <param name="prec">The minimum precision in bits.</param>
            <remarks>
            <para>
            Normally, a variable should be initialized once only or at least be cleared, using <see cref="M:Math.Gmp.Native.gmp_lib.mpf_clear(Math.Gmp.Native.mpf_t)">mpf_clear</see>, between initializations. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_default_prec(Math.Gmp.Native.mp_bitcnt_t)">mpf_set_default_prec</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_get_default_prec">mpf_get_default_prec</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_init(Math.Gmp.Native.mpf_t)">mpf_init</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_inits(Math.Gmp.Native.mpf_t[])">mpf_inits</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_clear(Math.Gmp.Native.mpf_t)">mpf_clear</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_clears(Math.Gmp.Native.mpf_t[])">mpf_clears</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_get_prec(Math.Gmp.Native.mpf_t)">mpf_get_prec</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_prec(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_bitcnt_t)">mpf_set_prec</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_prec_raw(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_bitcnt_t)">mpf_set_prec_raw</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Initializing_Floats">Initializing Floats</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Initializing-Floats.html#Initializing-Floats">GNU MP - Initializing Floats</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize a new floating-point number x with 64-bit precision.
            mpf_t x = new mpf_t();
            gmp_lib.mpf_init2(x, 64U);
            
            // Assert that the value of x is 0.0, and that its precision is 64 bits.
            Assert.IsTrue(gmp_lib.mpf_get_d(x) == 0.0);
            uint p = gmp_lib.mpf_get_prec(x);
            Assert.IsTrue(gmp_lib.mpf_get_prec(x) == 64U);
            
            // Release unmanaged memory allocated for x.
            gmp_lib.mpf_clear(x);
            </code> 
            <code language="VB.NET">
            ' Create and initialize a new floating-point number x with 64-bit precision.
            Dim x As New mpf_t()
            gmp_lib.mpf_init2(x, 64UI)
            
            ' Assert that the value of x is 0.0, and that its precision is 64 bits.
            Assert.IsTrue(gmp_lib.mpf_get_d(x) = 0.0)
            Dim p As UInteger = gmp_lib.mpf_get_prec(x)
            Assert.IsTrue(gmp_lib.mpf_get_prec(x) = 64UI)
            
            ' Release unmanaged memory allocated for x.
            gmp_lib.mpf_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_inits(Math.Gmp.Native.mpf_t[])">
            <summary>
            Initialize a NULL-terminated list of <see cref="T:Math.Gmp.Native.mpf_t">mpf_t</see> variables, and set their values to 0.
            </summary>
            <param name="x">The operand float.</param>
            <remarks>
            <para>
            The precision of the initialized variables is undefined unless a default precision has already
            been established by a call to <see cref="M:Math.Gmp.Native.gmp_lib.mpf_set_default_prec(Math.Gmp.Native.mp_bitcnt_t)">mpf_set_default_prec</see>. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_default_prec(Math.Gmp.Native.mp_bitcnt_t)">mpf_set_default_prec</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_get_default_prec">mpf_get_default_prec</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_init(Math.Gmp.Native.mpf_t)">mpf_init</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_init2(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_bitcnt_t)">mpf_init2</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_clear(Math.Gmp.Native.mpf_t)">mpf_clear</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_clears(Math.Gmp.Native.mpf_t[])">mpf_clears</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_get_prec(Math.Gmp.Native.mpf_t)">mpf_get_prec</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_prec(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_bitcnt_t)">mpf_set_prec</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_prec_raw(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_bitcnt_t)">mpf_set_prec_raw</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Initializing_Floats">Initializing Floats</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Initializing-Floats.html#Initializing-Floats">GNU MP - Initializing Floats</a></seealso>
            <example>
            <code language="C#">
            // Create new floating-point numbers x1, x2 and x3.
            mpf_t x1 = new mpf_t();
            mpf_t x2 = new mpf_t();
            mpf_t x3 = new mpf_t();
            
            // Initialize the floating-point numbers.
            gmp_lib.mpf_inits(x1, x2, x3, null);
            
            // Assert that their value is 0.
            Assert.IsTrue(gmp_lib.mpf_get_d(x1) == 0.0);
            Assert.IsTrue(gmp_lib.mpf_get_d(x2) == 0.0);
            Assert.IsTrue(gmp_lib.mpf_get_d(x3) == 0.0);
            
            // Release unmanaged memory allocated for the floating-point numbers.
            gmp_lib.mpf_clears(x1, x2, x3, null);
            </code> 
            <code language="VB.NET">
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_init_set(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">
            <summary>
            Initialize <paramref name="rop"/> and set its value from <paramref name="op"/>.
            </summary>
            <param name="rop">The result float.</param>
            <param name="op">The operand.</param>
            <remarks>
            <para>
            The precision of <paramref name="rop"/> will be taken from the active default precision, as set by <see cref="M:Math.Gmp.Native.gmp_lib.mpf_set_default_prec(Math.Gmp.Native.mp_bitcnt_t)">mpf_set_default_prec</see>. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_init_set_ui(Math.Gmp.Native.mpf_t,System.UInt32)">mpf_init_set_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_init_set_si(Math.Gmp.Native.mpf_t,System.Int32)">mpf_init_set_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_init_set_d(Math.Gmp.Native.mpf_t,System.Double)">mpf_init_set_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_init_set_str(Math.Gmp.Native.mpf_t,Math.Gmp.Native.char_ptr,System.Int32)">mpf_init_set_str</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Simultaneous_Float_Init_Assign">Simultaneous Float Init &amp; Assign</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Simultaneous-Float-Init-_0026-Assign.html#Simultaneous-Float-Init-_0026-Assign">GNU MP - Combined Float Initialization and Assignment</a></seealso>
            <example>
            <code language="C#">
            // Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64U);
            
            // Create, initialize, and set a new floating-point number x to 10.
            mpf_t x = new mpf_t();
            gmp_lib.mpf_init_set_si(x, 10);
            
            // Create, initialize, and set a new floating-point number y to x.
            mpf_t y = new mpf_t();
            gmp_lib.mpf_init_set(y, x);
            
            // Assert that the value of y is 10.
            Assert.IsTrue(gmp_lib.mpf_get_d(y) == 10.0);
            
            // Release unmanaged memory allocated for x and y.
            gmp_lib.mpf_clears(x, y, null);
            </code> 
            <code language="VB.NET">
            ' Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64UI)
            
            ' Create, initialize, and set a new floating-point number x to 10.
            Dim x As New mpf_t()
            gmp_lib.mpf_init_set_si(x, 10)
            
            ' Create, initialize, and set a new floating-point number y to x.
            Dim y As New mpf_t()
            gmp_lib.mpf_init_set(y, x)
            
            ' Assert that the value of y is 10.
            Assert.IsTrue(gmp_lib.mpf_get_d(y) = 10.0)
            
            ' Release unmanaged memory allocated for x and y.
            gmp_lib.mpf_clears(x, y, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_init_set_d(Math.Gmp.Native.mpf_t,System.Double)">
            <summary>
            Initialize <paramref name="rop"/> and set its value from <paramref name="op"/>.
            </summary>
            <param name="rop">The result float.</param>
            <param name="op">The operand.</param>
            <remarks>
            <para>
            The precision of <paramref name="rop"/> will be taken from the active default precision, as set by <see cref="M:Math.Gmp.Native.gmp_lib.mpf_set_default_prec(Math.Gmp.Native.mp_bitcnt_t)">mpf_set_default_prec</see>. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_init_set(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_init_set</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_init_set_ui(Math.Gmp.Native.mpf_t,System.UInt32)">mpf_init_set_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_init_set_si(Math.Gmp.Native.mpf_t,System.Int32)">mpf_init_set_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_init_set_str(Math.Gmp.Native.mpf_t,Math.Gmp.Native.char_ptr,System.Int32)">mpf_init_set_str</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Simultaneous_Float_Init_Assign">Simultaneous Float Init &amp; Assign</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Simultaneous-Float-Init-_0026-Assign.html#Simultaneous-Float-Init-_0026-Assign">GNU MP - Combined Float Initialization and Assignment</a></seealso>
            <example>
            <code language="C#">
            // Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64U);
            
            // Create, initialize, and set a new floating-point number to -123.0
            mpf_t x = new mpf_t();
            gmp_lib.mpf_init_set_d(x, -123.0);
            
            // Assert that the value of x is -123.0.
            Assert.IsTrue(gmp_lib.mpf_get_d(x) == -123.0);
            
            // Release unmanaged memory allocated for x.
            gmp_lib.mpf_clear(x);
            </code> 
            <code language="VB.NET">
            ' Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64UI)
            
            ' Create, initialize, and set a new floating-point number to -123.0
            Dim x As New mpf_t()
            gmp_lib.mpf_init_set_d(x, -123.0)
            
            ' Assert that the value of x is -123.0.
            Assert.IsTrue(gmp_lib.mpf_get_d(x) = -123.0)
            
            ' Release unmanaged memory allocated for x.
            gmp_lib.mpf_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_init_set_si(Math.Gmp.Native.mpf_t,System.Int32)">
            <summary>
            Initialize <paramref name="rop"/> and set its value from <paramref name="op"/>.
            </summary>
            <param name="rop">The result float.</param>
            <param name="op">The operand.</param>
            <remarks>
            <para>
            The precision of <paramref name="rop"/> will be taken from the active default precision, as set by <see cref="M:Math.Gmp.Native.gmp_lib.mpf_set_default_prec(Math.Gmp.Native.mp_bitcnt_t)">mpf_set_default_prec</see>. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_init_set(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_init_set</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_init_set_ui(Math.Gmp.Native.mpf_t,System.UInt32)">mpf_init_set_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_init_set_d(Math.Gmp.Native.mpf_t,System.Double)">mpf_init_set_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_init_set_str(Math.Gmp.Native.mpf_t,Math.Gmp.Native.char_ptr,System.Int32)">mpf_init_set_str</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Simultaneous_Float_Init_Assign">Simultaneous Float Init &amp; Assign</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Simultaneous-Float-Init-_0026-Assign.html#Simultaneous-Float-Init-_0026-Assign">GNU MP - Combined Float Initialization and Assignment</a></seealso>
            <example>
            <code language="C#">
            // Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64U);
            
            // Create, initialize and set a new floating-point number to -123.
            mpf_t x = new mpf_t();
            gmp_lib.mpf_init_set_si(x, -123);
            
            // Assert that the value of x is -123.
            Assert.IsTrue(gmp_lib.mpf_get_d(x) == -123.0);
            
            // Release unmanaged memory allocated for x.
            gmp_lib.mpf_clear(x);
            </code> 
            <code language="VB.NET">
            ' Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64UI)
            
            ' Create, initialize and set a new floating-point number to -123.
            Dim x As New mpf_t()
            gmp_lib.mpf_init_set_si(x, -123)
            
            ' Assert that the value of x is -123.
            Assert.IsTrue(gmp_lib.mpf_get_d(x) = -123.0)
            
            ' Release unmanaged memory allocated for x.
            gmp_lib.mpf_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_init_set_str(Math.Gmp.Native.mpf_t,Math.Gmp.Native.char_ptr,System.Int32)">
            <summary>
            Initialize <paramref name="rop"/> and set its value from the string in <paramref name="str"/>.
            </summary>
            <param name="rop">The result float.</param>
            <param name="str">The operand string.</param>
            <param name="base">The base.</param>
            <returns>This function returns 0 if the entire string is a valid number in base <paramref name="base"/>. Otherwise it returns -1.</returns>
            <remarks>
            <para>
            See <see cref="M:Math.Gmp.Native.gmp_lib.mpf_set_str(Math.Gmp.Native.mpf_t,Math.Gmp.Native.char_ptr,System.Int32)">mpf_set_str</see> for details on the assignment operation. 
            </para>
            <para>
            Note that <paramref name="rop"/> is initialized even if an error occurs. (I.e., you have to call <see cref="M:Math.Gmp.Native.gmp_lib.mpf_clear(Math.Gmp.Native.mpf_t)">mpf_clear</see> for it.) 
            </para>
            <para>
            The precision of <paramref name="rop"/> will be taken from the active default precision, as set by <see cref="M:Math.Gmp.Native.gmp_lib.mpf_set_default_prec(Math.Gmp.Native.mp_bitcnt_t)">mpf_set_default_prec</see>. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_init_set(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_init_set</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_init_set_ui(Math.Gmp.Native.mpf_t,System.UInt32)">mpf_init_set_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_init_set_si(Math.Gmp.Native.mpf_t,System.Int32)">mpf_init_set_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_init_set_d(Math.Gmp.Native.mpf_t,System.Double)">mpf_init_set_d</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Simultaneous_Float_Init_Assign">Simultaneous Float Init &amp; Assign</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Simultaneous-Float-Init-_0026-Assign.html#Simultaneous-Float-Init-_0026-Assign">GNU MP - Combined Float Initialization and Assignment</a></seealso>
            <example>
            <code language="C#">
            // Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64U);
            
            // Create, initialize, and set a new floating-point number x to 0.0234.
            char_ptr value = new char_ptr("234e-4");
            mpf_t x = new mpf_t();
            gmp_lib.mpf_init_set_str(x, value, 10);
            
            // Assert that x is 40.
            Assert.IsTrue(x.ToString() == "0.234e-1");
            
            // Release unmanaged memory allocated for x and y.
            gmp_lib.mpf_clear(x);
            gmp_lib.free(value);
            </code> 
            <code language="VB.NET">
            ' Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64UI)
            
            ' Create, initialize, and set a new floating-point number x to 0.0234.
            Dim value As New char_ptr("234e-4")
            Dim x As New mpf_t()
            gmp_lib.mpf_init_set_str(x, value, 10)
            
            ' Assert that x is 40.
            Assert.IsTrue(x.ToString() = "0.234e-1")
            
            ' Release unmanaged memory allocated for x and y.
            gmp_lib.mpf_clear(x)
            gmp_lib.free(value)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_init_set_ui(Math.Gmp.Native.mpf_t,System.UInt32)">
            <summary>
            Initialize <paramref name="rop"/> and set its value from <paramref name="op"/>.
            </summary>
            <param name="rop">The result float.</param>
            <param name="op">The operand.</param>
            <remarks>
            <para>
            The precision of <paramref name="rop"/> will be taken from the active default precision, as set by <see cref="M:Math.Gmp.Native.gmp_lib.mpf_set_default_prec(Math.Gmp.Native.mp_bitcnt_t)">mpf_set_default_prec</see>. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_init_set(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_init_set</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_init_set_si(Math.Gmp.Native.mpf_t,System.Int32)">mpf_init_set_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_init_set_d(Math.Gmp.Native.mpf_t,System.Double)">mpf_init_set_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_init_set_str(Math.Gmp.Native.mpf_t,Math.Gmp.Native.char_ptr,System.Int32)">mpf_init_set_str</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Simultaneous_Float_Init_Assign">Simultaneous Float Init &amp; Assign</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Simultaneous-Float-Init-_0026-Assign.html#Simultaneous-Float-Init-_0026-Assign">GNU MP - Combined Float Initialization and Assignment</a></seealso>
            <example>
            <code language="C#">
            // Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64U);
            
            // Create, initialize, and set a new floating-point number to 100.
            mpf_t x = new mpf_t();
            gmp_lib.mpf_init_set_ui(x, 100U);
            
            // Assert that the value of x is 100.
            Assert.IsTrue(gmp_lib.mpf_get_d(x) == 100.0);
            
            // Release unmanaged memory allocated for x.
            gmp_lib.mpf_clear(x);
            </code> 
            <code language="VB.NET">
            ' Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64UI)
            
            ' Create, initialize, and set a new floating-point number to 100.
            Dim x As New mpf_t()
            gmp_lib.mpf_init_set_ui(x, 100UI)
            
            ' Assert that the value of x is 100.
            Assert.IsTrue(gmp_lib.mpf_get_d(x) = 100.0)
            
            ' Release unmanaged memory allocated for x.
            gmp_lib.mpf_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_inp_str(Math.Gmp.Native.mpf_t,Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.Int32)">
            <summary>
            Read a string in base <paramref name="base"/> from <paramref name="stream"/>, and put the read float in <paramref name="rop"/>.
            </summary>
            <param name="rop">The result float.</param>
            <param name="stream">Pointer to file stream.</param>
            <param name="base">The base.</param>
            <returns>Return the number of bytes read, or if an error occurred, return 0.</returns>
            <remarks>
            <para>
            The string is of the form "M@N" or, if the base is 10 or less, alternatively "MeN".
            "M" is the mantissa and "N’" is the exponent.
            The mantissa is always in the specified <paramref name="base"/>.
            The exponent is either in the specified <paramref name="base"/> or, if <paramref name="base"/> is negative, in decimal.
            The decimal point expected is taken from the current locale, on systems providing <c>localeconv</c>.
            </para>
            <para>
            The argument <paramref name="base"/> may be in the ranges 2 to 36, or -36 to -2.
            Negative values are used to specify that the exponent is in decimal. 
            </para>
            <para>
            Unlike the corresponding <c>mpz</c> function, the <paramref name="base"/> will not be determined from the leading
            characters of the string if base is 0.
            This is so that numbers like "0.23" are not interpreted as octal.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_out_str(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.Int32,Math.Gmp.Native.size_t,Math.Gmp.Native.mpf_t)">mpf_out_str</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#IO_of_Floats">I/O of Floats</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/I_002fO-of-Floats.html#I_002fO-of-Floats">GNU MP - I/O of Floats</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize op.
            mpf_t op = new mpf_t();
            gmp_lib.mpf_init(op);
            
            // Write op to a temporary file.
            string pathname = System.IO.Path.GetTempFileName();
            System.IO.File.WriteAllText(pathname, "0.123456e6");
            
            // Read op from the temporary file, and assert that the number of bytes read is 6.
            ptr&lt;FILE&gt; stream = new ptr&lt;FILE&gt;();
            _wfopen_s(out stream.Value.Value, pathname, "r");
            Assert.IsTrue(gmp_lib.mpf_inp_str(op, stream, 10) == 10);
            fclose(stream.Value.Value);
            
            // Assert that op is 123456.
            Assert.IsTrue(gmp_lib.mpf_get_ui(op) == 123456U);
            
            // Delete temporary file.
            System.IO.File.Delete(pathname);
            
            // Release unmanaged memory allocated for op.
            gmp_lib.mpf_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create and initialize op.
            Dim op As New mpf_t()
            gmp_lib.mpf_init(op)
            
            ' Write op to a temporary file.
            Dim pathname As String = System.IO.Path.GetTempFileName()
            System.IO.File.WriteAllText(pathname, "0.123456e6")
            
            ' Read op from the temporary file, and assert that the number of bytes read is 6.
            Dim stream As New ptr(Of FILE)()
            _wfopen_s(stream.Value.Value, pathname, "r")
            Assert.IsTrue(gmp_lib.mpf_inp_str(op, stream, 10) = 10)
            fclose(stream.Value.Value)
            
            ' Assert that op is 123456.
            Assert.IsTrue(gmp_lib.mpf_get_ui(op) = 123456UI)
            
            ' Delete temporary file.
            System.IO.File.Delete(pathname)
            
            ' Release unmanaged memory allocated for op.
            gmp_lib.mpf_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_integer_p(Math.Gmp.Native.mpf_t)">
            <summary>
            Return non-zero if <paramref name="op"/> is an integer.
            </summary>
            <param name="op">The operand float.</param>
            <returns>Return non-zero if <paramref name="op"/> is an integer.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_ceil(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_ceil</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_floor(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_floor</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_trunc(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_trunc</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_ulong_p(Math.Gmp.Native.mpf_t)">mpf_fits_ulong_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_slong_p(Math.Gmp.Native.mpf_t)">mpf_fits_slong_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_uint_p(Math.Gmp.Native.mpf_t)">mpf_fits_uint_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_sint_p(Math.Gmp.Native.mpf_t)">mpf_fits_sint_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_ushort_p(Math.Gmp.Native.mpf_t)">mpf_fits_ushort_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_sshort_p(Math.Gmp.Native.mpf_t)">mpf_fits_sshort_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_urandomb(Math.Gmp.Native.mpf_t,Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.mp_bitcnt_t)">mpf_urandomb</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_random2(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_exp_t)">mpf_random2</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Miscellaneous_Float_Functions">Miscellaneous Float Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Miscellaneous-Float-Functions.html#Miscellaneous-Float-Functions">GNU MP - Miscellaneous Float Functions</a></seealso>
            <example>
            <code language="C#">
            // Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64U);
            
            // Create, initialize, and set a new floating-point number x to 10.
            mpf_t x = new mpf_t();
            gmp_lib.mpf_init_set_d(x, 10);
            
            // Assert that s is an integer.
            Assert.IsTrue(gmp_lib.mpf_integer_p(x) != 0);
            
            // Release unmanaged memory allocated for x.
            </code> 
            <code language="VB.NET">
            ' Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64UI)
            
            ' Create, initialize, and set a new floating-point number x to 10.
            Dim x As New mpf_t()
            gmp_lib.mpf_init_set_d(x, 10)
            
            ' Assert that s is an integer.
            Assert.IsTrue(gmp_lib.mpf_integer_p(x) &lt;&gt; 0)
            
            ' Release unmanaged memory allocated for x.
            gmp_lib.mpf_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_mul(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> * <paramref name="op2"/>. 
            </summary>
            <param name="rop">The result float.</param>
            <param name="op1">The first operand.</param>
            <param name="op2">The second operand.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_add(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_sub(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_mul_ui(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,System.UInt32)">mpf_mul_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_div(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_div</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_sqrt(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_sqrt</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_pow_ui(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,System.UInt32)">mpf_pow_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_neg(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_abs(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_abs</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_mul_2exp(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_bitcnt_t)">mpf_mul_2exp</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Float_Arithmetic">Float Arithmetic</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Float-Arithmetic.html#Float-Arithmetic">GNU MP - Float Arithmetic</a></seealso>
            <example>
            <code language="C#">
            // Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64U);
            
            // Create, initialize, and set a new floating-point number x to 10.
            mpf_t x = new mpf_t();
            gmp_lib.mpf_init_set_si(x, 10);
            
            // Create, initialize, and set a new floating-point number y to -210.
            mpf_t y = new mpf_t();
            gmp_lib.mpf_init_set_si(y, -210);
            
            // Create and initialize a new floating-point number z.
            mpf_t z = new mpf_t();
            gmp_lib.mpf_init(z);
            
            // Set z = x * y.
            gmp_lib.mpf_mul(z, x, y);
            
            // Assert that the value of z is -2100.
            Assert.IsTrue(gmp_lib.mpf_get_d(z) == -2100.0);
            
            // Release unmanaged memory allocated for x, y, and z.
            gmp_lib.mpf_clears(x, y, z, null);
            </code> 
            <code language="VB.NET">
            ' Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64UI)
            
            ' Create, initialize, and set a new floating-point number x to 10.
            Dim x As New mpf_t()
            gmp_lib.mpf_init_set_si(x, 10)
            
            ' Create, initialize, and set a new floating-point number y to -210.
            Dim y As New mpf_t()
            gmp_lib.mpf_init_set_si(y, -210)
            
            ' Create and initialize a new floating-point number z.
            Dim z As New mpf_t()
            gmp_lib.mpf_init(z)
            
            ' Set z = x * y.
            gmp_lib.mpf_mul(z, x, y)
            
            ' Assert that the value of z is -2100.
            Assert.IsTrue(gmp_lib.mpf_get_d(z) = -2100.0)
            
            ' Release unmanaged memory allocated for x, y, and z.
            gmp_lib.mpf_clears(x, y, z, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_mul_2exp(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_bitcnt_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> * 2^<paramref name="op2"/>. 
            </summary>
            <param name="rop">The result float.</param>
            <param name="op1">The first operand.</param>
            <param name="op2">The second operand.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_add(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_sub(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_mul(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_mul_ui(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,System.UInt32)">mpf_mul_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_div(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_div</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_sqrt(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_sqrt</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_pow_ui(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,System.UInt32)">mpf_pow_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_neg(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_abs(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_abs</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Float_Arithmetic">Float Arithmetic</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Float-Arithmetic.html#Float-Arithmetic">GNU MP - Float Arithmetic</a></seealso>
            <example>
            <code language="C#">
            // Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64U);
            
            // Create, initialize, and set a new floating-point number x to 100.
            mpf_t x = new mpf_t();
            gmp_lib.mpf_init_set_si(x, 100);
            
            // Create and initialize a new floating-point number z.
            mpf_t z = new mpf_t();
            gmp_lib.mpf_init(z);
            
            // Set z = x * 2^8.
            gmp_lib.mpf_mul_2exp(z, x, 8U);
            
            // Assert that the value of z is 25600.
            Assert.IsTrue(gmp_lib.mpf_get_d(z) == 25600.0);
            
            // Release unmanaged memory allocated for x and z.
            gmp_lib.mpf_clears(x, z, null);
            </code> 
            <code language="VB.NET">
            ' Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64UI)
            
            ' Create, initialize, and set a new floating-point number x to 100.
            Dim x As New mpf_t()
            gmp_lib.mpf_init_set_si(x, 100)
            
            ' Create and initialize a new floating-point number z.
            Dim z As New mpf_t()
            gmp_lib.mpf_init(z)
            
            ' Set z = x * 2^8.
            gmp_lib.mpf_mul_2exp(z, x, 8UI)
            
            ' Assert that the value of z is 25600.
            Assert.IsTrue(gmp_lib.mpf_get_d(z) = 25600.0)
            
            ' Release unmanaged memory allocated for x and z.
            gmp_lib.mpf_clears(x, z, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_mul_ui(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,System.UInt32)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> * <paramref name="op2"/>. 
            </summary>
            <param name="rop">The result float.</param>
            <param name="op1">The first operand.</param>
            <param name="op2">The second operand.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_add(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_sub(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_mul(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_div(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_div</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_sqrt(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_sqrt</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_pow_ui(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,System.UInt32)">mpf_pow_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_neg(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_abs(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_abs</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_mul_2exp(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_bitcnt_t)">mpf_mul_2exp</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Float_Arithmetic">Float Arithmetic</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Float-Arithmetic.html#Float-Arithmetic">GNU MP - Float Arithmetic</a></seealso>
            <example>
            <code language="C#">
            // Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64U);
            
            // Create, initialize, and set a new floating-point number x to 10.
            mpf_t x = new mpf_t();
            gmp_lib.mpf_init_set_si(x, 10);
            
            // Create and initialize a new floating-point number z.
            mpf_t z = new mpf_t();
            gmp_lib.mpf_init(z);
            
            // Set z = x * 210.
            gmp_lib.mpf_mul_ui(z, x, 210U);
            
            // Assert that the value of z is 2100.
            Assert.IsTrue(gmp_lib.mpf_get_d(z) == 2100.0);
            
            // Release unmanaged memory allocated for x and z.
            gmp_lib.mpf_clears(x, z, null);
            </code> 
            <code language="VB.NET">
            ' Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64UI)
            
            ' Create, initialize, and set a new floating-point number x to 10.
            Dim x As New mpf_t()
            gmp_lib.mpf_init_set_si(x, 10)
            
            ' Create and initialize a new floating-point number z.
            Dim z As New mpf_t()
            gmp_lib.mpf_init(z)
            
            ' Set z = x * 210.
            gmp_lib.mpf_mul_ui(z, x, 210UI)
            
            ' Assert that the value of z is 2100.
            Assert.IsTrue(gmp_lib.mpf_get_d(z) = 2100.0)
            
            ' Release unmanaged memory allocated for x and z.
            gmp_lib.mpf_clears(x, z, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_neg(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">
            <summary>
            Set <paramref name="rop"/> to -<paramref name="op"/>. 
            </summary>
            <param name="rop">The result float.</param>
            <param name="op">The operand.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_add(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_sub(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_mul(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_div(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_div</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_sqrt(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_sqrt</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_pow_ui(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,System.UInt32)">mpf_pow_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_abs(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_abs</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Float_Arithmetic">Float Arithmetic</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Float-Arithmetic.html#Float-Arithmetic">GNU MP - Float Arithmetic</a></seealso>
            <example>
            <code language="C#">
            // Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64U);
            
            // Create, initialize, and set a new floating-point number x to 10.
            mpf_t x = new mpf_t();
            gmp_lib.mpf_init_set_si(x, 10);
            
            // Create and initialize a new floating-point number z.
            mpf_t z = new mpf_t();
            gmp_lib.mpf_init(z);
            
            // Set z = -x.
            gmp_lib.mpf_neg(z, x);
            
            // Assert that the value of z is -10.
            Assert.IsTrue(gmp_lib.mpf_get_d(z) == -10.0);
            
            // Release unmanaged memory allocated for x and z.
            gmp_lib.mpf_clears(x, z, null);
            </code> 
            <code language="VB.NET">
            ' Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64UI)
            
            ' Create, initialize, and set a new floating-point number x to 10.
            Dim x As New mpf_t()
            gmp_lib.mpf_init_set_si(x, 10)
            
            ' Create and initialize a new floating-point number z.
            Dim z As New mpf_t()
            gmp_lib.mpf_init(z)
            
            ' Set z = -x.
            gmp_lib.mpf_neg(z, x)
            
            ' Assert that the value of z is -10.
            Assert.IsTrue(gmp_lib.mpf_get_d(z) = -10.0)
            
            ' Release unmanaged memory allocated for x and z.
            gmp_lib.mpf_clears(x, z, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_out_str(Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.Int32,Math.Gmp.Native.size_t,Math.Gmp.Native.mpf_t)">
            <summary>
            Print <paramref name="op"/> to <paramref name="stream"/>, as a string of digits.
            </summary>
            <param name="stream">Pointer to file stream.</param>
            <param name="base">The base.</param>
            <param name="n_digits">Maximum number fo digits to write.</param>
            <param name="op">The operand float.</param>
            <returns>Return the number of bytes written, or if an error occurred, return 0.</returns>
            <remarks>
            <para>
            The mantissa is prefixed with an "0." and is in the given <paramref name="base"/>,
            which may vary from 2 to 62 or from -2 to -36.
            An exponent is then printed, separated by an "e", or if the <paramref name="base"/>
            is greater than 10 then by an "@".
            The exponent is always in decimal.
            The decimal point follows the current locale, on systems providing <c>localeconv</c>. 
            </para>
            <para>
            For <paramref name="base"/> in the range 2..36, digits and lower-case letters are used;
            for -2..-36, digits and upper-case letters are used; for 37..62, digits,
            upper-case letters, and lower-case letters (in that significance order) are used. 
            </para>
            <para>
            Up to <paramref name="n_digits"/> will be printed from the mantissa, except that no more
            digits than are accurately representable by op will be printed.
            <paramref name="n_digits"/> can be 0 to select that accurate maximum. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_inp_str(Math.Gmp.Native.mpf_t,Math.Gmp.Native.ptr{Math.Gmp.Native.FILE},System.Int32)">mpf_inp_str</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#IO_of_Floats">I/O of Floats</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/I_002fO-of-Floats.html#I_002fO-of-Floats">GNU MP - I/O of Floats</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op to 123456.
            mpf_t op = new mpf_t();
            gmp_lib.mpf_init_set_ui(op, 123456U);
            
            // Get a temporary file.
            string pathname = System.IO.Path.GetTempFileName();
            
            // Open temporary file for writing.
            ptr&lt;FILE&gt; stream = new ptr&lt;FILE&gt;();
            _wfopen_s(out stream.Value.Value, pathname, "w");
            
            // Write op to temporary file, and assert that the number of bytes written is 10.
            Assert.IsTrue(gmp_lib.mpf_out_str(stream, 10, 0, op) == 10);
            
            // Close temporary file.
            fclose(stream.Value.Value);
            
            // Assert that the content of the temporary file is "123456".
            string result = System.IO.File.ReadAllText(pathname);
            Assert.IsTrue(result == "0.123456e6");
            
            // Delete temporary file.
            System.IO.File.Delete(pathname);
            
            // Release unmanaged memory allocated for op.
            gmp_lib.mpf_clear(op);
            </code> 
            <code language="VB.NET">
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_pow_ui(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,System.UInt32)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/>^<paramref name="op2"/>.
            </summary>
            <param name="rop">The result float.</param>
            <param name="op1">The first operand.</param>
            <param name="op2">The second operand.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_add(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_sub(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_mul(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_div(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_div</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_sqrt(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_sqrt</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_neg(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_abs(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_abs</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Float_Arithmetic">Float Arithmetic</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Float-Arithmetic.html#Float-Arithmetic">GNU MP - Float Arithmetic</a></seealso>
            <example>
            <code language="C#">
            // Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64U);
            
            // Create, initialize, and set a new floating-point number x to 10.
            mpf_t x = new mpf_t();
            gmp_lib.mpf_init_set_si(x, 10);
            
            // Create and initialize a new floating-point number z.
            mpf_t z = new mpf_t();
            gmp_lib.mpf_init(z);
            
            // Set z = sqrt(x).
            gmp_lib.mpf_pow_ui(z, x, 3U);
            
            // Assert that the value of z is 1000.
            Assert.IsTrue(gmp_lib.mpf_get_d(z) == 1000.0);
            
            // Release unmanaged memory allocated for x and z.
            gmp_lib.mpf_clears(x, z, null);
            </code> 
            <code language="VB.NET">
            ' Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64UI)
            
            ' Create, initialize, and set a new floating-point number x to 10.
            Dim x As New mpf_t()
            gmp_lib.mpf_init_set_si(x, 10)
            
            ' Create and initialize a new floating-point number z.
            Dim z As New mpf_t()
            gmp_lib.mpf_init(z)
            
            ' Set z = sqrt(x).
            gmp_lib.mpf_pow_ui(z, x, 3UI)
            
            ' Assert that the value of z is 1000.
            Assert.IsTrue(gmp_lib.mpf_get_d(z) = 1000.0)
            
            ' Release unmanaged memory allocated for x and z.
            gmp_lib.mpf_clears(x, z, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_random2(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_exp_t)">
            <summary>
            Generate a random float of at most <paramref name="max_size"/> limbs, with long strings of zeros and ones in the binary representation.
            </summary>
            <param name="rop">The result float.</param>
            <param name="max_size">The maximum number of limbs.</param>
            <param name="exp">The range of the random exponent.</param>
            <remarks>
            <para>
            The exponent of the number is in the interval -<paramref name="exp"/> to <paramref name="exp"/> (in limbs).
            This function is useful for testing functions and algorithms, since these kind of random numbers have proven to be more
            likely to trigger corner-case bugs.
            Negative random numbers are generated when <paramref name="max_size"/> is negative. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_ceil(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_ceil</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_floor(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_floor</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_trunc(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_trunc</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_integer_p(Math.Gmp.Native.mpf_t)">mpf_integer_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_ulong_p(Math.Gmp.Native.mpf_t)">mpf_fits_ulong_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_slong_p(Math.Gmp.Native.mpf_t)">mpf_fits_slong_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_uint_p(Math.Gmp.Native.mpf_t)">mpf_fits_uint_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_sint_p(Math.Gmp.Native.mpf_t)">mpf_fits_sint_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_ushort_p(Math.Gmp.Native.mpf_t)">mpf_fits_ushort_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_sshort_p(Math.Gmp.Native.mpf_t)">mpf_fits_sshort_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_urandomb(Math.Gmp.Native.mpf_t,Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.mp_bitcnt_t)">mpf_urandomb</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Miscellaneous_Float_Functions">Miscellaneous Float Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Miscellaneous-Float-Functions.html#Miscellaneous-Float-Functions">GNU MP - Miscellaneous Float Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of rop to 0.
            mpf_t rop = new mpf_t();
            gmp_lib.mpf_init(rop);
            
            // Generate a random floating-point number with at most 10 limbs and its exponent in [-5 5].
            gmp_lib.mpf_random2(rop, 10, 5);
            
            // Free all memory occupied by rop.
            gmp_lib.mpf_clear(rop);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of rop to 0.
            Dim rop As New mpf_t()
            gmp_lib.mpf_init(rop)
            
            ' Generate a random floating-point number with at most 10 limbs and its exponent in [-5 5].
            gmp_lib.mpf_random2(rop, 10, 5)
            
            ' Free all memory occupied by rop.
            gmp_lib.mpf_clear(rop)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_reldiff(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">
            <summary>
            Compute the relative difference between <paramref name="op1"/> and <paramref name="op2"/> and store the result in <paramref name="rop"/>. This is | <paramref name="op1"/> - <paramref name="op2"/> | / <paramref name="op1"/>. 
            </summary>
            <param name="rop">The result float.</param>
            <param name="op1">The first operand float.</param>
            <param name="op2">The second operand float.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_cmp(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_cmp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_cmp_z(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpz_t)">mpf_cmp_z</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_cmp_d(Math.Gmp.Native.mpf_t,System.Double)">mpf_cmp_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_cmp_ui(Math.Gmp.Native.mpf_t,System.UInt32)">mpf_cmp_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_cmp_si(Math.Gmp.Native.mpf_t,System.Int32)">mpf_cmp_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_sgn(Math.Gmp.Native.mpf_t)">mpf_sgn</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Float_Comparison">Float Comparison</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Float-Comparison.html#Float-Comparison">GNU MP - Float Comparison</a></seealso>
            <example>
            <code language="C#">
            // Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64U);
            
            // Create, initialize, and set a new floating-point number x to 10.
            mpf_t x = new mpf_t();
            gmp_lib.mpf_init_set_si(x, 10);
            
            // Create, initialize, and set a new floating-point number y to -210.
            mpf_t y = new mpf_t();
            gmp_lib.mpf_init_set_si(y, -210);
            
            // Create and initialize a new floating-point number z.
            mpf_t z = new mpf_t();
            gmp_lib.mpf_init(z);
            
            // Set z = |x - y| / x.
            gmp_lib.mpf_reldiff(z, x, y);
            
            // Assert that the value of z is 22.
            Assert.IsTrue(gmp_lib.mpf_get_d(z) == 22.0);
            
            // Release unmanaged memory allocated for x, y, and z.
            gmp_lib.mpf_clears(x, y, z, null);
            </code> 
            <code language="VB.NET">
            ' Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64UI)
            
            ' Create, initialize, and set a new floating-point number x to 10.
            Dim x As New mpf_t()
            gmp_lib.mpf_init_set_si(x, 10)
            
            ' Create, initialize, and set a new floating-point number y to -210.
            Dim y As New mpf_t()
            gmp_lib.mpf_init_set_si(y, -210)
            
            ' Create and initialize a new floating-point number z.
            Dim z As New mpf_t()
            gmp_lib.mpf_init(z)
            
            ' Set z = |x - y| / x.
            gmp_lib.mpf_reldiff(z, x, y)
            
            ' Assert that the value of z is 22.
            Assert.IsTrue(gmp_lib.mpf_get_d(z) = 22.0)
            
            ' Release unmanaged memory allocated for x, y, and z.
            gmp_lib.mpf_clears(x, y, z, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_set(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">
            <summary>
            Set the value of <paramref name="rop"/> from <paramref name="op"/>. 
            </summary>
            <param name="rop">The result float.</param>
            <param name="op">The operand.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_ui(Math.Gmp.Native.mpf_t,System.UInt32)">mpf_set_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_si(Math.Gmp.Native.mpf_t,System.Int32)">mpf_set_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_d(Math.Gmp.Native.mpf_t,System.Double)">mpf_set_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_z(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpz_t)">mpf_set_z</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_q(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpq_t)">mpf_set_q</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_str(Math.Gmp.Native.mpf_t,Math.Gmp.Native.char_ptr,System.Int32)">mpf_set_str</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_swap(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_swap</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Assigning_Floats">Assigning Floats</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Assigning-Floats.html#Assigning-Floats">GNU MP - Assigning Floats</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number x to 10.
            mpf_t x = new mpf_t();
            gmp_lib.mpf_init2(x, 128U);
            gmp_lib.mpf_set_si(x, 10);
            
            // Create, initialize, and set a new floating-point number y to -210.
            mpf_t y = new mpf_t();
            gmp_lib.mpf_init2(y, 128U);
            gmp_lib.mpf_set_si(y, -210);
            
            // Assign the value of y to x.
            gmp_lib.mpf_set(x, y);
            
            // Assert that the value of x is -210.
            Assert.IsTrue(gmp_lib.mpf_get_d(x) == -210.0);
            
            // Release unmanaged memory allocated for x and y.
            gmp_lib.mpf_clears(x, y, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number x to 10.
            Dim x As New mpf_t()
            gmp_lib.mpf_init2(x, 128UI)
            gmp_lib.mpf_set_si(x, 10)
            
            ' Create, initialize, and set a new floating-point number y to -210.
            Dim y As New mpf_t()
            gmp_lib.mpf_init2(y, 128UI)
            gmp_lib.mpf_set_si(y, -210)
            
            ' Assign the value of y to x.
            gmp_lib.mpf_set(x, y)
            
            ' Assert that the value of x is -210.
            Assert.IsTrue(gmp_lib.mpf_get_d(x) = -210.0)
            
            ' Release unmanaged memory allocated for x and y.
            gmp_lib.mpf_clears(x, y, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_set_d(Math.Gmp.Native.mpf_t,System.Double)">
            <summary>
            Set the value of <paramref name="rop"/> from <paramref name="op"/>. 
            </summary>
            <param name="rop">The result float.</param>
            <param name="op">The operand.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_set</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_ui(Math.Gmp.Native.mpf_t,System.UInt32)">mpf_set_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_si(Math.Gmp.Native.mpf_t,System.Int32)">mpf_set_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_z(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpz_t)">mpf_set_z</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_q(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpq_t)">mpf_set_q</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_str(Math.Gmp.Native.mpf_t,Math.Gmp.Native.char_ptr,System.Int32)">mpf_set_str</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_swap(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_swap</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Assigning_Floats">Assigning Floats</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Assigning-Floats.html#Assigning-Floats">GNU MP - Assigning Floats</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize a new floating-point number.
            mpf_t x = new mpf_t();
            gmp_lib.mpf_init2(x, 128U);
            
            // Set x to -123.0.
            gmp_lib.mpf_set_d(x, -123.0);
            
            // Assert that the value of x is -123.0.
            Assert.IsTrue(gmp_lib.mpf_get_d(x) == -123.0);
            
            // Release unmanaged memory allocated for x.
            gmp_lib.mpf_clear(x);
            </code> 
            <code language="VB.NET">
            ' Create and initialize a new floating-point number.
            Dim x As New mpf_t()
            gmp_lib.mpf_init2(x, 128UI)
            
            ' Set x to -123.0.
            gmp_lib.mpf_set_d(x, -123.0)
            
            ' Assert that the value of x is -123.0.
            Assert.IsTrue(gmp_lib.mpf_get_d(x) = -123.0)
            
            ' Release unmanaged memory allocated for x.
            gmp_lib.mpf_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_set_default_prec(Math.Gmp.Native.mp_bitcnt_t)">
            <summary>
            Set the default precision to be at least <paramref name="prec"/> bits.
            </summary>
            <param name="prec">The minimum precision in bits.</param>
            <remarks>
            <para>
            All subsequent calls to <see cref="M:Math.Gmp.Native.gmp_lib.mpf_init(Math.Gmp.Native.mpf_t)">mpf_init</see> will use this precision, but previously initialized variables are unaffected. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_get_default_prec">mpf_get_default_prec</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_init(Math.Gmp.Native.mpf_t)">mpf_init</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_init2(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_bitcnt_t)">mpf_init2</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_inits(Math.Gmp.Native.mpf_t[])">mpf_inits</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_clear(Math.Gmp.Native.mpf_t)">mpf_clear</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_clears(Math.Gmp.Native.mpf_t[])">mpf_clears</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_get_prec(Math.Gmp.Native.mpf_t)">mpf_get_prec</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_prec(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_bitcnt_t)">mpf_set_prec</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_prec_raw(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_bitcnt_t)">mpf_set_prec_raw</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Initializing_Floats">Initializing Floats</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Initializing-Floats.html#Initializing-Floats">GNU MP - Initializing Floats</a></seealso>
            <example>
            <code language="C#">
            // Set default precision to 128 bits.
            gmp_lib.mpf_set_default_prec(128U);
            
            // Assert that the value of x is 128 bits.
            Assert.IsTrue(gmp_lib.mpf_get_default_prec() == 128U);
            </code> 
            <code language="VB.NET">
            ' Set default precision to 128 bits.
            gmp_lib.mpf_set_default_prec(128UI)
            
            ' Assert that the value of x is 128 bits.
            Assert.IsTrue(gmp_lib.mpf_get_default_prec() = 128UI)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_set_prec(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_bitcnt_t)">
            <summary>
            Set the precision of <paramref name="rop"/> to be at least <paramref name="prec"/> bits.
            </summary>
            <param name="rop">The result float.</param>
            <param name="prec">The minimum precision in bits.</param>
            <remarks>
            <para>
            The value in rop will be truncated to the new precision. 
            </para>
            <para>
            This function requires a call to <c>realloc</c>, and so should not be used in a tight loop. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_default_prec(Math.Gmp.Native.mp_bitcnt_t)">mpf_set_default_prec</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_get_default_prec">mpf_get_default_prec</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_init(Math.Gmp.Native.mpf_t)">mpf_init</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_init2(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_bitcnt_t)">mpf_init2</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_inits(Math.Gmp.Native.mpf_t[])">mpf_inits</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_clear(Math.Gmp.Native.mpf_t)">mpf_clear</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_clears(Math.Gmp.Native.mpf_t[])">mpf_clears</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_get_prec(Math.Gmp.Native.mpf_t)">mpf_get_prec</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_prec_raw(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_bitcnt_t)">mpf_set_prec_raw</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Initializing_Floats">Initializing Floats</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Initializing-Floats.html#Initializing-Floats">GNU MP - Initializing Floats</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize a new floating-point number x.
            mpf_t x = new mpf_t();
            gmp_lib.mpf_init(x);
            
            // Set its precision to 64 bits.
            gmp_lib.mpf_set_prec(x, 64U);
            
            // Assert that the value of x is 0.0, and that its precision is 64 bits.
            Assert.IsTrue(gmp_lib.mpf_get_d(x) == 0.0);
            Assert.IsTrue(gmp_lib.mpf_get_prec(x) == 64U);
            
            // Release unmanaged memory allocated for x.
            gmp_lib.mpf_clear(x);
            </code> 
            <code language="VB.NET">
            ' Create and initialize a new floating-point number x.
            Dim x As New mpf_t()
            gmp_lib.mpf_init(x)
            
            ' Set its precision to 64 bits.
            gmp_lib.mpf_set_prec(x, 64UI)
            
            ' Assert that the value of x is 0.0, and that its precision is 64 bits.
            Assert.IsTrue(gmp_lib.mpf_get_d(x) = 0.0)
            Assert.IsTrue(gmp_lib.mpf_get_prec(x) = 64UI)
            
            ' Release unmanaged memory allocated for x.
            gmp_lib.mpf_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_set_prec_raw(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_bitcnt_t)">
            <summary>
            Set the precision of <paramref name="rop"/> to be at least <paramref name="prec"/> bits, without changing the memory allocated. 
            </summary>
            <param name="rop">The result float.</param>
            <param name="prec">The minimum precision in bits.</param>
            <remarks>
            <para>
            <paramref name="prec"/> must be no more than the allocated precision for <paramref name="rop"/>,
            that being the precision when <paramref name="rop"/> was initialized, or in the most recent <see cref="M:Math.Gmp.Native.gmp_lib.mpf_set_prec(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_bitcnt_t)">mpf_set_prec</see>. 
            </para>
            <para>
            The value in <paramref name="rop"/> is unchanged, and in particular if it had a higher precision than <paramref name="prec"/>
            it will retain that higher precision. New values written to <paramref name="rop"/> will use the new <paramref name="prec"/>. 
            </para>
            <para>
            Before calling <see cref="M:Math.Gmp.Native.gmp_lib.mpf_clear(Math.Gmp.Native.mpf_t)">mpf_clear</see> or the full <see cref="M:Math.Gmp.Native.gmp_lib.mpf_set_prec(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_bitcnt_t)">mpf_set_prec</see>, another <see cref="M:Math.Gmp.Native.gmp_lib.mpf_set_prec_raw(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_bitcnt_t)">mpf_set_prec_raw</see> call
            must be made to restore <paramref name="rop"/> to its original allocated precision. Failing to do so will have unpredictable results.
            </para>
            <para>
            <see cref="M:Math.Gmp.Native.gmp_lib.mpf_get_prec(Math.Gmp.Native.mpf_t)">mpf_get_prec</see> can be used before <see cref="M:Math.Gmp.Native.gmp_lib.mpf_set_prec_raw(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_bitcnt_t)">mpf_set_prec_raw</see> to get the original allocated precision.
            After <see cref="M:Math.Gmp.Native.gmp_lib.mpf_set_prec_raw(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_bitcnt_t)">mpf_set_prec_raw</see> it reflects the prec value set. 
            </para>
            <para>
            <see cref="M:Math.Gmp.Native.gmp_lib.mpf_set_prec_raw(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_bitcnt_t)">mpf_set_prec_raw</see> is an efficient way to use an <see cref="T:Math.Gmp.Native.mpf_t">mpf_t</see> variable at different precisions during a calculation,
            perhaps to gradually increase precision in an iteration, or just to use various different precisions for different purposes during a calculation. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_default_prec(Math.Gmp.Native.mp_bitcnt_t)">mpf_set_default_prec</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_get_default_prec">mpf_get_default_prec</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_init(Math.Gmp.Native.mpf_t)">mpf_init</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_init2(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_bitcnt_t)">mpf_init2</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_inits(Math.Gmp.Native.mpf_t[])">mpf_inits</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_clear(Math.Gmp.Native.mpf_t)">mpf_clear</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_clears(Math.Gmp.Native.mpf_t[])">mpf_clears</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_get_prec(Math.Gmp.Native.mpf_t)">mpf_get_prec</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_prec(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_bitcnt_t)">mpf_set_prec</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Initializing_Floats">Initializing Floats</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Initializing-Floats.html#Initializing-Floats">GNU MP - Initializing Floats</a></seealso>
            <example>
            <code language="C#">
            // Set default precision to 128 bits.
            gmp_lib.mpf_set_default_prec(128U);
            
            // Create, initialize, and set a new rational y to 200 / 3.
            mpq_t y = new mpq_t();
            gmp_lib.mpq_init(y);
            gmp_lib.mpq_set_ui(y, 200, 3U);
            
            // Create, initialize, and set a new floating-point number x to y.
            mpf_t x = new mpf_t();
            gmp_lib.mpf_init(x);
            gmp_lib.mpf_set_q(x, y);
            
            Assert.IsTrue(x.ToString() == "0.6666666666666666666666666666666666666667e2");
            
            // Change precision of x, and set its value to 10000 / 3.
            gmp_lib.mpf_set_prec_raw(x, 8U);
            gmp_lib.mpq_set_ui(y, 10000, 3U);
            gmp_lib.mpf_set_q(x, y);
            
            Assert.IsTrue(x.ToString() == "0.333333333333333333333e4");
            
            // Restore precision of x.
            gmp_lib.mpf_set_prec_raw(x, 128U);
            
            // Release unmanaged memory allocated for x and y.
            gmp_lib.mpf_clear(x);
            gmp_lib.mpq_clear(y);
            </code> 
            <code language="VB.NET">
            ' Set default precision to 128 bits.
            gmp_lib.mpf_set_default_prec(128UI)
            
            ' Create, initialize, and set a new rational y to 200 / 3.
            Dim y As New mpq_t()
            gmp_lib.mpq_init(y)
            gmp_lib.mpq_set_ui(y, 200, 3UI)
            
            ' Create, initialize, and set a new floating-point number x to y.
            Dim x As New mpf_t()
            gmp_lib.mpf_init(x)
            gmp_lib.mpf_set_q(x, y)
            Assert.IsTrue(x.ToString() = "0.6666666666666666666666666666666666666667e2")
            
            ' Change precision of x, and set its value to 10000 / 3.
            gmp_lib.mpf_set_prec_raw(x, 8UI)
            gmp_lib.mpq_set_ui(y, 10000, 3UI)
            gmp_lib.mpf_set_q(x, y)
            Assert.IsTrue(x.ToString() = "0.333333333333333333333e4")
            
            ' Restore precision of x.
            gmp_lib.mpf_set_prec_raw(x, 128UI)
            
            ' Release unmanaged memory allocated for x and y.
            gmp_lib.mpf_clear(x)
            gmp_lib.mpq_clear(y)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_set_q(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpq_t)">
            <summary>
            Set the value of <paramref name="rop"/> from <paramref name="op"/>. 
            </summary>
            <param name="rop">The result float.</param>
            <param name="op">The operand.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_set</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_ui(Math.Gmp.Native.mpf_t,System.UInt32)">mpf_set_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_si(Math.Gmp.Native.mpf_t,System.Int32)">mpf_set_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_d(Math.Gmp.Native.mpf_t,System.Double)">mpf_set_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_z(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpz_t)">mpf_set_z</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_str(Math.Gmp.Native.mpf_t,Math.Gmp.Native.char_ptr,System.Int32)">mpf_set_str</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_swap(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_swap</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Assigning_Floats">Assigning Floats</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Assigning-Floats.html#Assigning-Floats">GNU MP - Assigning Floats</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new rational y to 200 / 5.
            mpq_t y = new mpq_t();
            gmp_lib.mpq_init(y);
            gmp_lib.mpq_set_ui(y, 200, 5U);
            
            // Create, initialize, and set a new floating-point number x to y.
            mpf_t x = new mpf_t();
            gmp_lib.mpf_init(x);
            gmp_lib.mpf_set_q(x, y);
            
            // Assert that x is 40.
            Assert.IsTrue(x.ToString() == "0.4e2");
            
            // Release unmanaged memory allocated for x and y.
            gmp_lib.mpf_clear(x);
            gmp_lib.mpq_clear(y);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new rational y to 200 / 5.
            Dim y As New mpq_t()
            gmp_lib.mpq_init(y)
            gmp_lib.mpq_set_ui(y, 200, 5UI)
            
            ' Create, initialize, and set a new floating-point number x to y.
            Dim x As New mpf_t()
            gmp_lib.mpf_init(x)
            gmp_lib.mpf_set_q(x, y)
            
            ' Assert that x is 40.
            Assert.IsTrue(x.ToString() = "0.4e2")
            
            ' Release unmanaged memory allocated for x and y.
            gmp_lib.mpf_clear(x)
            gmp_lib.mpq_clear(y)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_set_si(Math.Gmp.Native.mpf_t,System.Int32)">
            <summary>
            Set the value of <paramref name="rop"/> from <paramref name="op"/>. 
            </summary>
            <param name="rop">The result float.</param>
            <param name="op">The operand.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_set</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_ui(Math.Gmp.Native.mpf_t,System.UInt32)">mpf_set_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_d(Math.Gmp.Native.mpf_t,System.Double)">mpf_set_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_z(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpz_t)">mpf_set_z</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_q(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpq_t)">mpf_set_q</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_str(Math.Gmp.Native.mpf_t,Math.Gmp.Native.char_ptr,System.Int32)">mpf_set_str</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_swap(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_swap</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Assigning_Floats">Assigning Floats</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Assigning-Floats.html#Assigning-Floats">GNU MP - Assigning Floats</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize a new floating-point number.
            mpf_t x = new mpf_t();
            gmp_lib.mpf_init2(x, 128U);
            
            // Set x to -123.
            gmp_lib.mpf_set_si(x, -123);
            
            // Assert that the value of x is -123.
            Assert.IsTrue(gmp_lib.mpf_get_d(x) == -123.0);
            
            // Release unmanaged memory allocated for x.
            gmp_lib.mpf_clear(x);
            </code> 
            <code language="VB.NET">
            ' Create and initialize a new floating-point number.
            Dim x As New mpf_t()
            gmp_lib.mpf_init2(x, 128UI)
            
            ' Set x to -123.
            gmp_lib.mpf_set_si(x, -123)
            
            ' Assert that the value of x is -123.
            Assert.IsTrue(gmp_lib.mpf_get_d(x) = -123.0)
            
            ' Release unmanaged memory allocated for x.
            gmp_lib.mpf_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_set_str(Math.Gmp.Native.mpf_t,Math.Gmp.Native.char_ptr,System.Int32)">
            <summary>
            Set the value of <paramref name="rop"/> from the string in <paramref name="str"/>.
            </summary>
            <param name="rop">The result float.</param>
            <param name="str">The input string.</param>
            <param name="base">The base.</param>
            <returns>This function returns 0 if the entire string is a valid number in base <paramref name="base"/>. Otherwise it returns -1.</returns>
            <remarks>
            <para>
            The string is of the form "M@N" or, if the <paramref name="base"/> is 10 or less,
            alternatively "MeN".
            "M" is the mantissa and "N" is the exponent.
            The mantissa is always in the specified <paramref name="base"/>.
            The exponent is either in the specified <paramref name="base"/> or, if <paramref name="base"/> is negative, in decimal.
            The decimal point expected is taken from the current locale, on systems providing <c>localeconv</c>. 
            </para>
            <para>
            The argument <paramref name="base"/> may be in the ranges 2 to 62, or -62 to -2.
            Negative values are used to specify that the exponent is in decimal. 
            </para>
            <para>
            For bases up to 36, case is ignored; upper-case and lower-case letters have the same value;
            for bases 37 to 62, upper-case letter represent the usual 10..35 while lower-case
            letter represent 36..61. 
            </para>
            <para>
            Unlike the corresponding <c>mpz</c> function, the <paramref name="base"/> will not be determined from the leading characters
            of the string if base is 0. This is so that numbers like "0.23" are not interpreted as octal. 
            </para>
            <para>
            White space is allowed in the string, and is simply ignored.
            [This is not really true; white-space is ignored in the beginning of the string and within the mantissa,
            but not in other places, such as after a minus sign or in the exponent.
            We are considering changing the definition of this function, making it fail when there is any white-space
            in the input, since that makes a lot of sense.
            Please tell us your opinion about this change.
            Do you really want it to accept "3 14" as meaning 314 as it does now?] 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_set</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_ui(Math.Gmp.Native.mpf_t,System.UInt32)">mpf_set_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_si(Math.Gmp.Native.mpf_t,System.Int32)">mpf_set_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_d(Math.Gmp.Native.mpf_t,System.Double)">mpf_set_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_z(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpz_t)">mpf_set_z</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_q(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpq_t)">mpf_set_q</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_swap(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_swap</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Assigning_Floats">Assigning Floats</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Assigning-Floats.html#Assigning-Floats">GNU MP - Assigning Floats</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number x to 0.0234.
            mpf_t x = new mpf_t();
            gmp_lib.mpf_init(x);
            char_ptr value = new char_ptr("234e-4");
            gmp_lib.mpf_set_str(x, value, 10);
            
            // Assert that x is 40.
            Assert.IsTrue(x.ToString() == "0.234e-1");
            
            // Release unmanaged memory allocated for x and y.
            gmp_lib.mpf_clear(x);
            gmp_lib.free(value);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number x to 0.0234.
            Dim x As New mpf_t()
            gmp_lib.mpf_init(x)
            Dim value As New char_ptr("234e-4")
            gmp_lib.mpf_set_str(x, value, 10)
            
            ' Assert that x is 40.
            Assert.IsTrue(x.ToString() = "0.234e-1")
            
            ' Release unmanaged memory allocated for x and y.
            gmp_lib.mpf_clear(x)
            gmp_lib.free(value)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_set_ui(Math.Gmp.Native.mpf_t,System.UInt32)">
            <summary>
            Set the value of <paramref name="rop"/> from <paramref name="op"/>. 
            </summary>
            <param name="rop">The result float.</param>
            <param name="op">The operand.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_set</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_si(Math.Gmp.Native.mpf_t,System.Int32)">mpf_set_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_d(Math.Gmp.Native.mpf_t,System.Double)">mpf_set_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_z(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpz_t)">mpf_set_z</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_q(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpq_t)">mpf_set_q</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_str(Math.Gmp.Native.mpf_t,Math.Gmp.Native.char_ptr,System.Int32)">mpf_set_str</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_swap(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_swap</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Assigning_Floats">Assigning Floats</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Assigning-Floats.html#Assigning-Floats">GNU MP - Assigning Floats</a></seealso>
            <example>
            <code language="C#">
            // Create and initialize a new floating-point number.
            mpf_t x = new mpf_t();
            gmp_lib.mpf_init2(x, 128U);
            
            // Set x to 100.
            gmp_lib.mpf_set_ui(x, 100U);
            
            // Assert that the value of x is 100.
            Assert.IsTrue(gmp_lib.mpf_get_d(x) == 100.0);
            
            // Release unmanaged memory allocated for x.
            gmp_lib.mpf_clear(x);
            </code> 
            <code language="VB.NET">
            ' Create and initialize a new floating-point number.
            Dim x As New mpf_t()
            gmp_lib.mpf_init2(x, 128UI)
            
            ' Set x to 100.
            gmp_lib.mpf_set_ui(x, 100UI)
            
            ' Assert that the value of x is 100.
            Assert.IsTrue(gmp_lib.mpf_get_d(x) = 100.0)
            
            ' Release unmanaged memory allocated for x.
            gmp_lib.mpf_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_set_z(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpz_t)">
            <summary>
            Set the value of <paramref name="rop"/> from <paramref name="op"/>. 
            </summary>
            <param name="rop">The result float.</param>
            <param name="op">The operand.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_set</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_ui(Math.Gmp.Native.mpf_t,System.UInt32)">mpf_set_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_si(Math.Gmp.Native.mpf_t,System.Int32)">mpf_set_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_d(Math.Gmp.Native.mpf_t,System.Double)">mpf_set_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_q(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpq_t)">mpf_set_q</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_str(Math.Gmp.Native.mpf_t,Math.Gmp.Native.char_ptr,System.Int32)">mpf_set_str</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_swap(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_swap</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Assigning_Floats">Assigning Floats</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Assigning-Floats.html#Assigning-Floats">GNU MP - Assigning Floats</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new integer y to 200.
            mpz_t y = new mpz_t();
            gmp_lib.mpz_init(y);
            gmp_lib.mpz_set_ui(y, 200U);
            
            // Create, initialize, and set a new floating-point number x to y.
            mpf_t x = new mpf_t();
            gmp_lib.mpf_init(x);
            gmp_lib.mpf_set_z(x, y);
            
            // Assert that x is 200.
            Assert.IsTrue(x.ToString() == "0.2e3");
            
            // Release unmanaged memory allocated for x and y.
            gmp_lib.mpf_clear(x);
            gmp_lib.mpz_clear(y);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new integer y to 200.
            Dim y As New mpz_t()
            gmp_lib.mpz_init(y)
            gmp_lib.mpz_set_ui(y, 200UI)
            
            ' Create, initialize, and set a new floating-point number x to y.
            Dim x As New mpf_t()
            gmp_lib.mpf_init(x)
            gmp_lib.mpf_set_z(x, y)
            
            ' Assert that x is 200.
            Assert.IsTrue(x.ToString() = "0.2e3")
            
            ' Release unmanaged memory allocated for x and y.
            gmp_lib.mpf_clear(x)
            gmp_lib.mpz_clear(y)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_sgn(Math.Gmp.Native.mpf_t)">
            <summary>
            Return +1 if op &gt; 0, 0 if op = 0, and -1 if op &lt; 0. 
            </summary>
            <param name="op">The operand float.</param>
            <returns>Return +1 if op &gt; 0, 0 if op = 0, and -1 if op &lt; 0.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_cmp(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_cmp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_cmp_z(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpz_t)">mpf_cmp_z</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_cmp_d(Math.Gmp.Native.mpf_t,System.Double)">mpf_cmp_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_cmp_ui(Math.Gmp.Native.mpf_t,System.UInt32)">mpf_cmp_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_cmp_si(Math.Gmp.Native.mpf_t,System.Int32)">mpf_cmp_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_reldiff(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_reldiff</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Float_Comparison">Float Comparison</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Float-Comparison.html#Float-Comparison">GNU MP - Float Comparison</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set the value of op to -10.
            mpf_t op = new mpf_t();
            gmp_lib.mpf_init_set_si(op, -10);
            
            // Assert that the sign of op is -1.
            Assert.IsTrue(gmp_lib.mpf_sgn(op) == -1);
            
            // Release unmanaged memory allocated for op.
            gmp_lib.mpf_clear(op);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set the value of op to -10.
            Dim op As New mpf_t()
            gmp_lib.mpf_init_set_si(op, -10)
            
            ' Assert that the sign of op is -1.
            Assert.IsTrue(gmp_lib.mpf_sgn(op) = -1)
            
            ' Release unmanaged memory allocated for op.
            gmp_lib.mpf_clear(op)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_size(Math.Gmp.Native.mpf_t)">
            <summary>
            Return the number of limbs currently in use.
            </summary>
            <param name="op">The operand float.</param>
            <returns>The number of limbs currently in use.</returns>
            <seealso cref="T:Math.Gmp.Native.mpf_t">mpf_t</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Float_Arithmetic">Float Arithmetic</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Float-Arithmetic.html#Float-Arithmetic">GNU MP - Float Arithmetic</a></seealso>
            <example>
            <code language="C#">
            // Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64U);
            
            // Create, initialize, and set a new floating-point number x.
            mpf_t x = "1.00000000000000000000001";
            
            // Assert that the size of x is 1.
            Assert.IsTrue(gmp_lib.mpf_size(x) == 4);
            
            // Release unmanaged memory allocated for x.
            gmp_lib.mpf_clear(x);
            </code> 
            <code language="VB.NET">
            ' Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64UI)
            
            ' Create, initialize, and set a new floating-point number x.
            Dim x As mpf_t = "1.00000000000000000000001"
            
            ' Assert that the size of x is 1.
            Assert.IsTrue(gmp_lib.mpf_size(x) = 4)
            
            ' Release unmanaged memory allocated for x.
            gmp_lib.mpf_clear(x)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_sqrt(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">
            <summary>
            Set <paramref name="rop"/> to the square root of <paramref name="op"/>. 
            </summary>
            <param name="rop">The result float.</param>
            <param name="op">The operand.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_add(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_sub(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_mul(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_div(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_div</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_sqrt_ui(Math.Gmp.Native.mpf_t,System.UInt32)">mpf_sqrt_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_pow_ui(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,System.UInt32)">mpf_pow_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_neg(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_abs(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_abs</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Float_Arithmetic">Float Arithmetic</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Float-Arithmetic.html#Float-Arithmetic">GNU MP - Float Arithmetic</a></seealso>
            <example>
            <code language="C#">
            // Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64U);
            
            // Create, initialize, and set a new floating-point number x to 100.
            mpf_t x = new mpf_t();
            gmp_lib.mpf_init_set_si(x, 100);
            
            // Create and initialize a new floating-point number z.
            mpf_t z = new mpf_t();
            gmp_lib.mpf_init(z);
            
            // Set z = sqrt(x).
            gmp_lib.mpf_sqrt(z, x);
            
            // Assert that the value of z is 10.
            Assert.IsTrue(gmp_lib.mpf_get_d(z) == 10.0);
            
            // Release unmanaged memory allocated for x and z.
            gmp_lib.mpf_clears(x, z, null);
            </code> 
            <code language="VB.NET">
            ' Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64UI)
            
            ' Create, initialize, and set a new floating-point number x to 100.
            Dim x As New mpf_t()
            gmp_lib.mpf_init_set_si(x, 100)
            
            ' Create and initialize a new floating-point number z.
            Dim z As New mpf_t()
            gmp_lib.mpf_init(z)
            
            ' Set z = sqrt(x).
            gmp_lib.mpf_sqrt(z, x)
            
            ' Assert that the value of z is 10.
            Assert.IsTrue(gmp_lib.mpf_get_d(z) = 10.0)
            
            ' Release unmanaged memory allocated for x and z.
            gmp_lib.mpf_clears(x, z, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_sqrt_ui(Math.Gmp.Native.mpf_t,System.UInt32)">
            <summary>
            Set <paramref name="rop"/> to the square root of <paramref name="op"/>. 
            </summary>
            <param name="rop">The result float.</param>
            <param name="op">The operand.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_add(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_sub(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_mul(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_div(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_div</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_sqrt(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_sqrt</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_pow_ui(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,System.UInt32)">mpf_pow_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_neg(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_abs(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_abs</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Float_Arithmetic">Float Arithmetic</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Float-Arithmetic.html#Float-Arithmetic">GNU MP - Float Arithmetic</a></seealso>
            <example>
            <code language="C#">
            // Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64U);
            
            // Create and initialize a new floating-point number z.
            mpf_t z = new mpf_t();
            gmp_lib.mpf_init(z);
            
            // Set z = sqrt(100).
            gmp_lib.mpf_sqrt_ui(z, 100U);
            
            // Assert that the value of z is 10.
            Assert.IsTrue(gmp_lib.mpf_get_d(z) == 10.0);
            
            // Release unmanaged memory allocated for x and z.
            gmp_lib.mpf_clear(z);
            </code> 
            <code language="VB.NET">
            ' Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64UI)
            
            ' Create and initialize a new floating-point number z.
            Dim z As New mpf_t()
            gmp_lib.mpf_init(z)
            
            ' Set z = sqrt(100).
            gmp_lib.mpf_sqrt_ui(z, 100UI)
            
            ' Assert that the value of z is 10.
            Assert.IsTrue(gmp_lib.mpf_get_d(z) = 10.0)
            
            ' Release unmanaged memory allocated for x and z.
            gmp_lib.mpf_clear(z)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_sub(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> - <paramref name="op2"/>.
            </summary>
            <param name="rop">The result float.</param>
            <param name="op1">The first operand.</param>
            <param name="op2">The second operand.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_add(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_ui_sub(Math.Gmp.Native.mpf_t,System.UInt32,Math.Gmp.Native.mpf_t)">mpf_ui_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_sub_ui(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,System.UInt32)">mpf_sub_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_mul(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_div(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_div</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_sqrt(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_sqrt</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_pow_ui(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,System.UInt32)">mpf_pow_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_neg(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_abs(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_abs</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Float_Arithmetic">Float Arithmetic</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Float-Arithmetic.html#Float-Arithmetic">GNU MP - Float Arithmetic</a></seealso>
            <example>
            <code language="C#">
            // Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64U);
            
            // Create, initialize, and set a new floating-point number x to 10.
            mpf_t x = new mpf_t();
            gmp_lib.mpf_init_set_si(x, 10);
            
            // Create, initialize, and set a new floating-point number y to -210.
            mpf_t y = new mpf_t();
            gmp_lib.mpf_init_set_si(y, -210);
            
            // Create and initialize a new floating-point number z.
            mpf_t z = new mpf_t();
            gmp_lib.mpf_init(z);
            
            // Set z = x - y.
            gmp_lib.mpf_sub(z, x, y);
            
            // Assert that the value of z is 220.
            Assert.IsTrue(gmp_lib.mpf_get_d(z) == 220.0);
            
            // Release unmanaged memory allocated for x, y, and z.
            gmp_lib.mpf_clears(x, y, z, null);
            </code> 
            <code language="VB.NET">
            ' Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64UI)
            
            ' Create, initialize, and set a new floating-point number x to 10.
            Dim x As New mpf_t()
            
            gmp_lib.mpf_init_set_si(x, 10)
            
            ' Create, initialize, and set a new floating-point number y to -210.
            Dim y As New mpf_t()
            gmp_lib.mpf_init_set_si(y, -210)
            
            ' Create and initialize a new floating-point number z.
            Dim z As New mpf_t()
            gmp_lib.mpf_init(z)
            
            ' Set z = x - y.
            gmp_lib.mpf_sub(z, x, y)
            /// 
            ' Assert that the value of z is 220.
            Assert.IsTrue(gmp_lib.mpf_get_d(z) = 220.0)
            
            ' Release unmanaged memory allocated for x, y, and z.
            gmp_lib.mpf_clears(x, y, z, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_sub_ui(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,System.UInt32)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> - <paramref name="op2"/>.
            </summary>
            <param name="rop">The result float.</param>
            <param name="op1">The first operand.</param>
            <param name="op2">The second operand.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_add(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_sub(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_ui_sub(Math.Gmp.Native.mpf_t,System.UInt32,Math.Gmp.Native.mpf_t)">mpf_ui_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_mul(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_div(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_div</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_sqrt(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_sqrt</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_pow_ui(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,System.UInt32)">mpf_pow_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_neg(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_abs(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_abs</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Float_Arithmetic">Float Arithmetic</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Float-Arithmetic.html#Float-Arithmetic">GNU MP - Float Arithmetic</a></seealso>
            <example>
            <code language="C#">
            // Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64U);
            
            // Create, initialize, and set a new floating-point number x to 10.
            mpf_t x = new mpf_t();
            gmp_lib.mpf_init_set_si(x, 10);
            
            // Create and initialize a new floating-point number z.
            mpf_t z = new mpf_t();
            gmp_lib.mpf_init(z);
            
            // Set z = x - 200.
            gmp_lib.mpf_sub_ui(z, x, 200U);
            
            // Assert that the value of z is -190.
            Assert.IsTrue(gmp_lib.mpf_get_d(z) == -190.0);
            
            // Release unmanaged memory allocated for x and z.
            gmp_lib.mpf_clears(x, z, null);
            </code> 
            <code language="VB.NET">
            ' Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64UI)
            
            ' Create, initialize, and set a new floating-point number x to 10.
            Dim x As New mpf_t()
            gmp_lib.mpf_init_set_si(x, 10)
            
            ' Create and initialize a new floating-point number z.
            Dim z As New mpf_t()
            gmp_lib.mpf_init(z)
            
            ' Set z = x - 200.
            gmp_lib.mpf_sub_ui(z, x, 200UI)
            
            ' Assert that the value of z is -190.
            Assert.IsTrue(gmp_lib.mpf_get_d(z) = -190.0)
            
            ' Release unmanaged memory allocated for x and z.
            gmp_lib.mpf_clears(x, z, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_swap(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">
            <summary>
            Swap <paramref name="rop1"/> and <paramref name="rop2"/> efficiently. 
            </summary>
            <param name="rop1">The first result float.</param>
            <param name="rop2">The second result float.</param>
            <remarks>
            <para>
            Both the values and the precisions of the two variables are swapped.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_set</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_ui(Math.Gmp.Native.mpf_t,System.UInt32)">mpf_set_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_si(Math.Gmp.Native.mpf_t,System.Int32)">mpf_set_si</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_d(Math.Gmp.Native.mpf_t,System.Double)">mpf_set_d</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_z(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpz_t)">mpf_set_z</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_q(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpq_t)">mpf_set_q</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_set_str(Math.Gmp.Native.mpf_t,Math.Gmp.Native.char_ptr,System.Int32)">mpf_set_str</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Assigning_Floats">Assigning Floats</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Assigning-Floats.html#Assigning-Floats">GNU MP - Assigning Floats</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and set a new floating-point number x to 10.
            mpf_t x = new mpf_t();
            gmp_lib.mpf_init2(x, 128U);
            gmp_lib.mpf_set_si(x, 10);
            
            // Create, initialize, and set a new floating-point number y to -210.
            mpf_t y = new mpf_t();
            gmp_lib.mpf_init2(y, 128U);
            gmp_lib.mpf_set_si(y, -210);
            
            // Swap the values of x and y.
            gmp_lib.mpf_swap(x, y);
            
            // Assert that the value of x is -210.
            Assert.IsTrue(gmp_lib.mpf_get_d(x) == -210.0);
            
            // Assert that the value of y is 10.
            Assert.IsTrue(gmp_lib.mpf_get_d(y) == 10.0);
            
            // Release unmanaged memory allocated for x and y.
            gmp_lib.mpf_clears(x, y, null);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and set a new floating-point number x to 10.
            Dim x As New mpf_t()
            gmp_lib.mpf_init2(x, 128UI)
            gmp_lib.mpf_set_si(x, 10)
            
            ' Create, initialize, and set a new floating-point number y to -210.
            Dim y As New mpf_t()
            gmp_lib.mpf_init2(y, 128UI)
            gmp_lib.mpf_set_si(y, -210)
            
            ' Swap the values of x and y.
            gmp_lib.mpf_swap(x, y)
            
            ' Assert that the value of x is -210.
            Assert.IsTrue(gmp_lib.mpf_get_d(x) = -210.0)
            
            ' Assert that the value of y is 10.
            Assert.IsTrue(gmp_lib.mpf_get_d(y) = 10.0)
            
            ' Release unmanaged memory allocated for x and y.
            gmp_lib.mpf_clears(x, y, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_trunc(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op"/> rounded to the integer towards zero. 
            </summary>
            <param name="rop">The result float.</param>
            <param name="op">The operand float.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_ceil(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_ceil</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_floor(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_floor</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_integer_p(Math.Gmp.Native.mpf_t)">mpf_integer_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_ulong_p(Math.Gmp.Native.mpf_t)">mpf_fits_ulong_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_slong_p(Math.Gmp.Native.mpf_t)">mpf_fits_slong_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_uint_p(Math.Gmp.Native.mpf_t)">mpf_fits_uint_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_sint_p(Math.Gmp.Native.mpf_t)">mpf_fits_sint_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_ushort_p(Math.Gmp.Native.mpf_t)">mpf_fits_ushort_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_sshort_p(Math.Gmp.Native.mpf_t)">mpf_fits_sshort_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_urandomb(Math.Gmp.Native.mpf_t,Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.mp_bitcnt_t)">mpf_urandomb</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_random2(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_exp_t)">mpf_random2</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Miscellaneous_Float_Functions">Miscellaneous Float Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Miscellaneous-Float-Functions.html#Miscellaneous-Float-Functions">GNU MP - Miscellaneous Float Functions</a></seealso>
            <example>
            <code language="C#">
            // Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64U);
            
            // Create, initialize, and set a new floating-point number x to 10.4.
            mpf_t x = new mpf_t();
            gmp_lib.mpf_init_set_d(x, 10.4);
            
            // Create and initialize a new floating-point number z.
            mpf_t z = new mpf_t();
            gmp_lib.mpf_init(z);
            
            // Set z = trunc(x).
            gmp_lib.mpf_trunc(z, x);
            
            // Assert that the value of z is 10.
            Assert.IsTrue(gmp_lib.mpf_get_d(z) == 10.0);
            
            // Release unmanaged memory allocated for x and z.
            gmp_lib.mpf_clears(x, z, null);
            </code> 
            <code language="VB.NET">
            ' Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64UI)
            
            ' Create, initialize, and set a new floating-point number x to 10.4.
            Dim x As New mpf_t()
            gmp_lib.mpf_init_set_d(x, 10.4)
            
            ' Create and initialize a new floating-point number z.
            Dim z As New mpf_t()
            gmp_lib.mpf_init(z)
            
            ' Set z = trunc(x).
            gmp_lib.mpf_trunc(z, x)
            
            ' Assert that the value of z is 10.
            Assert.IsTrue(gmp_lib.mpf_get_d(z) = 10.0)
            
            ' Release unmanaged memory allocated for x and z.
            gmp_lib.mpf_clears(x, z, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_ui_div(Math.Gmp.Native.mpf_t,System.UInt32,Math.Gmp.Native.mpf_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> / <paramref name="op2"/>. 
            </summary>
            <param name="rop">The result float.</param>
            <param name="op1">The first operand.</param>
            <param name="op2">The second operand.</param>
            <remarks>
            <para>
            Division is undefined if the divisor is zero, and passing a zero divisor to the divide
            functions will make it intentionally divide by zero.
            This lets the user handle arithmetic exceptions in division functions in the same manner
            as other arithmetic exceptions. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_add(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_sub(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_mul(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_div(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_div</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_div_ui(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,System.UInt32)">mpf_div_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_sqrt(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_sqrt</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_pow_ui(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,System.UInt32)">mpf_pow_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_neg(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_abs(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_abs</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_div_2exp(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,System.UInt32)">mpf_div_2exp</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Float_Arithmetic">Float Arithmetic</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Float-Arithmetic.html#Float-Arithmetic">GNU MP - Float Arithmetic</a></seealso>
            <example>
            <code language="C#">
            // Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64U);
            
            // Create, initialize, and set a new floating-point number x to 10.
            mpf_t x = new mpf_t();
            gmp_lib.mpf_init_set_si(x, 10);
            
            // Create and initialize a new floating-point number z.
            mpf_t z = new mpf_t();
            gmp_lib.mpf_init(z);
            
            // Set z = 210 / x.
            gmp_lib.mpf_ui_div(z, 210U, x);
            
            // Assert that the value of z is 21.
            Assert.IsTrue(gmp_lib.mpf_get_d(z) == 21.0);
            
            // Release unmanaged memory allocated for x and z.
            gmp_lib.mpf_clears(x, z, null);
            </code> 
            <code language="VB.NET">
            ' Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64UI)
            
            ' Create, initialize, and set a new floating-point number x to 10.
            Dim x As New mpf_t()
            gmp_lib.mpf_init_set_si(x, 10)
            
            ' Create and initialize a new floating-point number z.
            Dim z As New mpf_t()
            gmp_lib.mpf_init(z)
            
            ' Set z = 210 / x.
            gmp_lib.mpf_ui_div(z, 210UI, x)
            
            ' Assert that the value of z is 21.
            Assert.IsTrue(gmp_lib.mpf_get_d(z) = 21.0)
            
            ' Release unmanaged memory allocated for x and z.
            gmp_lib.mpf_clears(x, z, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_ui_sub(Math.Gmp.Native.mpf_t,System.UInt32,Math.Gmp.Native.mpf_t)">
            <summary>
            Set <paramref name="rop"/> to <paramref name="op1"/> - <paramref name="op2"/>.
            </summary>
            <param name="rop">The result float.</param>
            <param name="op1">The first operand.</param>
            <param name="op2">The second operand.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_add(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_sub(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_sub_ui(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,System.UInt32)">mpf_sub_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_mul(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_div(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_div</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_sqrt(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_sqrt</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_pow_ui(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t,System.UInt32)">mpf_pow_ui</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_neg(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_abs(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_abs</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Float_Arithmetic">Float Arithmetic</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Float-Arithmetic.html#Float-Arithmetic">GNU MP - Float Arithmetic</a></seealso>
            <example>
            <code language="C#">
            // Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64U);
            
            // Create, initialize, and set a new floating-point number y to -210.
            mpf_t y = new mpf_t();
            gmp_lib.mpf_init_set_si(y, -210);
            
            // Create and initialize a new floating-point number z.
            mpf_t z = new mpf_t();
            gmp_lib.mpf_init(z);
            
            // Set z = 10 - y.
            gmp_lib.mpf_ui_sub(z, 10U, y);
            
            // Assert that the value of z is 220.
            Assert.IsTrue(gmp_lib.mpf_get_d(z) == 220.0);
            
            // Release unmanaged memory allocated for y, and z.
            gmp_lib.mpf_clears(y, z, null);
            </code> 
            <code language="VB.NET">
            ' Set default precision to 64 bits.
            gmp_lib.mpf_set_default_prec(64UI)
            
            ' Create, initialize, and set a new floating-point number y to -210.
            Dim y As New mpf_t()
            gmp_lib.mpf_init_set_si(y, -210)
            
            ' Create and initialize a new floating-point number z.
            Dim z As New mpf_t()
            gmp_lib.mpf_init(z)
            
            ' Set z = 10 - y.
            gmp_lib.mpf_ui_sub(z, 10UI, y)
            
            ' Assert that the value of z is 220.
            Assert.IsTrue(gmp_lib.mpf_get_d(z) = 220.0)
            
            ' Release unmanaged memory allocated for y, and z.
            gmp_lib.mpf_clears(y, z, Nothing)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpf_urandomb(Math.Gmp.Native.mpf_t,Math.Gmp.Native.gmp_randstate_t,Math.Gmp.Native.mp_bitcnt_t)">
            <summary>
            Generate a uniformly distributed random float in <paramref name="rop"/>, such that 0 &#8804; rop &lt; 1, with <paramref name="nbits"/> significant bits in the mantissa or less if the precision of <paramref name="rop"/> is smaller.
            </summary>
            <param name="rop">The result float.</param>
            <param name="state">The random number generator state.</param>
            <param name="nbits">Number of significant bits.</param>
            <remarks>
            <para>
            The variable state must be initialized by calling one of the <c>gmp_randinit</c> functions
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Random_State_Initialization">Random State Initialization</a></seealso>
            (<a href="https://gmplib.org/manual/Random-State-Initialization.html#Random-State-Initialization">GNU MP - Random State Initialization</a>) before invoking this function. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_ceil(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_ceil</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_floor(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_floor</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_trunc(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mpf_t)">mpf_trunc</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_integer_p(Math.Gmp.Native.mpf_t)">mpf_integer_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_ulong_p(Math.Gmp.Native.mpf_t)">mpf_fits_ulong_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_slong_p(Math.Gmp.Native.mpf_t)">mpf_fits_slong_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_uint_p(Math.Gmp.Native.mpf_t)">mpf_fits_uint_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_sint_p(Math.Gmp.Native.mpf_t)">mpf_fits_sint_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_ushort_p(Math.Gmp.Native.mpf_t)">mpf_fits_ushort_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_fits_sshort_p(Math.Gmp.Native.mpf_t)">mpf_fits_sshort_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpf_random2(Math.Gmp.Native.mpf_t,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_exp_t)">mpf_random2</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Miscellaneous_Float_Functions">Miscellaneous Float Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Miscellaneous-Float-Functions.html#Miscellaneous-Float-Functions">GNU MP - Miscellaneous Float Functions</a></seealso>
            <example>
            <code language="C#">
            // Create, initialize, and seed a new random number generator.
            gmp_randstate_t state = new gmp_randstate_t();
            gmp_lib.gmp_randinit_mt(state);
            gmp_lib.gmp_randseed_ui(state, 100000U);
            
            // Create, initialize, and set the value of rop to 0.
            mpf_t rop = new mpf_t();
            gmp_lib.mpf_init(rop);
            
            // Generate a random integer in the range [0, 1) with 50 bits precision.
            gmp_lib.mpf_urandomb(rop, state, 50);
            
            // Free all memory occupied by state and rop.
            gmp_lib.gmp_randclear(state);
            gmp_lib.mpf_clear(rop);
            </code> 
            <code language="VB.NET">
            ' Create, initialize, and seed a new random number generator.
            Dim state As New gmp_randstate_t()
            gmp_lib.gmp_randinit_mt(state)
            gmp_lib.gmp_randseed_ui(state, 100000UI)
            
            ' Create, initialize, and set the value of rop to 0.
            Dim rop As New mpf_t()
            gmp_lib.mpf_init(rop)
            
            ' Generate a random integer in the range [0, 1) with 50 bits precision.
            gmp_lib.mpf_urandomb(rop, state, 50)
            
            ' Free all memory occupied by state and rop.
            gmp_lib.gmp_randclear(state)
            gmp_lib.mpf_clear(rop)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_add(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">
            <summary>
            Add {<paramref name="s1p"/>, <paramref name="s1n"/>} and {<paramref name="s2p"/>, <paramref name="s2n"/>}, and write the <paramref name="s1n"/> least significant limbs of the result to <paramref name="rp"/>. 
            </summary>
            <param name="rp">The result integer.</param>
            <param name="s1p">The first operand integer.</param>
            <param name="s1n">The number of limbs in <paramref name="s1p"/>.</param>
            <param name="s2p">The second operand integer.</param>
            <param name="s2n">The number of limbs in <paramref name="s2p"/>.</param>
            <returns>Return carry, either 0 or 1.</returns>
            <remarks>
            <para>
            This function requires that <paramref name="s1n"/> is greater than or equal to <paramref name="s2n"/>.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_add_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_add_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_addmul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_addmul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_by3(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_divexact_by3</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_by3c(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divexact_by3c</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divmod_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divmod_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divrem_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divrem_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mod_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_mod_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_mul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_mul_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_neg(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_sub_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sub_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_submul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_submul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sqr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sqr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sqrtrem(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sqrtrem</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_tdiv_qr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_tdiv_qr</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_Functions">Low-level Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operands, and expected result.
            mp_ptr s1p = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
            mp_ptr s2p = new mp_ptr(new uint[] { 0x00000001 });
            mp_ptr rp = new mp_ptr(new uint[2]);
            mp_ptr result = new mp_ptr(new uint[] { 0x00000000, 0x00000000 });
            
            // Set rp = s1 + s2.
            mp_limb_t carry = gmp_lib.mpn_add(rp, s1p, s1p.Size, s2p, s2p.Size);
            
            // Assert result of operation.
            Assert.IsTrue(carry == 1);
            Assert.IsTrue(rp.SequenceEqual(result));
            
            // Release unmanaged memory.
            gmp_lib.free(rp, s1p, s2p, result);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operands, and expected result.
            Dim s1p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
            Dim s2p As New mp_ptr(New UInteger() { &amp;H1})
            Dim rp As New mp_ptr(New UInteger(1) { })
            Dim result As New mp_ptr(New UInteger() { &amp;H0, &amp;H0})
            
            ' Set rp = s1 + s2.
            Dim carry As mp_limb_t = gmp_lib.mpn_add(rp, s1p, s1p.Size, s2p, s2p.Size)
            
            ' Assert result of operation.
            Assert.IsTrue(carry = 1)
            Assert.IsTrue(rp.SequenceEqual(result))
            
            ' Release unmanaged memory.
            gmp_lib.free(rp, s1p, s2p, result)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_add_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">
            <summary>
            Add {<paramref name="s1p"/>, <paramref name="n"/>} and <paramref name="s2limb"/>, and write the <paramref name="n"/> least significant limbs of the result to <paramref name="rp"/>.
            </summary>
            <param name="rp">The result integer.</param>
            <param name="s1p">The first operand integer.</param>
            <param name="n">The number of limbs in <paramref name="s1p"/>.</param>
            <param name="s2limb">The second operand integer.</param>
            <returns>Return carry, either 0 or 1.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_add_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_addmul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_addmul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_by3(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_divexact_by3</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_by3c(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divexact_by3c</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divmod_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divmod_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divrem_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divrem_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mod_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_mod_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_mul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_mul_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_neg(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_sub_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sub_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_submul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_submul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sqr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sqr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sqrtrem(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sqrtrem</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_tdiv_qr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_tdiv_qr</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_Functions">Low-level Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operands, and expected result.
            mp_ptr s1p = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
            mp_ptr rp = new mp_ptr(new uint[2]);
            mp_ptr result = new mp_ptr(new uint[] { 0x00000000, 0x00000000 });
            
            // Set rp = s1 + 1.
            mp_limb_t carry = gmp_lib.mpn_add_1(rp, s1p, s1p.Size, 1);
            
            // Assert result of operation.
            Assert.IsTrue(carry == 1);
            Assert.IsTrue(rp.SequenceEqual(result));
            
            // Release unmanaged memory.
            gmp_lib.free(rp, s1p, result);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operands, and expected result.
            Dim s1p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
            Dim rp As New mp_ptr(New UInteger(1) { })
            Dim result As New mp_ptr(New UInteger() { &amp;H0, &amp;H0})
            
            ' Set rp = s1 + 1.
             Dim carry As mp_limb_t = gmp_lib.mpn_add_1(rp, s1p, s1p.Size, 1)
            
            ' Assert result of operation.
            Assert.IsTrue(carry = 1)
            Assert.IsTrue(rp.SequenceEqual(result))
            
            ' Release unmanaged memory.
            gmp_lib.free(rp, s1p, result)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_add_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">
            <summary>
            Add {<paramref name="s1p"/>, <paramref name="n"/>} and {<paramref name="s2p"/>, <paramref name="n"/>}, and write the <paramref name="n"/> least significant limbs of the result to <paramref name="rp"/>. 
            </summary>
            <param name="rp">The result integer.</param>
            <param name="s1p">The first operand integer.</param>
            <param name="s2p">The second operand integer.</param>
            <param name="n">The number of limbs in <paramref name="s1p"/> and <paramref name="s2p"/>.</param>
            <returns>Return carry, either 0 or 1.</returns>
            <remarks>
            <para>
            This is the lowest-level function for addition.
            It is the preferred function for addition, since it is written in assembly for most CPUs.
            For addition of a variable to itself (i.e., <paramref name="s1p"/> equals <paramref name="s2p"/>)
            use <see cref="M:Math.Gmp.Native.gmp_lib.mpn_lshift(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,System.UInt32)">mpn_lshift</see> with a count of 1 for optimal speed.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_add_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_addmul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_addmul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_by3(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_divexact_by3</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_by3c(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divexact_by3c</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divmod_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divmod_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divrem_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divrem_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mod_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_mod_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_mul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_mul_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_neg(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_sub_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sub_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_submul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_submul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sqr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sqr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sqrtrem(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sqrtrem</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_tdiv_qr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_tdiv_qr</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_Functions">Low-level Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operands, and expected result.
            mp_ptr s1p = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
            mp_ptr s2p = new mp_ptr(new uint[] { 0x00000001, 0x00000000 });
            mp_ptr rp = new mp_ptr(new uint[2]);
            mp_ptr result = new mp_ptr(new uint[] { 0x00000000, 0x00000000 });
            
            // Set rp = s1 + s2.
            mp_limb_t carry = gmp_lib.mpn_add_n(rp, s1p, s2p, rp.Size);
            
            // Assert result of operation.
            Assert.IsTrue(carry == 1);
            Assert.IsTrue(rp.SequenceEqual(result));
            
            // Release unmanaged memory.
            gmp_lib.free(rp, s1p, s2p, result);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operands, and expected result.
            Dim s1p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
            Dim s2p As New mp_ptr(New UInteger() { &amp;H1, &amp;H0})
            Dim rp As New mp_ptr(New UInteger(1) { })
            Dim result As New mp_ptr(New UInteger() { &amp;H0, &amp;H0})
            
            ' Set rp = s1 + s2.
            Dim carry As mp_limb_t = gmp_lib.mpn_add_n(rp, s1p, s2p, rp.Size)
            
            ' Assert result of operation.
            
            Assert.IsTrue(carry = 1)
            Assert.IsTrue(rp.SequenceEqual(result))
            
            ' Release unmanaged memory.
            gmp_lib.free(rp, s1p, s2p, result)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_addmul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">
            <summary>
            Multiply {<paramref name="s1p"/>, <paramref name="n"/>} and <paramref name="s2limb"/>, and add the <paramref name="n"/> least significant limbs of the product to {<paramref name="rp"/>, <paramref name="n"/>} and write the result to <paramref name="rp"/>. 
            </summary>
            <param name="rp">The result integer.</param>
            <param name="s1p">The first operand integer.</param>
            <param name="n">The number of limbs in <paramref name="s1p"/>.</param>
            <param name="s2limb">The second operand integer.</param>
            <returns>Return the most significant limb of the product, plus carry-out from the addition.</returns>
            <remarks>
            <para>
            {<paramref name="s1p"/>, <paramref name="n"/>} and {<paramref name="rp"/>, <paramref name="n"/>} are allowed
            to overlap provided <paramref name="rp"/> &#8804; <paramref name="s1p"/>. 
            </para>
            <para>
            This is a low-level function that is a building block for general multiplication as well as other operations in GMP.
            It is written in assembly for most CPUs. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_add_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_add_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divexact_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_by3(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_divexact_by3</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_by3c(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divexact_by3c</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divmod_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divmod_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divrem_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divrem_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mod_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_mod_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_mul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_mul_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_neg(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_sub_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sub_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_submul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_submul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sqr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sqr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sqrtrem(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sqrtrem</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_tdiv_qr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_tdiv_qr</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_Functions">Low-level Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operands, and expected result.
            mp_ptr s1p = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
            mp_ptr rp = new mp_ptr(new uint[] { 0x00000002, 0x00000000 });
            mp_ptr result = new mp_ptr(new uint[] { 0x00000000, 0x00000000 });
            
            // Set rp += s1 * 2.
            mp_limb_t carry = gmp_lib.mpn_addmul_1(rp, s1p, s1p.Size, 2);
            
            // Assert result of operation.
            Assert.IsTrue(carry == 0x02);
            Assert.IsTrue(rp.SequenceEqual(result));
            
            // Release unmanaged memory.
            gmp_lib.free(rp, s1p, result);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operands, and expected result.
            Dim s1p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
            Dim rp As New mp_ptr(New UInteger() { &amp;H2, &amp;H0})
            Dim result As New mp_ptr(New UInteger() { &amp;H0, &amp;H0})
            
            ' Set rp += s1 * 2.
            Dim carry As mp_limb_t = gmp_lib.mpn_addmul_1(rp, s1p, s1p.Size, 2)
            
            ' Assert result of operation.
            Assert.IsTrue(carry = &amp;H2)
            Assert.IsTrue(rp.SequenceEqual(result))
            
            ' Release unmanaged memory.
            gmp_lib.free(rp, s1p, result)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_cmp(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">
            <summary>
            Compare {<paramref name="s1p"/>, <paramref name="n"/>} and {<paramref name="s2p"/>, <paramref name="n"/>}.
            </summary>
            <param name="s1p">The first operand integer.</param>
            <param name="s2p">The second operand integer.</param>
            <param name="n">The number of limbs in <paramref name="s1p"/> and <paramref name="s2p"/>.</param>
            <returns>Return a positive value if s1 &gt; s2, 0 if they are equal, or a negative value if s1 &lt; s2. </returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_perfect_power_p(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_perfect_power_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_perfect_square_p(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_perfect_square_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_zero_p(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_zero_p</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_Functions">Low-level Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operands, and expected result.
            mp_ptr s1p = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
            mp_ptr s2p = new mp_ptr(new uint[] { 0x00000001, 0x00000000 });
            
            // Assert s1p > s2p.
            Assert.IsTrue(gmp_lib.mpn_cmp(s1p, s2p, s1p.Size) > 0);
            
            // Release unmanaged memory.
            gmp_lib.free(s1p, s2p);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operands, and expected result.
            Dim s1p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
            Dim s2p As New mp_ptr(New UInteger() { &amp;H1, &amp;H0})
            
            ' Assert s1p > s2p.
            Assert.IsTrue(gmp_lib.mpn_cmp(s1p, s2p, s1p.Size) > 0)
            
            ' Release unmanaged memory.
            gmp_lib.free(s1p, s2p)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_zero_p(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">
            <summary>
            Test {<paramref name="sp"/>, <paramref name="n"/>} and return 1 if the operand is zero, 0 otherwise.
            </summary>
            <param name="sp">The operand integer.</param>
            <param name="n">The number of limbs in <paramref name="sp"/>.</param>
            <returns>Return 1 if the operand is zero, 0 otherwise.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_cmp(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_cmp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_perfect_power_p(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_perfect_power_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_perfect_square_p(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_perfect_square_p</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_Functions">Low-level Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operand.
            mp_ptr sp = new mp_ptr(new uint[] { 0x00000000, 0x00000000 });
            
            // Assert sp == 0.
            Assert.IsTrue(gmp_lib.mpn_zero_p(sp, sp.Size) == 1);
            
            // Release unmanaged memory.
            gmp_lib.free(sp);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operand.
            Dim sp As New mp_ptr(New UInteger() { &amp;H0, &amp;H0})
            
            ' Assert sp == 0.
            Assert.IsTrue(gmp_lib.mpn_zero_p(sp, sp.Size) = 1)
            
            ' Release unmanaged memory.
            gmp_lib.free(sp)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_divexact_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">
            <summary>
            Divide {<paramref name="sp"/>, <paramref name="n"/>} by <paramref name="d"/>, expecting it to divide exactly, and writing the result to {r<paramref name="rp"/>, <paramref name="n"/>}.
            </summary>
            <param name="rp">The result integer.</param>
            <param name="sp">The first operand integer.</param>
            <param name="n">The number of limbs in <paramref name="sp"/> and <paramref name="rp"/>.</param>
            <param name="d">The second operand integer.</param>
            <remarks>
            <para>
            If <paramref name="d"/> doesn’t divide exactly, the value written to {<paramref name="rp"/>, <paramref name="n"/>} is undefined.
            The areas at <paramref name="rp"/> and <paramref name="sp"/> have to be identical or completely separate, not partially overlapping.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_add_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_add_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_addmul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_addmul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_by3(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_divexact_by3</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_by3c(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divexact_by3c</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divmod_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divmod_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divrem_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divrem_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mod_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_mod_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_mul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_mul_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_neg(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_sub_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sub_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_submul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_submul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sqr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sqr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sqrtrem(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sqrtrem</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_tdiv_qr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_tdiv_qr</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_Functions">Low-level Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operands, and expected result.
            mp_ptr sp = new mp_ptr(new uint[] { 0xffffffff, 0x0000ffff });
            mp_ptr rp = new mp_ptr(new uint[2]);
            mp_ptr result = new mp_ptr(new uint[] { 0x55555555, 0x00005555 });
            
            // Set rp = sp / 3.
            gmp_lib.mpn_divexact_1(rp, sp, sp.Size, 0x3);
            
            // Assert result of operation.
            Assert.IsTrue(rp.SequenceEqual(result));
            
            // Release unmanaged memory.
            gmp_lib.free(rp, sp, result);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operands, and expected result.
            Dim sp As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;Hffff})
            Dim rp As New mp_ptr(New UInteger(1) { })
            Dim result As New mp_ptr(New UInteger() { &amp;H55555555, &amp;H5555})
            
            ' Set rp = sp / 3.
            gmp_lib.mpn_divexact_1(rp, sp, sp.Size, &amp;H3)
            
            ' Assert result of operation.
            Assert.IsTrue(rp.SequenceEqual(result))
            
            ' Release unmanaged memory.
            gmp_lib.free(rp, sp, result)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_divexact_by3(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">
            <summary>
            Divide {<paramref name="sp"/>, <paramref name="n"/>} by 3, expecting it to divide exactly, and writing the result to {<paramref name="rp"/>, <paramref name="n"/>}. 
            </summary>
            <param name="rp">The result integer.</param>
            <param name="sp">The operand integer.</param>
            <param name="n">The number of limbs in <paramref name="sp"/>.</param>
            <returns>If 3 divides exactly, the return value is zero and the result is the quotient. If not, the return value is non-zero and the result won’t be anything useful.</returns>
            <remarks>
            <para>
            <see cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_by3c(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divexact_by3c</see> takes an initial carry parameter, which can be the return value from a previous call,
            so a large calculation can be done piece by piece from low to high.
            <see cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_by3(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_divexact_by3</see> is simply a macro calling <see cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_by3c(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divexact_by3c</see> with a 0 carry parameter.
            </para>
            <para>
            These routines use a multiply-by-inverse and will be faster than <see cref="M:Math.Gmp.Native.gmp_lib.mpn_divrem_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divrem_1</see> on CPUs with
            fast multiplication but slow division. 
            </para>
            <para>
            The source a, result q, size n, initial carry i, and return value c satisfy
            c * b^n + a - i = 3 * q, where b = 2^<see cref="F:Math.Gmp.Native.gmp_lib.mp_bits_per_limb">mp_bits_per_limb</see>.
            The return c is always 0, 1 or 2, and the initial carry i must also be 0,
            1 or 2 (these are both borrows really). When c = 0 clearly q = (a - i) / 3.
            When c != 0, the remainder (a - i) mod 3 is given by 3 - c, because
            b ≡ 1 mod 3 (when <see cref="F:Math.Gmp.Native.gmp_lib.mp_bits_per_limb">mp_bits_per_limb</see> is even, which is always so currently). 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_add_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_add_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_addmul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_addmul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divexact_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_by3c(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divexact_by3c</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divmod_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divmod_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divrem_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divrem_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mod_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_mod_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_mul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_mul_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_neg(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_sub_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sub_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_submul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_submul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sqr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sqr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sqrtrem(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sqrtrem</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_tdiv_qr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_tdiv_qr</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_Functions">Low-level Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operands, and expected result.
            mp_ptr sp = new mp_ptr(new uint[] { 0xffffffff, 0x0000ffff });
            mp_ptr rp = new mp_ptr(new uint[2]);
            mp_ptr result = new mp_ptr(new uint[] { 0x55555555, 0x00005555 });
            
            // Set rp = sp / 3.
            mp_limb_t remainder = gmp_lib.mpn_divexact_by3(rp, sp, sp.Size);
            
            // Assert result of operation.
            Assert.IsTrue(remainder == 0);
            Assert.IsTrue(rp.SequenceEqual(result));
            
            // Release unmanaged memory.
            gmp_lib.free(rp, sp, result);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operands, and expected result.
            Dim sp As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;Hffff})
            Dim rp As New mp_ptr(New UInteger(1) { })
            Dim result As New mp_ptr(New UInteger() { &amp;H55555555, &amp;H5555})
            
            ' Set rp = sp / 3.
            Dim remainder As mp_limb_t = gmp_lib.mpn_divexact_by3(rp, sp, sp.Size)
            
            ' Assert result of operation.
            
            Assert.IsTrue(remainder = 0)
            Assert.IsTrue(rp.SequenceEqual(result))
            
            ' Release unmanaged memory.
            gmp_lib.free(rp, sp, result)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_divexact_by3c(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">
            <summary>
            Divide {<paramref name="sp"/>, <paramref name="n"/>} by 3, expecting it to divide exactly, and writing the result to {<paramref name="rp"/>, <paramref name="n"/>}. 
            </summary>
            <param name="rp">The result integer.</param>
            <param name="sp">The operand integer.</param>
            <param name="n">The number of limbs in <paramref name="sp"/>.</param>
            <param name="carry">The initial carry.</param>
            <returns>If 3 divides exactly, the return value is zero and the result is the quotient. If not, the return value is non-zero and the result won’t be anything useful.</returns>
            <remarks>
            <para>
            <see cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_by3c(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divexact_by3c</see> takes an initial carry parameter, which can be the return value from a previous call,
            so a large calculation can be done piece by piece from low to high.
            <see cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_by3(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_divexact_by3</see> is simply a macro calling <see cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_by3c(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divexact_by3c</see> with a 0 carry parameter.
            </para>
            <para>
            These routines use a multiply-by-inverse and will be faster than <see cref="M:Math.Gmp.Native.gmp_lib.mpn_divrem_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divrem_1</see> on CPUs with
            fast multiplication but slow division. 
            </para>
            <para>
            The source a, result q, size n, initial carry i, and return value c satisfy
            c * b^n + a - i = 3 * q, where b = 2^<see cref="F:Math.Gmp.Native.gmp_lib.mp_bits_per_limb">mp_bits_per_limb</see>.
            The return c is always 0, 1 or 2, and the initial carry i must also be 0,
            1 or 2 (these are both borrows really). When c = 0 clearly q = (a - i) / 3.
            When c != 0, the remainder (a - i) mod 3 is given by 3 - c, because
            b ≡ 1 mod 3 (when <see cref="F:Math.Gmp.Native.gmp_lib.mp_bits_per_limb">mp_bits_per_limb</see> is even, which is always so currently). 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_add_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_add_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_addmul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_addmul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divexact_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_by3(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_divexact_by3</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divmod_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divmod_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divrem_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divrem_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mod_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_mod_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_mul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_mul_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_neg(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_sub_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sub_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_submul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_submul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sqr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sqr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sqrtrem(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sqrtrem</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_tdiv_qr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_tdiv_qr</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_Functions">Low-level Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operands, and expected result.
            mp_ptr sp = new mp_ptr(new uint[] { 0xffffffff, 0x0000ffff });
            mp_ptr rp = new mp_ptr(new uint[2]);
            mp_ptr result = new mp_ptr(new uint[] { 0xaaaaaaaa, 0x5555aaaa });
            
            // Set rp = sp / 3.
            mp_limb_t remainder = gmp_lib.mpn_divexact_by3c(rp, sp, sp.Size, 1);
            
            // Assert result of operation.
            Assert.IsTrue(remainder == 1);
            Assert.IsTrue(rp.SequenceEqual(result));
            
            // Release unmanaged memory.
            gmp_lib.free(rp, sp, result);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operands, and expected result.
            Dim sp As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;Hffff})
            Dim rp As New mp_ptr(New UInteger(1) { })
            Dim result As New mp_ptr(New UInteger() { &amp;HaaaaaaaaUI, &amp;H5555aaaa})
            
            ' Set rp = sp / 3.
            Dim remainder As mp_limb_t = gmp_lib.mpn_divexact_by3c(rp, sp, sp.Size, 1)
            
            ' Assert result of operation.
            Assert.IsTrue(remainder = 1)
            Assert.IsTrue(rp.SequenceEqual(result))
            
            ' Release unmanaged memory.
            gmp_lib.free(rp, sp, result)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_divrem_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">
            <summary>
            Divide {<paramref name="s2p"/>, <paramref name="s2n"/>} by <paramref name="s3limb"/>, and write the quotient at <paramref name="r1p"/>.
            </summary>
            <param name="r1p"></param>
            <param name="qxn"></param>
            <param name="s2p"></param>
            <param name="s2n"></param>
            <param name="s3limb"></param>
            <returns>Return the remainder.</returns>
            <remarks>
            <para>
            The integer quotient is written to {<paramref name="r1p"/> + <paramref name="qxn"/>, <paramref name="s2n"/>}
            and in addition <paramref name="qxn"/> fraction limbs are developed and written to {<paramref name="r1p"/>, <paramref name="qxn"/>}.
            Either or both <paramref name="s2n"/> and <paramref name="qxn"/> can be zero.
            For most usages, <paramref name="qxn"/> will be zero. 
            </para>
            <para>
            <see cref="M:Math.Gmp.Native.gmp_lib.mpn_divmod_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divmod_1</see> exists for upward source compatibility and is simply a macro
            calling <see cref="M:Math.Gmp.Native.gmp_lib.mpn_divrem_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divrem_1</see> with a <paramref name="qxn"/> of 0. 
            </para>
            <para>
            The areas at <paramref name="r1p"/> and <paramref name="s2p"/> have to be identical or
            completely separate, not partially overlapping. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_add_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_add_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_addmul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_addmul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divexact_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_by3(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_divexact_by3</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_by3c(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divexact_by3c</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divmod_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divmod_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mod_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_mod_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_mul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_mul_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_neg(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_sub_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sub_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_submul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_submul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sqr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sqr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sqrtrem(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sqrtrem</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_tdiv_qr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_tdiv_qr</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_Functions">Low-level Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operands, and expected result.
            mp_ptr s2p = new mp_ptr(new uint[] { 0xffffffff, 0x0000ffff });
            mp_ptr r1p = new mp_ptr(new uint[2]);
            mp_ptr result = new mp_ptr(new uint[] { 0x435e50d7, 0x00000d79 });
            
            // Set r1p = s2p / 19.
            mp_limb_t remainder = gmp_lib.mpn_divrem_1(r1p, 0, s2p, s2p.Size, 0x13);
            
            // Assert result of operation.
            Assert.IsTrue(remainder == 10);
            Assert.IsTrue(r1p.SequenceEqual(result));
            
            // Release unmanaged memory.
            gmp_lib.free(r1p, s2p, result);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operands, and expected result.
            Dim s2p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;Hffff})
            Dim r1p As New mp_ptr(New UInteger(1) { })
            Dim result As New mp_ptr(New UInteger() { &amp;H435e50d7, &amp;Hd79})
            
            ' Set r1p = s2p / 19.
            Dim remainder As mp_limb_t = gmp_lib.mpn_divrem_1(r1p, 0, s2p, s2p.Size, &amp;H13)
            
            ' Assert result of operation.
            Assert.IsTrue(remainder = 10)
            Assert.IsTrue(r1p.SequenceEqual(result))
            
            ' Release unmanaged memory.
            gmp_lib.free(r1p, s2p, result)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_divmod_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">
            <summary>
            Divide {<paramref name="s2p"/>, <paramref name="s2n"/>} by <paramref name="s3limb"/>, and write the quotient at <paramref name="r1p"/>.
            </summary>
            <param name="r1p"></param>
            <param name="s2p"></param>
            <param name="s2n"></param>
            <param name="s3limb"></param>
            <returns>Return the remainder.</returns>
            <remarks>
            <para>
            The integer quotient is written to {<paramref name="r1p"/>, <paramref name="s2n"/>}.
            <paramref name="s2n"/> can be zero.
            </para>
            <para>
            <see cref="M:Math.Gmp.Native.gmp_lib.mpn_divmod_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divmod_1</see> exists for upward source compatibility and is simply a macro
            calling <see cref="M:Math.Gmp.Native.gmp_lib.mpn_divrem_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divrem_1</see> with a qxn of 0. 
            </para>
            <para>
            The areas at <paramref name="r1p"/> and <paramref name="s2p"/> have to be identical or
            completely separate, not partially overlapping. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_add_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_add_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_addmul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_addmul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divexact_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_by3(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_divexact_by3</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_by3c(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divexact_by3c</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divrem_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divrem_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mod_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_mod_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_mul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_mul_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_neg(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_sub_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sub_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_submul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_submul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sqr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sqr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sqrtrem(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sqrtrem</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_tdiv_qr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_tdiv_qr</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_Functions">Low-level Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operands, and expected result.
            mp_ptr s2p = new mp_ptr(new uint[] { 0xffffffff, 0x0000ffff });
            mp_ptr r1p = new mp_ptr(new uint[2]);
            mp_ptr result = new mp_ptr(new uint[] { 0x435e50d7, 0x00000d79 });
            
            // Set r1p = s2p / 19.
            mp_limb_t remainder = gmp_lib.mpn_divmod_1(r1p, s2p, s2p.Size, 0x13);
            
            // Assert result of operation.
            Assert.IsTrue(remainder == 10);
            Assert.IsTrue(r1p.SequenceEqual(result));
            
            // Release unmanaged memory.
            gmp_lib.free(r1p, s2p, result);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operands, and expected result.
            Dim s2p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;Hffff})
            Dim r1p As New mp_ptr(New UInteger(1) { })
            Dim result As New mp_ptr(New UInteger() { &amp;H435e50d7, &amp;Hd79})
            
            ' Set r1p = s2p / 19.
            Dim remainder As mp_limb_t = gmp_lib.mpn_divmod_1(r1p, s2p, s2p.Size, &amp;H13)
            
            ' Assert result of operation.
            Assert.IsTrue(remainder = 10)
            Assert.IsTrue(r1p.SequenceEqual(result))
            
            ' Release unmanaged memory.
            gmp_lib.free(r1p, s2p, result)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_gcd(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">
            <summary>
            Set {<paramref name="rp"/>, retval} to the greatest common divisor of {<paramref name="xp"/>, <paramref name="xn"/>} and {<paramref name="yp"/>, <paramref name="yn"/>}.
            </summary>
            <param name="rp">The result integer.</param>
            <param name="xp">The first operand integer.</param>
            <param name="xn">The number of limbs of <paramref name="xp"/>.</param>
            <param name="yp">The second operand integer.</param>
            <param name="yn">The number of limbs of <paramref name="yp"/>.</param>
            <returns>The result can be up to <paramref name="yn"/> limbs, the return value is the actual number produced; i.e. the number of limbs of <paramref name="rp"/>.</returns>
            <remarks>
            <para>
            Both source operands are destroyed. 
            </para>
            <para>
            It is required that <paramref name="xn"/> &#8805; <paramref name="yn"/> &gt; 0, and the most significant limb
            of {<paramref name="yp"/>, <paramref name="yn"/>} must be non-zero.
            No overlap is permitted between {<paramref name="xp"/>, <paramref name="xn"/>} and {<paramref name="yp"/>, <paramref name="yn"/>}. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_gcd_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_gcd_1</seealso>
            <seealso cref="O:Math.Gmp.Native.gmp_lib.mpn_gcdext">O:Math.Gmp.Native.gmp_lib.mpn_gcdext</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_Functions">Low-level Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operands, and expected result.
            mp_ptr xp = new mp_ptr(new uint[] { 0x964619c7, 0x00000002 });
            mp_ptr yp = new mp_ptr(new uint[] { 0xc2d24d55, 0x00000007 });
            mp_ptr rp = new mp_ptr(yp.Size);
            mp_ptr result = new mp_ptr(new uint[] { 0x964619c7, 0x00000002 });
            
            // Set rp = gcd(xp, yp).
            mp_size_t size = gmp_lib.mpn_gcd(rp, xp, xp.Size, yp, yp.Size);
            
            // Assert result of operation.
            Assert.IsTrue(size == result.Size);
            Assert.IsTrue(rp.SequenceEqual(result));
            
            // Release unmanaged memory.
            gmp_lib.free(rp, xp, yp, result);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operands, and expected result.
            Dim xp As New mp_ptr(New UInteger() { &amp;H964619c7UI, &amp;H2})
            Dim yp As New mp_ptr(New UInteger() { &amp;Hc2d24d55UI, &amp;H7})
            Dim rp As New mp_ptr(yp.Size)
            Dim result As New mp_ptr(New UInteger() { &amp;H964619c7UI, &amp;H2})
            
            ' Set rp = gcd(xp, yp).
            Dim size As mp_size_t = gmp_lib.mpn_gcd(rp, xp, xp.Size, yp, yp.Size)
            
            ' Assert result of operation.
            Assert.IsTrue(size = result.Size)
            Assert.IsTrue(rp.SequenceEqual(result))
            
            ' Release unmanaged memory.
            gmp_lib.free(rp, xp, yp, result)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_gcd_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">
            <summary>
            Return the greatest common divisor of {<paramref name="xp"/>, <paramref name="xn"/>} and <paramref name="ylimb"/>.
            </summary>
            <param name="xp">The first operand integer.</param>
            <param name="xn">The number of limbs of <paramref name="xp"/>.</param>
            <param name="ylimb">The second operand integer.</param>
            <returns>The greatest common divisor of {<paramref name="xp"/>, <paramref name="xn"/>} and <paramref name="ylimb"/>.</returns>
            <remarks>
            <para>
            Both operands must be non-zero. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_gcd(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_gcd</seealso>
            <seealso cref="O:Math.Gmp.Native.gmp_lib.mpn_gcdext">O:Math.Gmp.Native.gmp_lib.mpn_gcdext</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_Functions">Low-level Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operand.
            mp_ptr xp = new mp_ptr(new uint[] { 0x00000000, 0x00000001 });
            
            // Assert result of operation.
            Assert.IsTrue(gmp_lib.mpn_gcd_1(xp, xp.Size, 1073741824) == 1073741824);
            
            // Release unmanaged memory.
            gmp_lib.free(xp);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operand.
            Dim xp As New mp_ptr(New UInteger() { &amp;H0, &amp;H1})
            
            ' Assert result of operation.
            Assert.IsTrue(gmp_lib.mpn_gcd_1(xp, xp.Size, 1073741824) = 1073741824)
            
            ' Release unmanaged memory.
            gmp_lib.free(xp)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_gcdext(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t@,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">
            <summary>
            Compute the greatest common divisor G of U and V. Compute a cofactor S such that G = US + VT.
            </summary>
            <param name="gp">The fisrt result operand.</param>
            <param name="sp">The second result operand.</param>
            <param name="sn">Pointer to the number of limbs of <paramref name="sp"/>.</param>
            <param name="up">The first operand integer.</param>
            <param name="un">The number of limbs of <paramref name="up"/>.</param>
            <param name="vp">The second operand integer.</param>
            <param name="vn">The number of limbs of <paramref name="vp"/>.</param>
            <returns>The number of limbs of <paramref name="gp"/>.</returns>
            <remarks>
            <para>
            Let U be defined by {<paramref name="up"/>, <paramref name="un"/>}
            and let V be defined by {<paramref name="vp"/>, <paramref name="vn"/>}.
            </para>
            <para>
            The second cofactor T is not computed but can easily be obtained from (G - U * S) / V (the division will be exact).
            It is required that <paramref name="un"/> &#8805; <paramref name="vn"/> &gt; 0, 
            and the most significant limb of {<paramref name="vp"/>, <paramref name="vn"/>} must be non-zero. 
            </para>
            <para>
            Store G at <paramref name="gp"/> and let the return value define its limb count.
            Store S at <paramref name="sp"/> and let | <paramref name="sn"/>.Value | define its limb count.
            S can be negative; when this happens <paramref name="sn"/>.Value will be negative.
            The area at <paramref name="gp"/> should have room for <paramref name="vn"/> limbs
            and the area at <paramref name="sp"/> should have room for <paramref name="vn"/> + 1 limbs. 
            </para>
            <para>
            Both source operands are destroyed. 
            </para>
            <para>
            Compatibility notes: GMP 4.3.0 and 4.3.1 defined S less strictly.
            Earlier as well as later GMP releases define S as described here.
            GMP releases before GMP 4.3.0 required additional space for both input and output areas.
            More precisely, the areas {<paramref name="up"/>, <paramref name="un"/> + 1} and
            {<paramref name="vp"/>, <paramref name="vn"/> + 1} were destroyed (i.e. the operands
            plus an extra limb past the end of each), and the areas pointed to by <paramref name="gp"/>
            and <paramref name="sp"/> should each have room for <paramref name="un"/> + 1 limbs.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_gcd(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_gcd</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_gcd_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_gcd_1</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_Functions">Low-level Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operands, and expected result.
            mp_ptr up = new mp_ptr(new uint[] { 0x40000000, 0x00000000 });
            mp_ptr vp = new mp_ptr(new uint[] { 0x00000000, 0x00000001 });
            mp_ptr gp = new mp_ptr(new uint[vp.Size * (IntPtr.Size / 4)]);
            mp_ptr sp = new mp_ptr(new uint[(vp.Size + 1) * (IntPtr.Size / 4)]);
            mp_ptr result = new mp_ptr(new uint[] { 0x40000000, 0x00000000 });
            mp_ptr cofactor = new mp_ptr(new uint[] { 0x00000001, 0x00000000, 0x00000000 });
            
            // Set gp = gcd(up, vp).
            mp_size_t sn = 0;
            mp_size_t size = gmp_lib.mpn_gcdext(gp, sp, ref sn, up, up.Size, vp, vp.Size);
            
            // Assert result.
            Assert.IsTrue(size == 1);
            Assert.IsTrue(gp.SequenceEqual(result));
            Assert.IsTrue(sn == 1);
            Assert.IsTrue(sp.SequenceEqual(cofactor));
            
            // Release unmanaged memory.
            gmp_lib.free(gp, up, vp, sp, result, cofactor);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operands, and expected result.
            Dim up As New mp_ptr(New UInteger() { &amp;H40000000, &amp;H0})
            Dim vp As New mp_ptr(New UInteger() { &amp;H0, &amp;H1})
            Dim gp As New mp_ptr(New UInteger(vp.Size* (IntPtr.Size / 4) - 1) {})
            Dim sp As New mp_ptr(New UInteger((vp.Size + 1) * (IntPtr.Size / 4) - 1) {})
            Dim result As New mp_ptr(New UInteger() { &amp;H40000000, &amp;H0})
            Dim cofactor As New mp_ptr(New UInteger() { &amp;H1, &amp;H0, &amp;H0})
            
            ' Set gp = gcd(up, vp).
            Dim sn As mp_size_t = 0
            Dim size As mp_size_t = gmp_lib.mpn_gcdext(gp, sp, sn, up, up.Size, vp, vp.Size)
            
            ' Assert result.
            Assert.IsTrue(size = 1)
            Assert.IsTrue(gp.SequenceEqual(result))
            Assert.IsTrue(sn = 1)
            Assert.IsTrue(sp.SequenceEqual(cofactor))
            
            ' Release unmanaged memory.
            gmp_lib.free(gp, up, vp, sp, result, cofactor)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_gcdext(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.ptr{Math.Gmp.Native.mp_size_t},Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">
            <summary>
            Compute the greatest common divisor G of U and V. Compute a cofactor S such that G = US + VT.
            </summary>
            <param name="gp">The fisrt result operand.</param>
            <param name="sp">The second result operand.</param>
            <param name="sn">Pointer to the number of limbs of <paramref name="sp"/>.</param>
            <param name="up">The first operand integer.</param>
            <param name="un">The number of limbs of <paramref name="up"/>.</param>
            <param name="vp">The second operand integer.</param>
            <param name="vn">The number of limbs of <paramref name="vp"/>.</param>
            <returns>The number of limbs of <paramref name="gp"/>.</returns>
            <remarks>
            <para>
            Let U be defined by {<paramref name="up"/>, <paramref name="un"/>}
            and let V be defined by {<paramref name="vp"/>, <paramref name="vn"/>}.
            </para>
            <para>
            The second cofactor T is not computed but can easily be obtained from (G - U * S) / V (the division will be exact).
            It is required that <paramref name="un"/> &#8805; <paramref name="vn"/> &gt; 0, 
            and the most significant limb of {<paramref name="vp"/>, <paramref name="vn"/>} must be non-zero. 
            </para>
            <para>
            Store G at <paramref name="gp"/> and let the return value define its limb count.
            Store S at <paramref name="sp"/> and let | <paramref name="sn"/>.Value | define its limb count.
            S can be negative; when this happens <paramref name="sn"/>.Value will be negative.
            The area at <paramref name="gp"/> should have room for <paramref name="vn"/> limbs
            and the area at <paramref name="sp"/> should have room for <paramref name="vn"/> + 1 limbs. 
            </para>
            <para>
            Both source operands are destroyed. 
            </para>
            <para>
            Compatibility notes: GMP 4.3.0 and 4.3.1 defined S less strictly.
            Earlier as well as later GMP releases define S as described here.
            GMP releases before GMP 4.3.0 required additional space for both input and output areas.
            More precisely, the areas {<paramref name="up"/>, <paramref name="un"/> + 1} and
            {<paramref name="vp"/>, <paramref name="vn"/> + 1} were destroyed (i.e. the operands
            plus an extra limb past the end of each), and the areas pointed to by <paramref name="gp"/>
            and <paramref name="sp"/> should each have room for <paramref name="un"/> + 1 limbs.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_gcd(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_gcd</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_gcd_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_gcd_1</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_Functions">Low-level Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operands, and expected result.
            mp_ptr up = new mp_ptr(new uint[] { 0x40000000, 0x00000000 });
            mp_ptr vp = new mp_ptr(new uint[] { 0x00000000, 0x00000001 });
            mp_ptr gp = new mp_ptr(new uint[vp.Size * (IntPtr.Size / 4)]);
            mp_ptr sp = new mp_ptr(new uint[(vp.Size + 1) * (IntPtr.Size / 4)]);
            mp_ptr result = new mp_ptr(new uint[] { 0x40000000, 0x00000000 });
            mp_ptr cofactor = new mp_ptr(new uint[] { 0x00000001, 0x00000000, 0x00000000 });
            
            // Set gp = gcd(up, vp).
            ptr&lt;mp_size_t&gt; sn = new ptr&lt;mp_size_t&gt;(0);
            mp_size_t size = gmp_lib.mpn_gcdext(gp, sp, sn, up, up.Size, vp, vp.Size);
            
            // Assert result.
            Assert.IsTrue(size == 1);
            Assert.IsTrue(gp.SequenceEqual(result));
            Assert.IsTrue(sn.Value == 1);
            Assert.IsTrue(sp.SequenceEqual(cofactor));
            
            // Release unmanaged memory.
            gmp_lib.free(gp, up, vp, sp, result, cofactor);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operands, and expected result.
            Dim up As New mp_ptr(New UInteger() { &amp;H40000000, &amp;H0})
            Dim vp As New mp_ptr(New UInteger() { &amp;H0, &amp;H1})
            Dim gp As New mp_ptr(New UInteger(vp.Size* (IntPtr.Size / 4) - 1) {})
            Dim sp As New mp_ptr(New UInteger((vp.Size + 1) * (IntPtr.Size / 4) - 1) {})
            Dim result As New mp_ptr(New UInteger() { &amp;H40000000, &amp;H0})
            Dim cofactor As New mp_ptr(New UInteger() { &amp;H1, &amp;H0, &amp;H0})
            
            ' Set gp = gcd(up, vp).
            Dim sn As New ptr(Of mp_size_t)(0)
            Dim size As mp_size_t = gmp_lib.mpn_gcdext(gp, sp, sn, up, up.Size, vp, vp.Size)
            
            ' Assert result.
            Assert.IsTrue(size = 1)
            Assert.IsTrue(gp.SequenceEqual(result))
            Assert.IsTrue(sn.Value = 1)
            Assert.IsTrue(sp.SequenceEqual(cofactor))
            
            ' Release unmanaged memory.
            gmp_lib.free(gp, up, vp, sp, result, cofactor)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_get_str(Math.Gmp.Native.char_ptr,System.Int32,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">
            <summary>
            Convert {<paramref name="s1p"/>, <paramref name="s1n"/>} to a raw unsigned char array at <paramref name="str"/> in base <paramref name="base"/>, and return the number of characters produced.
            </summary>
            <param name="str">The result string.</param>
            <param name="base">The base.</param>
            <param name="s1p">The operand integer.</param>
            <param name="s1n">The number of limbs of <paramref name="s1p"/>.</param>
            <returns>The number of characters produced at <paramref name="str"/>.</returns>
            <remarks>
            <para>
            There may be leading zeros in the string.
            The string is not in ASCII; to convert it to printable format, add the ASCII codes for "0" or "A",
            depending on the base and range. <paramref name="base"/> can vary from 2 to 256. 
            </para>
            <para>
            The most significant limb of the input {<paramref name="s1p"/>, <paramref name="s1n"/>} must be non-zero.
            The input {<paramref name="s1p"/>, <paramref name="s1n"/>} is clobbered, except when base is a power of 2,
            in which case it’s unchanged. 
            </para>
            <para>
            The area at <paramref name="str"/> has to have space for the largest possible number
            represented by a <paramref name="s1n"/> long limb array, plus one extra character. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_set_str(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.char_ptr,Math.Gmp.Native.size_t,System.Int32)">mpn_set_str</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sizeinbase(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,System.Int32)">mpn_sizeinbase</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_Functions">Low-level Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operands.
            mp_ptr s1p = new mp_ptr(new uint[] { 0x00000001, 0x00000001 });
            char_ptr str = new char_ptr("xxxxxxxxxxxxxxxxx");
            
            // Convert s1p to hex string.
            size_t count = gmp_lib.mpn_get_str(str, 16, s1p, s1p.Size);
            
            // Copy out str to bytes.
            byte[] s = new byte[count];
            Marshal.Copy(str.ToIntPtr(), s, 0, (int)count);
            
            // Assert the non-ASCII, hex representation of s1p.
            Assert.IsTrue(s.SequenceEqual(new byte[] { 1, 0, 0, 0, 0, 0, 0, 0, 1 }));
            
            // Release unmanaged memory.
            gmp_lib.free(s1p);
            gmp_lib.free(str);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operands.
            Dim s1p As New mp_ptr(New UInteger() { &amp;H1, &amp;H1})
            Dim str As New char_ptr("xxxxxxxxxxxxxxxxx")
            
            ' Convert s1p to hex string.
            Dim count As size_t = gmp_lib.mpn_get_str(str, 16, s1p, s1p.Size)
            
            ' Copy out str to bytes.
            Dim s As Byte() = New Byte(count - 1) { }
            Marshal.Copy(str.ToIntPtr(), s, 0, CInt(count))
            
            ' Assert the non-ASCII, hex representation of s1p.
            Assert.IsTrue(s.SequenceEqual(New Byte() { 1, 0, 0, 0, 0, 0, 0, 0, 1}))
            
            ' Release unmanaged memory.
            gmp_lib.free(s1p)
            gmp_lib.free(str)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_hamdist(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">
            <summary>
            Compute the hamming distance between {<paramref name="s1p"/>, <paramref name="n"/>} and {<paramref name="s2p"/>, <paramref name="n"/>}, which is the number of bit positions where the two operands have different bit values. 
            </summary>
            <param name="s1p">The first operand integer.</param>
            <param name="s2p">The second operand integer.</param>
            <param name="n">The number of limbs of <paramref name="s1p"/> and <paramref name="s2p"/>.</param>
            <returns>The hamming distance between {<paramref name="s1p"/>, <paramref name="n"/>} and {<paramref name="s2p"/>.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_lshift(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,System.UInt32)">mpn_lshift</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_popcount(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_popcount</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_rshift(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,System.UInt32)">mpn_rshift</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_scan0(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_bitcnt_t)">mpn_scan0</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_scan1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_bitcnt_t)">mpn_scan1</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_Functions">Low-level Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operands.
            mp_ptr s1p = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
            mp_ptr s2p = new mp_ptr(new uint[] { 0x00000001, 0xffffffff });
            
            // Assert hamming distance.
            Assert.IsTrue(gmp_lib.mpn_hamdist(s1p, s2p, s1p.Size) == 31);
            
            // Release unmanaged memory.
            gmp_lib.free(s1p, s2p);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operands.
            Dim s1p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
            Dim s2p As New mp_ptr(New UInteger() { &amp;H1, &amp;HffffffffUI})
            
            ' Assert hamming distance.
            Assert.IsTrue(gmp_lib.mpn_hamdist(s1p, s2p, s1p.Size) = 31)
            
            ' Release unmanaged memory.
            gmp_lib.free(s1p, s2p)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_lshift(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,System.UInt32)">
            <summary>
            Shift {<paramref name="sp"/>, <paramref name="n"/>} left by <paramref name="count"/> bits, and write the result to {<paramref name="rp"/>, <paramref name="n"/>}. 
            </summary>
            <param name="rp">The result integer.</param>
            <param name="sp">The operand integer.</param>
            <param name="n">The number of limbs of <paramref name="sp"/>.</param>
            <param name="count">The number of bits ot shift.</param>
            <returns>The bits shifted out at the left are returned in the least significant count bits of the return value (the rest of the return value is zero).</returns>
            <remarks>
            <para>
            <paramref name="count"/> must be in the range 1 to <see cref="F:Math.Gmp.Native.gmp_lib.mp_bits_per_limb">mp_bits_per_limb</see> - 1.
            The regions {<paramref name="sp"/>, <paramref name="n"/>} and {<paramref name="rp"/>, <paramref name="n"/>} may overlap,
            provided <paramref name="rp"/> &#8805; <paramref name="sp"/>. 
            </para>
            <para>
            This function is written in assembly for most CPUs. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_hamdist(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_hamdist</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_popcount(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_popcount</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_rshift(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,System.UInt32)">mpn_rshift</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_scan0(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_bitcnt_t)">mpn_scan0</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_scan1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_bitcnt_t)">mpn_scan1</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_Functions">Low-level Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operands, and expected result.
            mp_ptr sp = new mp_ptr(new uint[] { 0xfffffffe, 0xffffffff });
            mp_ptr rp = new mp_ptr(new uint[2]);
            mp_ptr result = new mp_ptr(new uint[] { 0xfffffffc, 0xffffffff });
            
            // Set rp = sp &lt;&lt; 1.
            mp_limb_t bits = gmp_lib.mpn_lshift(rp, sp, sp.Size, 1);
            
            // Assert result of operation.
            Assert.IsTrue(bits == 1);
            Assert.IsTrue(rp.SequenceEqual(result));
            
            // Release unmanaged memory.
            gmp_lib.free(rp, sp, result);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operands, and expected result.
            Dim sp As New mp_ptr(New UInteger() { &amp;HfffffffeUI, &amp;HffffffffUI})
            Dim rp As New mp_ptr(New UInteger(1) { })
            Dim result As New mp_ptr(New UInteger() { &amp;HfffffffcUI, &amp;HffffffffUI})
            
            ' Set rp = sp &lt;&lt; 1.
            Dim bits As mp_limb_t = gmp_lib.mpn_lshift(rp, sp, sp.Size, 1)
            
            ' Assert result of operation.
            Assert.IsTrue(bits = 1)
            Assert.IsTrue(rp.SequenceEqual(result))
            
            ' Release unmanaged memory.
            gmp_lib.free(rp, sp, result)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_mod_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">
            <summary>
            Divide {<paramref name="s1p"/>, <paramref name="s1n"/>} by <paramref name="s2limb"/>, and return the remainder. 
            </summary>
            <param name="s1p">The first operand integer.</param>
            <param name="s1n">The number of limbs of <paramref name="s1p"/>.</param>
            <param name="s2limb">The second operand integer.</param>
            <returns>The remainder.</returns>
            <remarks>
            <para>
            <paramref name="s1n"/> can be zero.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_add_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_add_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_addmul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_addmul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divexact_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_by3(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_divexact_by3</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_by3c(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divexact_by3c</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divmod_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divmod_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divrem_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divrem_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_mul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_mul_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_neg(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_sub_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sub_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_submul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_submul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sqr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sqr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sqrtrem(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sqrtrem</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_tdiv_qr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_tdiv_qr</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_Functions">Low-level Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operand.
            mp_ptr s1p = new mp_ptr(new uint[] { 0xfffffffe, 0x0000ffff });
            
            // Assert s1p mod 3 is 2.
            Assert.IsTrue(gmp_lib.mpn_mod_1(s1p, s1p.Size, 3) == 2);
            
            // Release unmanaged memory.
            gmp_lib.free(s1p);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operand.
            Dim s1p As New mp_ptr(New UInteger() { &amp;HfffffffeUI, &amp;Hffff})
            
            ' Assert s1p mod 3 is 2.
            Assert.IsTrue(gmp_lib.mpn_mod_1(s1p, s1p.Size, 3) = 2)
            
            ' Release unmanaged memory.
            gmp_lib.free(s1p)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_mul(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">
            <summary>
            Multiply {<paramref name="s1p"/>, <paramref name="s1n"/>} and {<paramref name="s2p"/>, <paramref name="s2n"/>}, and write the (<paramref name="s1n"/> + <paramref name="s2n"/>)-limb result to <paramref name="rp"/>.
            </summary>
            <param name="rp">The result integer.</param>
            <param name="s1p">The first operand integer.</param>
            <param name="s1n">The number of limbs of <paramref name="s1p"/>.</param>
            <param name="s2p">The first operand integer.</param>
            <param name="s2n">The number of limbs of <paramref name="s2p"/>.</param>
            <returns>Return the most significant limb of the result.</returns>
            <remarks>
            <para>
            The destination has to have space for <paramref name="s1n"/> + <paramref name="s2n"/> limbs,
            even if the product’s most significant limb is zero.
            No overlap is permitted between the destination and either source.
            </para>
            <para>
            This function requires that <paramref name="s1n"/> is greater than or equal to <paramref name="s2n"/>. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_add_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_add_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_addmul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_addmul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divexact_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_by3(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_divexact_by3</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_by3c(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divexact_by3c</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divmod_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divmod_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divrem_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divrem_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mod_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_mod_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_mul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_mul_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_neg(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_sub_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sub_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_submul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_submul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sqr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sqr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sqrtrem(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sqrtrem</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_tdiv_qr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_tdiv_qr</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_Functions">Low-level Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operands, and expected result.
            mp_ptr s1p = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
            mp_ptr s2p = new mp_ptr(new uint[] { 0x00000002 });
            mp_ptr rp = new mp_ptr(new uint[3]);
            mp_ptr result = new mp_ptr(new uint[] { 0xfffffffe, 0xffffffff, 0x00000001 });
            
            // Set rp = s1 * s2.
            gmp_lib.mpn_mul(rp, s1p, s1p.Size, s2p, s2p.Size);
            
            // Assert result of operation.
            Assert.IsTrue(rp.SequenceEqual(result));
            
            // Release unmanaged memory.
            gmp_lib.free(rp, s1p, s2p, result);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operands, and expected result.
            Dim s1p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
            Dim s2p As New mp_ptr(New UInteger() { &amp;H2})
            Dim rp As New mp_ptr(New UInteger(2) { })
            Dim result As New mp_ptr(New UInteger() { &amp;HfffffffeUI, &amp;HffffffffUI, &amp;H1})
            
            ' Set rp = s1 * s2.
            gmp_lib.mpn_mul(rp, s1p, s1p.Size, s2p, s2p.Size)
            
            ' Assert result of operation.
            Assert.IsTrue(rp.SequenceEqual(result))
            
            ' Release unmanaged memory.
            gmp_lib.free(rp, s1p, s2p, result)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_mul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">
            <summary>
            Multiply {<paramref name="s1p"/>, <paramref name="n"/>} by <paramref name="s2limb"/>, and write the <paramref name="n"/> least significant limbs of the product to <paramref name="rp"/>.
            </summary>
            <param name="rp">The result integer.</param>
            <param name="s1p">The first operand integer.</param>
            <param name="n">The number of limbs of <paramref name="s1p"/>.</param>
            <param name="s2limb">The second operand integer.</param>
            <returns>Return the most significant limb of the product.</returns>
            <remarks>
            <para>
            {<paramref name="s1p"/>, <paramref name="n"/>} and {<paramref name="rp"/>, <paramref name="n"/>} 
            are allowed to overlap provided <paramref name="rp"/> &#8804; <paramref name="s1p"/>.
            </para>
            <para>
            This is a low-level function that is a building block for general multiplication as well as 
            other operations in GMP. It is written in assembly for most CPUs.
            </para>
            <para>
            Don’t call this function if <paramref name="s2limb"/> is a power of 2;
            use <see cref="M:Math.Gmp.Native.gmp_lib.mpn_lshift(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,System.UInt32)">mpn_lshift</see> with a count equal to the logarithm of
            <paramref name="s2limb"/> instead, for optimal speed. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_add_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_add_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_addmul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_addmul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divexact_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_by3(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_divexact_by3</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_by3c(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divexact_by3c</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divmod_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divmod_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divrem_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divrem_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mod_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_mod_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_mul_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_neg(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_sub_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sub_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_submul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_submul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sqr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sqr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sqrtrem(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sqrtrem</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_tdiv_qr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_tdiv_qr</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_Functions">Low-level Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operands, and expected result.
            mp_ptr s1p = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
            mp_ptr rp = new mp_ptr(new uint[2]);
            mp_ptr result = new mp_ptr(new uint[] { 0xfffffffe, 0xffffffff });
            
            // Set rp = s1 * 2.
            mp_limb_t carry = gmp_lib.mpn_mul_1(rp, s1p, s1p.Size, 2);
            
            // Assert result of operation.
            Assert.IsTrue(carry == 1);
            Assert.IsTrue(rp.SequenceEqual(result));
            
            // Release unmanaged memory.
            gmp_lib.free(rp, s1p, result);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operands, and expected result.
            Dim s1p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
            Dim rp As New mp_ptr(New UInteger(1) { })
            Dim result As New mp_ptr(New UInteger() { &amp;HfffffffeUI, &amp;HffffffffUI})
            
            ' Set rp = s1 * 2.
            Dim carry As mp_limb_t = gmp_lib.mpn_mul_1(rp, s1p, s1p.Size, 2)
            
            ' Assert result of operation.
            Assert.IsTrue(carry = 1)
            Assert.IsTrue(rp.SequenceEqual(result))
            
            ' Release unmanaged memory.
            gmp_lib.free(rp, s1p, result)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_mul_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">
            <summary>
            Multiply {<paramref name="s1p"/>, <paramref name="n"/>} and {<paramref name="s2p"/>, <paramref name="n"/>}, and write the (2 * <paramref name="n"/>)-limb result to <paramref name="rp"/>.
            </summary>
            <param name="rp">The result integer.</param>
            <param name="s1p">The first operand integer.</param>
            <param name="s2p">The second operand integer.</param>
            <param name="n">The number of limbs of <paramref name="s1p"/> and <paramref name="s2p"/>.</param>
            <remarks>
            <para>
            The destination has to have space for 2 * <paramref name="n"/> limbs, even if the product’s
            most significant limb is zero. No overlap is permitted between the destination and either source. 
            </para>
            <para>
            If the two input operands are the same, use <see cref="M:Math.Gmp.Native.gmp_lib.mpn_sqr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sqr</see>. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_add_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_add_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_addmul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_addmul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divexact_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_by3(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_divexact_by3</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_by3c(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divexact_by3c</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divmod_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divmod_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divrem_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divrem_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mod_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_mod_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_mul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_neg(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_sub_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sub_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_submul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_submul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sqr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sqr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sqrtrem(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sqrtrem</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_tdiv_qr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_tdiv_qr</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_Functions">Low-level Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operands, and expected result.
            mp_ptr s1p = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
            mp_ptr s2p = new mp_ptr(new uint[] { 0x00000002, 0x00000000 });
            mp_ptr rp = new mp_ptr(new uint[4]);
            mp_ptr result = new mp_ptr(new uint[] { 0xfffffffe, 0xffffffff, 0x00000001, 0x00000000 });
            
            // Set rp = s1 * s2.
            gmp_lib.mpn_mul_n(rp, s1p, s2p, s1p.Size);
            
            // Assert result of operation.
            Assert.IsTrue(rp.SequenceEqual(result));
            
            // Release unmanaged memory.
            gmp_lib.free(rp, s1p, s2p, result);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operands, and expected result.
            Dim s1p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
            Dim s2p As New mp_ptr(New UInteger() { &amp;H2, &amp;H0})
            Dim rp As New mp_ptr(New UInteger(3) { })
            Dim result As New mp_ptr(New UInteger() { &amp;HfffffffeUI, &amp;HffffffffUI, &amp;H1, &amp;H0})
            
            ' Set rp = s1 * s2.
            gmp_lib.mpn_mul_n(rp, s1p, s2p, s1p.Size)
            
            ' Assert result of operation.
            Assert.IsTrue(rp.SequenceEqual(result))
            
            ' Release unmanaged memory.
            gmp_lib.free(rp, s1p, s2p, result)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_sqr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">
            <summary>
            Compute the square of {<paramref name="s1p"/>, <paramref name="n"/>} and write the (2 * <paramref name="n"/>)-limb result to <paramref name="rp"/>.
            </summary>
            <param name="rp">The result integer.</param>
            <param name="s1p">The operand integer.</param>
            <param name="n">The number of limbs of <paramref name="s1p"/>.</param>
            <remarks>
            <para>
            The destination has to have space for 2 * <paramref name="n"/> limbs, even if the result’s
            most significant limb is zero. No overlap is permitted between the destination and the source. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_add_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_add_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_addmul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_addmul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divexact_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_by3(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_divexact_by3</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_by3c(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divexact_by3c</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divmod_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divmod_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divrem_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divrem_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mod_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_mod_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_mul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_mul_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_neg(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_sub_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sub_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_submul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_submul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sqrtrem(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sqrtrem</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_tdiv_qr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_tdiv_qr</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_Functions">Low-level Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operands, and expected result.
            mp_ptr s1p = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
            mp_ptr rp = new mp_ptr(new uint[4]);
            mp_ptr result = new mp_ptr(new uint[] { 0x00000001, 0x00000000, 0xfffffffe, 0xffffffff });
            
            // Set rp = s1^2.
            gmp_lib.mpn_sqr(rp, s1p, s1p.Size);
            
            // Assert result of operation.
            Assert.IsTrue(rp.SequenceEqual(result));
            
            // Release unmanaged memory.
            gmp_lib.free(rp, s1p, result);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operands, and expected result.
            Dim s1p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
            Dim rp As New mp_ptr(New UInteger(3) { })
            Dim result As New mp_ptr(New UInteger() { &amp;H1, &amp;H0, &amp;HfffffffeUI, &amp;HffffffffUI})
            
            ' Set rp = s1^2.
            gmp_lib.mpn_sqr(rp, s1p, s1p.Size)
            
            ' Assert result of operation.
            Assert.IsTrue(rp.SequenceEqual(result))
            
            ' Release unmanaged memory.
            gmp_lib.free(rp, s1p, result)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_neg(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">
            <summary>
            Perform the negation of {<paramref name="sp"/>, <paramref name="n"/>}, and write the result to {<paramref name="rp"/>, <paramref name="n"/>}.
            </summary>
            <param name="rp">The result integer.</param>
            <param name="sp">The operand integer.</param>
            <param name="n">The number of limbs of <paramref name="sp"/> and <paramref name="rp"/>.</param>
            <returns>Return borrow, either 0 or 1.</returns>
            <remarks>
            <para>
            This is equivalent to calling <see cref="M:Math.Gmp.Native.gmp_lib.mpn_sub_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sub_n</see> with a <paramref name="n"/>-limb
            zero minuend and passing {<paramref name="sp"/>, <paramref name="n"/>} as subtrahend.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_add_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_add_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_addmul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_addmul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divexact_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_by3(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_divexact_by3</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_by3c(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divexact_by3c</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divmod_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divmod_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divrem_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divrem_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mod_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_mod_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_mul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_mul_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_sub_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sub_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_submul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_submul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sqr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sqr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sqrtrem(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sqrtrem</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_tdiv_qr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_tdiv_qr</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_Functions">Low-level Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operands, and expected result.
            mp_ptr sp = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
            mp_ptr rp = new mp_ptr(new uint[2]);
            mp_ptr result = new mp_ptr(new uint[] { 0x0000001, 0x00000000 });
            
            // Set rp = -sp.
            mp_limb_t borrow = gmp_lib.mpn_neg(rp, sp, sp.Size);
            
            // Assert result of operation.
            Assert.IsTrue(borrow == 1);
            Assert.IsTrue(rp.SequenceEqual(result));
            
            // Release unmanaged memory.
            gmp_lib.free(rp, sp, result);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operands, and expected result.
            Dim sp As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
            Dim rp As New mp_ptr(New UInteger(1) { })
            Dim result As New mp_ptr(New UInteger() { &amp;H1, &amp;H0})
            
            ' Set rp = -sp.
            Dim borrow As mp_limb_t = gmp_lib.mpn_neg(rp, sp, sp.Size)
            
            ' Assert result of operation.
            Assert.IsTrue(borrow = 1)
            Assert.IsTrue(rp.SequenceEqual(result))
            
            ' Release unmanaged memory.
            gmp_lib.free(rp, sp, result)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_com(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">
            <summary>
            Perform the bitwise complement of {<paramref name="sp"/>, <paramref name="n"/>}, and write the result to {<paramref name="rp"/>, <paramref name="n"/>}.
            </summary>
            <param name="rp">The result integer.</param>
            <param name="sp">The operand integer.</param>
            <param name="n">The numbe rof limbs of <paramref name="rp>>"/> and <paramref name="sp"/>.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_and_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_and_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_andn_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_andn_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_com(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_com</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_ior_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_ior_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_iorn_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_iorn_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_nand_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_nand_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_nior_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_nior_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_xor_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_xor_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_xnor_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_xnor_n</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_Functions">Low-level Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operands, and expected result.
            mp_ptr sp = new mp_ptr(new uint[] { 0xf0f0f0f0, 0xf0f0f0f0 });
            mp_ptr rp = new mp_ptr(new uint[2]);
            mp_ptr result = new mp_ptr(new uint[] { 0x0f0f0f0f, 0x0f0f0f0f });
            
            // Set rp = not(sp).
            gmp_lib.mpn_com(rp, sp, sp.Size);
            
            // Assert result of operation.
            Assert.IsTrue(rp.SequenceEqual(result));
            
            // Release unmanaged memory.
            gmp_lib.free(rp, sp, result);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operands, and expected result.
            Dim sp As New mp_ptr(New UInteger() { &amp;Hf0f0f0f0UI, &amp;Hf0f0f0f0UI})
            Dim rp As New mp_ptr(New UInteger(1) { })
            Dim result As New mp_ptr(New UInteger() { &amp;Hf0f0f0f, &amp;Hf0f0f0f})
            
            ' Set rp = not(sp).
            gmp_lib.mpn_com(rp, sp, sp.Size)
            
            ' Assert result of operation.
            Assert.IsTrue(rp.SequenceEqual(result))
            
            ' Release unmanaged memory.
            gmp_lib.free(rp, sp, result)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_perfect_square_p(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">
            <summary>
            Return non-zero iff {<paramref name="s1p"/>, <paramref name="n"/>} is a perfect square.
            </summary>
            <param name="s1p">The operand integer.</param>
            <param name="n">The numbe rof limbs of <paramref name="s1p"/>.</param>
            <returns>Non-zero iff {<paramref name="s1p"/>, <paramref name="n"/>} is a perfect square.</returns>
            <remarks>
            <para>
            The most significant limb of the input {<paramref name="s1p"/>, <paramref name="n"/>} must be non-zero.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_cmp(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_cmp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_perfect_power_p(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_perfect_power_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_zero_p(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_zero_p</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_Functions">Low-level Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operand.
            mp_ptr s1p = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
            
            // Assert s1p is not a perfect square.
            Assert.IsTrue(gmp_lib.mpn_perfect_square_p(s1p, s1p.Size) == 0);
            
            // Release unmanaged memory.
            gmp_lib.free(s1p);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operand.
            Dim s1p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
            
            ' Assert s1p is not a perfect square.
            Assert.IsTrue(gmp_lib.mpn_perfect_square_p(s1p, s1p.Size) = 0)
            
            ' Release unmanaged memory.
            gmp_lib.free(s1p)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_perfect_power_p(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">
            <summary>
            Return non-zero iff {<paramref name="sp"/>, <paramref name="n"/>} is a perfect power.
            </summary>
            <param name="sp">The operand integer.</param>
            <param name="n">The numbe rof limbs of <paramref name="sp"/>.</param>
            <returns>Non-zero iff {<paramref name="sp"/>, <paramref name="n"/>} is a perfect power.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_cmp(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_cmp</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_perfect_square_p(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_perfect_square_p</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_zero_p(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_zero_p</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_Functions">Low-level Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operand.
            mp_ptr s1p = new mp_ptr(new uint[] { 0xd4a51000, 0x000000e8 });
            
            // Assert s1p is a perfect power.
            Assert.IsTrue(gmp_lib.mpn_perfect_power_p(s1p, s1p.Size) != 0);
            
            // Release unmanaged memory.
            gmp_lib.free(s1p);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operand.
            Dim s1p As New mp_ptr(New UInteger() { &amp;Hd4a51000UI, &amp;He8})
            
            ' Assert s1p is a perfect power.
            Assert.IsTrue(gmp_lib.mpn_perfect_power_p(s1p, s1p.Size) &lt;&gt; 0)
            
            ' Release unmanaged memory.
            gmp_lib.free(s1p)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_popcount(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">
            <summary>
            Count the number of set bits in {<paramref name="s1p"/>, <paramref name="n"/>}. 
            </summary>
            <param name="s1p">The operand integer.</param>
            <param name="n">The number of limbs of <paramref name="s1p"/>.</param>
            <returns>The number of set bits in {<paramref name="s1p"/>, <paramref name="n"/>}.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_hamdist(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_hamdist</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_lshift(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,System.UInt32)">mpn_lshift</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_rshift(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,System.UInt32)">mpn_rshift</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_scan0(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_bitcnt_t)">mpn_scan0</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_scan1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_bitcnt_t)">mpn_scan1</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_Functions">Low-level Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operand.
            mp_ptr s1p = new mp_ptr(new uint[] { 0x0000001, 0x00000001 });
            
            // Assert result of operation.
            Assert.IsTrue(gmp_lib.mpn_popcount(s1p, s1p.Size) == 2);
            
            // Release unmanaged memory.
            gmp_lib.free(s1p);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operand.
            Dim s1p As New mp_ptr(New UInteger() { &amp;H1, &amp;H1})
            
            ' Assert result of operation.
            Assert.IsTrue(gmp_lib.mpn_popcount(s1p, s1p.Size) = 2)
            
            ' Release unmanaged memory.
            gmp_lib.free(s1p)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_random(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">
            <summary>
            Generate a random number of length <paramref name="r1n"/> and store it at <paramref name="r1p"/>.
            </summary>
            <param name="r1p">The result integer.</param>
            <param name="r1n">The number of limbs of <paramref name="r1p"/>.</param>
            <remarks>
            <para>
            The most significant limb is always non-zero.
            <see cref="M:Math.Gmp.Native.gmp_lib.mpn_random(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_random</see> generates uniformly distributed limb data,
            <see cref="M:Math.Gmp.Native.gmp_lib.mpn_random2(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_random2</see> generates long strings of zeros and ones in the binary representation. 
            </para>
            <para>
            <see cref="M:Math.Gmp.Native.gmp_lib.mpn_random2(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_random2</see> is intended for testing the correctness of the <c>mpn</c> routines. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_random2(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_random2</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_Functions">Low-level Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operand.
            mp_ptr r1p = new mp_ptr(new uint[2]);
            
            // Generate random number.
            gmp_lib.mpn_random(r1p, gmp_lib.mp_bytes_per_limb == 4 ? 2 : 1);
            
            // Release unmanaged memory.
            gmp_lib.free(r1p);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operand.
            Dim r1p As New mp_ptr(New UInteger(1) { })
            
            ' Generate random number.
            gmp_lib.mpn_random(r1p, If(gmp_lib.mp_bytes_per_limb = 4, 2, 1))
            
            ' Release unmanaged memory.
            gmp_lib.free(r1p)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_random2(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">
            <summary>
            Generate a random number of length <paramref name="r1n"/> and store it at <paramref name="r1p"/>.
            </summary>
            <param name="r1p">The result integer.</param>
            <param name="r1n">The number of limbs of <paramref name="r1p"/>.</param>
            <remarks>
            <para>
            The most significant limb is always non-zero.
            <see cref="M:Math.Gmp.Native.gmp_lib.mpn_random(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_random</see> generates uniformly distributed limb data,
            <see cref="M:Math.Gmp.Native.gmp_lib.mpn_random2(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_random2</see> generates long strings of zeros and ones in the binary representation. 
            </para>
            <para>
            <see cref="M:Math.Gmp.Native.gmp_lib.mpn_random2(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_random2</see> is intended for testing the correctness of the <c>mpn</c> routines. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_random(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_random</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_Functions">Low-level Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operand.
            mp_ptr r1p = new mp_ptr(new uint[2]);
            
            // Generate random number.
            gmp_lib.mpn_random2(r1p, gmp_lib.mp_bytes_per_limb == 4 ? 2 : 1);
            
            // Release unmanaged memory.
            gmp_lib.free(r1p);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operand.
            Dim r1p As New mp_ptr(New UInteger(1) { })
            
            ' Generate random number.
            gmp_lib.mpn_random2(r1p, If(gmp_lib.mp_bytes_per_limb = 4, 2, 1))
            
            ' Release unmanaged memory.
            gmp_lib.free(r1p)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_rshift(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,System.UInt32)">
            <summary>
            Shift {<paramref name="sp"/>, <paramref name="n"/>} right by <paramref name="count"/> bits, and write the result to {<paramref name="rp"/>, <paramref name="n"/>}. 
            </summary>
            <param name="rp">The result integer.</param>
            <param name="sp">The operand integer.</param>
            <param name="n">The number of limbs of <paramref name="sp"/> and <paramref name="rp"/>.</param>
            <param name="count"></param>
            <returns>The bits shifted out at the right are returned in the most significant <paramref name="count"/> bits of the return value (the rest of the return value is zero).</returns>
            <remarks>
            <para>
            <paramref name="count"/> must be in the range 1 to <see cref="F:Math.Gmp.Native.gmp_lib.mp_bits_per_limb">mp_bits_per_limb</see> - 1.
            The regions {<paramref name="sp"/>, <paramref name="n"/>} and {<paramref name="rp"/>, <paramref name="n"/>}
            may overlap, provided <paramref name="rp"/> &#8804; <paramref name="sp"/>. 
            </para>
            <para>
            This function is written in assembly for most CPUs. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_hamdist(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_hamdist</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_lshift(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,System.UInt32)">mpn_lshift</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_popcount(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_popcount</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_scan0(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_bitcnt_t)">mpn_scan0</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_scan1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_bitcnt_t)">mpn_scan1</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_Functions">Low-level Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operands, and expected result.
            mp_ptr sp = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
            mp_ptr rp = new mp_ptr(new uint[2]);
            mp_ptr result = new mp_ptr(new uint[] { 0xffffffff, 0x7fffffff });
            
            // Set rp = sp &gt;&gt; 1.
            mp_limb_t bits = gmp_lib.mpn_rshift(rp, sp, sp.Size, 1);
            
            // Assert result of operation.
            Assert.IsTrue(bits == (gmp_lib.mp_bytes_per_limb == 4 ? 0x80000000 : 0x8000000000000000));
            Assert.IsTrue(rp.SequenceEqual(result));
            
            // Release unmanaged memory.
            gmp_lib.free(rp, sp, result);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operands, and expected result.
            Dim sp As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
            Dim rp As New mp_ptr(New UInteger(1) { })
            Dim result As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;H7fffffff})
            
            ' Set rp = sp &gt;&gt; 1.
            Dim bits As mp_limb_t = gmp_lib.mpn_rshift(rp, sp, sp.Size, 1)
            
            ' Assert result of operation.
            Assert.IsTrue(bits = (If(gmp_lib.mp_bytes_per_limb = 4, &amp;H80000000UI, &amp;H8000000000000000UL)))
            Assert.IsTrue(rp.SequenceEqual(result))
            
            ' Release unmanaged memory.
            gmp_lib.free(rp, sp, result)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_scan0(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_bitcnt_t)">
            <summary>
            Scan <paramref name="s1p"/> from bit position <paramref name="bit"/> for the next clear bit.
            </summary>
            <param name="s1p">The operand integer.</param>
            <param name="bit">The index of the starting bit.</param>
            <returns>The index of the next clear bit.</returns>
            <remarks>
            <para>
            It is required that there be a clear bit within the area at <paramref name="s1p"/>
            at or beyond bit position <paramref name="bit"/>, so that the function has something to return. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_hamdist(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_hamdist</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_lshift(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,System.UInt32)">mpn_lshift</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_popcount(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_popcount</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_rshift(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,System.UInt32)">mpn_rshift</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_scan1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_bitcnt_t)">mpn_scan1</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_Functions">Low-level Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operand.
            mp_ptr s1p = new mp_ptr(new uint[] { 0x0000001, 0x00000001 });
            
            // Assert result of operation.
            Assert.IsTrue(gmp_lib.mpn_scan0(s1p, 0) == 1);
            
            // Release unmanaged memory.
            gmp_lib.free(s1p);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operand.
            Dim s1p As New mp_ptr(New UInteger() { &amp;H1, &amp;H1})
            
            ' Assert result of operation.
            Assert.IsTrue(gmp_lib.mpn_scan0(s1p, 0) = 1)
            
            ' Release unmanaged memory.
            gmp_lib.free(s1p)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_scan1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_bitcnt_t)">
            <summary>
            Scan <paramref name="s1p"/> from bit position <paramref name="bit"/> for the next set bit.
            </summary>
            <param name="s1p">The operand integer.</param>
            <param name="bit">The index of the starting bit.</param>
            <returns>The index of the next set bit.</returns>
            <remarks>
            <para>
            It is required that there be a set bit within the area at <paramref name="s1p"/>
            at or beyond bit position <paramref name="bit"/>, so that the function has something to return. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_hamdist(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_hamdist</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_lshift(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,System.UInt32)">mpn_lshift</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_popcount(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_popcount</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_rshift(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,System.UInt32)">mpn_rshift</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_scan0(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_bitcnt_t)">mpn_scan0</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_Functions">Low-level Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operand.
            mp_ptr s1p = new mp_ptr(new uint[] { 0x0000001, 0x00000001 });
            
            // Assert result of operation.
            Assert.IsTrue(gmp_lib.mpn_scan1(s1p, 1) == 32);
            
            // Release unmanaged memory.
            gmp_lib.free(s1p);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operand.
            Dim s1p As New mp_ptr(New UInteger() { &amp;H1, &amp;H1})
            
            ' Assert result of operation.
            Assert.IsTrue(gmp_lib.mpn_scan1(s1p, 1) = 32)
            
            ' Release unmanaged memory.
            gmp_lib.free(s1p)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_set_str(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.char_ptr,Math.Gmp.Native.size_t,System.Int32)">
            <summary>
            Convert bytes {<paramref name="str"/>, <paramref name="strsize"/>} in the given <paramref name="base"/> to limbs at <paramref name="rp"/>. 
            </summary>
            <param name="rp">The result integer.</param>
            <param name="str">The operand string.</param>
            <param name="strsize">The length of <paramref name="str"/>.</param>
            <param name="base"></param>
            <returns>The number of limbs of <paramref name="rp"/>.</returns>
            <remarks>
            <para>
            <paramref name="str"/>[0] is the most significant input byte and
            <paramref name="str"/>[<paramref name="strsize"/> - 1] is the least significant input byte.
            Each byte should be a value in the range 0 to <paramref name="base"/> - 1,
            not an ASCII character. base can vary from 2 to 256.
            </para>
            <para>
            The converted value is {<paramref name="rp"/>, rn} where rn is the return value.
            If the most significant input byte <paramref name="str"/>[0] is non-zero,
            then <paramref name="rp"/>[rn - 1] will be non-zero,
            else <paramref name="rp"/>[rn - 1] and some number of subsequent limbs may be zero. 
            </para>
            <para>
            The area at <paramref name="rp"/> has to have space for the largest possible number with
            <paramref name="strsize"/> digits in the chosen <paramref name="base"/>, plus one extra limb. 
            </para>
            <para>
            The input must have at least one byte, and no overlap is permitted
            between {<paramref name="str"/>, <paramref name="strsize"/>} and the result at <paramref name="rp"/>. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_get_str(Math.Gmp.Native.char_ptr,System.Int32,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_get_str</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sizeinbase(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,System.Int32)">mpn_sizeinbase</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_Functions">Low-level Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operands.
            mp_ptr rp = new mp_ptr(new uint[2]);
            byte[] s = new byte[] { 1, 0, 0, 0, 0, 0, 0, 0, 1 };
            mp_ptr result = new mp_ptr(new uint[] { 0x00000001, 0x00000001 });
            char_ptr str = new char_ptr("xxxxxxxxxxxxxxxxx");
            Marshal.Copy(s, 0, str.ToIntPtr(), 9);
            
            // Convert rp from str in hex base.
            mp_size_t count = gmp_lib.mpn_set_str(rp, str, 9, 16);
            
            // Assert the non-ASCII, hex representation of s1p.
            Assert.IsTrue(count == rp.Size);
            Assert.IsTrue(rp.SequenceEqual(result));
            
            // Release unmanaged memory.
            gmp_lib.free(rp);
            gmp_lib.free(str);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operands.
            Dim rp As New mp_ptr(New UInteger(1) { })
            Dim s As Byte() = New Byte() { 1, 0, 0, 0, 0, 0, 0, 0, 1}
            Dim result As New mp_ptr(New UInteger() { &amp;H1, &amp;H1})
            Dim str As New char_ptr("xxxxxxxxxxxxxxxxx")
            Marshal.Copy(s, 0, str.ToIntPtr(), 9)
            
            ' Convert rp from str in hex base.
            Dim count As mp_size_t = gmp_lib.mpn_set_str(rp, str, 9, 16)
            
            ' Assert the non-ASCII, hex representation of s1p.
            Assert.IsTrue(count = rp.Size)
            Assert.IsTrue(rp.SequenceEqual(result))
            
            ' Release unmanaged memory.
            gmp_lib.free(rp)
            gmp_lib.free(str)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_sizeinbase(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,System.Int32)">
            <summary>
            Return the size of {<paramref name="xp"/>, <paramref name="n"/>} measured in number of digits in the given <paramref name="base"/>.
            </summary>
            <param name="xp">The operand integer.</param>
            <param name="n">The number of limbs of <paramref name="xp"/>.</param>
            <param name="base">The base.</param>
            <returns>The size of {<paramref name="xp"/>, <paramref name="n"/>} measured in number of digits in the given <paramref name="base"/>.</returns>
            <remarks>
            <para>
            <paramref name="base"/> can vary from 2 to 62.
            Requires <paramref name="n"/> &gt; 0 and <paramref name="xp"/>[<paramref name="n"/> - 1] &gt; 0.
            The result will be either exact or 1 too big.
            If base is a power of 2, the result is always exact. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_get_str(Math.Gmp.Native.char_ptr,System.Int32,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_get_str</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_set_str(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.char_ptr,Math.Gmp.Native.size_t,System.Int32)">mpn_set_str</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_Functions">Low-level Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operands, and expected result.
            mp_ptr xp = new mp_ptr(new uint[] { 0x00000001, 0x00000001 });
            
            // Assert that the number of bits required is 33.
            Assert.IsTrue(gmp_lib.mpn_sizeinbase(xp, xp.Size, 2) == 33);
            
            // Release unmanaged memory.
            gmp_lib.free(xp);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operands, and expected result.
            Dim xp As New mp_ptr(New UInteger() { &amp;H1, &amp;H1})
            
            ' Assert that the number of bits required is 33.
            Assert.IsTrue(gmp_lib.mpn_sizeinbase(xp, xp.Size, 2) = 33)
            
            ' Release unmanaged memory.
            gmp_lib.free(xp)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_sqrtrem(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">
            <summary>
            Compute the square root of {<paramref name="sp"/>, <paramref name="n"/>} and put the result at {<paramref name="r1p"/>, ceil(<paramref name="n"/> / 2)} and the remainder at {<paramref name="r2p"/>, retval}.
            </summary>
            <param name="r1p">The first result integer.</param>
            <param name="r2p">The second result integer.</param>
            <param name="sp">The operand integwer.</param>
            <param name="n">The number of limbs of <paramref name="sp"/>.</param>
            <returns>The number of limbs of <paramref name="r2p"/>.</returns>
            <remarks>
            <para>
            <paramref name="r2p"/> needs space for <paramref name="n"/> limbs,
            but the return value indicates how many are produced. 
            </para>
            <para>
            The most significant limb of {<paramref name="sp"/>, <paramref name="n"/>} must be non-zero.
            The areas {<paramref name="r1p"/>, ceil(<paramref name="n"/> / 2)} and
            {<paramref name="sp"/>, <paramref name="n"/>} must be completely separate. 
            The areas {<paramref name="r2p"/>, <paramref name="n"/>} and {<paramref name="sp"/>, <paramref name="n"/>}
            must be either identical or completely separate.
            </para>
            <para>
            If the remainder is not wanted then <paramref name="r2p"/> can be NULL, and in this case the return value
            is zero or non-zero according to whether the remainder would have been zero or non-zero.
            </para>
            <para>
            A return value of zero indicates a perfect square. See also <see cref="M:Math.Gmp.Native.gmp_lib.mpn_perfect_square_p(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_perfect_square_p</see>.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_add_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_add_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_addmul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_addmul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divexact_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_by3(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_divexact_by3</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_by3c(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divexact_by3c</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divmod_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divmod_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divrem_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divrem_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mod_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_mod_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_mul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_mul_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_neg(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_sub_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sub_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_submul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_submul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sqr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sqr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_tdiv_qr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_tdiv_qr</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_Functions">Low-level Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operands, and expected result.
            mp_ptr sp = new mp_ptr(new uint[] { 0x00000001, 0x00000001 });
            mp_ptr r1p = new mp_ptr(new uint[sp.Size * (gmp_lib.mp_bytes_per_limb / 4)]);
            mp_ptr r2p = new mp_ptr(new uint[sp.Size * (gmp_lib.mp_bytes_per_limb / 4)]);
            mp_ptr result = new mp_ptr(new uint[] { 0x00010000, 0x00000000 });
            mp_ptr remainder = new mp_ptr(new uint[] { 0x00000001, 0x00000000 });
            
            // Set r1p = trunc(sqrt(sp)), r2p = sp - r1p^2
            mp_size_t r2n = gmp_lib.mpn_sqrtrem(r1p, r2p, sp, sp.Size);
            
            // Assert result.
            Assert.IsTrue(r2n == 1);
             Assert.IsTrue(r1p.SequenceEqual(result));
            Assert.IsTrue(r2p.SequenceEqual(remainder));
            
            // Release unmanaged memory.
            gmp_lib.free(sp, r1p, r2p, result);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operands, and expected result.
            Dim sp As New mp_ptr(New UInteger() { &amp;H1, &amp;H1})
            Dim r1p As New mp_ptr(New UInteger(sp.Size * (gmp_lib.mp_bytes_per_limb / 4) - 1) {})
            Dim r2p As New mp_ptr(New UInteger(sp.Size * (gmp_lib.mp_bytes_per_limb / 4) - 1) {})
            Dim result As New mp_ptr(New UInteger() { &amp;H10000, &amp;H0})
            Dim remainder As New mp_ptr(New UInteger() { &amp;H1, &amp;H0})
            
            ' Set r1p = trunc(sqrt(sp)), r2p = sp - r1p^2
            Dim r2n As mp_size_t = gmp_lib.mpn_sqrtrem(r1p, r2p, sp, sp.Size)
            
            ' Assert result.
            Assert.IsTrue(r2n = 1)
            Assert.IsTrue(r1p.SequenceEqual(result))
            Assert.IsTrue(r2p.SequenceEqual(remainder))
            
            ' Release unmanaged memory.
            gmp_lib.free(sp, r1p, r2p, result)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_sub(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">
            <summary>
            Subtract {<paramref name="s2p"/>, <paramref name="s2n"/>} from {<paramref name="s1p"/>, <paramref name="s1n"/>}, and write the <paramref name="s1n"/> least significant limbs of the result to <paramref name="rp"/>.
            </summary>
            <param name="rp">The result integer.</param>
            <param name="s1p">The first operand integer.</param>
            <param name="s1n">The number of limbs of <paramref name="s1p"/>.</param>
            <param name="s2p">The second operand integer.</param>
            <param name="s2n">The number of limbs of <paramref name="s2p"/>.</param>
            <returns>Return borrow, either 0 or 1.</returns>
            <remarks>
            <para>
            This is the lowest-level function for subtraction. It is the preferred function for subtraction, since it is written in assembly for most CPUs.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_add_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_add_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_addmul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_addmul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divexact_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_by3(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_divexact_by3</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_by3c(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divexact_by3c</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divmod_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divmod_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divrem_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divrem_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mod_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_mod_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_mul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_mul_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_neg(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_sub_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sub_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_submul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_submul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sqr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sqr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sqrtrem(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sqrtrem</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_tdiv_qr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_tdiv_qr</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_Functions">Low-level Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operands, and expected result.
            mp_ptr s1p = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
            mp_ptr s2p = new mp_ptr(new uint[] { 0x00000001 });
            mp_ptr rp = new mp_ptr(new uint[2]);
            mp_ptr result = new mp_ptr(new uint[] { 0xfffffffe, 0xffffffff });
            
            // Set rp = s1 - s2.
            mp_limb_t borrow = gmp_lib.mpn_sub(rp, s1p, s1p.Size, s2p, s2p.Size);
            
            // Assert result of operation.
            Assert.IsTrue(borrow == 0);
            Assert.IsTrue(rp.SequenceEqual(result));
            
            // Release unmanaged memory.
            gmp_lib.free(rp, s1p, s2p, result);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operands, and expected result.
            Dim s1p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
            Dim s2p As New mp_ptr(New UInteger() { &amp;H1})
            Dim rp As New mp_ptr(New UInteger(1) { })
            Dim result As New mp_ptr(New UInteger() { &amp;HfffffffeUI, &amp;HffffffffUI})
            
            ' Set rp = s1 - s2.
            Dim borrow As mp_limb_t = gmp_lib.mpn_sub(rp, s1p, s1p.Size, s2p, s2p.Size)
            
            ' Assert result of operation.
            Assert.IsTrue(borrow = 0)
            Assert.IsTrue(rp.SequenceEqual(result))
            
            ' Release unmanaged memory.
            gmp_lib.free(rp, s1p, s2p, result)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_sub_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">
            <summary>
            Subtract <paramref name="s2limb"/> from {<paramref name="s1p"/>, <paramref name="n"/>}, and write the <paramref name="n"/> least significant limbs of the result to <paramref name="rp"/>.
            </summary>
            <param name="rp">The result integer.</param>
            <param name="s1p">The first operand integer.</param>
            <param name="n">The numbe rof limbs of <paramref name="s1p"/>.</param>
            <param name="s2limb">The second operand integer.</param>
            <returns>Return borrow, either 0 or 1.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_add_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_add_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_addmul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_addmul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divexact_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_by3(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_divexact_by3</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_by3c(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divexact_by3c</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divmod_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divmod_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divrem_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divrem_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mod_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_mod_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_mul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_mul_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_neg(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sub_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_submul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_submul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sqr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sqr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sqrtrem(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sqrtrem</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_tdiv_qr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_tdiv_qr</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_Functions">Low-level Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operands, and expected result.
            mp_ptr s1p = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
            mp_ptr rp = new mp_ptr(new uint[2]);
            mp_ptr result = new mp_ptr(new uint[] { 0xfffffffe, 0xffffffff });
            
            // Set rp = s1 - 1.
            mp_limb_t borrow = gmp_lib.mpn_sub_1(rp, s1p, s1p.Size, 1);
            
            // Assert result of operation.
            Assert.IsTrue(borrow == 0);
            Assert.IsTrue(rp.SequenceEqual(result));
            
            // Release unmanaged memory.
            gmp_lib.free(rp, s1p, result);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operands, and expected result.
            Dim s1p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
            Dim rp As New mp_ptr(New UInteger(1) { })
            Dim result As New mp_ptr(New UInteger() { &amp;HfffffffeUI, &amp;HffffffffUI})
            
            ' Set rp = s1 - 1.
            Dim borrow As mp_limb_t = gmp_lib.mpn_sub_1(rp, s1p, s1p.Size, 1)
            
            ' Assert result of operation.
            Assert.IsTrue(borrow = 0)
            Assert.IsTrue(rp.SequenceEqual(result))
            
            ' Release unmanaged memory.
            gmp_lib.free(rp, s1p, result)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_sub_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">
            <summary>
            Subtract {<paramref name="s2p"/>, <paramref name="n"/>} from {<paramref name="s1p"/>, <paramref name="n"/>}, and write the <paramref name="n"/> least significant limbs of the result to <paramref name="rp"/>.
            </summary>
            <param name="rp">The result integer.</param>
            <param name="s1p">The first operand integer.</param>
            <param name="s2p">The second operand integer.</param>
            <param name="n">The numbe rof limbs of <paramref name="s1p"/> and <paramref name="s2p"/>.</param>
            <returns>Return borrow, either 0 or 1.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_add_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_add_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_addmul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_addmul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divexact_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_by3(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_divexact_by3</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_by3c(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divexact_by3c</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divmod_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divmod_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divrem_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divrem_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mod_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_mod_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_mul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_mul_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_neg(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_sub_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_submul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_submul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sqr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sqr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sqrtrem(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sqrtrem</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_tdiv_qr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_tdiv_qr</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_Functions">Low-level Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operands, and expected result.
            mp_ptr s1p = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
            mp_ptr s2p = new mp_ptr(new uint[] { 0x00000001, 0x00000000 });
            mp_ptr rp = new mp_ptr(new uint[2]);
            mp_ptr result = new mp_ptr(new uint[] { 0xfffffffe, 0xffffffff });
            
            // Set rp = s1 - s2.
            mp_limb_t borrow = gmp_lib.mpn_sub_n(rp, s1p, s2p, rp.Size);
            
            // Assert result of operation.
            Assert.IsTrue(borrow == 0);
            Assert.IsTrue(rp.SequenceEqual(result));
            
            // Release unmanaged memory.
            gmp_lib.free(rp, s1p, s2p, result);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operands, and expected result.
            Dim s1p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
            Dim s2p As New mp_ptr(New UInteger() { &amp;H1, &amp;H0})
             Dim rp As New mp_ptr(New UInteger(1) { })
            Dim result As New mp_ptr(New UInteger() { &amp;HfffffffeUI, &amp;HffffffffUI})
            
            ' Set rp = s1 - s2.
            Dim borrow As mp_limb_t = gmp_lib.mpn_sub_n(rp, s1p, s2p, rp.Size)
            
            ' Assert result of operation.
            Assert.IsTrue(borrow = 0)
            Assert.IsTrue(rp.SequenceEqual(result))
            
            ' Release unmanaged memory.
            gmp_lib.free(rp, s1p, s2p, result)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_submul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">
            <summary>
            Multiply {<paramref name="s1p"/>, <paramref name="n"/>} and <paramref name="s2limb"/>, and subtract the <paramref name="n"/> least significant limbs of the product from {<paramref name="rp"/>, <paramref name="n"/>} and write the result to <paramref name="rp"/>.
            </summary>
            <param name="rp">The result integer.</param>
            <param name="s1p">The first operand integer.</param>
            <param name="n">The number of limbs of <paramref name="s1p"/></param>
            <param name="s2limb">The second operand integer.</param>
            <returns>Return the most significant limb of the product, plus borrow-out from the subtraction.</returns>
            <remarks>
            <para>
            {<paramref name="s1p"/>, <paramref name="n"/>} and {<paramref name="rp"/>, <paramref name="n"/>}
            are allowed to overlap provided <paramref name="rp"/> &#8804; <paramref name="s1p"/>.
            </para>
            <para>
            This is a low-level function that is a building block for general multiplication and division
            as well as other operations in GMP. It is written in assembly for most CPUs. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_add_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_add_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_addmul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_addmul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divexact_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_by3(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_divexact_by3</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_by3c(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divexact_by3c</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divmod_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divmod_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divrem_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divrem_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mod_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_mod_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_mul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_mul_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_neg(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_sub_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sub_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sqr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sqr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sqrtrem(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sqrtrem</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_tdiv_qr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_tdiv_qr</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_Functions">Low-level Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operands, and expected result.
            mp_ptr s1p = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
            mp_ptr rp = new mp_ptr(new uint[] { 0x00000002, 0x00000000 });
            mp_ptr result = new mp_ptr(new uint[] { 0x00000004, 0x00000000 });
            
            // Set rp -= s1 * 2.
            mp_limb_t borrow = gmp_lib.mpn_submul_1(rp, s1p, s1p.Size, 2);
            
            // Assert result of operation.
            Assert.IsTrue(borrow == 0x02);
            Assert.IsTrue(rp.SequenceEqual(result));
            
            // Release unmanaged memory.
            gmp_lib.free(rp, s1p, result);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operands, and expected result.
            Dim s1p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
            Dim rp As New mp_ptr(New UInteger() { &amp;H2, &amp;H0})
            Dim result As New mp_ptr(New UInteger() { &amp;H4, &amp;H0})
            
            ' Set rp -= s1 * 2.
            Dim borrow As mp_limb_t = gmp_lib.mpn_submul_1(rp, s1p, s1p.Size, 2)
            
            ' Assert result of operation.
            Assert.IsTrue(borrow = &amp;H2)
            Assert.IsTrue(rp.SequenceEqual(result))
            
            ' Release unmanaged memory.
            gmp_lib.free(rp, s1p, result)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_tdiv_qr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">
            <summary>
            Divide {<paramref name="np"/>, <paramref name="nn"/>} by {<paramref name="dp"/>, <paramref name="dn"/>} and put the quotient at {<paramref name="qp"/>, <paramref name="nn"/> - <paramref name="dn"/> + 1} and the remainder at {<paramref name="rp"/>, <paramref name="dn"/>}.
            </summary>
            <param name="qp">The result quotient integer.</param>
            <param name="rp">The result remainder integer.</param>
            <param name="qxn">Must be 0.</param>
            <param name="np">The numerator operand integer.</param>
            <param name="nn">The number of limbs of <paramref name="np"/>.</param>
            <param name="dp">The denominator operand integer.</param>
            <param name="dn">The number of limbs of <paramref name="dp"/>.</param>
            <remarks>
            <para>
            The quotient is rounded towards 0.
            </para>
            <para>
            No overlap is permitted between arguments, except that <paramref name="np"/> might
            equal <paramref name="rp"/>.
            The dividend size <paramref name="nn"/> must be greater than or equal to divisor
            size <paramref name="dn"/>.
            The most significant limb of the divisor must be non-zero.
            The <paramref name="qxn"/> operand must be zero. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_add</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_add_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_add_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_add_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_addmul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_addmul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divexact_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_by3(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_divexact_by3</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divexact_by3c(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divexact_by3c</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divmod_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divmod_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_divrem_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_divrem_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mod_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_mod_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_mul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_mul_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_mul_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_neg(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_neg</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sub</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_sub_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sub_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sub_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_submul_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_submul_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sqr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sqr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sqrtrem(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sqrtrem</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_Functions">Low-level Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operands, and expected result.
            mp_ptr np = new mp_ptr(new uint[] { 0xffffffff, 0x0000ffff });
            mp_ptr dp = new mp_ptr(new uint[] { 0x00000013 });
            mp_ptr qp = new mp_ptr(new uint[np.Size - dp.Size + 1]);
            mp_ptr rp = new mp_ptr(new uint[dp.Size]);
            mp_ptr quotient = new mp_ptr(new uint[] { 0x435e50d7, 0x00000d79 });
            mp_ptr remainder = new mp_ptr(new uint[] { 0x0000000a });
            
            // Set rp = np / dp.
            gmp_lib.mpn_tdiv_qr(qp, rp, 0, np, np.Size, dp, dp.Size);
            
            // Assert result of operation.
            Assert.IsTrue(qp.SequenceEqual(quotient));
            Assert.IsTrue(rp.SequenceEqual(remainder));
            
            // Release unmanaged memory.
            gmp_lib.free(qp, rp, np, dp, quotient, remainder);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operands, and expected result.
            Dim np As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;Hffff})
            Dim dp As New mp_ptr(New UInteger() { &amp;H13})
            Dim qp As New mp_ptr(New UInteger(np.Size - dp.Size) { })
            Dim rp As New mp_ptr(New UInteger(dp.Size - 1) { })
            Dim quotient As New mp_ptr(New UInteger() { &amp;H435e50d7, &amp;Hd79})
            Dim remainder As New mp_ptr(New UInteger() { &amp;Ha})
            
            ' Set rp = np / dp.
            gmp_lib.mpn_tdiv_qr(qp, rp, 0, np, np.Size, dp, dp.Size)
            
            ' Assert result of operation.
            Assert.IsTrue(qp.SequenceEqual(quotient))
            Assert.IsTrue(rp.SequenceEqual(remainder))
            
            ' Release unmanaged memory.
            gmp_lib.free(qp, rp, np, dp, quotient, remainder)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_and_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">
            <summary>
            Perform the bitwise logical and of {<paramref name="s1p"/>, <paramref name="n"/>} and {<paramref name="s2p"/>, <paramref name="n"/>}, and write the result to {<paramref name="rp"/>, <paramref name="n"/>}. 
            </summary>
            <param name="rp">The result integer.</param>
            <param name="s1p">The first operand integer.</param>
            <param name="s2p">The second operand integer.</param>
            <param name="n">The number of limbs of <paramref name="s1p"/> and <paramref name="s2p"/>.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_andn_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_andn_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_com(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_com</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_ior_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_ior_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_iorn_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_iorn_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_nand_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_nand_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_nior_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_nior_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_xor_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_xor_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_xnor_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_xnor_n</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_Functions">Low-level Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operands, and expected result.
            mp_ptr s1p = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
            mp_ptr s2p = new mp_ptr(new uint[] { 0x00000001, 0x12345678 });
            mp_ptr rp = new mp_ptr(new uint[2]);
            mp_ptr result = new mp_ptr(new uint[] { 0x00000001, 0x12345678 });
            
            // Set rp = s1 and s2.
            gmp_lib.mpn_and_n(rp, s1p, s2p, s1p.Size);
            
            // Assert result of operation.
            Assert.IsTrue(rp.SequenceEqual(result));
            
            // Release unmanaged memory.
            gmp_lib.free(rp, s1p, s2p, result);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operands, and expected result.
            Dim s1p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
            Dim s2p As New mp_ptr(New UInteger() { &amp;H1, &amp;H12345678})
            Dim rp As New mp_ptr(New UInteger(1) { })
            Dim result As New mp_ptr(New UInteger() { &amp;H1, &amp;H12345678})
            
            ' Set rp = s1 and s2.
            gmp_lib.mpn_and_n(rp, s1p, s2p, s1p.Size)
            
            ' Assert result of operation.
            Assert.IsTrue(rp.SequenceEqual(result))
            
            ' Release unmanaged memory.
            gmp_lib.free(rp, s1p, s2p, result)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_andn_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">
            <summary>
            Perform the bitwise logical and of {<paramref name="s1p"/>, <paramref name="n"/>} and the bitwise complement of {<paramref name="s2p"/>, <paramref name="n"/>}, and write the result to {<paramref name="rp"/>, <paramref name="n"/>}.
            </summary>
            <param name="rp">The result integer.</param>
            <param name="s1p">The first operand integer.</param>
            <param name="s2p">The second operand integer.</param>
            <param name="n">The number of limbs of <paramref name="s1p"/> and <paramref name="s2p"/>.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_and_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_and_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_com(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_com</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_ior_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_ior_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_iorn_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_iorn_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_nand_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_nand_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_nior_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_nior_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_xor_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_xor_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_xnor_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_xnor_n</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_Functions">Low-level Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operands, and expected result.
            mp_ptr s1p = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
            mp_ptr s2p = new mp_ptr(new uint[] { 0x00000001, 0x12345678 });
            mp_ptr rp = new mp_ptr(new uint[2]);
            mp_ptr result = new mp_ptr(new uint[] { 0xfffffffe, 0xedcba987 });
            
            // Set rp = s1 and not s2.
            gmp_lib.mpn_andn_n(rp, s1p, s2p, s1p.Size);
            
            // Assert result of operation.
            Assert.IsTrue(rp.SequenceEqual(result));
            
            // Release unmanaged memory.
            gmp_lib.free(rp, s1p, s2p, result);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operands, and expected result.
            Dim s1p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
            Dim s2p As New mp_ptr(New UInteger() { &amp;H1, &amp;H12345678})
            Dim rp As New mp_ptr(New UInteger(1) { })
            Dim result As New mp_ptr(New UInteger() { &amp;HfffffffeUI, &amp;Hedcba987UI})
            
            ' Set rp = s1 and not s2.
            gmp_lib.mpn_andn_n(rp, s1p, s2p, s1p.Size)
            
            ' Assert result of operation.
            Assert.IsTrue(rp.SequenceEqual(result))
            
            ' Release unmanaged memory.
            gmp_lib.free(rp, s1p, s2p, result)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_nand_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">
            <summary>
            Perform the bitwise logical and of {<paramref name="s1p"/>, <paramref name="n"/>} and {<paramref name="s2p"/>, <paramref name="n"/>}, and write the bitwise complement of the result to {<paramref name="rp"/>, <paramref name="n"/>}. 
            </summary>
            <param name="rp">The result integer.</param>
            <param name="s1p">The first operand integer.</param>
            <param name="s2p">The second operand integer.</param>
            <param name="n">The number of limbs of <paramref name="s1p"/> and <paramref name="s2p"/>.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_and_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_and_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_andn_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_andn_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_com(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_com</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_ior_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_ior_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_iorn_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_iorn_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_nior_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_nior_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_xor_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_xor_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_xnor_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_xnor_n</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_Functions">Low-level Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operands, and expected result.
            mp_ptr s1p = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
            mp_ptr s2p = new mp_ptr(new uint[] { 0x00000001, 0x12345678 });
            mp_ptr rp = new mp_ptr(new uint[2]);
            mp_ptr result = new mp_ptr(new uint[] { 0x00000001, 0x12345678 });
            
            // Set rp = not(s1 and s2).
            gmp_lib.mpn_and_n(rp, s1p, s2p, s1p.Size);
            
            // Assert result of operation.
            Assert.IsTrue(rp.SequenceEqual(result));
            
            // Release unmanaged memory.
            gmp_lib.free(rp, s1p, s2p, result);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operands, and expected result.
            Dim s1p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
            Dim s2p As New mp_ptr(New UInteger() { &amp;H1, &amp;H12345678})
             rp As New mp_ptr(New UInteger(1) { })
            Dim result As New mp_ptr(New UInteger() { &amp;H1, &amp;H12345678})
            
            ' Set rp = not(s1 and s2).
            gmp_lib.mpn_and_n(rp, s1p, s2p, s1p.Size)
            
            ' Assert result of operation.
            Assert.IsTrue(rp.SequenceEqual(result))
            
            ' Release unmanaged memory.
            gmp_lib.free(rp, s1p, s2p, result)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_ior_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">
            <summary>
            Perform the bitwise logical inclusive or of {<paramref name="s1p"/>, <paramref name="n"/>} and {<paramref name="s2p"/>, <paramref name="n"/>}, and write the result to {<paramref name="rp"/>, <paramref name="n"/>}. 
            </summary>
            <param name="rp">The result integer.</param>
            <param name="s1p">The first operand integer.</param>
            <param name="s2p">The second operand integer.</param>
            <param name="n">The number of limbs of <paramref name="s1p"/> and <paramref name="s2p"/>.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_and_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_and_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_andn_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_andn_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_com(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_com</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_iorn_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_iorn_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_nand_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_nand_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_nior_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_nior_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_xor_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_xor_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_xnor_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_xnor_n</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_Functions">Low-level Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operands, and expected result.
            mp_ptr s1p = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
            mp_ptr s2p = new mp_ptr(new uint[] { 0x00000001, 0x12345678 });
            mp_ptr rp = new mp_ptr(new uint[2]);
            mp_ptr result = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
            
            // Set rp = s1 or s2.
            gmp_lib.mpn_ior_n(rp, s1p, s2p, s1p.Size);
            
            // Assert result of operation.
            Assert.IsTrue(rp.SequenceEqual(result));
            
            // Release unmanaged memory.
            gmp_lib.free(rp, s1p, s2p, result);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operands, and expected result.
            Dim s1p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
            Dim s2p As New mp_ptr(New UInteger() { &amp;H1, &amp;H12345678})
            Dim rp As New mp_ptr(New UInteger(1) { })
            Dim result As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
            
            ' Set rp = s1 or s2.
            gmp_lib.mpn_ior_n(rp, s1p, s2p, s1p.Size)
            
            ' Assert result of operation.
            Assert.IsTrue(rp.SequenceEqual(result))
            
            ' Release unmanaged memory.
            gmp_lib.free(rp, s1p, s2p, result)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_iorn_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">
            <summary>
            Perform the bitwise logical inclusive or of {<paramref name="s1p"/>, <paramref name="n"/>} and the bitwise complement of {<paramref name="s2p"/>, <paramref name="n"/>}, and write the result to {<paramref name="rp"/>, <paramref name="n"/>}. 
            </summary>
            <param name="rp">The result integer.</param>
            <param name="s1p">The first operand integer.</param>
            <param name="s2p">The second operand integer.</param>
            <param name="n">The number of limbs of <paramref name="s1p"/> and <paramref name="s2p"/>.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_and_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_and_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_andn_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_andn_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_com(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_com</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_ior_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_ior_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_nand_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_nand_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_nior_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_nior_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_xor_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_xor_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_xnor_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_xnor_n</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_Functions">Low-level Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operands, and expected result.
            mp_ptr s1p = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
            mp_ptr s2p = new mp_ptr(new uint[] { 0x00000001, 0x12345678 });
            mp_ptr rp = new mp_ptr(new uint[2]);
            mp_ptr result = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
            
            // Set rp = s1 or not s2.
            gmp_lib.mpn_iorn_n(rp, s1p, s2p, s1p.Size);
            
            // Assert result of operation.
            Assert.IsTrue(rp.SequenceEqual(result));
            
            // Release unmanaged memory.
            gmp_lib.free(rp, s1p, s2p, result);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operands, and expected result.
            Dim s1p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
            Dim s2p As New mp_ptr(New UInteger() { &amp;H1, &amp;H12345678})
            Dim rp As New mp_ptr(New UInteger(1) { })
            Dim result As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
            
            ' Set rp = s1 or not s2.
            gmp_lib.mpn_iorn_n(rp, s1p, s2p, s1p.Size)
            
            ' Assert result of operation.
            Assert.IsTrue(rp.SequenceEqual(result))
            
            ' Release unmanaged memory.
            gmp_lib.free(rp, s1p, s2p, result)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_nior_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">
            <summary>
            Perform the bitwise logical inclusive or of {<paramref name="s1p"/>, <paramref name="n"/>} and {<paramref name="s2p"/>, <paramref name="n"/>}, and write the bitwise complement of the result to {<paramref name="rp"/>, <paramref name="n"/>}.
            </summary>
            <param name="rp">The result integer.</param>
            <param name="s1p">The first operand integer.</param>
            <param name="s2p">The second operand integer.</param>
            <param name="n">The number of limbs of <paramref name="s1p"/> and <paramref name="s2p"/>.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_and_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_and_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_andn_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_andn_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_com(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_com</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_ior_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_ior_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_iorn_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_iorn_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_nand_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_nand_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_xor_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_xor_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_xnor_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_xnor_n</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_Functions">Low-level Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operands, and expected result.
            mp_ptr s1p = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
            mp_ptr s2p = new mp_ptr(new uint[] { 0x00000001, 0x12345678 });
            mp_ptr rp = new mp_ptr(new uint[2]);
            mp_ptr result = new mp_ptr(new uint[] { 0x00000000, 0x00000000 });
            
            // Set rp = not (s1 or s2).
            gmp_lib.mpn_nior_n(rp, s1p, s2p, s1p.Size);
            
            // Assert result of operation.
            Assert.IsTrue(rp.SequenceEqual(result));
            
            // Release unmanaged memory.
            gmp_lib.free(rp, s1p, s2p, result);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operands, and expected result.
            Dim s1p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
            Dim s2p As New mp_ptr(New UInteger() { &amp;H1, &amp;H12345678})
            Dim rp As New mp_ptr(New UInteger(1) { })
            Dim result As New mp_ptr(New UInteger() { &amp;H0, &amp;H0})
            
            ' Set rp = not (s1 or s2).
            gmp_lib.mpn_nior_n(rp, s1p, s2p, s1p.Size)
            
            ' Assert result of operation.
            Assert.IsTrue(rp.SequenceEqual(result))
            
            ' Release unmanaged memory.
            gmp_lib.free(rp, s1p, s2p, result)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_xor_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">
            <summary>
            Perform the bitwise logical exclusive or of {<paramref name="s1p"/>, <paramref name="n"/>} and {<paramref name="s2p"/>, <paramref name="n"/>}, and write the result to {<paramref name="rp"/>, <paramref name="n"/>}. 
            </summary>
            <param name="rp">The result integer.</param>
            <param name="s1p">The first operand integer.</param>
            <param name="s2p">The second operand integer.</param>
            <param name="n">The number of limbs of <paramref name="s1p"/> and <paramref name="s2p"/>.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_and_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_and_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_andn_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_andn_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_com(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_com</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_ior_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_ior_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_iorn_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_iorn_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_nand_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_nand_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_nior_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_nior_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_xnor_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_xnor_n</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_Functions">Low-level Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operands, and expected result.
            mp_ptr s1p = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
            mp_ptr s2p = new mp_ptr(new uint[] { 0x00000001, 0x12345678 });
            mp_ptr rp = new mp_ptr(new uint[2]);
            mp_ptr result = new mp_ptr(new uint[] { 0xfffffffe, 0xedcba987 });
            
            // Set rp = s1 xor s2.
            gmp_lib.mpn_xor_n(rp, s1p, s2p, s1p.Size);
            
            // Assert result of operation.
            Assert.IsTrue(rp.SequenceEqual(result));
            
            // Release unmanaged memory.
            gmp_lib.free(rp, s1p, s2p, result);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operands, and expected result.
            Dim s1p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
            Dim s2p As New mp_ptr(New UInteger() { &amp;H1, &amp;H12345678})
            Dim rp As New mp_ptr(New UInteger(1) { })
            Dim result As New mp_ptr(New UInteger() { &amp;HfffffffeUI, &amp;Hedcba987UI})
            
            ' Set rp = s1 xor s2.
            gmp_lib.mpn_xor_n(rp, s1p, s2p, s1p.Size)
            
            ' Assert result of operation.
            Assert.IsTrue(rp.SequenceEqual(result))
            
            ' Release unmanaged memory.
            gmp_lib.free(rp, s1p, s2p, result)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_xnor_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">
            <summary>
            Perform the bitwise logical exclusive or of {<paramref name="s1p"/>, <paramref name="n"/>} and {<paramref name="s2p"/>, <paramref name="n"/>}, and write the bitwise complement of the result to {<paramref name="rp"/>, <paramref name="n"/>}. 
            </summary>
            <param name="rp">The result integer.</param>
            <param name="s1p">The first operand integer.</param>
            <param name="s2p">The second operand integer.</param>
            <param name="n">The number of limbs of <paramref name="s1p"/> and <paramref name="s2p"/>.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_and_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_and_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_andn_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_andn_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_com(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_com</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_ior_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_ior_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_iorn_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_iorn_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_nand_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_nand_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_nior_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_nior_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_xor_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_xor_n</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_Functions">Low-level Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operands, and expected result.
            mp_ptr s1p = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
            mp_ptr s2p = new mp_ptr(new uint[] { 0x00000001, 0x12345678 });
            mp_ptr rp = new mp_ptr(new uint[2]);
            mp_ptr result = new mp_ptr(new uint[] { 0x00000001, 0x12345678 });
            
            // Set rp = not(s1 xor s2).
            gmp_lib.mpn_xnor_n(rp, s1p, s2p, s1p.Size);
            
            // Assert result of operation.
            Assert.IsTrue(rp.SequenceEqual(result));
            
            // Release unmanaged memory.
            gmp_lib.free(rp, s1p, s2p, result);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operands, and expected result.
            Dim s1p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
            Dim s2p As New mp_ptr(New UInteger() { &amp;H1, &amp;H12345678})
            Dim rp As New mp_ptr(New UInteger(1) { })
            Dim result As New mp_ptr(New UInteger() { &amp;H1, &amp;H12345678})
            
            ' Set rp = not(s1 xor s2).
            gmp_lib.mpn_xnor_n(rp, s1p, s2p, s1p.Size)
            
            ' Assert result of operation.
            Assert.IsTrue(rp.SequenceEqual(result))
            
            ' Release unmanaged memory.
            gmp_lib.free(rp, s1p, s2p, result)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_copyi(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">
            <summary>
            Copy from {<paramref name="s1p"/>, <paramref name="n"/>} to {<paramref name="rp"/>, <paramref name="n"/>}, increasingly. 
            </summary>
            <param name="rp">The result integer.</param>
            <param name="s1p">The operand integer.</param>
            <param name="n">The number of limbs of <paramref name="s1p"/>.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_copyd(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_copyd</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_zero(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_zero</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_Functions">Low-level Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operands, and expected result.
            mp_ptr sp = new mp_ptr(new uint[] { 0xf0f0f0f0, 0xf0f0f0f0 });
            mp_ptr rp = new mp_ptr(new uint[2]);
            mp_ptr result = new mp_ptr(new uint[] { 0xf0f0f0f0, 0xf0f0f0f0 });
            
            // Set rp = sp.
            gmp_lib.mpn_copyi(rp, sp, sp.Size);
            
            // Assert result of operation.
            Assert.IsTrue(rp.SequenceEqual(result));
            
            // Release unmanaged memory.
            gmp_lib.free(rp, sp, result);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operands, and expected result.
            Dim sp As New mp_ptr(New UInteger() { &amp;Hf0f0f0f0UI, &amp;Hf0f0f0f0UI})
            Dim rp As New mp_ptr(New UInteger(1) { })
            Dim result As New mp_ptr(New UInteger() { &amp;Hf0f0f0f0UI, &amp;Hf0f0f0f0UI})
            
            ' Set rp = sp.
            gmp_lib.mpn_copyi(rp, sp, sp.Size)
            
            ' Assert result of operation.
            Assert.IsTrue(rp.SequenceEqual(result))
            
            ' Release unmanaged memory.
            gmp_lib.free(rp, sp, result)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_copyd(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">
            <summary>
            Copy from {<paramref name="s1p"/>, <paramref name="n"/>} to {<paramref name="rp"/>, <paramref name="n"/>}, decreasingly. 
            </summary>
            <param name="rp">The result integer.</param>
            <param name="s1p">The operand integer.</param>
            <param name="n">The number of limbs of <paramref name="s1p"/>.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_copyi(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_copyi</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_zero(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_zero</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_Functions">Low-level Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operands, and expected result.
            mp_ptr sp = new mp_ptr(new uint[] { 0xf0f0f0f0, 0xf0f0f0f0 });
            mp_ptr rp = new mp_ptr(new uint[2]);
            mp_ptr result = new mp_ptr(new uint[] { 0xf0f0f0f0, 0xf0f0f0f0 });
            
            // Set rp = sp.
            gmp_lib.mpn_copyd(rp, sp, sp.Size);
            
            // Assert result of operation.
            Assert.IsTrue(rp.SequenceEqual(result));
            
            // Release unmanaged memory.
            gmp_lib.free(rp, sp, result);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operands, and expected result.
            Dim sp As New mp_ptr(New UInteger() { &amp;Hf0f0f0f0UI, &amp;Hf0f0f0f0UI})
            Dim rp As New mp_ptr(New UInteger(1) { })
            Dim result As New mp_ptr(New UInteger() { &amp;Hf0f0f0f0UI, &amp;Hf0f0f0f0UI})
            
            ' Set rp = sp.
            gmp_lib.mpn_copyd(rp, sp, sp.Size)
            
            ' Assert result of operation.
            Assert.IsTrue(rp.SequenceEqual(result))
            
            ' Release unmanaged memory.
            gmp_lib.free(rp, sp, result)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_zero(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">
            <summary>
            Zero {<paramref name="rp"/>, <paramref name="n"/>}.
            </summary>
            <param name="rp">The result integer.</param>
            <param name="n">The number of limbs of <paramref name="rp"/>.</param>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_copyd(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_copyd</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_copyi(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_copyi</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_Functions">Low-level Functions</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operand, and expected result.
            mp_ptr rp = new mp_ptr(new uint[2]);
            mp_ptr result = new mp_ptr(new uint[] { 0x00000000, 0x00000000 });
            
            // Set rp = sp.
            gmp_lib.mpn_zero(rp, rp.Size);
            
            // Assert result of operation.
            Assert.IsTrue(rp.SequenceEqual(result));
            
            // Release unmanaged memory.
            gmp_lib.free(rp, result);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operand, and expected result.
            Dim rp As New mp_ptr(New UInteger(1) { })
            Dim result As New mp_ptr(New UInteger() { &amp;H0, &amp;H0})
            
            ' Set rp = sp.
            gmp_lib.mpn_zero(rp, rp.Size)
            
            ' Assert result of operation.
            Assert.IsTrue(rp.SequenceEqual(result))
            
            ' Release unmanaged memory.
            gmp_lib.free(rp, result)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_cnd_add_n(Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">
            <summary>
            If <paramref name="cnd"/> is non-zero, it produces the same result as a regular <see cref="M:Math.Gmp.Native.gmp_lib.mpn_add_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_add_n</see>, and if <paramref name="cnd"/> is zero, it copies {<paramref name="s1p"/>, <paramref name="n"/>} to the result area and returns zero.
            </summary>
            <param name="cnd">Conditonal value: non-zero for true, zero for false.</param>
            <param name="rp">The result integer.</param>
            <param name="s1p">The first operand integer.</param>
            <param name="s2p">The second operand integer.</param>
            <param name="n">The number of limbs of <paramref name="s1p"/> and <paramref name="s2p"/>.</param>
            <returns>If <paramref name="cnd"/> is non-zero, return carry, either 0 or 1, and if <paramref name="cnd"/> is zero, return 0.</returns>
            <remarks>
            <para>
            This function does conditional addition.
            If <paramref name="cnd"/> is non-zero, it produces the same result as a regular <see cref="M:Math.Gmp.Native.gmp_lib.mpn_add_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_add_n</see>,
            and if <paramref name="cnd"/> is zero, it copies {<paramref name="s1p"/>, <paramref name="n"/>} to the result area and returns zero.
            The functions is designed to have timing and memory access patterns depending only
            on size and location of the data areas, but independent of the condition <paramref name="cnd"/>.
            Like for <see cref="M:Math.Gmp.Native.gmp_lib.mpn_add_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_add_n</see>, on most machines, the timing will also be independent
            of the actual limb values. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_cnd_sub_n(Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_cnd_sub_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_add_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr)">mpn_sec_add_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_sub_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr)">mpn_sec_sub_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_cnd_swap(Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_cnd_swap</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_mul(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_sqr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_sqr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_powm(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_bitcnt_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_powm</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_tabselect(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_size_t)">mpn_sec_tabselect</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_div_qr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_div_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_div_r(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_div_r</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_invert(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_bitcnt_t,Math.Gmp.Native.mp_ptr)">mpn_sec_invert</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_functions_for_cryptography">Low-level functions for cryptography</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operands, and expected result.
            mp_ptr s1p = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
            mp_ptr s2p = new mp_ptr(new uint[] { 0x00000001, 0x00000000 });
            mp_ptr rp = new mp_ptr(new uint[2]);
            mp_ptr result = new mp_ptr(new uint[] { 0x00000000, 0x00000000 });
            
            // Set rp = s1 + s2.
            mp_limb_t carry = gmp_lib.mpn_cnd_add_n(1, rp, s1p, s2p, rp.Size);
            
            // Assert result of operation.
            Assert.IsTrue(carry == 1);
            Assert.IsTrue(rp.SequenceEqual(result));
            
            // Release unmanaged memory.
            gmp_lib.free(rp, s1p, s2p, result);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operands, and expected result.
            Dim s1p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
            Dim s2p As New mp_ptr(New UInteger() { &amp;H1, &amp;H0})
            Dim rp As New mp_ptr(New UInteger(1) { })
            Dim result As New mp_ptr(New UInteger() { &amp;H0, &amp;H0})
            
            ' Set rp = s1 + s2.
            Dim carry As mp_limb_t = gmp_lib.mpn_cnd_add_n(1, rp, s1p, s2p, rp.Size)
            
            ' Assert result of operation.
            Assert.IsTrue(carry = 1)
            Assert.IsTrue(rp.SequenceEqual(result))
            
            ' Release unmanaged memory.
            gmp_lib.free(rp, s1p, s2p, result)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_cnd_sub_n(Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">
            <summary>
            If <paramref name="cnd"/> is non-zero, it produces the same result as a regular <see cref="M:Math.Gmp.Native.gmp_lib.mpn_sub_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sub_n</see>, and if <paramref name="cnd"/> is zero, it copies {<paramref name="s1p"/>, <paramref name="n"/>} to the result area and returns zero.
            </summary>
            <param name="cnd">Conditonal value: non-zero for true, zero for false.</param>
            <param name="rp">The result integer.</param>
            <param name="s1p">The first operand integer.</param>
            <param name="s2p">The second operand integer.</param>
            <param name="n">The number of limbs of <paramref name="s1p"/> and <paramref name="s2p"/>.</param>
            <returns>If <paramref name="cnd"/> is non-zero, return borrow, either 0 or 1, and if <paramref name="cnd"/> is zero, return 0.</returns>
            <remarks>
            <para>
            This function does conditional addition.
            If <paramref name="cnd"/> is non-zero, it produces the same result as a regular <see cref="M:Math.Gmp.Native.gmp_lib.mpn_sub_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sub_n</see>,
            and if <paramref name="cnd"/> is zero, it copies {<paramref name="s1p"/>, <paramref name="n"/>} to the result area and returns zero.
            The functions is designed to have timing and memory access patterns depending only
            on size and location of the data areas, but independent of the condition <paramref name="cnd"/>.
            Like for <see cref="M:Math.Gmp.Native.gmp_lib.mpn_sub_n(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_sub_n</see>, on most machines, the timing will also be independent
            of the actual limb values. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_cnd_add_n(Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_cnd_add_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_add_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr)">mpn_sec_add_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_sub_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr)">mpn_sec_sub_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_cnd_swap(Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_cnd_swap</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_mul(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_sqr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_sqr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_powm(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_bitcnt_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_powm</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_tabselect(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_size_t)">mpn_sec_tabselect</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_div_qr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_div_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_div_r(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_div_r</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_invert(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_bitcnt_t,Math.Gmp.Native.mp_ptr)">mpn_sec_invert</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_functions_for_cryptography">Low-level functions for cryptography</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operands, and expected result.
            mp_ptr s1p = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
            mp_ptr s2p = new mp_ptr(new uint[] { 0x00000001, 0x00000000 });
            mp_ptr rp = new mp_ptr(new uint[2]);
            mp_ptr result = new mp_ptr(new uint[] { 0xfffffffe, 0xffffffff });
            
            // Set rp = s1 - s2.
            mp_limb_t borrow = gmp_lib.mpn_cnd_sub_n(1, rp, s1p, s2p, rp.Size);
            
            // Assert result of operation.
            Assert.IsTrue(borrow == 0);
            Assert.IsTrue(rp.SequenceEqual(result));
            
            // Release unmanaged memory.
            gmp_lib.free(rp, s1p, s2p, result);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operands, and expected result.
            Dim s1p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
            Dim s2p As New mp_ptr(New UInteger() { &amp;H1, &amp;H0})
            Dim rp As New mp_ptr(New UInteger(1) { })
            Dim result As New mp_ptr(New UInteger() { &amp;HfffffffeUI, &amp;HffffffffUI})
            
            ' Set rp = s1 - s2.
            Dim borrow As mp_limb_t = gmp_lib.mpn_cnd_sub_n(1, rp, s1p, s2p, rp.Size)
            
            ' Assert result of operation.
            Assert.IsTrue(borrow = 0)
            Assert.IsTrue(rp.SequenceEqual(result))
            
            ' Release unmanaged memory.
            gmp_lib.free(rp, s1p, s2p, result)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_sec_add_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr)">
            <summary>
            Set R to A + b, where R = {<paramref name="rp"/>, <paramref name="n"/>}, A = {<paramref name="ap"/>, <paramref name="n"/>}, and <paramref name="b"/> is a single limb.
            </summary>
            <param name="rp">The result integer.</param>
            <param name="ap">The first operand integer.</param>
            <param name="n">The number of limbs of <paramref name="ap"/> and <paramref name="rp"/>.</param>
            <param name="b">The second operand integer.</param>
            <param name="tp">The scratch operand integer.</param>
            <returns>Returns carry, either 0 or 1.</returns>
            <remarks>
            <para>
            This function takes O(N) time, unlike the leaky functions <see cref="M:Math.Gmp.Native.gmp_lib.mpn_add_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_add_1</see> which is O(1) on average.
            It requires scratch space of <see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_add_1_itch(Math.Gmp.Native.mp_size_t)">mpn_sec_add_1_itch</see>(n) limbs, to be passed in the <paramref name="tp"/> parameter.
            The scratch space requirements are guaranteed to be at most <paramref name="n"/> limbs, and increase monotonously in the operand size.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_cnd_add_n(Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_cnd_add_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_cnd_sub_n(Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_cnd_sub_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_add_1_itch(Math.Gmp.Native.mp_size_t)">mpn_sec_add_1_itch</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_sub_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr)">mpn_sec_sub_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_cnd_swap(Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_cnd_swap</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_mul(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_sqr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_sqr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_powm(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_bitcnt_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_powm</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_tabselect(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_size_t)">mpn_sec_tabselect</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_div_qr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_div_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_div_r(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_div_r</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_invert(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_bitcnt_t,Math.Gmp.Native.mp_ptr)">mpn_sec_invert</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_functions_for_cryptography">Low-level functions for cryptography</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operands, and expected result.
            mp_ptr ap = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
            mp_ptr result = new mp_ptr(new uint[] { 0x00000000, 0x00000000 });
            mp_ptr rp = new mp_ptr(result.Size);
            
            // Create scratch space.
            mp_size_t size = gmp_lib.mpn_sec_add_1_itch(ap.Size);
            mp_ptr tp = new mp_ptr(size);
            
            // Set rp = ap + 1.
            mp_limb_t carry = gmp_lib.mpn_sec_add_1(rp, ap, ap.Size, 1, tp);
            
            // Assert result of operation.
            Assert.IsTrue(carry == 1);
            Assert.IsTrue(rp.SequenceEqual(result));
            
            // Release unmanaged memory.
            gmp_lib.free(rp, ap, tp, result);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operands, and expected result.
            Dim ap As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
            Dim result As New mp_ptr(New UInteger() { &amp;H0, &amp;H0})
            Dim rp As New mp_ptr(result.Size)
            
            ' Create scratch space.
            Dim size As mp_size_t = gmp_lib.mpn_sec_add_1_itch(ap.Size)
            Dim tp As New mp_ptr(size)
            
            ' Set rp = ap + 1.
            Dim carry As mp_limb_t = gmp_lib.mpn_sec_add_1(rp, ap, ap.Size, 1, tp)
            
            ' Assert result of operation.
            Assert.IsTrue(carry = 1)
            Assert.IsTrue(rp.SequenceEqual(result))
            
            ' Release unmanaged memory.
            gmp_lib.free(rp, ap, tp, result)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_sec_add_1_itch(Math.Gmp.Native.mp_size_t)">
            <summary>
            Return the scratch space in number of limbs required by the function <see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_add_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr)">mpn_sec_add_1</see>.
            </summary>
            <param name="n">The number of limbs of the <see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_add_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr)">mpn_sec_add_1</see> operand.</param>
            <returns>The scratch space in number of limbs required by the function <see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_add_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr)">mpn_sec_add_1</see>.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_add_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr)">mpn_sec_add_1</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_functions_for_cryptography">Low-level functions for cryptography</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_sec_sub_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr)">
            <summary>
            Set R to A - b, where R = {<paramref name="rp"/>, <paramref name="n"/>}, A = {<paramref name="ap"/>, <paramref name="n"/>}, and <paramref name="b"/> is a single limb.
            </summary>
            <param name="rp">The result integer.</param>
            <param name="ap">The first operand integer.</param>
            <param name="n">The number of limbs of <paramref name="ap"/> and <paramref name="rp"/>.</param>
            <param name="b">The second operand integer.</param>
            <param name="tp">The scratch operand integer.</param>
            <returns>Returns borrow, either 0 or 1.</returns>
            <remarks>
            <para>
            This function takes O(N) time, unlike the leaky functions <see cref="M:Math.Gmp.Native.gmp_lib.mpn_sub_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t)">mpn_sub_1</see> which is O(1) on average.
            It requires scratch space of <see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_sub_1_itch(Math.Gmp.Native.mp_size_t)">mpn_sec_sub_1_itch</see>(n) limbs, to be passed in the <paramref name="tp"/> parameter.
            The scratch space requirements are guaranteed to be at most <paramref name="n"/> limbs, and increase monotonously in the operand size.
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_cnd_add_n(Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_cnd_add_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_cnd_sub_n(Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_cnd_sub_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_add_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr)">mpn_sec_add_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_sub_1_itch(Math.Gmp.Native.mp_size_t)">mpn_sec_sub_1_itch</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_cnd_swap(Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_cnd_swap</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_mul(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_sqr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_sqr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_powm(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_bitcnt_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_powm</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_tabselect(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_size_t)">mpn_sec_tabselect</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_div_qr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_div_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_div_r(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_div_r</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_invert(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_bitcnt_t,Math.Gmp.Native.mp_ptr)">mpn_sec_invert</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_functions_for_cryptography">Low-level functions for cryptography</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operands, and expected result.
            mp_ptr ap = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
            mp_ptr result = new mp_ptr(new uint[] { 0xfffffffe, 0xffffffff });
            mp_ptr rp = new mp_ptr(result.Size);
            
            // Create scratch space.
            mp_size_t size = gmp_lib.mpn_sec_sub_1_itch(ap.Size);
            mp_ptr tp = new mp_ptr(size);
            
            // Set rp = ap - 1.
            mp_limb_t borrow = gmp_lib.mpn_sec_sub_1(rp, ap, ap.Size, 1, tp);
            
            // Assert result of operation.
            Assert.IsTrue(borrow == 0);
            Assert.IsTrue(rp.SequenceEqual(result));
            
            // Release unmanaged memory.
            gmp_lib.free(rp, ap, tp, result);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operands, and expected result.
            Dim ap As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
            Dim result As New mp_ptr(New UInteger() { &amp;HfffffffeUI, &amp;HffffffffUI})
            Dim rp As New mp_ptr(result.Size)
            
            ' Create scratch space.
            Dim size As mp_size_t = gmp_lib.mpn_sec_sub_1_itch(ap.Size)
            Dim tp As New mp_ptr(size)
            
            ' Set rp = ap - 1.
            Dim borrow As mp_limb_t = gmp_lib.mpn_sec_sub_1(rp, ap, ap.Size, 1, tp)
            
            ' Assert result of operation.
            Assert.IsTrue(borrow = 0)
            Assert.IsTrue(rp.SequenceEqual(result))
            
            ' Release unmanaged memory.
            gmp_lib.free(rp, ap, tp, result)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_sec_sub_1_itch(Math.Gmp.Native.mp_size_t)">
            <summary>
            Return the scratch space in number of limbs required by the function <see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_sub_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr)">mpn_sec_sub_1</see>.
            </summary>
            <param name="n">The number of limbs of the <see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_sub_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr)">mpn_sec_sub_1</see> operand.</param>
            <returns>The scratch space in number of limbs required by the function <see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_sub_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr)">mpn_sec_sub_1</see>.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_sub_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr)">mpn_sec_sub_1</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_functions_for_cryptography">Low-level functions for cryptography</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_cnd_swap(Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">
            <summary>
            If <paramref name="cnd"/> is non-zero, swaps the contents of the areas {<paramref name="ap"/>, <paramref name="n"/>} and {<paramref name="bp"/>, <paramref name="n"/>}. Otherwise, the areas are left unmodified.
            </summary>
            <param name="cnd">Conditonal value: non-zero for true, zero for false.</param>
            <param name="ap">The first operand integer.</param>
            <param name="bp">The second operand integer.</param>
            <param name="n">The number of limbs of <paramref name="ap"/> and <paramref name="bp"/>.</param>
            <remarks>
            <para>
            Implemented using logical operations on the limbs, with the same memory accesses independent of the value of <paramref name="cnd"/>. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_cnd_add_n(Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_cnd_add_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_cnd_sub_n(Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_cnd_sub_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_add_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr)">mpn_sec_add_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_sub_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr)">mpn_sec_sub_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_mul(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_sqr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_sqr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_powm(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_bitcnt_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_powm</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_tabselect(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_size_t)">mpn_sec_tabselect</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_div_qr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_div_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_div_r(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_div_r</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_invert(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_bitcnt_t,Math.Gmp.Native.mp_ptr)">mpn_sec_invert</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_functions_for_cryptography">Low-level functions for cryptography</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operands, and expected result.
            mp_ptr ap = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
            mp_ptr bp = new mp_ptr(new uint[] { 0x00000001, 0x00000000 });
            mp_ptr a1p = new mp_ptr(new uint[] { 0x00000001, 0x00000000 });
            mp_ptr b1p = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
            
            // Exchange ab and bp.
            gmp_lib.mpn_cnd_swap(1, ap, bp, ap.Size);
            
            // Assert result of operation.
            Assert.IsTrue(ap.SequenceEqual(a1p));
            Assert.IsTrue(bp.SequenceEqual(b1p));
            
            // Release unmanaged memory.
            gmp_lib.free(ap, bp, a1p, b1p);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operands, and expected result.
            Dim ap As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
            Dim bp As New mp_ptr(New UInteger() { &amp;H1, &amp;H0})
            Dim a1p As New mp_ptr(New UInteger() { &amp;H1, &amp;H0})
            Dim b1p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
            
            ' Exchange ab and bp.
            gmp_lib.mpn_cnd_swap(1, ap, bp, ap.Size)
            
            ' Assert result of operation.
            Assert.IsTrue(ap.SequenceEqual(a1p))
            Assert.IsTrue(bp.SequenceEqual(b1p))
            
            ' Release unmanaged memory.
            gmp_lib.free(ap, bp, a1p, b1p)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_sec_mul(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">
            <summary>
            Set R to A * B, where A = {<paramref name="ap"/>, <paramref name="an"/>}, B = {<paramref name="bp"/>, <paramref name="bn"/>}, and R = {<paramref name="rp"/>, <paramref name="an"/> + <paramref name="bn"/>}. 
            </summary>
            <param name="rp">The result integer.</param>
            <param name="ap">The first operand integer.</param>
            <param name="an">The number of limbs of <paramref name="ap"/>.</param>
            <param name="bp">The second operand integer.</param>
            <param name="bn">The number of limbs of <paramref name="bp"/>.</param>
            <param name="tp">The scratch operand integer.</param>
            <remarks>
            <para>
            It is required that <paramref name="an"/> &#8805; bn &gt; 0. 
            </para>
            <para>
            No overlapping between R and the input operands is allowed.
            For A = B, use <see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_sqr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_sqr</see> for optimal performance. 
            </para>
            <para>
            This function requires scratch space of <see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_mul_itch(Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_size_t)">mpn_sec_mul_itch</see>(<paramref name="an"/>, <paramref name="bn"/>)
            limbs to be passed in the tp parameter. The scratch space requirements are guaranteed to increase monotonously in the operand sizes. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_cnd_add_n(Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_cnd_add_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_cnd_sub_n(Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_cnd_sub_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_add_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr)">mpn_sec_add_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_sub_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr)">mpn_sec_sub_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_cnd_swap(Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_cnd_swap</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_mul_itch(Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_size_t)">mpn_sec_mul_itch</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_sqr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_sqr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_powm(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_bitcnt_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_powm</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_tabselect(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_size_t)">mpn_sec_tabselect</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_div_qr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_div_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_div_r(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_div_r</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_invert(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_bitcnt_t,Math.Gmp.Native.mp_ptr)">mpn_sec_invert</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_functions_for_cryptography">Low-level functions for cryptography</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operands, and expected result.
            mp_ptr ap = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
            mp_ptr bp = new mp_ptr(new uint[] { 0x00000002 });
            mp_ptr result = new mp_ptr(new uint[] { 0xfffffffe, 0xffffffff, 0x00000001 });
            mp_ptr rp = new mp_ptr(ap.Size + bp.Size);
            
            // Create scratch space.
            mp_size_t size = gmp_lib.mpn_sec_mul_itch(ap.Size, bp.Size);
            mp_ptr tp = new mp_ptr(size);
            
            // Set rp = ap * bp.
            gmp_lib.mpn_sec_mul(rp, ap, ap.Size, bp, bp.Size, tp);
            
            // Assert result of operation.
            Assert.IsTrue(rp.SequenceEqual(result));
            
            // Release unmanaged memory.
            gmp_lib.free(rp, ap, bp, tp, result);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operands, and expected result.
            Dim ap As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
            Dim bp As New mp_ptr(New UInteger() { &amp;H2})
            Dim result As New mp_ptr(New UInteger() { &amp;HfffffffeUI, &amp;HffffffffUI, &amp;H1})
            Dim rp As New mp_ptr(ap.Size + bp.Size)
            
            ' Create scratch space.
            Dim size As mp_size_t = gmp_lib.mpn_sec_mul_itch(ap.Size, bp.Size)
            Dim tp As New mp_ptr(size)
            
            ' Set rp = ap * bp.
            gmp_lib.mpn_sec_mul(rp, ap, ap.Size, bp, bp.Size, tp)
            
            ' Assert result of operation.
            Assert.IsTrue(rp.SequenceEqual(result))
            
            ' Release unmanaged memory.
            gmp_lib.free(rp, ap, bp, tp, result)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_sec_mul_itch(Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_size_t)">
            <summary>
            Return the scratch space in number of limbs required by the function <see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_mul(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_mul</see>.
            </summary>
            <param name="an">The number of limbs of the <see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_mul(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_mul</see> first operand.</param>
            <param name="bn">The number of limbs of the <see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_mul(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_mul</see> second operand.</param>
            <returns>The scratch space in number of limbs required by the function <see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_mul(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_mul</see>.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_mul(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_mul</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_functions_for_cryptography">Low-level functions for cryptography</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_sec_sqr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">
            <summary>
            Set R to A^2, where A = {<paramref name="ap"/>, <paramref name="an"/>}, and R = {<paramref name="rp"/>, 2 * <paramref name="an"/>}. 
            </summary>
            <param name="rp">The result operand.</param>
            <param name="ap">The operand integer.</param>
            <param name="an">The number of limbs of <paramref name="ap"/>.</param>
            <param name="tp">The scratch operand integer.</param>
            <remarks>
            <para>
            It is required that <paramref name="an"/> &gt; 0. 
            </para>
            <para>
            No overlapping between R and the input operands is allowed. 
            </para>
            <para>
            This function requires scratch space of <see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_sqr_itch(Math.Gmp.Native.mp_size_t)">mpn_sec_sqr_itch</see>(<paramref name="an"/>)
            limbs to be passed in the <paramref name="tp"/> parameter.
            The scratch space requirements are guaranteed to increase monotonously in the operand size. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_cnd_add_n(Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_cnd_add_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_cnd_sub_n(Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_cnd_sub_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_add_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr)">mpn_sec_add_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_sub_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr)">mpn_sec_sub_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_cnd_swap(Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_cnd_swap</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_mul(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_sqr_itch(Math.Gmp.Native.mp_size_t)">mpn_sec_sqr_itch</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_powm(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_bitcnt_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_powm</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_tabselect(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_size_t)">mpn_sec_tabselect</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_div_qr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_div_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_div_r(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_div_r</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_invert(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_bitcnt_t,Math.Gmp.Native.mp_ptr)">mpn_sec_invert</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_functions_for_cryptography">Low-level functions for cryptography</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operands, and expected result.
            mp_ptr ap = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
            mp_ptr result = new mp_ptr(new uint[] { 0x00000001, 0x00000000, 0xfffffffe, 0xffffffff });
            mp_ptr rp = new mp_ptr(2 * ap.Size);
            
            // Create scratch space.
            mp_size_t size = gmp_lib.mpn_sec_sqr_itch(ap.Size);
            mp_ptr tp = new mp_ptr(size);
            
            // Set rp = s1^2.
            gmp_lib.mpn_sec_sqr(rp, ap, ap.Size, tp);
            
            // Assert result of operation.
            Assert.IsTrue(rp.SequenceEqual(result));
            
            // Release unmanaged memory.
            gmp_lib.free(rp, ap, tp, result);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operands, and expected result.
            Dim ap As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
            Dim result As New mp_ptr(New UInteger() { &amp;H1, &amp;H0, &amp;HfffffffeUI, &amp;HffffffffUI})
            Dim rp As New mp_ptr(2 * ap.Size)
            
            ' Create scratch space.
            Dim size As mp_size_t = gmp_lib.mpn_sec_sqr_itch(ap.Size)
            Dim tp As New mp_ptr(size)
            
            ' Set rp = s1^2.
            gmp_lib.mpn_sec_sqr(rp, ap, ap.Size, tp)
            
            ' Assert result of operation.
            Assert.IsTrue(rp.SequenceEqual(result))
            
            ' Release unmanaged memory.
            gmp_lib.free(rp, ap, tp, result)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_sec_sqr_itch(Math.Gmp.Native.mp_size_t)">
            <summary>
            Return the scratch space in number of limbs required by the function <see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_sqr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_sqr</see>.
            </summary>
            <param name="an">The number of limbs of the <see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_sqr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_sqr</see> operand.</param>
            <returns>The scratch space in number of limbs required by the function <see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_sqr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_sqr</see>.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_sqr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_sqr</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_functions_for_cryptography">Low-level functions for cryptography</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_sec_powm(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_bitcnt_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">
            <summary>
            Set R to (B^E) modulo M, where R = {<paramref name="rp"/>, <paramref name="n"/>}, M = {<paramref name="mp"/>, <paramref name="n"/>}, and E = {<paramref name="ep"/>, ceil(<paramref name="enb"/> / <see cref="F:Math.Gmp.Native.gmp_lib.mp_bits_per_limb">mp_bits_per_limb</see>)}. 
            </summary>
            <param name="rp">The result operand.</param>
            <param name="bp">The first operand integer.</param>
            <param name="bn">The number of limbs of <paramref name="bp"/>.</param>
            <param name="ep">The second operand integer.</param>
            <param name="enb">The number of limbs of <paramref name="ep"/>.</param>
            <param name="mp">The third operand integer.</param>
            <param name="n">The number of limbs of <paramref name="mp"/>.</param>
            <param name="tp">The scratch operand integer.</param>
            <remarks>
            <para>
            It is required that B &gt; 0, that M &gt; 0 is odd, and that E &lt; 2^<paramref name="enb"/>.
            </para>
            <para>
            No overlapping between R and the input operands is allowed. 
            </para>
            <para>
            This function requires scratch space of <see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_powm_itch(Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_bitcnt_t,Math.Gmp.Native.mp_size_t)">mpn_sec_powm_itch</see>(<paramref name="bn"/>, <paramref name="enb"/>, <paramref name="n"/>)
            limbs to be passed in the <paramref name="tp"/> parameter.
            The scratch space requirements are guaranteed to increase monotonously in the operand sizes. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_cnd_add_n(Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_cnd_add_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_cnd_sub_n(Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_cnd_sub_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_add_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr)">mpn_sec_add_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_sub_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr)">mpn_sec_sub_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_cnd_swap(Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_cnd_swap</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_mul(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_sqr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_sqr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_powm_itch(Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_bitcnt_t,Math.Gmp.Native.mp_size_t)">mpn_sec_powm_itch</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_tabselect(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_size_t)">mpn_sec_tabselect</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_div_qr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_div_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_div_r(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_div_r</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_invert(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_bitcnt_t,Math.Gmp.Native.mp_ptr)">mpn_sec_invert</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_functions_for_cryptography">Low-level functions for cryptography</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operands, and expected result.
            mp_ptr bp = new mp_ptr(new uint[] { 0x00000002 });
            mp_ptr ep = new mp_ptr(new uint[] { 0x00000004 });
            mp_ptr mp = new mp_ptr(new uint[] { 0x00000003 });
            mp_ptr result = new mp_ptr(new uint[] { 0x00000001 });
            mp_ptr rp = new mp_ptr(bp.Size);
            
            // Create scratch space.
            mp_size_t size = gmp_lib.mpn_sec_powm_itch(bp.Size, 3, mp.Size);
            mp_ptr tp = new mp_ptr(size);
            
            // Set rp = bp^ep mod mp.
            gmp_lib.mpn_sec_powm(rp, bp, bp.Size, ep, 3, mp, mp.Size, tp);
            
            // Assert result of operation.
            Assert.IsTrue(rp.SequenceEqual(result));
            
            // Release unmanaged memory.
            gmp_lib.free(rp, bp, ep, mp, tp, result);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operands, and expected result.
            Dim bp As New mp_ptr(New UInteger() { &amp;H2})
            Dim ep As New mp_ptr(New UInteger() { &amp;H4})
            Dim mp As New mp_ptr(New UInteger() { &amp;H3})
            Dim result As New mp_ptr(New UInteger() { &amp;H1})
            Dim rp As New mp_ptr(bp.Size)
            
            ' Create scratch space.
            Dim size As mp_size_t = gmp_lib.mpn_sec_powm_itch(bp.Size, 3, mp.Size)
            Dim tp As New mp_ptr(size)
            
            ' Set rp = bp^ep mod mp.
            gmp_lib.mpn_sec_powm(rp, bp, bp.Size, ep, 3, mp, mp.Size, tp)
            
            ' Assert result of operation.
            Assert.IsTrue(rp.SequenceEqual(result))
            
            ' Release unmanaged memory.
            gmp_lib.free(rp, bp, ep, mp, tp, result)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_sec_powm_itch(Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_bitcnt_t,Math.Gmp.Native.mp_size_t)">
            <summary>
            Return the scratch space in number of limbs required by the function <see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_powm(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_bitcnt_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_powm</see>.
            </summary>
            <param name="bn">The number of limbs of the <see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_powm(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_bitcnt_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_powm</see> first operand.</param>
            <param name="enb">The number of limbs of the <see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_powm(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_bitcnt_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_powm</see> second operand.</param>
            <param name="n">The number of limbs of the <see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_powm(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_bitcnt_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_powm</see> third operand.</param>
            <returns>The scratch space in number of limbs required by the function <see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_powm(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_bitcnt_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_powm</see>.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_powm(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_bitcnt_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_powm</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_functions_for_cryptography">Low-level functions for cryptography</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_sec_tabselect(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_size_t)">
            <summary>
            Select entry <paramref name="which"/> from table <paramref name="tab"/>, which has <paramref name="nents"/> entries, each <paramref name="n"/> limbs. Store the selected entry at <paramref name="rp"/>.
            </summary>
            <param name="rp">The result integer.</param>
            <param name="tab">The table of operand integers.</param>
            <param name="n">The number of limbs in each entry of the table.</param>
            <param name="nents">The number of entries in the table.</param>
            <param name="which">The zero-based index of the entry to select.</param>
            <remarks>
            <para>
            This function reads the entire table to avoid side-channel information leaks. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_cnd_add_n(Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_cnd_add_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_cnd_sub_n(Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_cnd_sub_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_add_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr)">mpn_sec_add_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_sub_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr)">mpn_sec_sub_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_cnd_swap(Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_cnd_swap</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_mul(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_sqr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_sqr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_powm(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_bitcnt_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_powm</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_powm_itch(Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_bitcnt_t,Math.Gmp.Native.mp_size_t)">mpn_sec_powm_itch</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_div_qr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_div_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_div_r(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_div_r</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_invert(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_bitcnt_t,Math.Gmp.Native.mp_ptr)">mpn_sec_invert</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_functions_for_cryptography">Low-level functions for cryptography</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operands, and expected result.
            mp_ptr tab = new mp_ptr(new uint[] { 0x11111111, 0x22222222, 0x33333333, 0x44444444, 0x33333333, 0x00000000 });
            mp_ptr result = new mp_ptr(new uint[] { 0x33333333 });
            mp_ptr rp = new mp_ptr(result.Size);
            
            // Set rp to third entry in tab.
            gmp_lib.mpn_sec_tabselect(rp, tab, 1, tab.Size, 2);
            
            // Assert result of operation.
            Assert.IsTrue(rp.SequenceEqual(result));
            
            // Release unmanaged memory.
            gmp_lib.free(tab, result);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operands, and expected result.
            Dim tab As New mp_ptr(New UInteger() { &amp;H11111111, &amp;H22222222, &amp;H33333333, &amp;H44444444, &amp;H33333333, &amp;H0})
            Dim result As New mp_ptr(New UInteger() { &amp;H33333333})
            Dim rp As New mp_ptr(result.Size)
            
            ' Set rp to third entry in tab.
            gmp_lib.mpn_sec_tabselect(rp, tab, 1, tab.Size, 2)
            
            ' Assert result of operation.
            Assert.IsTrue(rp.SequenceEqual(result))
            
            ' Release unmanaged memory.
            gmp_lib.free(tab, result)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_sec_div_qr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">
            <summary>
            Set Q to the truncated quotient N / D and R to N modulo D, where N = {<paramref name="np"/>, <paramref name="nn"/>}, D = {<paramref name="dp"/>, <paramref name="dn"/>}, Q’s most significant limb is the function return value and the remaining limbs are {<paramref name="qp"/>, <paramref name="nn"/> - <paramref name="dn"/>}, and R = {<paramref name="np"/>, <paramref name="dn"/>}. 
            </summary>
            <param name="qp">The quotient result operand.</param>
            <param name="np">The first operand and remainder result integer.</param>
            <param name="nn">The number of limbs of <paramref name="np"/>.</param>
            <param name="dp">The second operand integer.</param>
            <param name="dn">The number of limbs of <paramref name="dp"/>.</param>
            <param name="tp">The scratch operand integer.</param>
            <returns>Q’s most significant limb.</returns>
            <remarks>
            <para>
            It is required that <paramref name="nn"/> &#8805; <paramref name="dn"/> &#8805; 1, and that <paramref name="dp"/>[<paramref name="dn"/> - 1] &#8800; 0.
            This does not imply that N &#8805; D since N might be zero-padded. 
            </para>
            <para>
            Note the overlapping between N and R.
            No other operand overlapping is allowed.
            The entire space occupied by N is overwritten. 
            </para>
            <para>
            This function requires scratch space of <see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_div_qr_itch(Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_size_t)">mpn_sec_div_qr_itch</see>(<paramref name="nn"/>, <paramref name="dn"/>)
            limbs to be passed in the <paramref name="tp"/> parameter. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_cnd_add_n(Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_cnd_add_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_cnd_sub_n(Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_cnd_sub_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_add_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr)">mpn_sec_add_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_sub_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr)">mpn_sec_sub_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_cnd_swap(Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_cnd_swap</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_mul(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_sqr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_sqr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_powm(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_bitcnt_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_powm</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_tabselect(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_size_t)">mpn_sec_tabselect</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_div_qr_itch(Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_size_t)">mpn_sec_div_qr_itch</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_div_r(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_div_r</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_invert(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_bitcnt_t,Math.Gmp.Native.mp_ptr)">mpn_sec_invert</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_functions_for_cryptography">Low-level functions for cryptography</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operands, and expected result.
            mp_ptr np = new mp_ptr(new uint[] { 0xffffffff, 0x0000ffff });
            mp_ptr dp = new mp_ptr(new uint[] { 0x00000003 });
            mp_ptr remainder = new mp_ptr(new uint[] { 0x00000000 });
            mp_ptr qp = new mp_ptr(new uint[np.Size]);
            
            // Create scratch space.
            mp_size_t size = gmp_lib.mpn_sec_div_qr_itch(np.Size, dp.Size);
            mp_ptr tp = new mp_ptr(size);
            
            // Set qp = floor(np / dp) and rp = np mod dp.
            mp_limb_t mslimb = gmp_lib.mpn_sec_div_qr(qp, np, np.Size, dp, dp.Size, tp);
            
            // Assert result of operation.
            Assert.IsTrue(mslimb == (ulong)(gmp_lib.mp_bytes_per_limb == 4 ? 0x00005555 : 0x0000555555555555));
            Assert.IsTrue(qp[0] == (ulong)(gmp_lib.mp_bytes_per_limb == 4 ? 0x55555555 : 0x0000000000000000));
            Assert.IsTrue(np[0] == remainder[0]);
            
            // Release unmanaged memory.
            gmp_lib.free(qp, np, dp, remainder, tp);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operands, and expected result.
            Dim np As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;Hffff})
            Dim dp As New mp_ptr(New UInteger() { &amp;H3})
            Dim remainder As New mp_ptr(New UInteger() { &amp;H0})
            Dim qp As New mp_ptr(New UInteger(np.Size - 1) { })
            
            ' Create scratch space.
            Dim size As mp_size_t = gmp_lib.mpn_sec_div_qr_itch(np.Size, dp.Size)
            Dim tp As New mp_ptr(size)
            
            ' Set qp = floor(np / dp) and rp = np mod dp.
            Dim mslimb As mp_limb_t = gmp_lib.mpn_sec_div_qr(qp, np, np.Size, dp, dp.Size, tp)
            
            ' Assert result of operation.
            Assert.IsTrue(mslimb = CULng(If(gmp_lib.mp_bytes_per_limb = 4, &amp;H5555, &amp;H555555555555L)))
            Assert.IsTrue(qp(0) = CULng(If(gmp_lib.mp_bytes_per_limb = 4, &amp;H55555555, &amp;H0)))
            Assert.IsTrue(np(0) = remainder(0))
            
            ' Release unmanaged memory.
            gmp_lib.free(qp, np, dp, remainder, tp)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_sec_div_qr_itch(Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_size_t)">
            <summary>
            Return the scratch space in number of limbs required by the function <see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_div_qr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_div_qr</see>.
            </summary>
            <param name="nn">The number of limbs of the <see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_div_qr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_div_qr</see> first operand.</param>
            <param name="dn">The number of limbs of the <see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_div_qr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_div_qr</see> second operand.</param>
            <returns>The scratch space in number of limbs required by the function <see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_div_qr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_div_qr</see>.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_div_qr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_div_qr</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_functions_for_cryptography">Low-level functions for cryptography</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_sec_div_r(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">
            <summary>
            Set R to N modulo D, where N = {<paramref name="np"/>, <paramref name="nn"/>}, D = {<paramref name="dp"/>, <paramref name="dn"/>}, and R = {<paramref name="np"/>, <paramref name="dn"/>}. 
            </summary>
            <param name="np">The first operand and result integer.</param>
            <param name="nn">The number of limbs of <paramref name="np"/>.</param>
            <param name="dp">The second operand integer</param>
            <param name="dn">The number of limbs of <paramref name="dp"/>.</param>
            <param name="tp">The scratch operand integer.</param>
            <remarks>
            <para>
            It is required that <paramref name="nn"/> &#8805; <paramref name="dn"/> &#8805; 1,
            and that <paramref name="dp"/>[<paramref name="dn"/> - 1] &#8800; 0.
            This does not imply that N &#8805; D since N might be zero-padded. 
            </para>
            <para>
            Note the overlapping between N and R.
            No other operand overlapping is allowed.
            The entire space occupied by N is overwritten. 
            </para>
            <para>
            This function requires scratch space of <see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_div_r_itch(Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_size_t)">mpn_sec_div_r_itch</see>(<paramref name="nn"/>, <paramref name="dn"/>)
            limbs to be passed in the <paramref name="tp"/> parameter. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_cnd_add_n(Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_cnd_add_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_cnd_sub_n(Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_cnd_sub_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_add_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr)">mpn_sec_add_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_sub_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr)">mpn_sec_sub_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_cnd_swap(Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_cnd_swap</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_mul(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_sqr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_sqr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_powm(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_bitcnt_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_powm</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_tabselect(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_size_t)">mpn_sec_tabselect</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_div_qr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_div_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_div_r_itch(Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_size_t)">mpn_sec_div_r_itch</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_invert(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_bitcnt_t,Math.Gmp.Native.mp_ptr)">mpn_sec_invert</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_functions_for_cryptography">Low-level functions for cryptography</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operands, and expected result.
            mp_ptr np = new mp_ptr(new uint[] { 0xffffffff, 0x0000ffff });
            mp_ptr dp = new mp_ptr(new uint[] { 0x00000004 });
            
            // Create scratch space.
            mp_size_t size = gmp_lib.mpn_sec_div_r_itch(np.Size, dp.Size);
            mp_ptr tp = new mp_ptr(size);
            
            // Set np = np mod dp.
            gmp_lib.mpn_sec_div_r(np, np.Size, dp, dp.Size, tp);
            
            // Assert result of operation.
            Assert.IsTrue(np[0] == 3);
            
            // Release unmanaged memory.
            gmp_lib.free(np, dp, tp);
            </code> 
            <code language="VB.NET">
            ' Create multi-precision operands, and expected result.
            Dim np As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;Hffff})
            Dim dp As New mp_ptr(New UInteger() { &amp;H4})
            
            ' Create scratch space.
            Dim size As mp_size_t = gmp_lib.mpn_sec_div_r_itch(np.Size, dp.Size)
            Dim tp As New mp_ptr(size)
            
            ' Set np = np mod dp.
            gmp_lib.mpn_sec_div_r(np, np.Size, dp, dp.Size, tp)
            
            ' Assert result of operation.
            Assert.IsTrue(np(0) = 3)
            
            ' Release unmanaged memory.
            gmp_lib.free(np, dp, tp)
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_sec_div_r_itch(Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_size_t)">
            <summary>
            Return the scratch space in number of limbs required by the function <see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_div_r(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_div_r</see>.
            </summary>
            <param name="nn">The number of limbs of the <see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_div_r(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_div_r</see> first operand.</param>
            <param name="dn">The number of limbs of the <see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_div_r(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_div_r</see> second operand.</param>
            <returns>The scratch space in number of limbs required by the function <see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_div_r(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_div_r</see>.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_div_r(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_div_r</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_functions_for_cryptography">Low-level functions for cryptography</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_sec_invert(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_bitcnt_t,Math.Gmp.Native.mp_ptr)">
            <summary>
            Set R to the inverse of A modulo M, where R = {<paramref name="rp"/>, <paramref name="n"/>}, A = {<paramref name="ap"/>, <paramref name="n"/>}, and M = {<paramref name="mp"/>, <paramref name="n"/>}. This function’s interface is preliminary. 
            </summary>
            <param name="rp">The result integer.</param>
            <param name="ap">The first operand integer.</param>
            <param name="mp">The second operand integer.</param>
            <param name="n">The number of limbs of <paramref name="ap"/> and <paramref name="mp"/>.</param>
            <param name="nbcnt">The third operand integer.</param>
            <param name="tp">The scratch operand integer.</param>
            <returns>If an inverse exists, return 1, otherwise return 0 and leave R undefined.</returns>
            <remarks>
            <para>
            If an inverse exists, return 1, otherwise return 0 and leave R undefined.
            In either case, the input A is destroyed. 
            </para>
            <para>
            It is required that M is odd, and that <paramref name="nbcnt"/> &#8805; ceil(log(A + 1)) + ceil(log(M + 1)).
            A safe choice is <paramref name="nbcnt"/> = 2 * <paramref name="n"/> * <see cref="F:Math.Gmp.Native.gmp_lib.mp_bits_per_limb">mp_bits_per_limb</see>,
            but a smaller value might improve performance if M or A are known to have leading zero bits. 
            </para>
            <para>
            This function requires scratch space of <see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_invert_itch(Math.Gmp.Native.mp_size_t)">mpn_sec_invert_itch</see>(<paramref name="n"/>)
            limbs to be passed in the <paramref name="tp"/> parameter. 
            </para>
            </remarks>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_cnd_add_n(Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_cnd_add_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_cnd_sub_n(Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_cnd_sub_n</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_add_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr)">mpn_sec_add_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_sub_1(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr)">mpn_sec_sub_1</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_cnd_swap(Math.Gmp.Native.mp_limb_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t)">mpn_cnd_swap</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_mul(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_mul</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_sqr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_sqr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_powm(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_bitcnt_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_powm</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_tabselect(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_size_t)">mpn_sec_tabselect</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_div_qr(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_div_qr</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_div_r(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_ptr)">mpn_sec_div_r</seealso>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_invert_itch(Math.Gmp.Native.mp_size_t)">mpn_sec_invert_itch</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_functions_for_cryptography">Low-level functions for cryptography</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
            <example>
            <code language="C#">
            // Create multi-precision operands, and expected result.
            mp_ptr ap = new mp_ptr(new uint[] { 3 });
            mp_ptr mp = new mp_ptr(new uint[] { 11 });
            mp_ptr rp = new mp_ptr(ap.Size);
            mp_ptr result = new mp_ptr(new uint[] { 4 });
            
            // Create scratch space.
            mp_size_t size = gmp_lib.mpn_sec_invert_itch(ap.Size);
            mp_ptr tp = new mp_ptr(size);
            
            // Set rp = ap^-1 mod mp.
            gmp_lib.mpn_sec_invert(rp, ap, mp, ap.Size, (uint)(2 * ap.Size* gmp_lib.mp_bits_per_limb), tp);
            
            // Assert result of operation.
            Assert.IsTrue(rp[0] == result[0]);
            
            // Release unmanaged memory.
            gmp_lib.free(ap, mp, rp, result, tp);
            </code> 
            <code language="VB.NET">
            </code> 
            </example>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.mpn_sec_invert_itch(Math.Gmp.Native.mp_size_t)">
            <summary>
            Return the scratch space in number of limbs required by the function <see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_invert(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_bitcnt_t,Math.Gmp.Native.mp_ptr)">mpn_sec_invert</see>.
            </summary>
            <param name="n">The number of limbs of the <see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_invert(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_bitcnt_t,Math.Gmp.Native.mp_ptr)">mpn_sec_invert</see> first operand.</param>
            <returns>The scratch space in number of limbs required by the function <see cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_invert(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_bitcnt_t,Math.Gmp.Native.mp_ptr)">mpn_sec_invert</see>.</returns>
            <seealso cref="M:Math.Gmp.Native.gmp_lib.mpn_sec_invert(Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_ptr,Math.Gmp.Native.mp_size_t,Math.Gmp.Native.mp_bitcnt_t,Math.Gmp.Native.mp_ptr)">mpn_sec_invert</seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="/html/3af6b34c-3242-2b75-e7c7-ab79af8a4b0f.htm#Low_level_functions_for_cryptography">Low-level functions for cryptography</a></seealso>
            <seealso cref="T:Math.Gmp.Native.gmp_lib"><a href="https://gmplib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MP - Low-level Functions</a></seealso>
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.SafeNativeMethods.__gmp_randinit_default(System.IntPtr)">
            * obsolete */
        </member>
        <member name="M:Math.Gmp.Native.gmp_lib.SafeNativeMethods.__gmpn_random(System.IntPtr,System.Int32)">
            * undocumented now, but retained here for upward compatibility */
        </member>
        <member name="T:Math.Gmp.Native.mpf_t">
            <summary>
            Represents a multiple precision floating-point number.
            </summary>
            <remarks>
            <para>
            The floating point functions accept and return exponents in the C type <see cref="T:Math.Gmp.Native.mp_exp_t">mp_exp_t</see>.
            Currently this is usually a long, but on some systems it’s an int for efficiency.
            </para>
            <para>
            In .NET, this is a 32-bit integer.
            </para>
            </remarks>
            <seealso cref="T:Math.Gmp.Native.mp_exp_t">mp_exp_t</seealso>
            <seealso cref="T:Math.Gmp.Native.mp_limb_t">mp_limb_t</seealso>
            <seealso cref="T:Math.Gmp.Native.mpq_t">mpq_t</seealso>
            <seealso cref="T:Math.Gmp.Native.mpz_t">mpz_t</seealso>
        </member>
        <member name="P:Math.Gmp.Native.mpf_t._mp_size">
            <summary>
            The number of limbs currently in use, or the negative of that when representing a negative value.
            </summary>
            <remarks>
            <para>
            Zero is represented by <see cref="P:Math.Gmp.Native.mpf_t._mp_size">_mp_size</see> and <see cref="P:Math.Gmp.Native.mpf_t._mp_exp">_mp_exp</see> both set to zero,
            and in that case the <see cref="P:Math.Gmp.Native.mp_base._mp_d">mp_base._mp_d</see> data is unused.
            (In the future <see cref="P:Math.Gmp.Native.mpf_t._mp_exp">_mp_exp</see> might be undefined when representing zero.) 
            </para>
            </remarks>
        </member>
        <member name="P:Math.Gmp.Native.mpf_t._mp_prec">
            <summary>
            The precision of the mantissa, in limbs.
            </summary>
            <remarks>
            <para>
             In any calculation the aim is to produce <see cref="P:Math.Gmp.Native.mpf_t._mp_prec">_mp_prec</see> limbs of result (the most significant being non-zero). 
            </para>
            </remarks>
        </member>
        <member name="P:Math.Gmp.Native.mpf_t._mp_exp">
            <summary>
            The exponent, in limbs, determining the location of the implied radix point.
            </summary>
            <remarks>
            <para>
            Zero means the radix point is just above the most significant limb.
            Positive values mean a radix point offset towards the lower limbs and hence a value &#8805; 1, as for example in the diagram above.
            Negative exponents mean a radix point further above the highest limb. 
            </para>
            <para>
            Naturally the exponent can be any value, it doesn’t have to fall within the limbs as the diagram shows,
            it can be a long way above or a long way below.
            Limbs other than those included in the {<see cref="P:Math.Gmp.Native.mp_base._mp_d">mp_base._mp_d</see>, <see cref="P:Math.Gmp.Native.mpf_t._mp_size">_mp_size</see>} data are treated as zero.
            </para>
            </remarks>
        </member>
        <member name="P:Math.Gmp.Native.mpf_t._mp_d_intptr">
            <summary>
            Gets or sets the pointer to the significand array of limbs of the floating-point number.
            </summary>
        </member>
        <member name="M:Math.Gmp.Native.mpf_t.ToIntPtr">
            <summary>
            Gets the unmanaged memory pointer of the multiple precision floating-point number.
            </summary>
            <returns>The unmanaged memory pointer of the multiple precision floating-point number.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mpf_t.op_Implicit(System.String)~Math.Gmp.Native.mpf_t">
            <summary>
            Converts a <see cref="T:System.String">string</see> value to an <see cref="T:Math.Gmp.Native.mpf_t">mpf_t</see> value.
            </summary>
            <param name="value">A <see cref="T:System.String">string</see> value.</param>
            <returns>An <see cref="T:Math.Gmp.Native.mpf_t">mpf_t</see> value.</returns>
            <remarks>
            <para>
            Base is assumed to be 10 unless the first character of the string is <c>B</c>
            followed by the base <c>2</c> to <c>62</c> or <c>-62</c> to <c>-2</c> followed
            by a space and then the floating-point number.
            Negative values are used to specify that the exponent is in decimal.
            </para>
            </remarks>
        </member>
        <member name="M:Math.Gmp.Native.mpf_t.ToString">
            <summary>
            Return the string representation of the float.
            </summary>
            <returns>The string representation of the float.</returns>
        </member>
        <member name="T:Math.Gmp.Native.mpq_t">
            <summary>
            Represents a multiple precision rational number.
            </summary>
            <remarks></remarks>
            <seealso cref="T:Math.Gmp.Native.mpf_t">mpf_t</seealso>
            <seealso cref="T:Math.Gmp.Native.mpz_t">mpz_t</seealso>
        </member>
        <member name="M:Math.Gmp.Native.mpq_t.#ctor">
            <summary>
            Creates a new multiple precision rational.
            </summary>
        </member>
        <member name="P:Math.Gmp.Native.mpq_t._mp_num">
            <summary>
            Get the numerator integer of the rational.
            </summary>
            <returns>The numerator integer of the rational.</returns>
        </member>
        <member name="P:Math.Gmp.Native.mpq_t._mp_den">
            <summary>
            Get the denominator integer of the rational.
            </summary>
            <returns>The denominator integer of the rational.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mpq_t.ToIntPtr">
            <summary>
            Gets the unmanaged memory pointer of the multiple precision rational.
            </summary>
            <returns>The unmanaged memory pointer of the multiple precision rational.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mpq_t.op_Implicit(System.String)~Math.Gmp.Native.mpq_t">
            <summary>
            Converts a <see cref="T:System.String">string</see> value to an <see cref="T:Math.Gmp.Native.mpq_t">mpq_t</see> value.
            </summary>
            <param name="value">A <see cref="T:System.String">string</see> value.</param>
            <returns>An <see cref="T:Math.Gmp.Native.mpq_t">mpq_t</see> value.</returns>
            <remarks>
            <para>
            The leading characters are used: <c>0x</c> and <c>0X</c> for hexadecimal,
            <c>0b</c> and <c>0B</c> for binary, <c>0</c> for octal, or decimal otherwise.
            Note that this is done separately for the numerator and denominator, so for
            instance <c>0xEF/100</c> is <c>239/100</c>, whereas <c>0xEF/0x100</c> is
            <c>239/256</c>.
            </para>
            </remarks>
        </member>
        <member name="M:Math.Gmp.Native.mpq_t.ToString">
            <summary>
            Return the string representation of the rational.
            </summary>
            <returns>The string representation of the rational.</returns>
        </member>
        <member name="T:Math.Gmp.Native.gmp_randstate_t">
            <summary>
            Represents the state of a random number generator.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Math.Gmp.Native.gmp_randstate_t.#ctor">
            <summary>
            Creates a new random number generator state.
            </summary>
            <remarks>
            <para>
            When done with the random number generator state, unmanaged memory must be released with <see cref="M:Math.Gmp.Native.gmp_lib.free(Math.Gmp.Native.gmp_randstate_t)">free</see>.
            </para>
            </remarks>
        </member>
        <member name="M:Math.Gmp.Native.gmp_randstate_t.ToIntPtr">
            <summary>
            Get unmanaged memory pointer to the state of a random number generator.
            </summary>
            <returns>The unmanaged memory pointer to the state of a random number generator.</returns>
        </member>
        <member name="T:Math.Gmp.Native.mpz_t">
            <summary>
            Represents a multiple precision integer.
            </summary>
            <remarks></remarks>
            <seealso cref="T:Math.Gmp.Native.mp_limb_t">mp_limb_t</seealso>
            <seealso cref="T:Math.Gmp.Native.mpf_t">mpf_t</seealso>
            <seealso cref="T:Math.Gmp.Native.mpq_t">mpq_t</seealso>
        </member>
        <member name="M:Math.Gmp.Native.mpz_t.#ctor">
            <summary>
            Creates a new multiple precision integer.
            </summary>
        </member>
        <member name="P:Math.Gmp.Native.mpz_t._mp_alloc">
            <summary>
            The number of limbs currently allocated at <see cref="P:Math.Gmp.Native.mp_base._mp_d">mp_base._mp_d</see>.
            </summary>
            <remarks>
            <para>
            <see cref="P:Math.Gmp.Native.mpz_t._mp_alloc">mpz_t._mp_alloc</see> is the number of limbs currently allocated at <see cref="P:Math.Gmp.Native.mp_base._mp_d">mp_base._mp_d</see>,
            and naturally <see cref="P:Math.Gmp.Native.mpz_t._mp_alloc">mpz_t._mp_alloc</see> >= ABS(<see cref="P:Math.Gmp.Native.mpz_t._mp_size">mpz_t._mp_size</see>).
            When an mpz routine is about to (or might be about to) increase <see cref="P:Math.Gmp.Native.mpz_t._mp_size">mpz_t._mp_size</see>, it checks
            <see cref="P:Math.Gmp.Native.mpz_t._mp_alloc">mpz_t._mp_alloc</see> to see whether there’s enough space, and reallocates if not.
            </para>
            </remarks>
        </member>
        <member name="P:Math.Gmp.Native.mpz_t._mp_size">
            <summary>
            The number of limbs, or the negative of that when representing a negative integer.
            </summary>
            <remarks>
            <para>
            The number of limbs, or the negative of that when representing a negative integer.
            Zero is represented by <see cref="P:Math.Gmp.Native.mp_base._mp_size">mp_base._mp_size</see> set to zero, in which case
            the <see cref="P:Math.Gmp.Native.mp_base._mp_d">mp_base._mp_d</see> data is unused.
            </para>
            </remarks>
        </member>
        <member name="P:Math.Gmp.Native.mpz_t._mp_d_intptr">
            <summary>
            Gets or sets the pointer to the array of limbs of the integer.
            </summary>
        </member>
        <member name="M:Math.Gmp.Native.mpz_t.ToIntPtr">
            <summary>
            Gets the unmanaged memory pointer of the multiple precision integer.
            </summary>
            <returns>The unmanaged memory pointer of the multiple precision integer.</returns>
        </member>
        <member name="M:Math.Gmp.Native.mpz_t.op_Implicit(System.String)~Math.Gmp.Native.mpz_t">
            <summary>
            Converts a <see cref="T:System.String">string</see> value to an <see cref="T:Math.Gmp.Native.mpz_t">mpz_t</see> value.
            </summary>
            <param name="value">A <see cref="T:System.String">string</see> value.</param>
            <returns>An <see cref="T:Math.Gmp.Native.mpz_t">mpz_t</see> value.</returns>
            <remarks>
            <para>
            The leading characters are used: <c>0x</c> and <c>0X</c> for hexadecimal,
            <c>0b</c> and <c>0B</c> for binary, <c>0</c> for octal, or decimal otherwise.
            </para>
            </remarks>
        </member>
        <member name="M:Math.Gmp.Native.mpz_t.ToString">
            <summary>
            Return the string representation of the integer.
            </summary>
            <returns>The string representation of the integer.</returns>
        </member>
    </members>
</doc>
